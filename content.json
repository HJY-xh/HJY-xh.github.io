{"meta":{"title":"可乐加冰","subtitle":"","description":"","author":"HJY","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-07T06:13:07.313Z","updated":"2021-08-07T06:13:07.313Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-07T06:13:07.329Z","updated":"2021-08-07T06:13:07.329Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-08-07T06:13:07.340Z","updated":"2021-08-07T06:13:07.340Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-07T06:13:07.354Z","updated":"2021-08-07T06:13:07.354Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-08-07T06:11:15.550Z","updated":"2021-08-07T06:11:15.549Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-07T06:13:07.361Z","updated":"2021-08-07T06:13:07.361Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-07T06:13:32.748Z","updated":"2021-08-07T06:13:32.748Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Promise规范翻译","slug":"PromisesA+规范翻译","date":"2020-11-09T13:30:40.000Z","updated":"2021-08-07T05:59:13.910Z","comments":true,"path":"2020/11/09/PromisesA+规范翻译/","link":"","permalink":"http://example.com/2020/11/09/PromisesA+%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 原文 一个开放标准,通用的 JavaScript promise ,由开发者制定，供开发者使用。 Promise 用于表示一个异步操作的最终结果。与 Promise 交互的主要方式为then方法,该方法注册回调函数以接收 promise 的成功的结果或者失败的原因。 该规范详细说明了then方法的行为,所有基于 Promise/A+规范实现的 Promise 都必须以此为基础实现。因此规范应该非常稳定。尽管 Promises/A+组织可能会偶尔修改此规范以向后兼容,只有经过仔细考虑，讨论和测试后，我们才会集成大型或不向后兼容的更改。 从其发展过程来看，Promises/A+其实是把之前的Promises/A提案归纳总结为标准。扩展了一些现有的行为规范，并删除了一些有问题的、未明确的部分。 最终，Promises/A+规范核心内容不包括怎样处理 promises 的创建（create）,完成（fulfill）和拒绝（reject），而是选择专注于提供一个通用的，具备可互操作的then方法。上述的操作方法可能会在未来修改该规范时提及。 1. 术语1.1 “promise” 是一个拥有then方法的对象或函数，其行为符合本规范1.2 “thenable” 是一个定义了then方法的对象或函数1.3 “value” 可以是任何 JavaScript 的合法值（包括 undefined, thenable 和 promise）1.4 “exception” 是一个使用throw语句抛出的值。1.5 “reason”是一个表示 promise 失败的原因 2. 要求2.1 Promise 要求一个 Promise 必须处于以下三种状态中的其中一种: pending（等待）, fulfilled（完成）, 或 rejected（拒绝）。 2.1.1 当 promise 处于 pending 状态 2.1.1.1. 可以转换到 fulfilled 或 rejected 的状态。 2.1.2 当 promise 处于 fulfilled 状态 2.1.2.1 不能再转换状态。 2.1.2.2 必须有一个值(value),且不可改变。 2.1.3 当 promise 处于 rejected 状态 2.1.3.1 不能再转换状态。 2.1.3.2 必须有一个原因(reason),且不可改变。 这里的不可改变指的是恒等（即 === ），而不是意味着其内部的不可变（即仅仅是其引用地址不变，但属性值可被更改）。 2.2 then 方法一个 promise 必须提供一个then方法以读取其当前值、终值和失败原因。一个 promise 的then方法接收两个参数: 1promise.then(onFullfilled, onRejected); 2.2.1 onFulfilled和onRejected都是可选的参数: 2.2.1.1 如果onFullfilled不是一个函数，则它会被忽略 2.2.1.2 如果onRejected不是一个函数，则它会被忽略 2.2.2 如果onFulfilled是一个函数 2.2.2.1 必须在 promise 执行结束后执行，promise的 value 作为第一个参数 2.2.2.2 在 promise 执行结束前不可被调用 2.2.2.3 不能被多次调用 2.2.3 如果onRejected是一个函数 2.2.3.1 必须在 promise 被拒绝后执行,promise的 reason 作为第一个参数 2.2.3.2 在 promise 执行结束前不可被调用 2.2.3.3 不能被多次调用 2.2.4 onFulfilled和onRejected只有在执行环境堆栈仅包含平台代码时才可被调用 3.1 2.2.5 onFulfilled和onRejected必须被作为函数调用（即没有 this 值） 3.2 2.2.6 then方法可以被同一个 promise 调用多次 2.2.6.1 如果/当 promise是 fulfilled 状态，则所有相应的onFulfilled回调必须按注册顺序执行then方法 2.2.6.2 如果/当 promise是 rejected 状态，则所有相应的onRejected回调必须按注册顺序执行then方法 2.2.7 then方法必须返回一个 promise 对象3.3 1promise2 = promise1.then(onFulfilled, onRejected); 2.2.7.1 如果onFulfilled或者onRejected返回一个值x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x) 2.2.7.2 如果onFulfilled或者onRejected抛出一个异常e ，则promise2必须拒绝执行，并将e作为拒绝原因 2.2.7.3 如果onFulfilled不是一个函数并且promise1已经完成，则promise2必须使用与promise1相同的 value 来 fulfilled 2.2.7.4 如果onRejected不是一个函数并且promise1已经完成，则promise2必须使用与promise1相同的 reason 来 rejected 2.3 Promise 解决过程Promise 解决过程是一个抽象的操作,其需输入一个 promise 和一个值,我们表示为[[Resolve]](promise, x),如果 x 是一个 thenable(promise),它会尝试采用 x 的状态,前提是x行为至少有点像 promise。否则，它作为promise的 fulfilled 的 value 返回。对 thenables 的这种处理允许 promise 实现进行更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与不冲突的实现能良好共存。 要运行[[Resolve]](promise, x), 需遵循以下步骤： 2.3.1 如果promise和x指向同一对象，以TypeError为拒绝原因拒绝执行promise 2.3.2 如果x为 Promise,则使 promise 接受 x 的状态3.4 2.3.2.1 如果x处于 pending,promise 需保持 pending,直至x被执行或拒绝 2.3.2.2 如果x执行完毕,用相同的值执行promise 2.3.2.3 如果x被拒绝,用相同的原因拒绝promise 2.3.3 如果x为对象或者函数 2.3.3.1 把x.then赋值给then3.5 2.3.3.2 如果取x.then的值时抛出错误e,则用e作为 promise 的拒绝原因 2.3.3.3 如果then是函数,将x作为函数的作用域this调用之。传递两个回调函数作为参数,第一个参数叫做resolvePromise,第二个参数叫做rejectPromise: 2.3.3.3.1 如果resolvePromise以值y为参数被调用，则运行 [[Resolve]](promise, y) 2.3.3.3.2 如果rejectPromise以拒绝原因r为参数被调用,则以r拒绝promise 2.3.3.3.3 如果resolvePromise和rejectPromise均被调用,或者被同一参数调用了多次,则优先采用首次调用并忽略其余调用 2.3.3.3.4 如果调用then方法时抛出异常e, 2.3.3.3.4.1 如果resolvePromise或rejectPromise已经被调用,就忽略它 2.3.3.3.4.2 否则以e为原因拒绝promise 2.3.3.4 如果then不是函数,以x为参数执行promise 2.3.4 如果x不为对象或者函数,以x为参数执行promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而[[Resolve]](promise, thenable)的递归性质导致其被再次调用,根据上述的算法将会陷入无限递归。规范鼓励施者检测这样的递归是否存在,但不强制,如果检测到存在则以一个可识别的TypeError为原因来拒绝 promise。3.6 3. 备注3.1这里的“平台代码”指的是引擎,环境和 promise 实现代码。实践中要确保onFulfilled和onRejected方法异步执行,且应该在then方法被调用的那一轮事件循环之后的新执行栈中执行。这可以用“宏任务”机制实现,例如setTimeout或者setImmediate,或者用“微任务”机制,例如MutationObserver或process.nextTick。由于 promise 实现被认为是平台代码,因此它本身可能包含一个任务调度队列或“trampoline”的处理程序。 3.2也就是说在严格模式（strict）中，this的值为undefined;在非严格模式中其为全局对象。 3.3代码实现在满足所有要求的情况下可以允许promise2 === promise1。每个实现都要文档说明其是否允许以及在何种条件下允许 promise2 === promise1。 3.4一般来说,x如果它来自当前的实现,那么它是一个真正的 promise。该子句允许使用特定于实现的方法来采用已知符合的 promise 的状态。 3.5此过程首先存储引用x.then,然后测试,调用该引用,避免多次访问该x.then属性。这么做的原因是防止每次获取该值时,返回不同的情况（ES5 的 getter 特性可能会产生副作用） 3.6实现不应该对 thenable 链的深度设限,并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致TypeError异常；如果一条无限长的链上 thenable 均不相同,那么递归下去永远是正确的行为。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"margin 合并","slug":"margin合并","date":"2020-10-26T10:42:31.000Z","updated":"2021-08-07T05:59:13.885Z","comments":true,"path":"2020/10/26/margin合并/","link":"","permalink":"http://example.com/2020/10/26/margin%E5%90%88%E5%B9%B6/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 什么是 margin 合并MDN 定义 块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距,其大小为单个边距的最大值(或如果它们相等,则仅为其中一个),这种行为称为边距折叠. 举个 🌰 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;style&gt; body &#123; writing-mode: vertical-lr; &#125; div &#123; margin: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;hello&lt;/div&gt; &lt;div&gt;world&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 块级元素,但不包括浮动和绝对定位元素(他们可以让元素块状化) 只发生在垂直方向(不考虑writing-mode的情况,严格来说应该是只发生在和当前文档流方向的相垂直方向上,默认的文档流是水平流) margin 合并三种场景 相邻兄弟元素 margin 合并 父级和第一个/最后一个子元素 空的块级元素的 margin 合并 相邻兄弟元素 margin 合并例子如上 父级和第一个/最后一个子元素1234567891011&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot; style=&quot;margin-top: 30px;&quot;&gt;hello world&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;father&quot; style=&quot;margin-top: 30px;&quot;&gt; &lt;div class=&quot;son&quot;&gt;hello world&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;father&quot; style=&quot;margin-top: 30px;&quot;&gt; &lt;div class=&quot;son&quot; style=&quot;margin-top: 30px;&quot;&gt;hello world&lt;/div&gt;&lt;/div&gt; 如何阻止这里margin合并的发生?可以进行的操作(满足一个条件即可): 父元素设置块状格式化上下文元素 父级和第一个/最后一个子元素之间添加内联元素进行分隔 父元素设置border 父元素设置padding 空的块级元素的 margin 合并123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 如何阻止这里margin合并的发生?可以进行的操作(满足一个条件即可): 设置height或者min-height 添加内联元素进行分隔 父元素设置border 父元素设置padding margin 合并的计算规则 同向取极值12&lt;div style=&quot;margin-bottom: 50px;&quot;&gt;a&lt;/div&gt;&lt;div style=&quot;margin-top: 20px;&quot;&gt;b&lt;/div&gt; 此时两个div的间距为50px 123&lt;div style=&quot;height: 100px; background-color: antiquewhite;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;margin-bottom: -50px;&quot;&gt;a&lt;/div&gt; &lt;div style=&quot;margin-top: -20px;&quot;&gt;b&lt;/div&gt; 此时两个div的间距为-50px,视觉上非50px 反向取差值12&lt;div style=&quot;margin-bottom: 50px;&quot;&gt;a&lt;/div&gt;&lt;div style=&quot;margin-top: -20px;&quot;&gt;b&lt;/div&gt; 此时两个div的间距为30px,即 50px+(-20px) margin 合并的意义为什么会有margin最初CSS的设计本意就是为了图文信息的展示,有了默认的margin,图文就不会挤在一起,垂直方向上就可以层次分明.比如说&lt;p&gt;&lt;/p&gt;,其margin默认单位为em,为什么使用相对单位?浏览器的字号大小可以自定义,当我们自定义为较大值时,margin跟随变化,能够保持合适的排版. margin 合并的意义对于兄弟元素的margin合并其作用和em类似,都是为了让图文信息打得排版更舒服自然. 对于父子元素的margin合并的意义在于:在页面中任何地方插入和嵌套&lt;div&gt;&lt;/div&gt;都不会影响原来的块状布局. 1&lt;div style=&quot;margin-top: 20px;&quot;&gt;&lt;/div&gt; 现在在该元素外嵌套一层&lt;div&gt;&lt;/div&gt;标签,如果没有合并规则,该元素和兄弟节点的间距可能就会变大,也就影响了原来的布局. 对于自身的margin合并的意义在于可以避免空标签的影响 123456&lt;p&gt;a&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b&lt;/p&gt; 因为规则的存在,它和底下的代码是一样的效果 12&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"Babel转译下的装饰器","slug":"Babel转译下的装饰器","date":"2020-08-16T11:40:50.000Z","updated":"2021-08-07T05:59:13.676Z","comments":true,"path":"2020/08/16/Babel转译下的装饰器/","link":"","permalink":"http://example.com/2020/08/16/Babel%E8%BD%AC%E8%AF%91%E4%B8%8B%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 装饰器概念它是一个函数，它会通过返回一个新函数来修改传入的函数或方法的行为 装饰器用法 装饰类方法或属性(类成员) 装饰类 123456789101112131415161718192021222324252627282930const log = (target, name, descriptor) =&gt; &#123; let oldValue = descriptor.value; if (typeof descriptor.value === &quot;function&quot;) &#123; descriptor.value = function (...args) &#123; return console.log(oldValue.apply(this, args)); &#125; &#125; else &#123; console.log(descriptor.value) &#125;&#125;const foodCategory = (target, name, descriptor) =&gt; &#123; target.category = &quot;food&quot;;&#125;@foodCategoryclass Cola &#123; constructor(name) &#123; this.name = name; &#125; @log color() &#123; return `red`; &#125;&#125;let cola = new Cola(&quot;Coca Cola&quot;);cola.color(); // redconsole.log(Cola.category); // food 装饰方法本质上是通过 Object.defineProperty() 来实现的 经过babel转换之后(底下有babel详细操作): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&quot;use strict&quot;;/** * @function * 该函数的作用就是将数组中的方法添加到构造函数或者构造函数的原型中 * 最后返回这个构造函数。 */var _createClass = function () &#123; /** * 将props数组上的每一个对象都通过Object.defineProperty()方法 * 定义到目标对象target上去 */ function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; // 类的内部所有定义的方法,都是不可枚举的 descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; /** * @param &#123;protoProps&#125; 原型属性数组 * @param &#123;protoProps&#125; 静态属性数组 */ return function (Constructor, protoProps, staticProps) &#123; // 为构造函数prototype添加属性 // (即为用构造函数生成的实例原型添加属性,可以被实例通过原型链访问到) if (protoProps) defineProperties(Constructor.prototype, protoProps); // 为构造函数添加属性 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;();var _class, _desc, _value, _class2;/** * @function * 作用是检查 Person 是否是通过 new 的方式调用 * 防止构造函数被当做普通函数执行 */function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125;&#125;function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) &#123; var desc = &#123;&#125;; // 这里对 descriptor 属性做了一层拷贝 Object[&#x27;keys&#x27;](descriptor).forEach(function (key) &#123; desc[key] = descriptor[key]; &#125;); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; // 没有 value 或者 initializer 属性的,表明是 get 和 set 方法 // initializer是 Babel 的 Class 为了与 decorator 配合而产生的一个属性 if (&#x27;value&#x27; in desc || desc.initializer) &#123; desc.writable = true; &#125; // 这里处理多个 decorator 的情况,由类内向类外执行 desc = decorators.slice().reverse().reduce(function (desc, decorator) &#123; return decorator(target, property, desc) || desc; &#125;, desc); // void其实是javascript中的一个函数,接受一个参数,返回值永远是undefined if (context &amp;&amp; desc.initializer !== void 0) &#123; desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; &#125; if (desc.initializer === void 0) &#123; Object[&#x27;defineProperty&#x27;](target, property, desc); desc = null; &#125; return desc;&#125;var log = function log(target, name, descriptor) &#123; var oldValue = descriptor.value; if (typeof descriptor.value === &quot;function&quot;) &#123; descriptor.value = function () &#123; for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) &#123; args[_key] = arguments[_key]; &#125; return console.log(oldValue.apply(this, args)); &#125;; &#125; else &#123; console.log(descriptor.value); &#125;&#125;;var foodCategory = function foodCategory(target, name, descriptor) &#123; target.category = &quot;food&quot;;&#125;;var Cola = foodCategory(_class = (_class2 = function () &#123; function Cola(name) &#123; _classCallCheck(this, Cola); this.name = name; &#125; _createClass(Cola, [&#123; key: &quot;color&quot;, value: function color() &#123; return &quot;red&quot;; &#125; &#125;]); return Cola;&#125;(), (_applyDecoratedDescriptor(_class2.prototype, &quot;color&quot;, [log], Object.getOwnPropertyDescriptor(_class2.prototype, &quot;color&quot;), _class2.prototype)), _class2)) || _class;var cola = new Cola(&quot;Coca Cola&quot;);cola.color();console.log(Cola.category); babel详细操作使用npm init初始化项目:生成文件pakeage.json,它会将记录项目开发中所要用到的包,以及项目的详细信息 babel-cli是一种在命令行下使用Babel编译文件的简单方法,主要用于文件的输入输出安装babel命令行工具: 1npm install --global babel-cli 安装装饰器依赖: 1npm i --save-dev babel-plugin-transform-decorators-legacy 项目中创建**.babelrc**文件: 12345678&#123; &quot;presets&quot;: [ &quot;es2015&quot; ], &quot;plugins&quot;: [ &quot;transform-decorators-legacy&quot; ] &#125; 文件说明: .babelrcbabel所有的操作基本都会来读取这个配置文件,除了一些在回调函数中设置options参数的,如果没有这个配置文件,会从package.json文件的babel属性中读取配置 presets可以简单的把它视为 Babel Plugin 的集合 pluginsbabel中的插件,通过配置不同的插件告诉babel,代码中有哪些是需要转译的 使用babel命令转码: 1babel [fileName].js","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中offset、client、scroll","slug":"JavaScript中offset、client、scroll","date":"2020-06-10T13:49:20.000Z","updated":"2021-08-07T05:59:13.848Z","comments":true,"path":"2020/06/10/JavaScript中offset、client、scroll/","link":"","permalink":"http://example.com/2020/06/10/JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 写在前面在web前端开发中经常会碰到offset、client、scroll,容易混乱,这里记录一番.先放两张图,未来好查阅 :smile: offsetoffset: 偏移量它包括元素在屏幕上占用的所有可见的空间.元素的可见大小由其高度、宽度决定,包括所有的内边距padding,滚动条和边框border大小(注意:不包括外边距). 通过以下4个属性可以取得元素的偏移量: offsetHeight: offsetHeight = border-width * 2 + padding-top + padding-bottom + height offsetWidth: offsetWidth = border-width * 2 + padding-left + padding-right + width offsetLeft: offsetLeft = offsetParent 的padding-left + 中间元素的offsetWidth + 当前元素的margin-left offsetTop: offsetParent 的padding-top + 中间元素的offsetHeight + 当前元素的margin-top 它们都是只读属性,每次访问都要重新计算,如果经常访问,可以用变量存起来,以提高性能 clientclient: 客户区大小它包括元素内容及其内边距所占据的空间大小. 通过以下2个属性可以取得元素的客户区: clientHeight: padding-top + padding-bottom + height clientWidth: padding-left + padding-right + width 它们也是只读属性,每次访问都要重新计算 scrollscroll: 滚动大小它指的是滚动内容的元素的大小.有些元素(比如&lt;html&gt;),即使没有执行任何代码也能自动地添加滚动条;有些元素需要通过设置CSS的overflow属性才能滚动. 通过以下4个属性可以取得滚动的相关属性: scrollHeight: 在没有滚动条的情况下,元素实际内容的总高度 scrollWidth: 在没有滚动条的情况下,元素实际内容的总宽度 scrollLeft: 被隐藏在内容区域左侧的像素数,设置该属性可以改变元素的滚动位置 scrollTop: 被隐藏在内容区域上方的像素数,设置该属性可以改变元素的滚动位置 通常认为&lt;html&gt;元素是在web浏览器的视口中滚动的元素,所以带有垂直滚动条的页面总高度就是document.documentElement.scrollHeight.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"直击本质——读书笔记","slug":"读书笔记--直击本质","date":"2020-05-03T07:19:12.000Z","updated":"2021-08-07T05:59:13.622Z","comments":true,"path":"2020/05/03/读书笔记--直击本质/","link":"","permalink":"http://example.com/2020/05/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 这本书让我受益很多，思维导图分享给大家。以下再完善一些概念： 迁移思考：迁移思考是先找到经过抽象与当前问题“表面不同、本质相似”的问题，通过借用前面问题的解决方法，解决当下问题的思维方式。它的迁移对象主要是思维模型和底层逻辑。 升维思考：跳出眼前问题的限制和常规解法，通过层级、时间、视角、边界、位置、结构的变换，重新思考问题及其解决之道的思考方式。升维思考的本质是对价值观、人生观、世界观的重新审视，拓展及重塑。比如，层级思考法和时间轴思考法是对自我价值观的审视，视角思考法是对世界观的拓展和重塑，无边界思考法是对人生观的拓展和重塑。 逆向思维：它是对司空见惯的、似乎已成定论的事物或观点反过来思考的一种思维方式。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"JavaScript中Object常用方法","slug":"JavaScript中Object常用方法","date":"2020-04-30T14:34:24.000Z","updated":"2021-08-07T05:59:13.833Z","comments":true,"path":"2020/04/30/JavaScript中Object常用方法/","link":"","permalink":"http://example.com/2020/04/30/JavaScript%E4%B8%ADObject%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 写在前面本篇文章尚未完成!! 概述Object是JavaScript中标准内置对象，它非常强大，虽然在日常开发中却用的不多，但十分有必要深入学习。 Object.create()该方法创建一个新对象，使用现有的对象提供新创建对象的__proto__.Object.create(proto[, propertiesObject])参数： proto为新创建对象的原型对象 propertiesObject可选，如果没有指定为undefined，这样会添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及响应的属性名称。返回值： 一个新对象，带着指定原型对象和属性 Object.defineProperty()该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 先看看常用的对象定义属性并赋值的写法：密码，，，，，，，，，，，，，，，，，，。xcccccccccccccccccc.mpo[yup] 123456789101112131415let obj = &#123;&#125;;obj.name = &#x27;Cola&#x27;;console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;````这种方式简单粗暴，但是对象属性的值可以想改就改，想删就删：```javascriptlet obj = &#123;&#125;;obj.name = &#x27;Cola&#x27;;console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;obj.name = &#x27;Coca cola&#x27;;console.log(obj);// &#123; name: &#x27;Coca cola&#x27; &#125;delete obj.name;console.log(obj);// &#123;&#125; 再来看看Object.defineProperty(obj, prop, descriptor)参数： obj为要定义属性的对象 prop为要定义或修改的属性的名称或Symbol descriptor为要定义或修改的属性描述符返回值： 被传递给函数的对象 ES6新增Symbol类型，，由于它独一无二的特性，可以用该类型作为对象的key 123456789101112let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; value: &#x27;Cola&#x27;&#125;)console.log(obj);// &#123;&#125;console.log(obj.name);// Colaobj.name = &#x27;Coca cola&#x27;;console.log(obj.name);// Coladelete obj.name;console.log(obj.name);// Cola 通过实践发现以这样的写法定义的属性是无法被修改和删除的，且访问对象为空。要想和我们常规写法达到相同的效果，还需要修改属性描述符。对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符，用一张表来区分二者区别：| |configurable |enumerable |value |writable |get |set || ———— | ———— | ———— | ———— | ———— | ———— | ———— || 数据描述符 |√ |√ |√ |√ |× |× || 存取描述符 |√ |√ |× |× |√ |√ |如果一个描述符不具备value、enumerable、writable、configurable任意一个键，那么它会被认为是一个数据描述符；如果一个描述符同时拥有value或writable和get、set，则会产生一个异常。 下面再来看一个示例： 123456789101112131415let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; enumerable: true, configurable: true, writable: true, value: &#x27;Cola&#x27;&#125;)console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;console.log(obj.name);// Colaobj.name = &#x27;Coca cola&#x27;;console.log(obj.name);// Coca coladelete obj.name;console.log(obj.name);// undefined 可以看到obj对象和我们以常用写法达到的效果一样，这是因为enumerable描述符能够控制对象属性是否可枚举;writable描述符能够控制对象属性是否可写，也就是覆盖;configurable描述符能够控制对象属性是否可配置，也就是将属性从对象上删除。这里我们可以得出结论：除了value描述符，其他数据描述符的值默认为false。 那get和set呢，再看看以下的例子： 12345678910let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; enumerable: true, configurable: true, writable: true, value: &#x27;Cola&#x27;, get() &#123;&#125;, set() &#123;&#125;&#125;)// TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute 对照前文的表格，代码抛出异常，证实了value或writable和get、set不能同时出现。那怎么使用呢，按照异常提示信息，删掉value和writable描述符： 123456789101112131415let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; enumerable: true, configurable: true, get() &#123; console.log(&#x27;get!&#x27;); // return obj; &#125;, set(val) &#123; console.log(val); &#125;&#125;)console.log(obj);// &#123; name: [Getter/Setter] &#125;obj.name;// get!obj.name = &#x27;Coca cola&#x27;;// Coca cola 在上面代码中，每次访问obj.name总是返回同一个值，这是因为我们对这个属性做了特殊处理，也就是get方法做的事情；每次对obj.name进行赋值操作，控制台总是打印此次赋值的内容，也就是set方法做的事情。 Object.assign()该方法是ES6新添加的方法，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。Object.assign(target, ...sources)参数： target为目标对象 sources为源对象返回值： 目标对象用法示例：123456789101112131415161718192021let manA = &#123; name: &#x27;manA&#x27;, age: 23&#125;Object.defineProperties(manA, &#123; &#x27;address&#x27;: &#123; enumerable: true, value: &#x27;China&#x27; &#125;, &#x27;height&#x27;: &#123; value: &#x27;1.8m&#x27; &#125;&#125;)let manB = &#123; name: &#x27;manB&#x27;, age: 13&#125;let manC = Object.assign(&#123;&#125;, manA, manB, null, undefined);console.log(manC);// &#123; name: &#x27;manB&#x27;, age: 13, address: &#x27;China&#x27; &#125; 实践后可以得出结论： 该方法只拷贝源对象自身的并且可枚举的属性到目标对象（其内部使用源对象存取描述符get()和目标对象的set()方法，因此它会调用相关方法）。 该方法不会因为sources参数为null或undefined而报错。 深拷贝问题：Object.assign()方法只能实现浅拷贝：假如源对象的属性值是一个对象的引用，那么返回值中该属性值也直指向这个引用 123456789101112let manA = &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;China&#x27; &#125;&#125;let manB = Object.assign(&#123;&#125;, manA);console.log(manB);// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;China&#x27; &#125; &#125;manB.address.nationality = &#x27;Japan&#x27;;console.log(manA)；// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;Japan&#x27; &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中的防抖和节流","slug":"JavaScript中的防抖和节流","date":"2020-04-28T14:18:41.000Z","updated":"2021-08-07T05:59:13.785Z","comments":true,"path":"2020/04/28/JavaScript中的防抖和节流/","link":"","permalink":"http://example.com/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 概述防抖和节流是优化前端性能的一种手段。以下情况可以考虑使用防抖和节流： DOM 频繁重绘 频繁请求后端接口 浏览器的 resize、scroll（适合用节流） 鼠标的 mounsemove、mouseover（适合用节流） input 输入框的 keypress（适合用防抖） 防抖(debounce)核心思想：当事件被触发，延迟 n 秒后执行回调函数，如果在 n 秒内再次被触发，则重新计时延迟时间。 代码实现： 1234567891011function debounce(fn, delay) &#123; var timer; return function () &#123; var that = this; var args = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function () &#123; fn.apply(that, args); &#125;, delay); &#125;;&#125; 节流核心思想：在规定的一个单位时间内只能触发一次函数，如果在这个单位时间内出发多次函数，只有一次生效。 代码实现: 123456789101112131415function throttle(fn, delay) &#123; var timer; return function () &#123; var that = this; var args = arguments; if (timer) &#123; return; &#125; timer = setTimeout(function () &#123; fn.apply(that, args); // 在执行完fn后清空timer,throttle触发可以进入计时器 timer = null; &#125;, delay); &#125;;&#125; 节流与防抖的异同相同：在一段时间内防止函数被频繁调用，减少资源浪费，提升性能。不同：防抖是固定时间内只执行一次，节流是间隔固定时间后执行。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"MQTT协议详解","slug":"MQTT协议详解","date":"2020-04-26T05:18:56.000Z","updated":"2021-08-07T05:59:13.905Z","comments":true,"path":"2020/04/26/MQTT协议详解/","link":"","permalink":"http://example.com/2020/04/26/MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 概述MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)，是一种基于发布/订阅(public/subscribe)模式的轻量级物联网消息推送协议。该协议构建于TCP/IP协议上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的协议。这让它成为新兴的”机器到机器（M2M)”，”物联网(IoT)”场景下的理想选择。 特点 MQTT协议是轻量、简单、开放和易于实现的 提供服务质量管理 采用发布/订阅模式，方便消息传递 基于TCP/IP网络连接，提供有序，无损的双向连接 假如数据不可知，不强求传输数据的类型与格式，保持灵活性 1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量 应用场景MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域 物联网M2M通信，物联网大数据采集 Android消息推送，Web消息推送 移动即时消息，例如Facebook Messenger 智能硬件、智能家居 车联网通信、电动车站桩采集 电力、石油与能源等行业市场 主题和负载MQTT传输的消息分为：主题（Topic）和负载（payload） Topic：可以理解为消息的类型，订阅者订阅（Subscribe)后，就会收到该主题的消息内容（payload） payload：可以理解为消息的内容，失致订阅者具体要使用的内容 三种消息发布服务质量： 至多一次：消息发布完全依赖底层TCP/IP网络，qos=0。会发生消息丢失或重复的情况，这一级别可用于如下情况，环境传感器数据，丢失一次读记录影响不大 至少一次：确保消息到达，qos=1。但消息重复可能会发生 只有一次：确保消息到底一次，qos=2。 协议原理 实现方式MQTT协议具有三种身份：发布者（Publish)、代理（Broker)（服务器）、订阅者（Subscribe）其中，消息的发布者和订阅者都是客户端，消息代理是服务器。消息的发布者可以同时是订阅者 网络传输与应用消息MQTT会构建底层网络传输：它将简历客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关联。 MQTT客户端一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： 发布其他客户端可能会订阅的消息 订阅其他客户端发布的消息 退订或删除应用程序的消息 断开与服务器连接 MQTT服务端MQTT服务器已称为”消息代理”(Broker)，可以是一个应用程序或一台设备。它位于消息发布者和订阅者中间，它可以： 接受来自客户的网络连接 接受客户发布的应用消息 处理来自客户端的订阅和退订请求 向订阅的客户转发应用程序消息 MQTT协议中的订阅、主题、会话 订阅（Subscription）订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每个会话中的每个订阅都有一个不同的主题筛选器。 会话（Session）每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。绘画存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 主题名（Topic Name）连接到一个应用程序消息的标签，如果该标签与服务器的订阅相匹配，服务器就会将消息发送给订阅所匹配标签的客户端。 主题筛选器（Topic Filter）一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。 MQTT协议中的方法MQTT协议中定义了一些方法，也被称之为动作，来表示对于确定资源进行的操作。资源可以是预先存在的数据或者动态生成的数据，这取决于服务器的实现，通常来说，资源指服务器上的文件或输出。主要方法有： Connect：等待与服务器建立连接 Disconnect：等待MQTT客户端完成所作的工作，并与服务器断开TCP/IP会话 Subscribe:等待完成订阅 UnSubscribe:等待服务器取消客户端的一个或多个topics订阅 Publish：MQTT客户端发送消息请求，发送完成后返回应用程序线程 MQTT协议数据包结构在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Varibale header）、消息体（payload）三部分构成。 固定头（Fixed header）：存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识数据包类型为byte 1中bits7-4,相当于一个4位的无符号值，类型如下：标识位为byte 1中bits3-0,在不使用标识位的消息类型中，标识位被做为保留位。如果收到无效的标志时，接收端必须关闭网络连接： DUP：发布消息的副本，用来保证消息的可靠传输。如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送 QoS：发布消息的服务质量，即：保证消息传递的次数 00：最多一次，即：&lt;=1 01：至少一次，即：&gt;=1 10：一次，即：=1 11：预留 RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放剩余长度（Remaining Length）固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为 1时，表示长度不足，需要使用二个字节继续保存。 可变头（Varibale header）：存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识： 很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK 消息体（payload））：存在于部分MQTT数据包中，表示客户端收到的具体内容Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息： CONNECT:消息体内容主要是客户端的ClientID、订阅的Topic、Message以及用户名和密码 SUBSCRIBE:消息内内容是一系列要订阅的主题以及QoS SUBACK：消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复 UNSUBSCRIBE:消息体内容是要订阅的主题","categories":[{"name":"协议","slug":"协议","permalink":"http://example.com/categories/%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"霍乱时期的爱情——读书笔记","slug":"读书笔记--霍乱时期的爱情","date":"2020-04-20T13:12:03.000Z","updated":"2021-08-07T05:59:13.567Z","comments":true,"path":"2020/04/20/读书笔记--霍乱时期的爱情/","link":"","permalink":"http://example.com/2020/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 我相信爱情是有许多模样的，街头巷尾里互相搀扶的老夫老妻，小家里过着平平淡淡日子的夫妇，婚礼上很累却非常甜蜜的新人，还有拉着彼此的手在暴雨天一路奔跑的情侣等。当然，有积极正面的，热情似火的爱，也必然有阴暗扭曲，卑劣粗俗的爱，这本书让我看到关于爱情更多的细枝末节。当年轻的阿里萨第一次见到费尔明娜，一生内心的纠葛就此开始。从最初的懵懂羞涩，在花园装作看书看诗集，实则等待费尔明娜路过时的那一撇，那就是心动的第一个阶段吧。彼时费尔明娜乖巧懂事，对父亲言听计从，但在阿里萨鼓起勇气送出信件的那一天，她的心态悄然变化。虽然二人几乎没有或正式的面对面的对话，但是在信中从无话不谈到私定终身，看到这里我觉得有些荒诞，但也不可否认，在那个年代这是可能发生的事情，或许这不是靠谱的爱情，但它一定是两个少男少女勇敢无畏，憧憬爱情的表现。纸里包不住火，洛伦索发现女儿的地下情，愤怒之余却也拿女儿没什么办法，只能带着女儿出去旅行一场，以期让她忘记阿里萨。在经历时间和空间的考验之后，费尔明娜在代笔门廊处看见阿里萨的第一眼果断决定放弃这一段长达数年的感情，她完全没有想到阿里萨是这般模样。我想这是爱情的一种残酷，发现自己朝思暮想的另一半因为某种不合的观念，失望占据内心，想要迫切希望离开，以逃避给自己带来的情感冲击。而阿里萨也因此陷入漫长的相思之苦，在无数个日日夜夜幻想着未来继续和费尔明娜生活下去的可能。医生的出现，让故事更加戏剧化，他和阿里萨是完完全全两种不同的人。医生光鲜亮丽，才华横溢，医术高超，和阿里萨奇怪装束，一身为爱情诗歌所浸染的气息形成鲜明对比。费尔明娜嫁给了医生，甜蜜旅行之后是多年的不开心，期间偶尔穿插着过往蜜月的回忆。漫长岁月不过弹指间就过去了，阿里萨对她的感情日渐病态，一边心里装着她，一边勾搭成百上千的女人满足生理上需求。漫长岁月里，阿里萨也有那么几个中意的女人，奇怪的是他从来没有放弃一直盘踞在内心的念想，也从未对其他人提起，少年时的爱慕经受了五十多年岁月的考验，尽管这种感情面目全非，阿里萨还是坚持了下去，足够令人惊叹。阿里萨终于等到医生死亡的消息，不像他想象中的体面离世，跌倒死亡让阿里萨没有把竞争对手比下去的快感。即便如此，暮年的他没有浪费太多时间，再次向费尔明娜表明心意，在坚持不懈的努力下，费尔明娜意识到自己是对阿里萨那一份特殊感情。最终在他们剩下的生命里借助霍乱的掩护，阿里萨如愿和费尔明娜一起在海上漂流了下去。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"网络攻击-XSS攻击详解","slug":"网络攻击-XSS攻击详解","date":"2020-03-10T05:39:41.000Z","updated":"2021-08-07T05:59:13.652Z","comments":true,"path":"2020/03/10/网络攻击-XSS攻击详解/","link":"","permalink":"http://example.com/2020/03/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB-XSS%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 XSS 概念跨站脚本攻击(XSS),是最普遍的Web应用安全漏洞. 这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中,当正常用户访问该页面时,则可导致嵌入的恶意脚本代码的执行,从而达到恶意攻击用户的目的. 人们经常将跨站脚本攻击(Cross Site Scripting)缩写为 CSS ,但这会与层叠样式表(Cascading Style Sheet,CSS)的缩写混淆,因此将其改为 XSS . XSS 危害 盗用 cookie ,获取敏感信息 XSS 原理HTML 是一种超文本标记语言,通过特殊对待一些字符来区别文本和标记:小于符号(&lt;)被看作是 HTML 标签的开始,浏览器会将特定的字符误认为HTML 标签.当 HTML标签引入了 JavaScript 脚本时,浏览器就会执行.因此,当这些特殊字符不能被动态页面检查或检查出错的时候,就会产生 XSS 漏洞 XSS 类型 反射型(非持久型):指发生请求时,XSS代码出现在请求URL中,作为参数提交到服务器,服务器解析并响应,响应结果中包含XSS代码,最后被浏览器解析并执行.这个过程像一次反射,故叫做反射型XSS. 存储型(持久型):将XSS代码存储在服务器中. DOM跨站:指受害者端的网页脚本在修改本地页面DOM环境时未进行合理的处置,而使得攻击脚本被执行.在整个攻击过程中,服务器响应的页面并没有发生变化,引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用 具体示例 反射型XSS假如一个接口http://www.test.com/xss/reflect.php的代码如下: 123&lt;?phpecho &#x27;x&#x27;&gt; 这里的x值没有经过处理直接输出,当客户端提交请求http://www.test.com/xss/reflect.php?x=&lt;script&gt;alert(1)&lt;/script&gt;,此时浏览器会触发alert()函数. 存储型XSS最典型的例子就是留言板XSS,当用户提交了一条包含XSS代码的留言存储到数据库,目标用户查看留言板时,留言内容会从数据库提取并展示在页面上,浏览器发现有XSS代码,就当成HTML和JavaScript解析执行,从而触发XSS攻击.简单的可以是一个alert()弹窗,复杂一些的可以是盗用用户cookie等操作. DOM XSSDOM XSS攻击并不需要服务器参与,触发攻击靠浏览器的DOM解析,核心是运用DOM函数.我们知道eval()函数有一个作用是将一段字符串转换成JavaScript语句,因此在JavaScript中使用eval()是一件有风险的事情,容易造成XSS攻击. 1eval(&quot;alert(&#x27;Hello world&#x27;)&quot;) 可能触发DOM XSS攻击的属性有: document.referer属性 window.name属性 location属性 innerHTML属性 documen.write 防范手段 入参字符过滤对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤. 出参进行编码像一些常见的符号,如&lt;&gt;在输入的时候要对其进行转换编码,这样做浏览器是不会对该标签进行解释执行的,同时也不影响显示效果. 入参长度限制xss攻击要能达成往往需要较长的字符串,因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网络攻击","slug":"网络攻击","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}]},{"title":"JavaScript中对象的拓展、密封及冻结三大特性","slug":"JavaScript中对象的拓展、密封及冻结三大特性","date":"2020-03-02T09:24:20.000Z","updated":"2021-08-07T05:59:13.800Z","comments":true,"path":"2020/03/02/JavaScript中对象的拓展、密封及冻结三大特性/","link":"","permalink":"http://example.com/2020/03/02/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95%E3%80%81%E5%AF%86%E5%B0%81%E5%8F%8A%E5%86%BB%E7%BB%93%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 属性描述符属性描述符是ES5引入的概念,它用于描述对象的特征. 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符. MDN中的描述：数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下) configurable: 可配置性.当且仅当该属性的 configurable 为 true 时,该属性描述符才能够被改变,同时该属性也能从对应的对象上被删除.默认为 false. enumerable: 可枚举性.当且仅当该属性的enumerable为true时,该属性才能够出现在对象的枚举属性中.默认为 false. 数据描述符同时具有以下可选键值： writable: 可写性.当且仅当该属性的writable为true时,value才能被赋值运算符改变.默认为 false. value: 属性值.该属性对应的值.可以是任何有效的 JavaScript 值(数值,对象,函数等).默认为 undefined. 存取描述符同时具有以下可选键值： get: 一个给属性提供 getter 的方法,如果没有 getter 则为 undefined.当访问该属性时.该方法会被执行,方法执行时没有参数传入,但是会传入this对象（由于继承关系,这里的this并不一定是定义该属性的对象）. set: 一个给属性提供 setter 的方法,如果没有 setter 则为 undefined.当属性值修改时,触发执行该方法.该方法将接受唯一参数,即该属性新的参数值. 描述符可同时具有的键值:| | configurable | enumerable | value | writable | get | set| ——– | —–: | :—-: | :—-: | :—-: | :—-: | :—-: || 数据描述符 | Yes | Yes | Yes | Yes | No | No || 存取描述符 | Yes | Yes | No | No | Yes | Yes | 如果一个描述符不具有value,writable,get 和 set 任意一个关键字,那么它将被认为是一个数据描述符.如果一个描述符同时有(value或writable)和(get或set)关键字,将会产生一个异常. 常用API: Object.defineProperty(obj, prop, descriptor) obj:在其上定义或修改属性的对象. prop:要定义或修改的属性的名称. descriptor:将被定义或修改的属性描述符. Object.defineProperties(obj, props) obj:在其上定义或修改属性的对象. props:要定义其可枚举属性或修改的属性描述符的对象.对象中存在的属性描述符主要有两种:数据描述符和访问器描述符 Object.getOwnPropertyDescriptors(obj) obj:任意对象. Object.getOwnPropertyDescriptor(obj, prop) obj:需要查找的目标对象. prop:目标对象内属性名称 用法示例:12345678910111213141516171819202122232425262728293031323334353637383940let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; configurable: false, enumerable: true, writable: true, value: &#x27;Cola&#x27;&#125;);Object.defineProperties(obj, &#123; color: &#123; configurable: false, enumerable: true, writable: true, value: &#x27;red&#x27; &#125;, price: &#123; configurable: false, enumerable: true, writable: true, value: &#x27;3.5&#x27; &#125;&#125;);Object.defineProperty(obj, &#x27;updatePrice&#x27;, &#123; configurable: false, enumerable: true, get: function () &#123; return this.capacity; &#125;, set: function (price) &#123; this.price = price; &#125;&#125;);console.log(obj);//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 3.5, updatePrice: [Getter/Setter] &#125;obj.updatePrice = 5;console.log(obj);//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 5, updatePrice: [Getter/Setter] &#125; 规则： 如果属性不可配置,则不能修改它的可配置性和可枚举性,否则抛出异常 1234567891011121314151617181920212223242526let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: false, enumerable: false&#125;)try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: true &#125;)&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; enumerable: true &#125;)&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;color&#x27;));//&#123; value: undefined, writable: false, enumerable: false, configurable: false &#125; 如果存取器属性是不可配置的，则不能修改get和set方法，也不能将它转换为数据属性 123456789101112131415161718192021222324252627282930313233343536373839404142let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; configurable: false, enumerable: true, get: function () &#123; return this.name; &#125;, set: function (name) &#123; this.name = name; &#125;&#125;);try &#123; Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; get: function () &#123; return &#x27;Coca &#x27; + this.name; &#125; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: updateName&#125;try &#123; Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; set: function (val) &#123; this.name = val + this.name; &#125; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: updateName&#125;try &#123; Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; value: &#x27;Coco Cola&#x27; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: updateName&#125; 如果数据属性是不可配置的,则不能将它转换为存取器属性;同时也不能将它的可写性从false修改成true，但可以从true修改为false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: false, writable: false, value: &#x27;red&#x27;&#125;);try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; writable: true &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; get: function () &#123; return this.name; &#125; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: false, writable: true, value: &#x27;3.5&#x27;&#125;);try &#123; Object.defineProperty(obj, &#x27;price&#x27;, &#123; writable: false, value: &#x27;5&#x27; &#125;);&#125; catch (e) &#123; console.log(e);&#125;try &#123; Object.defineProperty(obj, &#x27;price&#x27;, &#123; value: &#x27;6&#x27; &#125;);&#125; catch (e) &#123; console.log(e);&#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;color&#x27;)); //&#123; value: &#x27;red&#x27;, writable: false, enumerable: false, configurable: false &#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;price&#x27;)); //&#123; value: &#x27;5&#x27;, writable: false, enumerable: false, configurable: false &#125; 如果数据属性是不可配置且不可写的,就不能修改它的值;如果是可配置但不可写，则可以修改值 1234567891011121314151617181920212223242526272829303132333435363738394041let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: false, writable: false, value: &#x27;red&#x27;&#125;);try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; value: &#x27;blue&#x27; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: true, writable: false, value: &#x27;3.5&#x27;&#125;);//可以直接修改值Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: true, writable: false, value: &#x27;12&#x27;&#125;);console.log(obj.price); //5console.log(Object.getOwnPropertyDescriptor(obj, &#x27;price&#x27;)); //&#123; value: &#x27;12&#x27;, writable: false, enumerable: false, configurable: true &#125;//可以修改writable为true后再修改值Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: true, writable: true, value: &#x27;3.5&#x27;&#125;);obj.price = 5;console.log(obj.price); //5 严格模式下,只指定get时,如果对该属性赋值将会抛出类型错误异常,只指定set时,如果读取该属性将返回undefined,非严格模式下都不抛出异常 1234567891011121314151617181920212223242526272829&#x27;use strict&#x27;let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; get: function () &#123; return &#x27;Coca &#x27; + this.name; &#125;&#125;);try &#123; obj.color = &#x27;blue&#x27;;&#125; catch (e) &#123; console.log(e); //TypeError: Cannot set property color of #&lt;Object&gt; which has only a getter&#125;console.log(obj.color); //Coca ColaObject.defineProperty(obj, &#x27;price&#x27;, &#123; set: function (val) &#123; this.name = val; &#125;&#125;);try &#123; console.log(obj.price);//undefined&#125; catch (e) &#123; console.log(e); &#125; 扩展特性如果一个对象可以添加新的属性,那么这个对象是可扩展的.如何检验对象是否可扩展及如何让它变得不可扩展呢？ 常用API: Object.isExtensible(obj) obj：需要检测的对象 Object.preventExtensions(obj) obj：将要变得不可扩展的对象 用法示例:1234567891011121314151617181920212223242526272829303132333435let obj = &#123; name: &#x27;Cola&#x27;&#125;//新创建的对象默认是可扩展的console.log(Object.isExtensible(obj)); //trueObject.preventExtensions(obj);console.log(Object.isExtensible(obj)); //falseobj.color = &#x27;red&#x27;;console.log(obj); //&#123; name: &#x27;Cola&#x27; &#125;try &#123; Object.defineProperty(obj, &quot;name&quot;, &#123; value: &#x27;Coca Cola&#x27; &#125;); //使用`Object.defineProperty`方法为不可扩展对象添加新属性会抛出异常 Object.defineProperty(obj, &quot;price&quot;, &#123; value: 3.5 &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot define property price, object is not extensible&#125; finally &#123; console.log(obj); //&#123; name: &#x27;Coca Cola&#x27; &#125;&#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;name&#x27;));//&#123; value: &#x27;Coca Cola&#x27;, writable: true, enumerable: true, configurable: true &#125;//writable属性为false时，属性值不可修改Object.defineProperty(obj, &quot;name&quot;, &#123; value: &#x27;Coca Cola&#x27;, writable: false,&#125;);obj.name = &#x27;Sprite&#x27;;console.log(obj); 密封特性密封对象是指不可扩展，且自身所有属性都不可配置的对象. 也就是说密封对象要满足以下条件: 不能添加新属性 不能删除已有属性 不能修改已有属性的可枚举性、可配置性、可写性,但可能可以修改已有属性的值的对象 常用API: Object.isSealed(obj) obj：需要检测的对象 Object.seal(obj) obj：需要被密封的对象 用法示例:1234567891011121314151617let obj = &#123; name: &#x27;Cola&#x27;&#125;//新建的对象默认不是密封的console.log(Object.isSealed(obj)); //false//手动密封Object.preventExtensions(obj);Object.defineProperty(obj, &#x27;name&#x27;, &#123; configurable: false&#125;)console.log(Object.isSealed(obj)); //true//空对象的手动密封let obj2 = &#123;&#125;Object.preventExtensions(obj2);console.log(Object.isSealed(obj2));//true 12345678910111213141516let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.seal(obj);console.log(Object.isSealed(obj)); //true//密封后不再能够添加或删除属性obj.color = &#x27;red&#x27;;delete obj.name;console.log(obj); //&#123; name: &#x27;Coca Cola&#x27; &#125;//密封后如果writable为trueobj.name = &#x27;Coca Cola&#x27;;console.log(obj); //&#123; name: &#x27;Pepsi Cola&#x27; &#125; 冻结特性冻结对象要满足以下条件: 不能添加新属性 不能删除已有属性 不能修改已有属性的可枚举性、可配置性、可写性 即这个对象永远是不可变的. 常用API: Object.isFrozen(obj) obj：需要检测的对象 Object.freeze(obj) obj：需要被冻结的对象 用法示例:1234567891011121314let obj = &#123; name: &#x27;Cola&#x27;&#125;//新建的对象默认不是冻结的console.log(Object.isFrozen(obj)); //false//当对象变得不可扩展且无属性时，也成为冻结对象Object.preventExtensions(obj);delete obj.name;console.log(Object.isFrozen(obj));//true//不可扩展的空对象是一个密封对象，同时也是冻结对象console.log(Object.isSealed(Object.preventExtensions(&#123;&#125;))); //trueconsole.log(Object.isFrozen(Object.preventExtensions(&#123;&#125;))); //true 12345678910let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.freeze(obj);console.log(Object.isFrozen(obj)); //true//对冻结对象的任何操作都会失败obj.name = &#x27;Coca Cola&#x27;;delete obj.name;console.log(obj); 注意:再严格模式下,对冻结对象的操作会抛出类型异常 浅冻结1234567891011let obj = &#123; name: &#x27;Cola&#x27;, color: &#123; CocaCola: &#x27;red&#x27;, PepsiCola: &#x27;blue&#x27; &#125;&#125;Object.freeze(obj);obj.name = &#x27;Sprite&#x27;obj.color.CocaCola = &#x27;white&#x27;;console.log(obj);//&#123; name: &#x27;Cola&#x27;, color: &#123; CocaCola: &#x27;white&#x27;, PepsiCola: &#x27;blue&#x27; &#125; &#125; 深冻结123456789101112function completelyFreezeObj(obj) &#123; if (Object.prototype.toString.call(obj) != &quot;[object Object]&quot;) &#123; console.error(&quot;obj不是对象&quot;); return; &#125; Object.freeze(obj); Object.keys(obj).forEach((key) =&gt; &#123; if (Object.prototype.toString.call(obj[key]) == &quot;[object Object]&quot;) &#123; completelyFreezeObj(obj[key]); &#125; &#125;);&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Google JavaScript 编码规范部分整理","slug":"Google JavaScript 编码规范部分翻译整理","date":"2020-02-17T08:54:50.000Z","updated":"2021-08-07T05:59:13.704Z","comments":true,"path":"2020/02/17/Google JavaScript 编码规范部分翻译整理/","link":"","permalink":"http://example.com/2020/02/17/Google%20JavaScript%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 写在前面本文参考: https://google.github.io/styleguide/jsguide.html http://alloyteam.github.io/JX/doc/specification/google-javascript.xml https://max.book118.com/html/2019/0202/7052110006002005.shtm https://segmentfault.com/a/1190000012916070#item-5-22 https://github.com/wayou/wayou.github.io/issues/21 因本人水平有限,如有错误,可及时联系作者修改. 背景JavaScript 是一种客户端脚本语言，Google 的许多开源工程中都有用到它。这份指南列出了编写 JavaScript 时需要遵守的规则，当且仅当 JavaScript 源文件遵守此处规则时，它才被描述为 Google 风格。 JavaScript 语言规范 局部变量声明 使用const 和let用 const或 let 声明所有局部变量，默认情况下使用const，除非需要重新分配变量。 一个变量一个声明每个局部变量声明仅声明一个变量。不使用诸如 let a = 1, b = 2; 这样的声明形式。 在需要时进行声明，并尽快初始化局部变量不是在其包含的块或类似块的结构的开头习惯性地声明的。而是将局部声明在接近首次使用它们的地方(在合理范围内)，以最大程度地减小其范围。 根据需要声明类型可以在声明的局部变量上方添加JSDoc类型注释，或者如果不存在其他JSDoc，则可以在变量名称之前内联。 例： 1234567const /**! Array &lt;number&gt; */ data = [];/** * 一些描述 * @type &#123;! Array &lt;number&gt;&#125; */ const data = []; 不允许混合使用内联和JSDoc样式：因为编译器将仅处理第一个JSDoc，即内联注释会丢失，例： 1/** 一些描述。*/ const /**！Array &lt;number&gt; */ 数据= []; 提示：在许多情况下，编译器可以推断出模板化类型，但不能推断其参数。当初始化字面量或构造函数调用不包含模板参数类型的任何值(例如，空数组，对象，Map和Set)或变量在闭包中修改时，在这些情况下，局部变量类型注释特别有用，否则编译器会将模板参数推断成未知。 数组字面量 使用逗号结尾如果最后一个元素和右括号之间有换行符，请在结尾加上逗号，例：1234const values = [ &#x27;first value&#x27;, &#x27;second value&#x27;,]; 不要使用可变参数的 Array构造函数构造函数很容易因为传参不恰当而导致错误。请改用字面量形式。不建议的形式，例： 1234const a1 = new Array(x1, x2, x3);const a2 = new Array(x1, x2);const a3 = new Array(x1);const a4 = new Array(); 除了第三种情况外，这可以按照预期工作：如果x1为整数，那么a3则是一个长度为x1的数组，其所有元素均为undefined。如果x1为其他任何数字，则将引发异常。 建议的写法，例： 1234const a1 = [x1, x2, x3];const a2 = [x1, x2];const a3 = [x1];const a4 = []; 在适当的时候，允许用new Array(length)显示分配一个给定长度的数组。 非数字属性请勿在数组上定义或使用非数字属性（除了length）。使用Map（或Object）代替。 解构数组字面量可用于分配的左侧以执行解构（例如，从单个数组中解压缩多个值或可迭代时）。 可以包含最后一个rest元素（在…和变量名之间没有空格）,例：123const [a, b, c, ...rest] = generateResults();//解构赋值还可以忽略某些元素let [, b,, d] = someArray 解构也可以用于函数参数（请注意，参数名称是必需的，但会被忽略）。如果解构数组的参数是可选的，要始终指定[]为默认值，并在左侧提供默认值，例：12/** @param &#123;!Array&lt;number&gt;=&#125; param1 */function optionalDestructuring([a = 4, b = 2] = []) &#123; … &#125;; 错误的写法，例：1function badDestructuring([a, b] = [4, 2]) &#123; … &#125;; 提示：对于将多个值（解包）到一个函数的参数或返回中，在可能的情况下，优先选择对象分解而不是数组分解，因为它允许命名单个元素并为每个元素指定不同的类型。 展开运算符数组字面量可以包含展开运算符（… ），以将元素从一个或多个可迭代对象中展开，而不是用更笨拙的构造Array.prototype 。变量紧跟在展开运算符后，没有空格。 对象字面量 不要使用Object构造函数虽然Object 构造器没有上述类似的问题, 但鉴于可读性和一致性考虑, 最好还是在字面上更清晰地指明，例：123var o = &#123;&#125;;var o2 = &#123; a: 0, b: 1, c: 2 &#125; 请勿混用带引号和不带引号的键对象字面量可以表示结构（具有未加引号的键和/或符号）或字典（具有引号和/或计算的键）。不要将这两种键类型混合在单个对象字面量中，例：1234let obj = &#123; width: 42,// struct风格的未加引号的键 &#x27;maxWidth&#x27;: 43 // dict风格的加引号的键&#125; 这还扩展到将属性名称传递给函数，例如 hasOwnProperty。特别是这样做会破坏编译后的代码，因为编译器无法重命名/混淆字符串文字。不建议的写法，例：12345/** @type &#123;&#123;width: number, maxWidth: (number|undefined)&#125;&#125; */const o = &#123;width: 42&#125;;if (o.hasOwnProperty(&#x27;maxWidth&#x27;)) &#123;...&#125; 最好这样实现，例：12345/** @type &#123;&#123;width: number, maxWidth: (number|undefined)&#125;&#125; */const o = &#123;width: 42&#125;;if (o.maxWidth != null) &#123;...&#125; 计算的属性名称允许使用计算的属性名称（例如&#123;[&#39;key&#39;+ foo（）]：42&#125;），并且将其视为dict样式（带引号的）键（即，不得与非引号的键混合使用），除非计算出的属性 是一个符号（例如[Symbol.iterator]）。 枚举值也可以用于计算键，但不应与同一字面量中的非枚举键混合使用,例：1234567function foo()&#123; return &#x27;width&#x27;&#125;let obj = &#123; width: 42, [&#x27;max&#x27; + foo()] : 43&#125; 方法速记可以使用方法简写（&#123;method（）&#123;…&#125;&#125;）代替冒号后紧跟函数或箭头函数常量，从而在对象上定义方法。例：123456let obj = &#123; width: 42, getWidth()&#123; return this.width; &#125;&#125; 速记属性对象字面量允许使用速记属性,例：1234567const foo = 1;const bar = 2;const obj = &#123;foo,bar,method() &#123; return this.foo + this.bar; &#125;&#125;; 解构对象解构模式可以在分配的左侧使用，以执行解构并从单个对象解压缩多个值。分解后的对象也可以用作函数参数，但应保持尽可能的简单：单个级别的未引用速记属性。 参数解构中可能不使用更深层的嵌套和计算的属性。 在解构参数的左侧指定任何默认值（&#123;str =&#39;some default&#39;&#125; = &#123;&#125;，而不是&#123;str&#125; = &#123;str：&#39;some default&#39;&#125;），如果解构对象为本身是可选的，它必须默认为&#123;&#125;。 可以为分解结构参数的JSDoc指定任何名称（该名称未使用，但编译器需要）,例：12345678910111213141516/*** @param &#123;string&#125; ordinary* @param &#123;&#123;num: (number|undefined), str: (string|undefined)&#125;=&#125; param1* num: The number of times to do something.* str: A string to do stuff to.*/function destructured(ordinary, &#123;num, str = &#x27;some default&#x27;&#125; = &#123;&#125;)不被允许的写法，例：/** @param &#123;&#123;x: &#123;num: (number|undefined), str: (string|undefined)&#125;&#125;&#125; param1 */function nestedTooDeeply(&#123;x: &#123;num, str&#125;&#125;) &#123;&#125;;/** @param &#123;&#123;num: (number|undefined), str: (string|undefined)&#125;=&#125; param1 */function nonShorthandProperty(&#123;num: a, str: b&#125; = &#123;&#125;) &#123;&#125;;/** @param &#123;&#123;a: number, b: number&#125;&#125; param1 */function computedKey(&#123;a, b, [a + b]: c&#125;) &#123;&#125;;/** @param &#123;&#123;a: number, b: string&#125;=&#125; param1 */function nontrivialDefault(&#123;a, b&#125; = &#123;a: 2, b: 4&#125;) &#123;&#125;; 枚举枚举是通过将@enum批注添加到对象字面量中来定义的。 定义枚举后，可能无法将其他属性添加到枚举中。 枚举必须是常量，并且所有枚举值都必须是不可变的,例：12345678910111213141516171819/*** Supported temperature scales.* @enum &#123;string&#125;*/const TemperatureScale = &#123; CELSIUS: &#x27;celsius&#x27;, FAHRENHEIT: &#x27;fahrenheit&#x27;,&#125;;/*** An enum with two options.* @enum &#123;number&#125;*/const Option = &#123; /** The option used shall have been the first. */ FIRST_OPTION: 1, /** The second among two options. */ SECOND_OPTION: 2,&#125;; 类 构造函数构造函数是可选的,子类构造函数必须在设置任何字段或以其他方式访问this之前调用super（）。正确的写法,例:1234constructor(name, age, height) &#123; super(name,age); this.height = height;&#125; 错误的写法,例:12345constructor(name, age, height) &#123; this.height = height; super(name,age); //SyntaxError: &#x27;this&#x27; is not allowed before super()&#125; 字段在构造函数中设置所有具体对象的字段（即方法以外的所有属性）。使用 @const 修饰的字段代表常量，不能被重新赋值。 使用适当的可见性注释（@private，@protected，@package）注释非公共字段，并在所有@private字段的名称后面加上下划线。 字段永远不会设置在具体类的原型上,例:123456789class Foo &#123;constructor() &#123; /** @private @const &#123;!Bar&#125; */ this.bar_ = computeBar(); /** @protected @const &#123;!Baz&#125; */ this.baz = computeBaz();&#125;&#125; 提示:类在初始化之后，就不能再向其添加或删除属性了，因为这会影响虚拟机对其进行优化。如果必要，可以将之后才进行初始化的字段先赋值为 undefined，这样先占位之后，防止后面再添加新属性。对象身上的@struct 注释可以对不存在的字段的访问进行检查。类自带了这一功能。 计算属性计算属性只能用于类的属性是 symbol 的情况。 Dict-style 类型的属性（带引号或非 symbol 的计算属性是不被允许的。对于可遍历的类，需要定义其 [Symbol.iterator] 方法。其他情况下少用 Symbol。 注意:使用其他内建的 symbol 时要格外小心（e.g. Symbol.isConcatSpreadable）,因为编译器没有对它进行垫片（向后兼容）处理，所以在旧版浏览器中会有问题 静态方法在不影响可读性的前提下，推荐使用模块内部的函数而不是静态方法。 静态方法应该只用于基类。静态方法不应该从一个保存了实例的变量身上调用，这个实例有可能是构造器或者子类的构造器初始化而来（静态方法应该使用 @nocollapse 来注释），而且如果子类没有定义该方法的话，不应该从子类直接调用。 错误的写法,例: 1234class Base &#123; /** @nocollapse */ static foo() &#123;&#125; &#125;class Sub extends Base &#123;&#125;function callFoo(cls) &#123; cls.foo(); &#125; // discouraged: don&#x27;t call static methods dynamicallySub.foo(); // illegal: don&#x27;t call static methods on subclasses that don&#x27;t define it themselves 声明类的旧方式ES6 方式的类声明是首选，但在某些情况下ES6类可能不可行。例如： 如果存在或将要存在子类，包括框架创建的子类，还不能立即使用 ES6 风格的类声明。因为如果基类使用 ES6 方式的话，所有子类代码都需要更改。 有些框架在调用子类构造器时需要显式提供 this，而 ES6 风格的类中在调用 super 前是获取不到 this 的。 此规则还应用于这些代码：let，const，默认参数，rest 和箭头函数。 通过 goog.defineClass 可以进行类 ES6 方式的类声明： 123456789101112131415161718let C = goog.defineClass(S, &#123;/*** @param &#123;string&#125; value*/constructor(value) &#123; S.call(this, 2); /** @const */ this.prop = value;&#125;,/*** @param &#123;string&#125; param* @return &#123;number&#125;*/method(param) &#123; return 0;&#125;,&#125;); 另外，尽管goog.defineClass所有新代码都应首选，但也可以使用更传统的语法,例: 123456789101112131415161718/*** @constructor @extends &#123;S&#125;* @param &#123;string&#125; value*/function C(value) &#123;S.call(this, 2);/** @const */this.prop = value;&#125;goog.inherits(C, S);/*** @param &#123;string&#125; param* @return &#123;number&#125;*/C.prototype.method = function(param) &#123;return 0;&#125;; 如果有基类的话，实例中的属性需要在基类的构造器中定义。而方法则需要在构造器的原型上定义。 一开始正确地定义构造器的继承关系并不是件容易的事！所以，最好使用 the Closure Library 提供的 goog.inherits 方法。 不要直接操作prototype通过 class 关键字定义类比操作 prototype 更加简洁和直观。一般情况下的代码并没有必要操作原型，尽管它们对于定义旧式类声明中定义的类仍然有用。明确禁止混入和修改内置对象的原型.例外:框架代码(例如Polymer或Angular)可能需要使用prototypes，否则实现起来会更加丑陋。 Getters and Setters不要使用 JavaScript getter和 setter属性。其行为不透明出问题难追查，编译器支持上也有局限。提供正常的方法来代替他们。 例外：在某些情况下不可避免地会定义getter或setter（例如Angular和Polymer等数据绑定框架，或者无法与调整的外部API的兼容时）。仅在这些情况下，使用getter和setter时要格外小心，前提是它们是通过get和set简写方法关键字定义的Object.defineProperties（或（不是 Object.defineProperty，这会干扰属性重命名））。Getters不得更改可观察状态。 不允许的写法,例: 123class Foo &#123;get next() &#123; return this.nextId++; &#125;&#125; 重写 toString可以重写 toString 方法，但始终应该返回成功，并且不产生副作用（side effects）。 提示:需要注意的是，特别是在 toString 中调用其他方法时，特殊情况可能导致死循环。 接口接口可以通过 @interface 或 @record 来声明。通过 @record 声明的接口能够被显式（i.e. 通过 @implements）或者隐式地被类或对象实现。接口上的所有非静态方法主体都必须为空块。 字段必须在类构造函数中声明为未初始化的成员,例: 12345678910111213141516/*** Something that can frobnicate.* @record*/class Frobnicator &#123;constructor() &#123; /** @type &#123;number&#125; The number of attempts before giving up. */ this.attempts;&#125;/*** Performs the frobnication according to the given strategy.* @param &#123;!FrobnicationStrategy&#125; strategy*/frobnicate(strategy) &#123;&#125;&#125; 抽象类适当时使用抽象类。抽象类和方法必须使用注释@abstract。不要使用goog.abstractMethod。请参阅抽象类和方法。 函数 顶级函数顶级函数可以直接在导出对象上定义，也可以在本地声明，也可以选择导出,例:1234/** @param &#123;string&#125; str */exports.processString = (str) =&gt; &#123;// Process the string.&#125;; 123456/** @param &#123;string&#125; str */const processString = (str) =&gt; &#123;// Process the string.&#125;;exports = &#123;processString&#125;; 嵌套函数及闭包函数内可包含嵌套函数的定义。如果需要，可以赋值给一个 const 变量。 箭头函数箭头函数提供了简洁的函数语法，并简化了嵌套函数的作用域。 优先选择箭头函数而不是function关键字，特别是对于嵌套函数。 推荐使用箭头函数代替 f.bind(this)，特别是代替 goog.bind(f,this)。 避免const self = this这样的写法。箭头函数特别适合用于可能会传参回调。 箭头的左侧包含零个或多个参数。如果只有一个未分解的参数，则参数周围的括号是可选的。使用括号时，可以指定内联参数类型 提示:始终都写括号是种好的做法，因为后面如果一旦新加了参数又忘记写括号则会有语法错误。 箭头的右侧包含函数的主体。 默认情况下，主体为block语句（零个或多个用花括号括起来的语句）。 如果发生以下情况之一，则主体也可能是隐式返回的单个表达式：程序逻辑要求返回值，或者void运算符位于单个函数或方法调用之前（使用void确保未定义返回，防止泄漏值并传达意图）。 如果单一表达形式提高了可读性（例如，对于简短表达或简单表达），则它是首选,例: 12345678910111213141516171819202122232425/*** Arrow functions can be documented just like normal functions.* @param &#123;number&#125; numParam A number to add.* @param &#123;string&#125; strParam Another number to add that happens to be a string.* @return &#123;number&#125; The sum of the two parameters.*/const moduleLocalFunc = (numParam, strParam) =&gt; numParam + Number(strParam);// Uses the single expression syntax with `void` because the program logic does// not require returning a value.getValue((result) =&gt; void alert(`Got $&#123;result&#125;`));class CallbackExample &#123;constructor() &#123; /** @private &#123;number&#125; */ this.cachedValue_ = 0; // For inline callbacks, you can use inline typing for parameters. // Uses a block statement because the value of the single expression should // not be returned and the expression is not a single function call. getNullableValue((/** ?number */ result) =&gt; &#123; this.cachedValue_ = result == null ? 0 : result; &#125;);&#125;&#125; 不建议的写法,例: 123456/*** A function with no params and no returned value.* This single expression body usage is illegal because the program logic does* not require returning a value and we&#x27;re missing the `void` operator.*/const moduleLocalFunc = () =&gt; anotherFunction(); 生成器(Generators)生成器带来许多有用的抽象概念，必要时可以使用。 通过在function关键字后面加*号来定义一个生成器，后面加空格与生成器名称隔开。使用代理的yield时，在yield关键字后加*号,例: 12345678910111213141516/** @return &#123;!Iterator&lt;number&gt;&#125; */function* gen1() &#123; yield 42;&#125;/** @return &#123;!Iterator&lt;number&gt;&#125; */const gen2 = function*() &#123; yield* gen1();&#125;class SomeClass &#123;/** @return &#123;!Iterator&lt;number&gt;&#125; */* gen() &#123; yield 42; &#125;&#125; 参数和返回类型函数参数和返回类型通常应使用JSDoc注释记录。 默认参数参数列表中通过等号来指定可选参数。可选参数必须在=运算符的两侧都包含空格，命名上与正常参数一样（不使用 opt_ 前缀），JSDoc 指定类型时使用=后缀，顺序上置于正常参数之后，不要用初始化以确保代码明确。所有可选参数都需要指定默认值，哪怕它是undefined。123456789101112131415/*** @param &#123;string&#125; required This parameter is always needed.* @param &#123;string=&#125; optional This parameter can be omitted.* @param &#123;!Node=&#125; node Another optional parameter.*/function maybeDoSomething(required, optional = &#x27;&#x27;, node = undefined) &#123;&#125;/** @interface */class MyInterface &#123;/*** Interface and abstract methods must omit default parameter values.* @param &#123;string=&#125; optional*/someMethod(optional) &#123;&#125;&#125; 尽量少地使用可选参数。参数不定的情况下推荐使用解构的方式，这样所定义出来的 API 更加可读。 注意：与 Python 不同，初始化可选参数时返回新的非可变对象（[] 或 {}）是可以的。因为每次可选参数被使用时，都是重新赋值，不会与上一次的复用。包括函数调用的任何表达式都会用到初始化模块，所以初始化模块应该尽量简单。避免初始化模块暴露共享可变域，这容易导致函数调用之间的无意耦合。 剩余参数使用剩余参数而不是 arguments。JSDoc 中使用...标识剩余参数。剩余参数必需位于参数列表末尾。注意...与参数名间没有空格。也不要给剩余参数命名。千万不要给变量或参数取名arguments，这会覆盖内建的同名参数,例:12345/*** @param &#123;!Array&lt;string&gt;&#125; array This is an ordinary parameter.* @param &#123;...number&#125; numbers The remainder of arguments are all numbers.*/function variadic(array, ...numbers) &#123;&#125; 泛型定义泛型函数或方法时需在JS注文中加上@template TYPE。 扩展运算符可使用展示操作符（...）来调用函数。当使用数组或可遍历对象解析后作为函数入参时，推荐使用展开操作符来替代 Function.prototype.apply。注意...后面没有空格,例: 12function myFunction(...elements) &#123;&#125;myFunction(...array, ...iterable, ...generator()); 字符串字面量 使用单引号常规字符串使用单引号(&#39;)而非双引号(&quot;)来定义。通常情况下，字符串不能跨行。 提示:如果字符串包含单引号字符，请考虑使用模板字符串，以避免不得不对引号进行转义。 模板字符串使用模板字符串（ `）替代复杂的字符串拼接，特别是参与拼接的变量很多时。模板字符串是可以跨越多行的。模板字符串跨越多行时，可不受代码块缩进规则限制，如果加上缩进好看些的话也可以,例: 1234567function arithmetic(a, b) &#123;return `Here is a table of arithmetic operations:$&#123;a&#125; + $&#123;b&#125; = $&#123;a + b&#125;$&#123;a&#125; - $&#123;b&#125; = $&#123;a - b&#125;$&#123;a&#125; * $&#123;b&#125; = $&#123;a * b&#125;$&#123;a&#125; / $&#123;b&#125; = $&#123;a / b&#125;`;&#125; 不要使用多行接续无论是常规字符串还是模板字符串中都不要使用多行接续（即在行尾加反斜杠\\）。虽然 ES5 允许这么操作，但反斜杠后的空格会导致问题，并且这种形式也不易读。错误的写法,例:123const longString = &#x27;This is a very long string that far exceeds the 80 \\column limit. It unfortunately contains long stretches of spaces due \\to how the continued lines are indented.&#x27;; 正确的写法,例:123const longString = &#x27;This is a very long string that far exceeds the 80 &#x27; +&#x27;column limit. It does not contain long stretches of spaces since &#x27; +&#x27;the concatenated strings are cleaner.&#x27;; 数字字面量数字可有多种呈现形式：十进制，十六进制，八进制或二进制。分别使用小写的 0x，0o，0b 前缀表示十六进制，八进制以及二进制数字。除此之外不应该出现以0开头的数字。 控制结构 for循环ES6之后一共有三种for循环,推荐使用for-offor-in适用于字典类型（dist-style）而不要用于遍历数组。配合Object.prototype.hasOwnProperty来过滤掉非直接的属性。推荐使用for-of 和 Object.keys，其次才是 for-in。 异常异常是语言中重要的一部分，发生异常时应尽可能抛出。始终抛出Error或子类的Error，而不是抛出字符串或其他对象作为异常。使用 Error时始终通过new来创建新实例。 这种处理扩展到Promise拒绝值，因为在异步函数中Promise.reject（obj）等效于throw obj; 。 自定义类型的错误提供了非常好的方式展示函数中的异常。当原生错误类型不能满足需求时，应尽可能创建自定义的异常。 遇到错误后立即抛出优于将错误进行传递。 空的 catch 块 响应捕获到的异常，什么也不做是非常正确的。 当确实在catch块中不执行任何操作时，但记得加注释解释一下原因,例: 123456try &#123; return handleNumericResponse(response);&#125; catch (ok) &#123;// it&#x27;s not numeric; that&#x27;s fine, just continue&#125;return handleTextResponse(response); 错误的写法,例: 12345try &#123; shouldFail(); fail(&#x27;expected an error&#x27;);&#125; catch (expected) &#123;&#125; 提示:不像其他一些语言，上面示例行不通，因为会通过fail来捕获处理。所以使用assertThrows。 switch 语句术语解释：switch 语句体中其实是很多组的代码块。每一组又包含一个或多个 switch 标签（case Foo: 或 default:）以及标签后跟随的代码语句。 Fall-through：要加注释每个 switch 标签要么通过break，return，throw 结束，要么通过注释直接跳过到下一标签。在发生跳过的情况时，随便加个注释都行。如果是最后一个标签可以不加,例:1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; default 是不能省的即使 default 标签中不包含逻辑，也不要省略。 this 应该只在类的构造器或方法中使用this，或类中的箭头函数。其他情况下使用·this·需要在函数的 JSDoc 结尾处添加 @this 注释。 不要使用this来引用全局对象，eval的执行上下文，事件的触发元素，以及函数这种不必要的用法中 call()，apply() 。 相等检查使用恒等运算符（=== /！==），但以下情况除外。 需要强制转换的异常捕捉null和undefined值：1234if (someObjectOrPrimitive == null) &#123; // Checking for null catches both null and undefined for objects and primitives , // but does not catch other falsy values like 0 or the empty string.&#125; 禁止使用的特性 with杜绝使用with关键字。这样的代码不易读，而且 ES5 之后就禁止掉了。 代码的动态求值不要使用eval或Function(...string) 构造器代码加载器（code loader）中除外）。这些关键字很危险并且在 CSP 环境中是不工作的。 CSP 指 Content Security Policy (CSP) 自动分号添加始终以分号结束语句（类与函数的声明除外）。 非标准的特性不要使用还不是标准的特性。包括已经被移除的特性（e.g. WeakMap.clear），还未纳入标准的新特性（e.g. TC39 目前的草稿，提议，通过提议但还未完成标准制定），或一些只被部分浏览器所实现的特性。只使用包含在 ECMA-262 或 WHATWG standards 标签中的特性。但一些有自己规范的项目是可以使用这些特性的，比如 Chrome 插件或 Node.js。三方转译器提供的特性也是被禁止的。 原始类型的包装对象对于原始值的包装对象（Boolean, Number, String, Symbol）不能用new调用，也不能用来作类型声明。错误的写法,例:12const /** Boolean */ x = new Boolean(false);if (x) alert(typeof x); // alerts &#x27;object&#x27; - WAT? 这些包装器可在需要类型转换时当作函数来调用（而不是使用拼接空字符串的方式来转成字符串），或用于创建 symbol。12const /** boolean */ x = Boolean(0);if (!x) alert(typeof x); // alerts &#x27;boolean&#x27;, as expected 修改原生对象千万不要修改原生对象，向其构造器或原型添加方法都是不行的。进行了这些操作的三方库也要避免使用。编译器在编译时会尽可能提供这些原生对象的原始版本；所以原生对象的任何东西都不要去动。 不到万不得已，不要向全局对象添加属性（e.g. 三方库需要这样做）。 JavaScript 编码风格 JSDocJSDoc 使用在了所有的类，字段以及方法上。 通用形式JSDoc 基本的形式如下：123456/*** Multiple lines of JSDoc text are written here,* wrapped normally.* @param &#123;number&#125; arg A number to do something to.*/function doSomething(arg) &#123; … &#125; 或者这种单行的形式：12/** @const @private &#123;!Foo&#125; A short bit of JSDoc. */this.foo_ = foo; 如果单行形式长到需要折行，则需要切换到多行模式而不是使用单行形式。有许多工具会对 JSDoc 文档进行解析以提取出有效的信息对代码进行检查和优化。所以这些注释需要好好写。 MarkdownJSDoc 支持 Markdown，所以必要时可包含 HTML。工具会自动提取 JSDoc 的内容，其中自己书写的格式会被忽略。比如如果你写成下面这个样子：123456/*** Computes weight based on three factors:* items sent* items received* last timestamp*/ 最终提取出来是这样的：Computes weight based on three factors: items sent items received last timestamp取而代之的是，我们应该按 markdown 的语法来格式化,例：1234567/*** Computes weight based on three factors:** - items sent* - items received* - last timestamp*/ JSDoc标签本规则可使用 JSDoc tags 的一个子集。详细列表见附录。大部分 tags 独占一行。错误的写法,例：12345/*** The &quot;param&quot; tag must occupy its own line and may not be combined.* @param &#123;number&#125; left @param &#123;number&#125; right*/function add(left, right) &#123; ... &#125; 简单的 tag 无需额外数据（比如 @private，@const，@final，@export），可以合并到一行。 123456789101112131415161718/*** Place more complex annotations (like &quot;implements&quot; and &quot;template&quot;)* on their own lines. Multiple simple tags (like &quot;export&quot; and &quot;final&quot;)* may be combined in one line.* @export @final* @implements &#123;Iterable&lt;TYPE&gt;&#125;* @template TYPE*/class MyClass &#123;/*** @param &#123;!ObjType&#125; obj Some object.* @param &#123;number=&#125; num An optional number.*/constructor(obj, num = 42) &#123; /** @private @const &#123;!Array&lt;!ObjType|number&gt;&#125; */ this.data_ = [obj, num];&#125;&#125; 关于合并及合并后的顺序没有明确的规范，代码中保持一致即可。 换行换行之后的 tag 块使用四个空格进行缩进。12345678910/*** Illustrates line wrapping for long param/return descriptions.* @param &#123;string&#125; foo This is a param with a description too long to fit in* one line.* @return &#123;number&#125; This returns something that has a description too long to* fit in one line.*/exports.method = function(foo) &#123;return 5;&#125;; @fileoverview 换行时不缩进。 文件头部注释一个文件可以在头部有个总览。包括版权信息，作者以及默认可选的可见信息/visibility level等。文件中包含多个类时，头部这个总览显得很有必要。它可以帮助别人快速了解该文件的内容。如果写了，则应该有一个描述字段简单介绍文件中的内容以及一些依赖，或者其他信息。换行后不缩进,例:12345/*** @fileoverview Description of file, its uses and information* about its dependencies.* @package*/ 类的注释类，接口以及 records 需要有描述，参数，实现的接口以及可见性或其他适当的 tags 注释。类的描述需要告诉读者类的作用及何时使用该类，以及其他一些可以帮助别人正确使用该类的有用信息。构造器上的文本描述可省略。@constructor 和 @extends 不与 class 一起使用，除非该类是用来声明接口 @interface 或者扩展一个泛型类。123456789101112131415161718192021222324/*** A fancier event target that does cool things.* @implements &#123;Iterable&lt;string&gt;&#125;*/class MyFancyTarget extends EventTarget &#123;/*** @param &#123;string&#125; arg1 An argument that makes this more interesting.* @param &#123;!Array&lt;number&gt;&#125; arg2 List of numbers to be processed.*/constructor(arg1, arg2) &#123; // ...&#125;&#125;;/*** Records are also helpful.* @extends &#123;Iterator&lt;TYPE&gt;&#125;* @record* @template TYPE*/class Listable &#123;/** @return &#123;TYPE&#125; The next item in line to be returned. */next() &#123;&#125;&#125; 枚举和 typedef 注释所有枚举和typedef必须在上一行用适当的JSDoc标记（@typedef或@enum）进行记录。 公共枚举和typedef也必须有描述。 单个枚举项可能在上一行带有JSDoc注释的文档中。123456789101112131415/*** A useful type union, which is reused often.* @typedef &#123;!Bandersnatch|!BandersnatchType&#125;*/let CoolUnionType;/*** Types of bandersnatches.* @enum &#123;string&#125;*/const BandersnatchType = &#123;/** This kind is really frumious. */FRUMIOUS: &#x27;frumious&#x27;,/** The less-frumious kind. */MANXOME: &#x27;manxome&#x27;,&#125;; Typedefs 可方便地用于定义 records 类型，或 unions 的别名，复杂函数，或者 泛型类型。Typedefs 不适合用来定义字段很多的 records，因为其不支持对每个字段进行文档书写，也不适合用于模板或递归引用中。对于大型 records 使用 @record。 方法与函数注释在方法和命名函数中，必须记录参数和返回类型，除非相同签名@overrides省略所有类型。必要时应记录此类型。如果函数没有非空的return语句，则可以省略返回类型。 如果方法，参数和返回描述（但不是类型）在方法的其余JSDoc或其签名中显而易见，则可以省略。 方法的描述应使用第三人称。 如果方法覆盖超类方法，则它必须包含@override注释。覆盖的方法从超类方法继承所有JSDoc注释（包括可见性注释），并且应在覆盖的方法中将其省略。但是，如果在类型注释中完善了任何类型，则必须显式指定所有@param和@return注释。 1234567891011121314151617181920212223/** A class that does something. */class SomeClass extends SomeBaseClass &#123;/*** Operates on an instance of MyClass and returns something.* @param &#123;!MyClass&#125; obj An object that for some reason needs detailed* explanation that spans multiple lines.* @param &#123;!OtherClass&#125; obviousOtherClass* @return &#123;boolean&#125; Whether something occurred.*/someMethod(obj, obviousOtherClass) &#123; ... &#125;/** @override */overriddenMethod(param) &#123; ... &#125;&#125;/*** Demonstrates how top-level functions follow the same rules. This one* makes an array.* @param &#123;TYPE&#125; arg* @return &#123;!Array&lt;TYPE&gt;&#125;* @template TYPE*/function makeArray(arg) &#123; ... &#125; 如果只需要记录函数的参数和返回类型，则可以选择在函数签名中使用内联JSDocs。 这些内联JSDocs指定不带标签的return和param类型,例: 1function /** string */ foo(/** number */ arg) &#123;...&#125; 如果需要描述或标签，请在方法上方使用单个JSDoc注释。 例如，返回值的方法需要@return标记。 1234567class MyClass &#123;/*** @param &#123;number&#125; arg* @return &#123;string&#125;*/bar(arg) &#123;...&#125;&#125; 以下写法是错误的: 1234567// Illegal inline JSDocs.class MyClass &#123;/** @return &#123;string&#125; */ foo() &#123;...&#125;&#125;/** Function description. */ bar() &#123;...&#125; 在匿名函数中，注释通常是可选的。 如果自动类型推断不足或显式注释提高了可读性，则对param进行注释并返回如下类型： 123456promise.then(/** @return &#123;string&#125; */(/** !Array&lt;string&gt; */ items) =&gt; &#123;doSomethingWith(items);return items[0];&#125;); 命名 适用于所有标识符的规则可用于标识符的有 ASCII 字符，数字，还有下划线 _ 以及不太常用的 $ (一些框架里面比如 Angular 会用)。 标识符取名尽量表意。不要怕名字太长，因为代码是给人看的，别人能看懂最重要。不要使用带歧义的缩写或者项目之外的人看不懂的缩写，也不要通过删除某个单词中的字符来发明缩写，例: 1234errorCount // No abbreviation.dnsConnectionIndex // Most people know what &quot;DNS&quot; stands for.referrerUrl // Ditto for &quot;URL&quot;.customerId // &quot;Id&quot; is both ubiquitous and unlikely to be misunderstood. 不建议的写法例： 1234567n // Meaningless.nErr // Ambiguous abbreviation.nCompConns // Ambiguous abbreviation.wgcConnections // Only your group knows what this stands for.pcReader // Lots of things can be abbreviated &quot;pc&quot;.cstmrId // Deletes internal letters.kSecondsPerDay // Do not use Hungarian notation. 标识符类型的命名规则 包名包名全是lowerCamelCase。例如， my.exampleCode.deepSpace但不是my.examplecode.deepspace或my.example_code.deep_space。 类名定义类，接口，记录和 typedef 名称时,使用大写开头的驼峰UpperCamelCase。 未被导出的类只本地使用，并没有用 @private 标识，所以命名上不需要以下划线结尾。 类型名称通常为名词或名词短语。比如，Request，ImmutableList，或者 VisibilityMode。此外，接口名有时会是一个形容词或形容短语（比如 Readable）。 方法名方法名使用小写开头的驼峰。私有方法需以下划线结尾。 方法名一般为动词或动词短语。比如sendMessage或者stop_。属性的 Getter 或 Setter 不是必需的，如果有的话，也是小写驼峰命名且需要类似这样 getFoo(对于布尔值使用 isFoo 或 hasFoo 形式)， setFoo(value)。 单元测试代码中的方法名会出现用下划线来分隔组件形式。一种典型的形式是这样的 test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如 testPop_emptyStack。对于这种测试代码中的方法，命名上没有统一的要求。 枚举名枚举使用大写开头的驼峰，和类相似，一般一个单数形式的名词。枚举中的元素写成CONSTANT_CASE。 常量名常量写成 CONSTANT_CASE：所有字母使用大写，以下划线分隔单词。私有静态属性可以用内部变量代替，所以不会有使用私有枚举的情况，也就无需将常量以下划线结尾来命名。 常量的定义每个常量都是 @const 标识的静态属性或模块内部通过const声明的变量，但并不是所有 @const 标识的静态属性或 const声明的变量都是常量。需要常量时，先想清楚该对象是否真的不可变。例如，如果该对象中可观察状态中任何一个可被改变，那么几乎可以肯定它不是常数。只是想着不去改变它的值是不够的，我们要求它需要从本质上来说应该一成不变,例:12345678910111213// Constantsconst NUMBER = 5;/** @const */ exports.NAMES = ImmutableList.of(&#x27;Ed&#x27;, &#x27;Ann&#x27;);/** @enum */ exports.SomeEnum = &#123; ENUM_CONSTANT: &#x27;value&#x27; &#125;;// Not constantslet letVariable = &#x27;non-const&#x27;;class MyClass &#123; constructor() &#123; /** @const &#123;string&#125; */ this.nonStatic = &#x27;non-static&#x27;; &#125; &#125;;/** @type &#123;string&#125; */ MyClass.staticButMutable = &#x27;not @const, can be reassigned&#x27;;const /** Set&lt;string&gt; */ mutableCollection = new Set();const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);const Foo = goog.require(&#x27;my.Foo&#x27;); // mirrors imported nameconst logger = log.getLogger(&#x27;loggers.are.not.immutable&#x27;); 常量的名称通常是名词或名词短语。 本地别名给导入的变量起别名来提高可读性是可行的。函数中也有使用别名的情况。别名必需是const类型。 非常量字段名非常量字段（静态或其他）使用小写开头的驼峰，如果是私有的私有的则以下划线结尾。 一般是名词或名词短语。例如 computedValues，index_。 参数名参数使用小写开头的驼峰形式。即使参数需要一个构造器来初始化时，也是这一规则。 公有方法的参数名不能只使用一个字母。 例外：如果三方库需要，参数名可以用 $ 开头。此例外不适用于其他标识符（e.g. 本地变量或属性）。 局部变量名如上所述，除了模块本地（顶级）常量外，本地变量名称都用lowerCamelCase形式编写。 函数作用域中的常量仍遵循lowerCamelCase形式。 请注意，即使变量包含构造函数，也将使用lowerCamelCase形式。 模板参数名模板参数力求简洁，用一个单词，一个字母表示，全部使用大写，例如 TYPE，THIS。 模板本地名未导出的模块本地名称是隐式私有的。 它们未被标记为@private，并且不以下划线结尾。这适用于类，函数，变量，常量，枚举和其他模块本地标识符。 驼峰：定义有时将一个英文短语转成驼峰有很多形式，例如首字母进行缩略，IPv6 以及 iOS 这种都有出现。为保证代码可控，本规范规定出如下规则。 将短语移除撇号转成ASCII表示。例如 Müller’s algorithm 表示成 Muellers algorithm。 将上述结果拆分成单词，以空格或其他不发音符号（中横线）进行分隔。 推荐的做法：如果其中包含一个已经常用的驼峰翻译，直接提取出来（e.g. AdWords 会成为 adwords）。需要注意的是 iOS 本身并不是个驼峰形式，它不属性任何形式，所以它不适用本条规则。 将所有字母转成小写，然后将以下情况中的首字母大写： 每个单词的首字母，这样便得到了大写开头的驼峰 除首个单词的其他所有单词的首字母，这样得到小写开头的驼峰 将上述结果合并。 过程中原来名称中的大小写均被忽略，例： 1234567Prose form | Correct | Incorrect------------- | ------------- | -------------&quot;XML HTTP request&quot; | XmlHttpRequest | XMLHTTPRequest&quot;new customer ID&quot; | newCustomerId | newCustomerID&quot;inner stopwatch&quot; | innerStopwatch | innerStopWatch&quot;supports IPv6 on iOS?&quot; | supportsIpv6OnIos | supportsIPv6OnIOS&quot;YouTube importe&quot; | YouTubeImporter | YoutubeImporter 可以接受，但不推荐。 注意：一些英文词汇通过中横线连接的方式是有歧义的，比如 “nonempty” 和 “non-empty” 都是正确写法，所以方法名 checkNonempty checkNonEmpty 都算正确。 格式化 术语解释：代码块（block-like construct）指类，函数，方法这些元素的正文部分，或花括号包裹的代码部分。参考数组字面量,对象字面量的定义，数组或对象也可以被视作一个类似于块的构造。提示:使用 clang-format。社区已经做了大量努力以使得 clang-format 能够很好地处理 JavaScript 文件。其中也集成了几位著名代码开发者的努力。 - 大括号(花括号) - 括号用于各种流程控制结构 括号用在各种控制结构中（譬如 if，else，for，do，while 等），即使结构中只包含一句代码。第一条指令的非空块状结构必须另起一行。 错误的写法,例: 1234if (someVeryLongCondition()) doSomething();for (let i = 0; i &lt; foo.length; i++) bar(foo[i]); **例外:**如果指令可以完全地用写在一行里，那么可以不用大括号以增加可读性,例:’if (shortCondition()) foo();` - 非空代码块：K&amp;R 风格 非空代码块使用的花括号遵循 Kernighan and Ritchie 风格 (也即 [Egyptian brackets](https://blog.codinghorror.com/new-programming-jargon/))： - 左花括号不另起新行 - 左花括号后紧跟换行 - 右花括号前需要换行 - 如果右花括号结束了语句，或者它是函数、类、类中的方法的结束括号，则其后面需要换行。如果后面紧跟的是 else，catch 或 while，或逗号，分号以及右括号，则不需要跟一个换行。 例: 123456789101112131415class InnerClass &#123;constructor() &#123;&#125;/** @param &#123;number&#125; foo */method(foo) &#123; if (condition(foo)) &#123; try &#123; // Note: this might fail. something(); &#125; catch (err) &#123; recover(); &#125; &#125;&#125;&#125; - 空代码块：应紧凑 对于空代码块打开的时候就应立即闭合，中间不留空格，换行以及其他任何字符（`&#123;&#125;`），除非该代码块处于一个连续的声明语境中（譬如这些带有多个代码块的语句 `if/else`，`try/catch/finally`）,例:`function doNothing() &#123;&#125;`。 错误的写法，例： 123456789if (condition) &#123;// …&#125; else if (otherCondition) &#123;&#125; else &#123;// …&#125;try &#123;// …&#125; catch (e) &#123;&#125; - 代码块中的缩进：2个空格 每当新开一个区块或块状结构，增加两个空格的缩进。区块结束之后，缩进恢复到前一级水平。缩进对该区块内的代码和注释同样有要求。 - 数组字面量：可作为块状结构 任何数组都可以按块状结构的格式书写。例如，以下的写法都是有效（不代表全部写法）： 1234567891011121314const a = [ 0, 1, 2,];const b = [0, 1, 2]; const c = [0, 1, 2];someMethod(foo, [ 0, 1, 2,], bar); 允许其他组合，尤其是在强调元素之间的语义分组时，而不是只用来减小较大数组的垂直大小。 - 对象字面量：可作为块状结构 对象字面量也可以当作代码块处理，规则与上面数组字面量类似。以下写法都是合法的： 12345678910111213const a = &#123; a: 0, b: 1,&#125;;const b = &#123;a: 0, b: 1&#125;; const c = &#123;a: 0, b: 1&#125;;someMethod(foo, &#123; a: 0, b: 1,&#125;, bar); - 类 类的声明（无论是内容声明[declarations]还是表达式声明[expressions]）都像块状结构一样缩进。在类的方法声明和类中的内容声明（表达式结束时仍然需要加分号）的右大括号（后一个大括号）之后不加分号。其中可以使用关键字extends，但是不要用@extends的JS注文（JSDoc），除非你继承了一个模板类型（templatized type）,例： 123456789101112class Foo &#123;constructor() &#123; /** @type &#123;number&#125; */ this.x = 42; &#125;/** @return &#123;number&#125; */method() &#123; return this.x; &#125;&#125;Foo.Empty = class &#123;&#125;; 12345678910111213/** @extends &#123;Foo&lt;string&gt;&#125; */foo.Bar = class extends Foo &#123;/** @override */method() &#123; return super.method() / 2; &#125;&#125;;/** @interface */class Frobnicator &#123;/** @param &#123;string&#125; message */ frobnicate(message) &#123;&#125;&#125; - 函数表达式 当声明匿名函数时，函数正文在原有缩进水平上增加两个空格的缩进，例： 1234567891011121314151617181920prefix.something.reallyLongFunctionName(&#x27;whatever&#x27;, (a1, a2) =&gt; &#123;// Indent the function body +2 relative to indentation depth// of the &#x27;prefix&#x27; statement one line above.if (a1.equals(a2)) &#123; someOtherLongFunctionName(a1); &#125; else &#123; andNowForSomethingCompletelyDifferent(a2.parrot); &#125;&#125;);some.reallyLongFunctionCall(arg1, arg2, arg3) .thatsWrapped() .then((result) =&gt; &#123; // Indent the function body +2 relative to the indentation depth // of the &#x27;.then()&#x27; call. if (result) &#123; result.use(); &#125; &#125;); - Switch语句 就像其他块状结构，该语句的缩进方式也是+2。 开始新的一条Switch标签，格式要像开始一个新的块状结构，新起一行，缩进+2。适当时候可以用块状结构来明确Switch全文范围。而到下一条Switch标签的开始行，缩进（暂时）还原到原缩进水平。 在break和下一条Switch标签之间可以适当地空一行。 例： 123456789101112switch (animal) &#123; case Animal.BANDERSNATCH: handleBandersnatch(); break; case Animal.JABBERWOCK: handleJabberwock(); break; default: throw new Error(&#x27;Unknown animal&#x27;);&#125; - 声明语句 - 一个声明占一行 每个声明语句后都跟换行。 - 分号是必需的 语句后需用分号结束。不能依赖于编辑器的自动分号插入功能。 - 最大列宽：80 对于 JavaScript 源码，规定其单行长度不超过 80 字符。除以下列出的情形外，超出的时候需要根据下面的换行规则来进行换行操作。 例外的情形： - `goog.module`，`goog.require`和`goog.requireType`语句 - ES模块的`import`和`export from`语句 - 换行 **术语解释：**换行指将一个表达式拆分成多行展示。 并没有一个全面准确的的规则来指导每种场景下该如何换行，相反，对同一段代码往往存在多种合法的换行方式。 **提示：尽管换行大多时候是为了满足列宽限制，但在满足的情况下，编码过程中每个人做法也不尽相同，这是可以的。抽取方法或变量有可能会规避掉换行的问题。** - 何处该换行 换行的的准则是：尽量在优先级高的语法层面（higher syntactic level）进行，例： 123currentEstimate = calc(currentEstimate + x * currentEstimate) / 2.0; 不推荐的写法，例： 12currentEstimate = calc(currentEstimate + x * currentEstimate) / 2.0; 上面示例中，语法优先级从高到低依次为：赋值，除法，函数调用，参数，数字常量。 操作符的规则： - 请在运算符之后换行（注意这和JAVA谷歌代码风格不同）。“.”并不是一个运算符，所以不适用上述规则。 - 方法和构造函数之后的左圆括号不能换行。 - 逗号紧跟前面的代码。 **注意：换行首要目的是保持代码整洁，当最小行数能满足需求时，换行是不需要的。** - 换行后后续行至少有4个空格的缩进 当发生换行时，第一行后面跟着的其他行至少缩进 4 个空格，除非满足代码块的缩进规则，可另说。 换行后后续跟随多行时，缩进可适当大于 4 个空格。通常，语法中低优先级的后续行以 4 的倍数进行缩进，如果只有两行并且处于同一优先级，则保持一样的缩进即可。 - 空格 - 垂直方向的空格 以下场景需要有一个空行： - 类或对象中的方法间 例外的情形：对象中属性间的空行是可选的。如果有的话，一般是用来将属性进行分组。 - 方法体中，尽量少地使用空行来进行代码的分隔。函数体开始和结束都不要加空行。 - 类或对象中首个方法前及最后一个方法后的空行，既不提倡也不反对。 连续多个空行是允许的，但不鼓励这么做。 - 水平方向的空格 水平方向的空格根据出现的位置不同分为三类：行首（一行的开始），行尾（一行的结束）以及行间（一行中除去行首及行尾的部分）。行首的空格（i.e. 缩进）无处不在。行尾的空格是禁止的。 除了 Javascript 本身及其他规则的要求，还有字面量，注释，JSDoc 等需要的空格外，单个的 ASCII 类型的空格在以下情形中也是需要的。 - 将关键字（比如 `if`，`for`，`catch`）与括号（`(`）分隔。 - 将关键字（`else`，`catch`）与闭合括号（`&#125;`） 分隔。 - 对于左花括号有两种例外： - 作为函数首个参数的对象之前，数组中首个对象元素 （`foo(&#123;a: [&#123;c: d&#125;]&#125;)`）。 - 在模板表达式中，因为模板语法的限制不能加空格（`abc$&#123;1 + 2&#125;def`）。 - 二元，三元操作符的两边。 - 逗号或分号后，但其前面是不允许有空格的。 - 对象字面量中冒号后面。 - 双斜线（//）两边。这里可以使用多个空格，但也不是必需的。 - JSDoc 注释及其两边 比如简写的类型声明`this.foo = /** @type &#123;number&#125; */ (bar);` 或 `function(/** string */ foo) &#123;;` 或 `baz(/* buzz= */ true)` - 水平对齐:不鼓励 **术语解释：**水平对齐是在代码中添加可变数量的附加空格的一种做法，目的是使某些标记直接出现在前几行中其他标记的下面。 下面的示例中展示了正常的代码及带水平对齐的代码，后者是不推荐的: 12345678&#123;tiny: 42, // this is greatlonger: 435, // this too&#125;;&#123;tiny: 42, // permitted, but future editslonger: 435, // may leave it unaligned&#125;; 这种做法是允许的，但 Google 风格里面不推荐。甚至在已经存在的代码中也不鼓励继续使用这种方式进行维护。 **注意：对齐可以增加可读性，但是对后续的维护增加了困难。考虑到后续改写代码可能只会该代码中的一行。修改可能会导致规则允许下格式的崩坏。这常常会错使代码编写者（比如你）调整附近几行的空格，从而导致一系列的格式重写。这样，只是一行的修改就会有一个“爆炸半径”（对附近代码的影响）。这么做最多会让你做一些无用功，但是至少是个失败的历史版本，降低了阅读者的速度，也会导致一些合并冲突。** - 函数参数 本规则更倾向于把所有函数的参数放在函数名的同一行。如果这么做让代码超出了80字符的限制，那么就必须做基于可读性的自动换行。为了节约空间，最好每行都接近80字符，或者一个参数一行来增加可读性。缩进4个空格。允许和圆括号对齐，但是不推荐。 下列就是最常见的函数参数对齐模式： 12345678910111213141516171819202122232425// Arguments start on a new line, indented four spaces. Preferred when the// arguments don&#x27;t fit on the same line with the function name (or the keyword// &quot;function&quot;) but fit entirely on the second line. Works with very long// function names, survives renaming without reindenting, low on space.doSomething( descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) &#123;// …&#125;// If the argument list is longer, wrap at 80. Uses less vertical space,// but violates the rectangle rule and is thus not recommended.doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo, tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) &#123;// …&#125;// Four-space, one argument per line. Works with long function names,// survives renaming, and emphasizes each argument.doSomething( veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo, tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) &#123;// …&#125; - 分组括号（Grouping parentheses）：推荐的写法 只有代码作者和审阅者都觉得如果不分组不会引起歧义，并且加了分组也不会让代码变得更易读，那么分组可以省略。因为，不是每个人都将操作符优先级熟记于心。 对于这些关键字，不要添加额外的分组 `delete`，`typeof`，`void`，`return`，`throw`，`case`，`in`，`of` 以及 `yield`。 类型转换时需要使用括号强制分组：`/** @type &#123;!Foo&#125; */ (foo)`。 - 注释 本规则讨论注释的写法。JSDoc 相关的注释单独在上面已经讨论过了。 - 块注释风格 块状注释与被注释代码保持相同缩进。`/* ... */ `和 `//` 都是。对于多行的` /* ... */ `注释，后续注释行以`*`开头且与上一行缩进保持一致。参数的注释紧随参数之后，用于在函数名或参数名无法完全表达其意思的情况,例： 123456789/** This is* okay.*/// And so// is this./* This is fine, too. */ 不要将JSDoc（`/ **…* /`）用于实现注释。 - 参数名称注释 每当值和方法名称未能充分传达含义时，都应使用“参数名称”注释，并且将方法重构得更清晰是不可行的。 它们的首选格式是值之前使用`=`： 1someFunction(obviousParam, /* shouldRender= */ true, /* name= */ &#x27;hello&#x27;); 为了与周围的代码保持一致，可以将它们放在值后面，而不使用`=`： 1someFunction(obviousParam, true /* shouldRender */, &#x27;hello&#x27; /* name */); 写在最后保持一致性. 当你在编辑代码之前，先花一些时间查看一下现有代码的风格。比如，如果现有的代码给算术运算符添加了空格，你也应该添加。 代码风格中一个关键点是整理一份常用词汇表, 开发者认同它并且遵循, 这样在代码中就能统一表述。 这里提出了一些全局上的风格规则, 但也要考虑自身情况形成自己的代码风格。 但如果你添加的代码和现有的代码有很大的区别, 这就让阅读者感到很不和谐。 所以, 避免这种情况的发生。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"人生——读书笔记","slug":"读书笔记--人生","date":"2020-02-13T11:54:00.000Z","updated":"2021-08-07T05:59:13.574Z","comments":true,"path":"2020/02/13/读书笔记--人生/","link":"","permalink":"http://example.com/2020/02/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 如果此时此刻有人和我说：人生如梦，世事难料。我肯定请他坐下来喝两杯畅谈一下人生!必须承认,以往很多时候，年纪轻轻的我不曾真正好好珍惜眼前的一切,即便一些大道理烂熟于心。从某种程度上来说，我和高加林一样：受过教育,想要更好的生活。但生活常常和我或者说我们开玩笑，一切在惊喜和挫败往复循环，它教会我们很多东西,但大多情况下，我们会先失去一些东西，比如友情，或者一些物质上东西，然后再深刻地体会到某些道理，然而不是深切感受完就可以避免以后发生类似的事情给我们带来的伤害。高加林生于农村，长于县城，书中说多年的教育洗去他身上的泥土气息，我是认同的，他受教育的时间远多于在农村老家生活的时间，且几乎没有劳作，同时他能一眼看尽农村人的一生，这无疑坚定了他想扎根城市的决心。高明楼的儿子勉勉强强上完高中走后门夺走了高加林的教师工作，断了高加林的念想，高加林的父母老老实实本本分分一辈子，这样的受打击的事情让一家人感到怎样的无助和绝望，我无法想象。这里我是替他们一家打抱不平的；回归农民，高玉德把轻松的活交给儿子，儿子第一天上县城的表现让人唏嘘，却也因此开启了和巧珍的爱情。经历心里的麻木和生理上的痛苦，还有巧珍热烈且温柔的爱，高的心态渐渐平和，但身边人对于他想回到城里的想法清清楚楚。生活过得去，却失去了实现梦想的机会，这里我是同情他的，因为这也是真实生活中一些人真实的样子；而后高加林的叔叔坐着”大领导”的位置归来，马占胜又一手包办高加林的工作，高的前程似乎又得见光明。回到城里的他，生活和事业都有了很大的起色，我是高兴的。后来黄亚萍对他展开热烈的爱情攻势，一边是内心真正爱着的巧珍，一边是象征着梦想的未来，最终选择他选择和中学同学”私定终身”，抛弃巧珍。在更远更大的天地向他招手时候，再一次出现人生波折，高被检举，再次回到农村已然物是人非，巧珍已嫁为他人妇。此刻她仍然盼着高能够好好活下去，自己去为高谋出路，高也后悔不已。看到这里我也经历一系列情绪波折，开始非常佩服作者。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"跨域及解决方案","slug":"跨域及解决方案","date":"2020-02-12T09:24:11.000Z","updated":"2021-08-07T05:59:13.635Z","comments":true,"path":"2020/02/12/跨域及解决方案/","link":"","permalink":"http://example.com/2020/02/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 跨域问题的产生前端开发人员都知道,浏览器安全的基石是”同源策略”（same-origin policy）.同源策略是 1995 年由 Netscape 公司引入浏览器.目前所有浏览器都实行这个策略.它主要是为了防止XSS,CSRF攻击. 域名URL的构成——http://主机名 . 域名（端口号、参数、查询等可选） 此外,我们还要知道域是分层管理的,像中国的行政级别:最高层的域是根域(root)”.”,就是一个点,像国家主席一样.全球只有13个根域服务器,基本数都在美国,中国一台根域服务器都没有. 根域的下一层就是第二层次的顶级域(TLD),像各省的省长.它也就是俗称的”域名后缀”,顶级域划分方法: 按国家划分: .cn(中国)、.tw(台湾)、.hk(香港)等 按组织性质划分: .org、.net、.com、.gov、.cc等 反向域: arpa(这是反向解析的特殊顶级域) 顶级域的下一层就是普通的域,公司或个人在互联网上注册的域名一般都是这些普通的域,如baidu.com. 注意点: 顶级域名就是一级域名 N级域名就是在N-1级域名前追加一级 同源策略这里的”同源”指的是: 协议相同 域名相同 端口相同 带来的限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM无法获得 AJAX请求不能发送 但是有三个标签是允许跨域加载资源的: &lt;img src=””&gt; &lt;link href=””&gt; &lt;script src=””&gt; 常见的跨域场景当协议、子域名、主域名、端口号任意一个不相同时,都是不同的域.不同域之间相互请求资源,就称为”跨域“,常见跨域场景如下所示: 注意点: 如果是协议和端口造成的跨域问题,”前台”是无能为力的 在跨域问题上,仅仅是通过”URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断. 这里你或许有两个疑问: 在跨域的情况下,请求被怎么处理了? 跨域并不是请求发不出去,请求能发出去,服务端能收到请求并正常响应,只是响应结果被浏览器拦截了. 为什么提交表单可以避免跨域问题,Ajax就不行? 跨域的目的是为了组织用户读到另一个域名下的内容,Ajax可以获取响应,这里存在有安全隐患,故而浏览器拦截了响应;表单则只是提交数据,不会获取新的内容,所以可以发去跨域请求. 跨域解决方案CORS跨域资源共享(Cross-Origin Resource Sharing)CORS 需要浏览器和后端同时支持,实现 CORS 通信的关键是后端.目前几乎所有浏览器都支持 CORS, IE则不能低于IE10.服务端设置 Access-Control-Allow-Origin 就可以开启 CORS. 该属性可以表示哪些域名可以访问资源,如果设置通配符则表示所有网站都可以访问资源.虽然设置 CORS 和前端没什么关系,但是通过这种方式解决跨域问题的话,会在发送请求时出现两种情况,分别为简单请求和非简单请求(需预检请求). 简单请求: 使用下面任意HTTP方法的: GET HEAD POST Content-Type 的值仅限于下列三者之一: text/plain multipart/form-data application/x-www-form-urlencoded 对于简单请求,浏览器会直接发送 CORS 请求,具体说来就是在 header 中加入 Origin 请求头字段.同样,在响应头中,返回服务器设置的相关 CORS 头部字段, Access-Control-Allow-Origin 字段为允许跨域请求的源.请求时浏览器在请求头的 Origin 中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回,具体如下:非简单请求: 使用下面任意HTTP方法的: PUT DELETE CONNECT OPTIONS TRACE PATCH Content-Type 的值不属于下列三者之一: text/plain multipart/form-data application/x-www-form-urlencoded 当符合非简单请求(预检请求)的条件时,浏览器会自动先发送一个options请求,如果服务端支持该请求,则会将真正的请求发送到后端;反之,控制台将会抛出错误. 如果非简单请求(预检请求)发送成功，则会在头部多返回以下字段: 123Access-Control-Allow-Origin: http://localhost:8000 //该字段表明可供那个源跨域Access-Control-Allow-Methods: GET, POST, PUT // 该字段表明服务端支持的请求方法Access-Control-Allow-Headers: X-Custom-Header // 实际请求将携带的自定义请求首部字段 JSONP 原理:利用**&lt;script&gt;**标签没有跨域限制的漏洞,网页可以得到从其它来源动态产生 JSON 数据.JSONP 请求必须要对方的服务器做支持才可以. JSONP和AJAX对比:二者都是客户端遵循向服务器发送请求,从服务器获取数据的方式.但AJAX属于同源策略,JSONP不是. 看个例子: 12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;mera http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;title&gt;JSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://a2.att.hudong.com/36/48/19300001357258133412489354717.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JavaScript中Promise","slug":"JavaScript中Promise","date":"2020-02-11T09:16:41.000Z","updated":"2021-08-07T05:59:13.859Z","comments":true,"path":"2020/02/11/JavaScript中Promise/","link":"","permalink":"http://example.com/2020/02/11/JavaScript%E4%B8%ADPromise/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 Promise 出现的原因在 Promise 出现以前,处理一个Ajax请求,大概是这样的: 123$.get(&#x27;url&#x27;, &#123;data: data&#125;, function(result)&#123; console.log(&#x27;成功&#x27;, result)// 成功的回调，result为异步拿到的数据&#125;); 看起来还不错,但需求变化了,现在需要根据第前面的结果继续请求,代码大概如下： 123456789101112$.get(&#x27;url&#x27;, &#123;data: data&#125;, function(result1)&#123; $.get(&#x27;url&#x27;, &#123;data: result1&#125;, function(result2)&#123; $.get(&#x27;url&#x27;, &#123;data: result2&#125;, function(result3)&#123; $.get(&#x27;url&#x27;, &#123;data: result3&#125;, function(result4)&#123; ...... $.get(&#x27;url&#x27;, &#123;data: resultn&#125;, function(resultn+1)&#123; console.log(&#x27;成功&#x27;) &#125; &#125; &#125; &#125;&#125;); 以上就是回调地狱,更糟糕的是,我们可能还要对每次请求的结果进行一些处理,代码会更加臃肿,后期维护也非常痛苦! 那么总结一下回调地狱的特点: 代码臃肿 可读性差 耦合度过高,可维护性差 代码复用性差 容易出现Bug 只能在回调里处理异常 后来出现了Promise,它以一种更加友好的代码组织方式,解决了异步嵌套的问题: 12345let 请求结果1 = 请求1();let 请求结果2 = 请求2(请求结果1); let 请求结果3 = 请求3(请求结果2); let 请求结果4 = 请求2(请求结果3); let 请求结果5 = 请求3(请求结果4); 类似与上面同步的写法.于是Promise规范诞生了! 什么是PromisePromise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值. 优点: 异步操作将以同步的流程表达出来,避免了层层嵌套的回调函数. Promise 对象提供了统一的接口,使得控制异步操作更容易. 缺点: 无法取消,一旦新建就会立即执行,无法中途取消. 若不设置回调函数,promise 内部会抛出错误,不会反映到外部 Promise/A+ 规范** Promise 规范 **有很多,如 Promise/A , Promise/B , Promise/D 以及 Promise/A 的升级版 Promise/A+ ,最终ES6采用了 Promise/A+ 规范. Promise 规范: 英文版: https://promisesaplus.com/ 中文版: http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/ 总结如下: 一个 Promise 对象有种个状态,并且状态一旦改变,便不能再被更改为其他状态. pending: 异步任务正在执行. fulfilled: 异步任务执行成功. rejected: 异步任务执行失败. then方法可以被同一个 Promise 调用多次,且必须返回一个 Promise Promise 语法1new Promise( function(resolve, reject) &#123;/* executor */&#125; ); Promise构造函数接受一个函数作为参数,该函数的两个参数分别是resolve和reject.它们是两个函数,由 JavaScript 引擎提供,不用自己部署. resolve 函数的作用:将Promise实例的状态从”pending”到”fulfilled”,在异步操作成功时调用,并将异步操作的结果,作为参数传递出去. reject 函数的作用:将Promise实例的状态从”pending”到”rejected”,在异步操作失败时调用,并将异步操作报出的错误，作为参数传递出去. 例子: 123456789101112let promise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&#x27;Cola&#x27;); console.log(promise);//Promise &#123; &#x27;Cola&#x27; &#125; &#125;, 300);&#125;);promise.then(function (value) &#123; console.log(value);//Cola&#125;);console.log(promise);//Promise &#123; &lt;pending&gt; &#125; 输出顺序: 123Promise &#123; &lt;pending&gt; &#125;Promise &#123; &#x27;Cola&#x27; &#125;Cola Promise 常用API Promise.resolve() Promise.reject() Promise.then(成功回调函数，失败回调函数) Promise.then(成功回调函数).catch(失败回调函数) Promise.then(成功回调函数).catch(失败回调函数).finally(成功失败都执行的函数)1234567891011let promise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&#x27;Cola&#x27;); &#125;, 300);&#125;).then(data =&gt; &#123; console.log(&#x27;I like &#x27; + data)&#125;).catch(function (error) &#123; console.log(error);&#125;).finally(function () &#123; console.log(&#x27;这是finally&#x27;)&#125;); Promise.all(iterable):方法返回一个 Promise 实例,此实例在 iterable 参数内所有的 promise 都”完成（resolved）”或参数中不包含 promise 时回调完成（resolve）;如果参数中 promise 有一个失败（rejected）,此实例回调失败（reject）,失败原因的是第一个失败 promise 的结果.12345678910let p1 = Promise.resolve(&#x27;I&#x27;);let p2 = &#x27;like&#x27;let p3 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&#x27;Cola&#x27;); &#125;, 300);&#125;)Promise.all([p1, p2, p3]).then(function (value) &#123; console.log(value);//[ &#x27;I&#x27;, &#x27;like&#x27;, &#x27;Cola&#x27; ]&#125;); Promise.race(iterable):返回一个 promise,一旦迭代器中的某个promise解决或拒绝,返回的 promise就会解决或拒绝.1234567891011const promise1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, &#x27;one&#x27;);&#125;);const promise2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, &#x27;two&#x27;);&#125;);Promise.race([promise1, promise2]).then(function(value) &#123; console.log(value);//two&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"JavaScript的同步异步和执行机制","slug":"JavaScript的同步异步和执行机制","date":"2020-02-10T07:23:13.000Z","updated":"2021-08-07T05:59:13.732Z","comments":true,"path":"2020/02/10/JavaScript的同步异步和执行机制/","link":"","permalink":"http://example.com/2020/02/10/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 ##JavaScript中的单线程技术的出现总是和应用场景密切相关.JavaScript诞生于1995年,主要用于处理表单验证操作,也就是实现用户和浏览器的交互. 由此带来一个思考:这门语言为什么是单线程?作为浏览器脚本语言,JavaScript 的主要用途是与用户互动,以及操作 DOM.这决定了它只能是单线程,否则会带来很复杂的同步问题.比如,假定JavaScript同时有两个线程,一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以,为了避免复杂性，从一诞生,JavaScript 就是单线程,这已经成了这门语言的核心特征,将来也不会改变. 为了利用多核 CPU 的计算能力,HTML5 提出 Web Worker 标准,允许 JavaScript 脚本创建多个线程,但是子线程完全受主线程控制,且不得操作 DOM.所以,这个新标准并没有改变 JavaScript 单线程的本质. 那么单线程的特点就很明显了: 实现起来比较简单,执行环境相对单纯； 只要有一个任务耗时很长,后面的任务都必须排队等着,会拖延整个程序的执行.(常见的浏览器无响应(假死),往往就是因为某一段Javascript代码长时间运行(比如死循),导致整个页面卡在这个地方,其他任务无法执行.) 同步和异步在JS中,同步意味着在很多情况下CPU在等待:后一个任务等待前一个任务结束,然后再执行,程序的执行顺序与任务的排列顺序是一致的、同步的;也就是说当一件事情没有处理完成,JS会一直处理它,直至完成,才会开始下一件事情,这样可能会堵塞代码执行; 异步则是指每一个任务有一个或多个回调函数(callback),前一个任务结束后,不是执行后一个任务,而是执行回调函数,后一个任务则是不等前一个任务结束就执行,所以程序的执行顺序与任务的排列顺序是不一致的、异步的. 一句话概括就是:同步等结果,异步不等结果. JavaScript的执行机制流程图如下:注意点: JS代码分为同步任务和异步任务. 同步任务进入主线程执行,异步任务进入Event Table(事件表),当事件表中的异步任务完成后会在**Event Queue(事件队列)**中注册回调函数. 主线程中的任务全部完成后,才会执行Event Queue中的任务. JS解析器会不断重复检查主线程执行栈是否为空,然后重复第3步,这称为Event Loop(事件循环). 宏任务和微任务JS代码的类型如下图所示: 宏任务主要有: script代码段 setTimeout setInterval I/O 微任务主要有: process.nextTick Promise 注意点: 任务有**宏任务(Macro Task)和微任务(Micro Task)**之分,这对JS代码的执行有更细致的影响. 异步任务中的宏任务和微任务会进入不同的Event Queue(事件队列),即Event Queue又可以分为宏任务队列和微任务队列. setInterval会按照设定的时间间隔重复地在Event Queue中注册回调函数,如果某一段时间主线程代码执行太久,那么setInterval的回调函数可能阻塞到一起执行,无法保持设定的时间间隔,如果此时setInterval用于动画,则体现为卡顿. 详细过程 通常来说,页面中JS的执行顺序是这样的: 第一轮事件循环: 1.主线程执行JS整段(宏代码),将ajax、setTimeOut、promise等回调函数注册到Event Queue中,并区分宏任务和微任务. 2.主线程提取并执行Evene Queue中的ajax、promise等所有微任务,并注册微任务中的异步任务到Event Queue(如果有). 第二轮事件循环: 1.主线程提取并执行Evene Queue中的第一个宏任务,注册该任务中的异步任务到Evene Queue(如果有). 2.执行Evene Queue中所有的微任务,并注册微任务中的异步任务到Evene Queue(如果有). 类似的循环:宏任务没执行完一个,就清空一次时间队列中的微任务.注意点:事件队列中分”宏任务队列”和”微任务队列”，每执行一次任务都可能注册新的宏任务或微任务到相应的任务队列中. 例子12345678910111213141516171819202122232425262728293031323334353637383940414243console.log(&#x27;1&#x27;);// 记作 set1setTimeout(function () &#123; console.log(&#x27;2&#x27;); // set4 setTimeout(function() &#123; console.log(&#x27;3&#x27;); &#125;); // pro2 new Promise(function (resolve) &#123; console.log(&#x27;4&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;5&#x27;) &#125;)&#125;)// 记作 pro1new Promise(function (resolve) &#123; console.log(&#x27;6&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;7&#x27;); // set3 setTimeout(function() &#123; console.log(&#x27;8&#x27;); &#125;);&#125;)// 记作 set2setTimeout(function () &#123; console.log(&#x27;9&#x27;); // 记作 pro3 new Promise(function (resolve) &#123; console.log(&#x27;10&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;11&#x27;); &#125;)&#125;)// 最终输出 : 1 6 7 2 4 5 9 10 11 8 3 第一轮事件循环: 1.将整段script作为第一个宏任务进入主线程,遇到console.log,输出1. 2.遇到set1,其回调函数被分发到宏任务Event Queue中. 3.遇到pro1,new Promise直接执行,输出6.then被分发到微任务Event Queue中. 4.遇到set2,其回调函数被分发到宏任务Event Queue中. 5.主线程的整段JS代码(宏任务)执行完成,开始清空所有微任务;主线程执行微任务pro1,输出7;遇到set3，注册回调函数。 第二轮事件循环 1.主线程执行队列中第一个宏任务set1,输出2;遇到set4,注册回调;再遇到pro2,new Promise直接执行,输出4,并注册回调. 2.set1(宏任务)执行完,开始清空微任务,主线程执行微任务pro2,输出5; 第三轮事件循环 1.主线程执行队列中第一个宏任务set2，输出9；代码中遇到了pro3，new promise()直接输出10，并注册回调； 2.set2宏任务执行完毕，开始情况微任务，主线程执行微任务pro3，输出11。 类似循环…","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"围城——读书笔记","slug":"读书笔记--围城","date":"2020-02-09T15:27:15.000Z","updated":"2021-08-07T05:59:13.594Z","comments":true,"path":"2020/02/09/读书笔记--围城/","link":"","permalink":"http://example.com/2020/02/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%9B%B4%E5%9F%8E/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 惊叹钱老的经典！借着小说揭露那个时代的病态，文笔犀利，辛辣讽刺。方鸿渐自己留洋归来，在有着前清举人称号的父亲，迂腐的母亲，惺惺作态的弟妹的大家庭中，代表着西式文化，与传统的中国文化进行了一场激烈的碰撞。还有和肝胆相照的赵辛楣，极具才气的苏小姐，道貌岸然的李梅亭等一系列个性鲜明人物的故事，道出世事无常，人性虚伪，也暗讽陈腐的旧中国包括代表西方文化的部分知识分子。“城中的人想出去，城外的人想冲进来”，我想这话不仅仅只是说婚姻，生活也是如此。方鸿渐的一生都在城内外兜兜转转，恋爱跟着失恋，教书跟着被辞退，结婚跟着不快乐。之后方鸿渐和孙柔嘉的结合，到底不是有情人终成眷属，步入婚姻，逐渐暴露出双方的真实，原生家庭带来的矛盾，经济上的窘迫，让两个人并不快乐。可以说这样婚姻是围城，不过也不能忽视现实。在现实中我们也会深陷”围城”，大多时候都是我们自己造成的困扰和奇怪的想法，消极的想法总是让人感到悲观，要经常审视自己的内心。有些人快乐的时候很少，和生活一直在做抗争，有些人一直保持积极乐观的心态，带着极大的热情生活，这些人并非一直如此，状态相互转化间可见”围城”并非牢不可破，该破的是我们自己的想法。 围城—读书笔记2.3-2.10小范宝贝《围城》这本书，刚看时没有什么深刻的体会，但它可能经典就经典在随着故事情节的发展，人性的弱点与人生的荒凉慢慢的展现在了你的面前，甚至会使读者在方鸿渐的身上找到一丝情感的共鸣，像是人性的缩影，在他的身上体现的淋漓尽致。故事以夕阳下海面上缓缓行驶的船只开头，在这艘船上方鸿渐与“半裸的”“局部真理的”鲍小姐有了一夜的情缘。而同时，同样留学归来的苏小姐也对他芳心暗许。苏文纨家室不错又是留样归来，长得也眉清目秀，可是方鸿渐到最后也没有喜欢上苏小姐，反而是对她的表妹唐晓芙可以说是一见钟情。钱钟书先生是这样描述唐晓芙的：唐小姐妩媚端正的圆脸，有两个浅酒涡。天生着一般女人要花钱费时、调脂和粉来仿造的好脸色，新鲜得使人见了忘掉口渴而又觉嘴馋，仿佛是好水果。她眼睛并不顶大，可是灵活温柔，反衬得许多女人的大眼睛只像政治家讲的大话，大而无当。古典学者看她说笑时露出的好牙齿，会诧异为什么古今中外诗人，都甘心变成女人头插的钗，腰束的带，身体睡的席，甚至脚下践踏的鞋，可是从没想到化作她的牙刷。她头发没烫，眉毛不镊，口红也没有擦，似乎安心遵守天生的限止，不要弥补造化的缺陷。总而言之，唐小姐是摩登文明社会里那桩罕物——一个真正的女孩子。这段话，真的是我在整本书中，见过的对女孩子最美好的描述了，唐小姐就像一朵红玫瑰，深深地插进了方鸿渐的心中。而这段感情最终也因为他自己的懦弱与退缩夭折在了那个下着大雨的午后。如果说鲍小姐代表肉欲，苏小姐代表才情和家室，唐小姐代表初恋，那接下来出现的这位孙柔嘉则代表了婚姻。孙小姐出现时，一张寡淡的脸上有着些小的雀斑，这与唐小姐的外貌描述简直天差地别。而她一个女孩独自和4个男人一起出远门去大学教书，这种行为刚开始让我不太理解，可看到后面她父母的重男轻女，迫使她一个女孩子要不断的努力才能创造出属于自己的好生活。原以为她是一个乖巧甚至有些单纯的女生，可在她一步一步设下圈套，让方鸿渐慢慢走进自己婚姻的围城中时，让我觉得她实在心思深重，却也觉得她有些可怜。家庭和生活的压力逼迫她成长为了一个敏感、富有心计的女子。她与方鸿渐婚后也渐渐暴露出自己善妒、专横的一面。她过于聪明，每每吵架嘴上说着不想方鸿渐的朋友觉得她限制了他的生活，可他们有哪一次吵架不是孙柔嘉在限制他呢？在生活上、工作上，甚至是朋友的交往上。她很勇敢，她大胆的追求自己的幸福，选择了方鸿渐这在她看来是最好的选择，她拥有抗争人生，迎来幸福生活的勇气，可她选择的却未必是幸福的生活。他们的婚后生活打破了方鸿渐对婚姻的幻想，这是一段被掌控的婚姻，而方鸿渐在被生活不断打磨棱角的同时，也在不断的向他的婚姻做出妥协。可是这些妥协并不能改变他们不断的争吵、不断的发生矛盾的现状。是啊，方鸿渐从来就不是一个会主动争取的人，他好像经不得一点挫折与麻烦。他总是在有了一点点退路后拔腿就跑，不愿意面对一点点的困难或者说努力一点点。考取文凭时是这样，与岳父岳母闹翻时是这样，大学教书时没有聘书也是这样。他也曾在年轻的时候意气风发，被大家吹捧、有女孩喜爱。那时他的身边围绕着的是苏小姐、赵先生、唐小姐、曹先生，这些人无一例外都是家世好，文化高，他也曾是这些人中的一员。但是在时间的细细打磨下，他慢慢露出了原本的样子。文凭是假的，家室也一般，性格又软弱，只有那一身的傲气还算真实。最后只能娶一个像孙柔嘉这样平凡的女生作为妻子，还说“也许这正是我所需要的”。他总是被迫的接受着，还反过来安慰自己也许一切都是最好的安排，真是一个可悲又可恨的人物。方鸿渐有些小聪明，也比一般人有学识，可他的一生，在我看来的的确确是一场悲剧。他一生都无法走出自己的围城里。这个围城，不是别人给他造的，而是他的懦弱退缩加上他莫名的不肯低头的傲气，自己给自己设下的围城。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"JavaScript中Set和Map","slug":"JavaScript中Set和Map","date":"2020-02-07T07:32:12.000Z","updated":"2021-08-07T05:59:13.872Z","comments":true,"path":"2020/02/07/JavaScript中Set和Map/","link":"","permalink":"http://example.com/2020/02/07/JavaScript%E4%B8%ADSet%E5%92%8CMap/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 SetES6 提供了新的数据结构 Set.它类似于数组,但是成员的值都是唯一的,没有重复的值. Set 本身是一个构造函数,用来生成 Set 数据结构.基本用法: 123let set = new Set([1,1,2,3,4,4]);console.log(set);//Set &#123; 1, 2, 3, 4 &#125;console.log(set.size);//4 接下来详细了解一下Set实例的属性和方法: 属性 size:返回集合所包含元素的数量 方法 操作方法(见例子1) add(value):向集合中添加一个新的项 delete(value):从集合中移除一个值 has(value): 判断一个值在集合中是否存在,存在返回true,否则false clear(): 移除集合里所有的项 遍历方法(见例子2) keys():返回键名的遍历器 values():返回键值的遍历器 entries():返回键值对的遍历器 forEach():使用回调函数遍历每个成员 例子1: 123456789101112131415let set = new Set();set.add(&#x27;Cola&#x27;);set.add(3.5);set.add(&#x27;red&#x27;);console.log(set);//Set &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;set.delete(3.5);console.log(set);//Set &#123; &#x27;Cola&#x27;, &#x27;red&#x27; &#125;console.log(set.has(&#x27;red&#x27;));//trueconsole.log(set.has(&#x27;blue&#x27;));//falseset.clear();console.log(set);//Set &#123;&#125; 例子2: 1234567891011let set = new Set([&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;]);console.log(set.keys());//SetIterator &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;console.log(set.values());//SetIterator &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;console.log(set.entries());//SetIterator &#123; [ &#x27;Cola&#x27;, &#x27;Cola&#x27; ], [ 3.5, 3.5 ], [ &#x27;red&#x27;, &#x27;red&#x27; ] &#125;set.forEach((value, key, array) =&gt; &#123; console.log(key + &#x27; : &#x27; + value + &#x27; : &#x27; + array);&#125;)//Cola : Cola : [object Set]//3.5 : 3.5 : [object Set]//red : red : [object Set] 注意:Set的遍历顺序就是插入顺序,由于 Set 结构没有键名,只有键值(或者说键名和键值是同一个值),所以keys方法和values方法的行为完全一致 for of遍历方式: 1234567891011121314let set = new Set([&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;]);for(let value of set)&#123; console.log(value);&#125;//Cola//3.5//redfor(let [value,key] of set.entries())&#123; console.log(value+&#x27;:&#x27;+key);&#125;//Cola:Cola//3.5:3.5//red:red Set和Array转换 数组 =&gt; Set: 123let arr = [&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;];let set = new Set(arr);console.log(set);//Set &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125; Set =&gt; 数组: 123let set = new Set([&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;]);let arr = Array.from(set)console.log(arr);//[ &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; ] WeakSet我们再看看Set,当有对象存储在Set实例中时,这相当于把对象存储在变量中,只要Set实例的引用仍然存在,所存储的对象就无法被垃圾回收机制回收,从而无法释放内存: 123456789101112let set = new Set();let obj = &#123;name:&#x27;Cola&#x27;&#125;;let color = &#x27;red&#x27;;set.add(obj);set.add(color);console.log(set.size); // 2obj = null;color = &#x27;blue&#x27;;console.log(set.size); // 2console.log(obj); // nullconsole.log(set); // Set &#123; &#123; name: &#x27;Cola&#x27; &#125;, &#x27;red&#x27; &#125; WeakSet 结构与 Set 类似,也是不重复的值的集合.但它与 Set 有两个区别: WeakSet 的成员只能是对象，而不能是其他类型的值. 12let ws = new WeakSet();ws.add(&#x27;Cala&#x27;);//TypeError: Invalid value used in weak set WeakSet 中的对象都是弱引用,即垃圾回收机制不考虑 WeakSet 对该对象的引用,也就是说,如果其他对象都不再引用该对象,那么垃圾回收机制会自动回收该对象所占用的内存,不考虑该对象还存在于 WeakSet 之中.因为这个特点,WeakSet 不可遍历. 12345678let ws = new WeakSet();let obj =&#123;name:&#x27;Cola&#x27;&#125;ws.add(obj);ws.add(&#123;&#125;);console.log(ws.has(obj))//truews.delete(obj)console.log(ws.has(obj))//false Weak Set 不提供任何迭代器(例如 keys() 与 values() 方法),没有size属性. MapMap类型是一组键值对的结构,具有极快的查找速度.它是键值对的有序列表，而键和值都可以是任意类型.基本用法: 123456let map = new Map([[&#x27;type&#x27;,&#x27;food&#x27;],[&#x27;name&#x27;, &#x27;Cola&#x27;]]);map.set(&#x27;color&#x27;, &#x27;red&#x27;).set(&#x27;price&#x27;, 3.5);console.log(map.size)//4console.log(map.get(&#x27;name&#x27;))//Colaconsole.log(map.get(&#x27;size&#x27;))//undefinedconsole.log(map);//Map &#123; &#x27;type&#x27; =&gt; &#x27;food&#x27;, &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, &#x27;color&#x27; =&gt; &#x27;red&#x27;, &#x27;price&#x27; =&gt; 3.5 &#125; 接下来详细了解一下Set实例的属性和方法: 属性 size:返回集合所包含元素的数量 方法 操作方法(见例子3) set(key, value):设置键名key对应的键值为value,然后返回整个 Map 结构.如果key已经有值,则键值会被更新,否则就新生成该键.set方法返回的是当前的Map对象，因此可以采用链式写法 get(key):读取key对应的键值，如果找不到key，返回undefined has(key):判断指定键在Map中是否存在,存在返回true,否则false delete(ley):移除Map中的建以及对应的值 clear():移除Map中所有的键与值 遍历方法(见例子4) keys():返回键名的遍历器 values():返回键值的遍历器 entries():返回所有成员的遍历器 forEach():遍历 Map 的所有成员 例子3: 123456789101112let map = new Map()map.set(&#x27;name&#x27;, &#x27;Cola&#x27;);map.set(&#x27;price&#x27;, 3.5);console.log(map.has(&#x27;name&#x27;))//trueconsole.log(map.has(&#x27;color&#x27;))//falsemap.delete(&#x27;name&#x27;);console.log(map.has(&#x27;name&#x27;))//falsemap.clear();console.log(map.size)//0 例子4: 1234567891011121314151617let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]);console.log(map.keys());//MapIterator &#123; &#x27;type&#x27;, &#x27;name&#x27;, &#x27;color&#x27;, &#x27;price&#x27; &#125;console.log(map.values());//MapIterator &#123; &#x27;food&#x27;, &#x27;Cola&#x27;, &#x27;red&#x27;, 3.5 &#125;console.log(map.entries());//MapIterator &#123;// [ &#x27;type&#x27;, &#x27;food&#x27; ],// [ &#x27;name&#x27;, &#x27;Cola&#x27; ],// [ &#x27;color&#x27;, &#x27;red&#x27; ],// [ &#x27;price&#x27;, 3.5 ] &#125;map.forEach((value, key, map) =&gt; &#123; console.log(key + &#x27;:&#x27; + value)&#125;)//type:food//name:Cola//color:red//price:3.5 for of遍历方式: 12345678let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]);for (let item of map.entries()) &#123; console.log(item[0] + &#x27;:&#x27; + item[1])&#125;//type:food//name:Cola//color:red//price:3.5 Map与其他数据结构的相互转换 Map =&gt; 数组123let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]);let arr = [...map];//或者 let arr = Array.from(map);console.log(arr);//[ [ &#x27;type&#x27;, &#x27;food&#x27; ],[ &#x27;name&#x27;, &#x27;Cola&#x27; ],[ &#x27;color&#x27;, &#x27;red&#x27; ],[ &#x27;price&#x27;, 3.5 ] ] 数组 =&gt; Map1let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]); Map =&gt; 对象1234567891011let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [2, &#x27;red&#x27;]]);function mapToObj(strMap) &#123; let obj = Object.create(null); for (let [k, v] of strMap) &#123; obj[k] = v; &#125; return strMap;&#125;console.log(mapToObj(map))//Map &#123; &#x27;type&#x27; =&gt; &#x27;food&#x27;, &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, 2 =&gt; &#x27;red&#x27; &#125; 对象 =&gt; Map1234567891011obj = &#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27; &#125;;function objToMap(obj) &#123; let map = new Map(); for (let item of Object.keys(obj)) &#123; map.set(item, obj[item]); &#125; return map;&#125;console.log(objToMap(obj));//Map &#123; &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, &#x27;color&#x27; =&gt; &#x27;red&#x27; &#125; WeakSet如果希望不再引用Map的时候自动触发垃圾回收机制.那么也需要WeakMap。 123456789let map = new WeakMap();const key = document.getElementById(&#x27;div&#x27;);map.set(key, &#x27;这是一个div&#x27;);map.get(key) // &quot;这是一个div&quot;//移除该元素key.parentNode.removeChild(key);key = null;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中IIFE","slug":"JavaScript中IIFE","date":"2020-02-06T10:10:25.000Z","updated":"2021-08-07T05:59:13.820Z","comments":true,"path":"2020/02/06/JavaScript中IIFE/","link":"","permalink":"http://example.com/2020/02/06/JavaScript%E4%B8%ADIIFE/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 概念IIFE(Immediately-Invoked Function Expression) 立即执行函数表达式,也就是说在声明函数的同时立即调用该函数.先看看IIFE的语法: 1234(function()&#123; let color = &#x27;red&#x27;; console.log(color);&#125;)()//red 常规函数的定义和调用: 123456function cola()&#123; let color = &#x27;red&#x27;; console.log(color);&#125;cola();//red 为什么有IIFE如果只是为了执行一个函数,从上面的例子可以看出好处有限.实际上IIFE的出现是为了弥补JS在在scope方面的缺陷：JS只有全局作用域(global scope)、函数作用域(function scope),从ES6开始才有块级作用域(block scope).在JS中，只有function才能实现作用域隔离，因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。 1234567let color = &#x27;blue&#x27;;function cola() &#123; let color = &#x27;red&#x27;; return color;&#125;console.log(cola());//redconsole.log(color); 在我们通常的理解中，将代码封装到函数中的目的是为了复用。在JS中，声明函数的目的在大多数情况下也是为了复用，但是JS迫于作用域控制手段的贫乏，我们也经常看到只使用一次的函数：目的就是为了隔离作用域.既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也省掉了！这就是IIFE的由来。 IIFE一些要注意的地方123(function () &#123; //statements&#125;)(); 表达式中的变量不能从外部访问123456(function () &#123;let color = &#x27;red&#x27;;return color;&#125;)()//redconsole.log(color);//抛出错误 : ReferenceError: color is not defined 将IIFE分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果 123456let res = (function () &#123; let color = &#x27;red&#x27;; return color;&#125;)();console.log(res);//red IIFE的多参数 123(function (window, document) &#123; // 这里可以调用到window和document &#125;)(window, document); 总结IIFE的目的是为了隔离作用域,防止污染全局命名空间.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中深拷贝和浅拷贝","slug":"JavaScript中深拷贝和浅拷贝","date":"2020-02-05T11:07:22.000Z","updated":"2021-08-07T05:59:13.806Z","comments":true,"path":"2020/02/05/JavaScript中深拷贝和浅拷贝/","link":"","permalink":"http://example.com/2020/02/05/JavaScript%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 在JavaScript中,对于引用类型数据的值,当从一个变量向另一个变量复制引用类型值时，这个值的副本其实是一个指针，两个变量指向同一个堆对象，改变其中一个变量，另一个也会受到影响.这种拷贝分为两种情况:拷贝引用和拷贝实例,也就是我们说的浅拷贝和深拷贝. 浅拷贝 浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用:第一个例子是直接拷贝原对象的引用 12345678let obj = &#123; name: &quot;Cola&quot;, detail: &#123; price: 3.5 &#125;, color: [&#x27;red&#x27;] &#125;;let obj2 = obj;obj2.name = &quot;Coca Cola&quot;;obj2.detail.price = 5;obj2.color[0] = &#x27;blue&#x27;;console.log(obj)//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; price: 5 &#125;, color: [ &#x27;blue&#x27; ] &#125;console.log(obj2)//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; price: 5 &#125;, color: [ &#x27;blue&#x27; ] &#125; 再看第二个例子,理解拷贝一层的含义(Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。注意：Object.assign()拷贝的是属性值，假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值) 1234567let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = Object.assign(&#123;&#125;, obj);obj2.name=&#x27;Coca Cola&#x27;;obj2.detail.color=&#x27;blue&#x27;;console.log(obj);//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;console.log(obj2);//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125; 其他实现方法 扩展运算符 1234567let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = &#123;...obj&#125;;obj2.name=&#x27;Coca Cola&#x27;;obj2.detail.color=&#x27;blue&#x27;;console.log(obj);//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;console.log(obj2);//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125; Array.prototype.slice(),该方法提取并返回一个新的数组,如果源数组中的元素是个对象的引用,slice会拷贝这个对象的引用到新的数组 1234567let arr = [&#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125;];let arr2 = arr.slice();arr2[0] = &#x27;Coca Cola&#x27;;arr2[1].color = &#x27;blue&#x27;;console.log(arr);//[ &#x27;Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]console.log(arr2);//[ &#x27;Coca Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ] Array.prototype.concat(),该方法用于合并多个数组,并返回一个新的数组,和slice方法类似,当源数组中的元素是个对象的引用，concat在合并时拷贝的就是这个对象的引用 12345678let arr = [&#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125;];let arr2 = [&#123; price: 3.5 &#125;];let arr3 = arr.concat(arr2);arr3[0] = &#x27;Coca Cola&#x27;;arr3[2].price = 5;console.log(arr);//[ &#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125; ]console.log(arr2);//[ &#123; price: 5 &#125; ] 手动实现浅拷贝: 123456789101112131415161718192021function shallowClone(source) &#123; if (!source || typeof source !== &#x27;object&#x27;) &#123; throw new Error(&#x27;error arguments&#x27;); &#125; var target = source.constructor === Array ? [] : &#123;&#125;; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; target[key] = source[key]; &#125; &#125; return target;&#125;let obj = [&#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125;];let obj2 = shallowClone(obj);obj[0] = &#x27;Coca Cola&#x27;obj[1].color = &#x27;blue&#x27;console.log(obj)//[ &#x27;Coca Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]console.log(obj2)//[ &#x27;Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ] 深拷贝 深拷贝是拷贝多层，每一级别的数据都会拷贝出来:也就是说深拷贝会另外拷贝一份一个一模一样的对象,从堆内存中开辟一个新的区域存放新对象,新对象跟原对象不共享内存，修改新对象不会改到原对象. 常用方法:JSON.parse(JSON.stringify()) 123456let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = JSON.parse(JSON.stringify(obj));obj2.name = &#x27;Coca Cola&#x27;;obj2.detail.color = &#x27;blue&#x27;console.log(obj);//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;console.log(obj2);//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125; 这是前端开发过程中比较常用的深拷贝方式。原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象.它有一些值得注意的地方 拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失 对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null 还可以借助jQuery，lodash等第三方库完成一个深拷贝实例. 手动实现深拷贝 123456789101112131415161718192021222324function deepClone(source) &#123; if (!source || typeof source !== &#x27;object&#x27;) &#123; throw new Error(&#x27;error arguments&#x27;); &#125; var target = source.constructor === Array ? [] : &#123;&#125;; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; if (typeof source[key] === &#x27;object&#x27; &amp;&amp; source[key]) &#123; target[key] = deepClone(source[key]); &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = deepClone(obj);obj2.name=&#x27;Coca Cola&#x27;;obj2.detail.color = &#x27;blue&#x27;;console.log(obj) // &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;console.log(obj2) // &#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript对象和JSON","slug":"JavaScript对象和JSON","date":"2020-02-05T03:45:23.000Z","updated":"2021-08-07T05:59:13.747Z","comments":true,"path":"2020/02/05/JavaScript对象和JSON/","link":"","permalink":"http://example.com/2020/02/05/JavaScript%E5%AF%B9%E8%B1%A1%E5%92%8CJSON/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 二者概念JSON(JavaScript Object Notation)是一种轻量级的数据交换格式,它主要用于跨平台交流数据.这种数据格式是从JavaScript对象中演变出来的，它是JavaScript的一个子集。JSON本身的意思就是JavaScript对象表示法（JavaScript Object Notation），它用严格的JavaScript对象表示法来表示结构化的数据，因此 JSON 的属性名必须有双引号。 JSON 数据结构有两种，这两种结构就是对象和数组，通过这两种结构可以表示各种复杂的结构。 123456789&#123; &quot;college&quot;: &quot;TKK&quot;, &quot;age&quot;: 16, &quot;students&quot;:[ &#123;&quot;firstName&quot;:&quot;ITT&quot;,&quot;lastName&quot;:&quot;16001&quot;&#125;, &#123;&quot;firstName&quot;:&quot;ITT&quot;,&quot;lastName&quot;:&quot;16002&quot;&#125;, &#123;&quot;firstName&quot;:&quot;ITT&quot;,&quot;lastName&quot;:&quot;16003&quot;&#125; ]&#125; 二者转换 JSON 数据转换为 JS 对象:eval()函数: 1234let txt = &#x27;&#123;&quot;college&quot;: &quot;TKK&quot;,&quot;age&quot;: 16,&quot;students&quot;: [&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16001&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16002&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16003&quot; &#125;]&#125;&#x27;let obj = eval(&quot;(&quot; + txt + &quot;)&quot;);console.log(obj);console.log(typeof obj);//object 使用eval()函数时,必须为传入的JSON数据添加括号”()”,否则会报语法错误.该函数除了可以解析JSON数据,也可以用于执行JavaScript 脚本片段，这就会带来潜在的安全问题。 JSON 数据转换为 JS 对象:parse()函数: 1234let txt = &#x27;&#123;&quot;college&quot;: &quot;TKK&quot;,&quot;age&quot;: 16,&quot;students&quot;: [&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16001&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16002&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16003&quot; &#125;]&#125;&#x27;let obj = JSON.parse(txt);console.log(obj);console.log(typeof obj);//object 这是专门的 JSON Parser 来实现只用于解析 JSON 数据，不会执行 JavaScript 脚本，而且速度更快。 JS 对象转换为 JSON 数据:JSON.strigify() 函数 123let obj = &#123; college: &quot;TKK&quot;, age: 16 &#125;;let txt = JSON.stringify(obj);console.log(txt);//&quot;&#123;&quot;college&quot;:&quot;TKK&quot;,&quot;age&quot;:16&#125;&quot; #一张表格来区别二者: 区别 Json Javascript对象 含义 仅仅是一种数据格式 对象的实例 传输 可以跨平台数据传输，速度快 不能传输 表现 1. 键值对 2. 键必须加双引号 3. 值不能为方法函数/undefined/NaN 1.键值对 2.值可以是函数、对象、字符串、数字、boolean 等 相互转换 Json → JS 对象：1. var obj = JSON.parse(jsonstring); 2. var obj = eval(“(“+jsonstring+”)”); JS 对象 → Json：JSON.stringify(obj);","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript数据类型详解","slug":"JavaScript数据类型详解","date":"2020-02-04T11:18:53.000Z","updated":"2021-08-07T05:59:13.759Z","comments":true,"path":"2020/02/04/JavaScript数据类型详解/","link":"","permalink":"http://example.com/2020/02/04/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 一.JavaScript数据类型ECMAScript标准规定了7种数据类型，其把这7种数据类型又分为两种：原始类型和对象类型。原始类型也叫基本数据类型，对象类型也叫引用数据类型。 基本数据类型 Null: 只包含一个值: null Undefined: 只包含一个值: undefined Boolean: 包含两个值: true 和 false Number: 整数或浮点数,还有一些特殊值: -Infinity、**+Infinity、NaN** String: 一串表示文本值的字符序列 Symbol: 一种实例,是唯一且不可改变的数据类型 (在ES10中加入了第七种基本数据类型BigInt) 引用数据类型 Object: 除了常用的Object,还有Array,Function,Date,RegExp等也是特殊的对象 二.基本数据类型和引用数据类型的区别基本数据类型具有不可变性在ECMAScript标准中，它们被定义为primitive values，即原始值，代表值本身是不可被改变的。 以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的： 1234567let name = &quot;Cola&quot;;name.slice(1);//olaname.substr(2);//laname.trim(1);//Colaname.toLowerCase(1);//colaname[1];//oconsole.log(name);//Cola 可以看到对name字符串调用方法后再次打印它的值,name没有发生改变,由此可以得知字符串的不可变性.而这些方法都是在原字符串的基础上产生新字符串. 接下来我们对字符串进行赋值操作: 123let name = &quot;Cola&quot;;name = &quot;Coca &quot; + name;console.log(name);//Coca Cola 发现name的值”改变”了.这是为什么?其实,name只是指向**”Cola”的一个指针,指针的指向可以改变,所以name = “Coca “ + name;执行后改变了name的指向,而“Coca Cola”**这个原始值仍然不可改变. 引用数据类型易变引用类型的值实际存储在堆内存中,在栈中存储的是一个固定长度的地址,该地址指向堆内存中的值. 1234let name = &quot;Cola&quot;;let obj1 = &#123; name: &quot;Cola&quot; &#125;;let obj2 = function () &#123; &#125;;let obj3 = [1, 2]; 基本数据类型的比较是值的比较,引用数据类型的比较是引用(地址)的比较123456let a = 1;let a1 = 1;let b = &#123;&#125;;let b1 = &#123;&#125;;console.log(a === a1);//trueconsole.log(b === b1);//false 两种数据类型的复制区别基本数据类型的复制: 12345let name = &quot;Cola&quot;;let name2 = name;//此时内存开辟了一块新的空间用于存储Colaname2=&quot;Coca Cola&quot;;console.log(name);//Colaconsole.log(name2);//Coca Cola 引用数据类型的复制: 1234let obj=&#123;name:&quot;Cola&quot;&#125;;let obj2 = obj;obj2.name=&quot;Coca Cola&quot;;//实际上复制的是栈中存储的地址,因此obj和obj2指向的是同一个对象console.log(obj.name);//Coca Cola 特别注意:ECMAScript中所有的函数的参数都是按值传递的值传递: 123456let name = &#x27;Cola&#x27;;function changeValue(name)&#123; name = &#x27;Coca Cola&#x27;;&#125;changeValue(name);console.log(name);//Cola 上面执行的结果是Cola,可见函数参数是按值传递的. “引用传递”: 123456let obj = &#123; name: &quot;Cola&quot; &#125;;function changeValue(obj) &#123; obj.name = &#x27;Coca Cola&#x27;;&#125;changeValue(obj);console.log(obj.name);//Coca Cola 这里彷佛违背了上面说的,其实没有.当函数参数是引用类型时,Js同样将参数复制了一个副本到局部变量,只不过这个副本是指向堆内存中的地址,也就是在函数内部会对该对象的属性进行操作. 三.null和undefined的区别先看看他们之间的关系: 1234console.log(typeof null);//objectconsole.log(typeof undefined);//undefinedconsole.log(null == undefined);//true 二者都默认转换成falseconsole.log(null === undefined);//false null表示没有对象,即此处不应该有值 作为函数的参数时,表示该函数的参数不是对象 作为对象原型链的终点 undefined表示缺少值,即此处应该有值,但没有定义 定义了形参,没有传实参,显示undefined 访问对象的属性名不存在时,显示undefined 函数没有返回值时,拿到的是undefined 函数有返回值却没有赋值时,拿到的是undefined null 和 undefined 转换成number数据类型时: - null 默认转成 0 - undefined 默认转成 NaN 四.知识点很多的Number类型 JavaScript 只有一种数字类型,即为Number，如 5 和 5.12 是相同的类型,也就是说,所有数字都是浮点数。 JavaScript 使用“双精度64位格式IEEE 754”标准 NaN: Not a Number,不是一个数,但它属于数值类型 NaN和任何值进行操作都会返回NaN NaN与任何值都不相等,包括NaN本身 isNaN(): 这是用于检测一个变量是不是Number类型的函数,它接收一个参数,参数可以是任何类型,该函数会尝试把传入的参数转换为数值,不能转换为数值的值返回true，能转换的返回false。 数值转换 Number() parseInt() 取整 parseFloat() 浮点数 Number()转换规则 如果是布尔值，true和false会被转换为1和0。 12Number(true) // 1Number(false) // 0 如果是数字，没有特殊变换。 12Number(1) // 1Number(100) // 100 null 和 undefined 在上文提及 如果是字符串 字符串中只包含数字（包括前面带正/负号的情况），则将其转换为十进制数值,数字前面有0的会被忽略(不管前面有几个0，全部忽略)，例如”010”会转换成10。1234Number(&quot;1&quot;) // 1Number(&quot;123&quot;) // 123Number(&quot;010&quot;) // 10 (前导的0会被忽略)Number(&quot;-10&quot;) // -10 字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值。123Number(&quot;1.1&quot;) // 1.1Number(&quot;0.1&quot;) // 0.1Number(&quot;0000.1&quot;) // 0.1 (前导的0会被忽略) 字符串中包含有效的十六进制格式（一般用数字0到9和字母A到F（或af）表示，其中:AF表示10~15，这些称作十六进制数字），如”0xf”,将其转换成相同大小的十进制整数值。1Number(0xf) // 15 字符串为空，转换成0。1Number(&quot;&quot;) // 0 字符串中包含除了以上格式之外的字符，则转换为NaN，如字符串中既有数字又有字母的情况。123456Number(&quot;Hello Wolrd&quot;) // NaNNumber(&quot;0ff6600&quot;) // NaNNumber(&quot;ff6600&quot;) // NaNNumber(&quot;0.1a&quot;) // NaNNumber(&quot;10a&quot;) // NaNNumber(&quot;a10.1&quot;) // NaN parseInt(string,radix) 这是一个将一个字符串转换成x进制整数的函数。 传入的第一个参数为字符串，如果参数不是字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。第二个参数为整数，表示按照xx进制转换，如传入参数10表示按十进制规则转换， 从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找（不管后面是否好友数字），把找到的当做数字返回。如果字符串中以0x开头且后跟数字字符，就会将其当做一个十六进制整数。 1234567parseInt(&quot;123abc&quot;) // 123parseInt(&quot;&quot;) // NaNparseInt(&quot;12.5px&quot;) // 12parseInt(&quot;0xA&quot;) // 10 (16进制)parseInt(&quot;0xf&quot;) // 15 (16进制)parseInt(&quot;070&quot;) // 70parseInt(&quot;70&quot;) // 70 parseInt(string,radix) 解析一个参数（必要时先转换为字符串）并返回一个浮点数。默认解析十进制值。 12345function circumference(r) &#123; return parseFloat(r) * 2.0 * Math.PI;&#125;console.log(circumference(4.567));// expected output: 28.695307297889173console.log(circumference(&#x27;4.567abcdefgh&#x27;));// expected output: 28.695307297889173 从左到右依次解析字符，一直解析到字符串末尾，遇到非数字字符会或遇到第二个浮点数（在这之前的字符串都会被解析）会使解析停止,如”3.14”解析成3.14，”3.14.1234”解析成3.14 忽略参数首尾空白符 十六进制格式的字符串始终会被转换成01234567891011parseFloat(&quot;3.14&quot;) // 3.14parseFloat(&quot;-3.14&quot;) //-3.14parseFloat(&quot;+3.14&quot;) //3.14parseFloat(&quot;0003.14&quot;) // 3.14parseFloat(&quot; 3.14 &quot;) // 3.14parseFloat(&quot;3.14abc&quot;) // 3.14parseFloat(&quot;3.14.5678&quot;) // 3.14parseFloat(&quot;abc3.14&quot;) // NaNparseFloat(&quot;abc123&quot;) // NaNparseFloat(&quot;123abc&quot;) // 123parseFloat(&quot;0xA&quot;) //0 #####parseInt() 和parseFloat() 的区别在于： parseFloat() 所解析的字符串中第一个小数点是有效的，而parseInt() 遇到小数点会停止解析。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript原型和原型链","slug":"JavaScript原型和原型链","date":"2020-02-03T10:34:20.000Z","updated":"2021-08-07T05:59:13.772Z","comments":true,"path":"2020/02/03/JavaScript原型和原型链/","link":"","permalink":"http://example.com/2020/02/03/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 Constructor 构造函数先写一个构造函数Person(构造函数一般为了区别普通函数，要求首字母大写): 1234function Person(name, age)&#123; this.name = name; this.age = age;&#125; prototype 原型原型是一个对象，实例”继承”对象的属性.也就是说在原型上定义的属性，通过”继承”这个行为，实例也拥有这个属性.该行为是在new关键字内部实现的. 我们把构造函数打印出来看看，发现其内部有一个名为prototype属性，通过它就能访问到原型: Person 就是构造函数，Person.prototype 就是原型 instance 实例现在有构造函数了,我们可以在原型上创建可以被”继承”的属性,并通过new关键词创建实例 可以使用 instanceof 就是判断一个实例是否属于某种类型,现在创建一个实例: 12let person = new Person(&quot;小黄&quot;,22);console.log(person instanceof Person);//true 如果我们在原型上定义一个属性后再实例化对象: 12345678function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.eyeColor = &quot;black&quot;let person = new Person(&quot;小黄&quot;,22);console.log(person.eyeColor);//black proto 隐式原型实例通过 proto 访问到原型： 所以以下二者等价 12345678function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.eyeColor = &quot;black&quot;let person = new Person(&quot;小黄&quot;,22);console.log(person.__proto__ === Person.prototype);//true constructor 构造函数(属性)原型可以通过constructor访问到构造函数: 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;console.log(Person.prototype.constructor === Person);//true 继续完善关系图:注意这里的 constructor 是原型的一个属性，Constructor 指的才是真正的构造函数。两者名字不要弄混了 原型链原型同样也可以通过 proto 访问到原型的原型,直到搜索到null: 123456789101112131415161718function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.eyeColor = &quot;black&quot;;function People()&#123;&#125;People.prototype = new Person();let people = new People()console.log(people instanceof Object)//trueconsole.log(people instanceof People)//trueconsole.log(people instanceof Person)//trueconsole.log(people.eyeColor)//blackconsole.log(people.__proto__)//Person &#123;&#125;console.log(people.__proto__.__proto__)//Person &#123;eyeColor: &quot;black&quot;&#125;console.log(people.__proto__.__proto__.__proto__)// &#123;&#125;console.log(people.__proto__.__proto__.__proto__.__proto__)//null 由此可以得出原型、原型链、构造函数、实例、null之间的关系:","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript创建对象的几种方式","slug":"JavaScript创建对象的几种方式","date":"2020-02-03T07:34:24.000Z","updated":"2021-08-07T05:59:13.718Z","comments":true,"path":"2020/02/03/JavaScript创建对象的几种方式/","link":"","permalink":"http://example.com/2020/02/03/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 使用对象字面量 这是创建对象最简单的方法。 使用对象文字，可以在一条语句中定义和创建对象。 对象文字指的是花括号 {} 中的名称:键值对（比如 age:62）。 例子： 12345678910let person = &#123; name:&quot;小黄&quot;, age:22, eyeColor:&quot;black&quot;, say:function()&#123; alert(this.name+&quot;今年&quot;+this.age+&quot;岁!&quot;); &#125;&#125;;person.say()//调用 通过关键词 new 例子: 123456789let person = new Object();person.name = &quot;小黄&quot;;person.age = 22;person.eyeColor = &quot;black&quot;; person.say = function()&#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;);&#125;;person.say()//调用 通过构造函数 无参构造函数 例子:12345678910function Person()&#123;&#125;let person = new Person(); person.name = &quot;小黄&quot;;person.age = 22;person.eyeColor = &quot;black&quot;; person.say = function() &#123; alert(person.name+&quot;今年&quot;+person.age+&quot;岁!&quot;);&#125;;person.say()//调用 带参构造函数 例子:1234567891011function Person(name, age, eyeColor) &#123; this.name = name; this.age = age; this.eyeColor = eyeColor; this.say = function() &#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;); &#125;;&#125;let person = new Person(&quot;小黄&quot;, 22, &quot;black&quot;); //实例化、创建对象person.say()//调用 工厂模式 例子: 12345678910111213function createPerson(name, age, eyeColor) &#123; let person = new Object(); person.name = name; person.age = age; person.eyeColor = eyeColor; person.say = function() &#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;); &#125;; return person;&#125;let my = createPerson(&quot;小黄&quot;, 22, &quot;black&quot;);//实例化my.say();//调用 原型模式 例子: 12345678910function Person(name, age, eyeColor)&#123;&#125;Person.prototype.name = &quot;小黄&quot;;Person.prototype.age = 22;Person.prototype.eyeColor = &quot;black&quot;; Person.prototype.say = function() &#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;); &#125;let person = new Person();person.say(); 构造函数和原型组合模式 例子: 123456789101112function Person(name, age, eyeColor)&#123; this.name = name; this.age = age; this.eyeColor = eyeColor; &#125;;Person.prototype.say = function()&#123; return this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;&#125;;let person = new Person(&quot;小黄&quot;, 22, &quot;black&quot;);console.log(person.say());","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"为什么编程语言的都要定义数据类型","slug":"为什么编程语言的都要定义数据类型","date":"2020-02-03T06:27:56.000Z","updated":"2021-08-07T05:59:13.658Z","comments":true,"path":"2020/02/03/为什么编程语言的都要定义数据类型/","link":"","permalink":"http://example.com/2020/02/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E9%83%BD%E8%A6%81%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"我们都知道声明变量时，需要在内存中为该变量开辟空间。不同的数据类型占用的内存空间是不同的，如int占用4字节，char占用2字节(java中)，指定数据类型是为了给不同的数据类型分配不同的内存空间，既能适当地存储该变量的值，又不会浪费内存空间。 实际上还有其他原因，可以一句话概括为:数据类型是面向编译器的，决定编译器对相应类型的处理方式。以如下C++代码进行说明: 12345678int a=100;int b=200;double a1=10.1;double b1=10.2;a=a+b;a1=a1+b1; 这段代码非常简单，定义了四个数据，两种类型。a=a+b; 和 a1=a1+b1; 这两条语句几乎一样，但在计算机中使用了不同的处理器:整数使用普通的CPU，而浮点数必须使用浮点运算器。所以，这两句话，产生的机器代码完全不同！ 那么编译器碰到如上代码时如何知道使用哪一种机器指令呢，此时定义数据类型的意义就凸显出来了:编译器就会检查进行加法操作的两个加数的数据类型，根据他们的数据类型，来确定到底使用哪一个运算器的机器代码。 再次总结:数据类型的背后，隐藏的是编译器或者解释器对数据处理方式的定义。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程原理相关","slug":"编程原理相关","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"}]},{"title":"git账号密码输入错误后如何重新输入密码","slug":"git账号密码输入错误后如何重新输入密码","date":"2020-02-03T01:18:16.000Z","updated":"2021-08-07T05:59:13.690Z","comments":true,"path":"2020/02/03/git账号密码输入错误后如何重新输入密码/","link":"","permalink":"http://example.com/2020/02/03/git%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E9%94%99%E8%AF%AF%E5%90%8E%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 搜索–&gt;凭据管理器 –&gt; windows凭据 –&gt;找到对应git凭据删除 –&gt; 重新拉取","categories":[{"name":"解决方案","slug":"解决方案","permalink":"http://example.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"MongoDB常用命令","slug":"MongoDB常用命令","date":"2020-01-31T09:22:58.000Z","updated":"2021-08-07T05:59:13.898Z","comments":true,"path":"2020/01/31/MongoDB常用命令/","link":"","permalink":"http://example.com/2020/01/31/MongoDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 为了从命令提示符下运行 MongoDB 服务器，必须从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件。 1E:\\MongoDB\\bin&gt;mongod --dbpath E:\\MongoDB\\data\\db 数据库:查看当前版本1db.version() 数据库:查看所有数据库1show dbs 查看当前数据库1db 创建数据库1use DATABASE_NAME 删除当前数据库1db.dropDatabase() 集合:在当前数据库创建集合1db.createCollection(name, options) 参数说明： name: 要创建的集合名称 options: 可选参数, 指定有关内存大小及索引的选项 字段 类型 描述 capped 布尔 （可选） 如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 （可选） 如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 （可选） 为固定集合指定一个最大值，以千字节计（KB）。如果 capped 为 true，也需要指定该字段。 max 数值 （可选） 指定固定集合中包含文档的最大数量。 在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。 例子:创建固定集合 hjy_friends，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。 1db.createCollection(&quot;hjy_friends&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; ) 在 MongoDB 中，可以不需要创建集合。当插入一些文档时，MongoDB 会自动创建集合。 1db.hjy_classmates.insert(&#123;&quot;name&quot;:&quot;小黄&quot;&#125;) 查看当前数据库下所有集合123show tablesshow collections 删除集合1db.COLLECTION_NAME.drop() 文档:向集合中插入文档1db.COLLECTION_NAME.insert(document) 例子:在hjy_friends集合中创建一条文档: 1db.hjy_friends.insert(&#123;name:&quot;小黄朋友&quot;,age:22&#125;) 更新文档1db.COLLECTION_NAME.update() 例子: 1db.hjy_friends.update(&#123;age:22&#125;,&#123;$set:&#123;name:&quot;小黄的朋友&quot;&#125;&#125;) 删除文档(2.6版本后)1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 例子: 1db.hjy_friends.update(&#123;age:22&#125;,&#123;$set:&#123;name:&quot;小黄的朋友&quot;&#125;&#125;) 查询的文档1db.COLLECTION_NAME.find() pretty()方法以格式化的方式来显示所有文档 1db.COLLECTION_NAME.find().pretty()","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"}]},{"title":"关系型数据库遵循的ACID规则","slug":"ACID规则","date":"2020-01-24T01:35:24.000Z","updated":"2021-08-07T05:59:13.670Z","comments":true,"path":"2020/01/24/ACID规则/","link":"","permalink":"http://example.com/2020/01/24/ACID%E8%A7%84%E5%88%99/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 ** 事务的英文中是transaction ** ** ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）的缩写 ** 事务事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换为另一种状态。 原子性（atomicity）原子性很容易理解，即不可分割，事务里的所有操作要么全部被执行，要么全部不执行。也就是说事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要**回滚[1]**。 一致性（consistency）事务的执行使得数据库从一种正确状态转换成另外一种正确状态。 例子:假设用户A和用户B两者账户的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个账户户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（isolation）所谓的隔离性(在有些教程中也称独立性)是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。 例子:A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 持久性（durability）事务正确提交之后，其结果将永远保存在数据库之中，即使在事务提交之后有了其他故障，事务的处理结果也会得到保存。 释义:回滚:删除由一个或多个部分完成的事务执行的更新。为保证应用程序、数据库或系统错误后还原数据库的完整性，需要使用回滚。回滚泛指程序更新失败, 返回上一次正确状态的行为。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"关系型数据库","slug":"关系型数据库","permalink":"http://example.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"人生海海——读书笔记","slug":"读书笔记--人生海海","date":"2020-01-11T02:27:15.000Z","updated":"2021-08-07T05:59:13.586Z","comments":true,"path":"2020/01/11/读书笔记--人生海海/","link":"","permalink":"http://example.com/2020/01/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F%E6%B5%B7%E6%B5%B7/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 通过”我”这第一人称陆陆续续从其他地方探听到上校曲折的一生，虽并非亲眼见证，但从别人口中娓娓道来也能感知那些跌宕起伏。上校在抗日，内战，文革那几十年来经历的一系列令人愤怒的背叛，战争年代的硝烟，自我宽容的救赎，一步步成全他有遗憾却完满的人生，有时候我不忍继续阅读下去，上校这一生令人心疼，年少的轻狂，救人救命的积极，前线的勇敢，化作他不再年轻时的豁达，唯独肚皮上的字，是他英勇无畏的体现，却让他一辈子被钉在民族大义的耻辱柱上，不敢展于人前，最终誓死捍卫秘密让他崩溃，不免令人唏嘘。人心是个复杂的多面体，在书中也体现得淋漓尽致，恨意和宽容在我们每个人身上都在相爱相杀，也正因为这样，这本书触动了心里某些东西，才影响到了我，为此感慨，为故事情节喜怒哀乐。在历史的滚滚洪流中，去看与上校相关的人和事，爷爷，父亲，老保长，小瞎子，林阿姨的恩怨情仇，或悔恨或遗憾，包括”我”的一生，波涛汹涌，前途茫茫，果真人生海海，潮起潮落。我认为他是民族英雄，虽然很难评判在那个时代的一个人，但上校始终没有背叛过国家，救人救命，除恶务尽。“记住，人生海海，敢死不叫勇气，活着才需要勇气，世上只有一种英雄主义，就是在认清了生活真相后依然热爱生活。”这段话深得我心，这本书完完全全注解了它意思，内在深刻，值得把这段故事记住。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"如何上传文件至远程服务器","slug":"如何上传文件至远程服务器","date":"2019-11-22T14:04:20.000Z","updated":"2021-08-07T05:59:13.641Z","comments":true,"path":"2019/11/22/如何上传文件至远程服务器/","link":"","permalink":"http://example.com/2019/11/22/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 当我们在自己的电脑上完成开发工作后,常常需要把项目打包上传到远程服务器上部署,那如何进行操作呢?本文提供一种相对简便的方法用以解决该问题. 本文实践具体场景:本地上传文件至华为云服务器,用Xshell这个强大的安全终端模拟软件来验证是否成功 通过FTP工具FTP（File Transfer Protocol）是Internet上用来传送文件的协议（文件传输协议）. 现在有很多FTP工具 : FlashFXP、FileZilla、xFTP等等,操作都不复杂,这里用FlashFXP做演示 打开FlashFXP进行操作 打开Xshell验证是否上传成功 可以看到终端输出的”哈哈哈”,说明文件上传成功.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"SpringBoot+MySQL+MyBatis的入门教程","slug":"SpringBoot+MySQL+MyBatis的入门教程","date":"2019-10-21T11:57:30.000Z","updated":"2021-08-07T05:59:13.944Z","comments":true,"path":"2019/10/21/SpringBoot+MySQL+MyBatis的入门教程/","link":"","permalink":"http://example.com/2019/10/21/SpringBoot+MySQL+MyBatis%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 本教程的开发环境以工具： JDK1.8 Navicat for MySQL（简单来说是一种数据库图形化工具，方便直接操作数据库） IntelliJ IDEA 开始之前,先对我们要用到的东西有个大概的了解: Spring Boot 中分为为 controller层、service层、dao层、entity层。 entity层存放实体类,与数据库中的属性值基本保持一致,定义为私有,实现set和get方法。 service层存放业务逻辑处理,不直接和数据库打交道,该层有接口还有接口的实现方法，在接口的实现方法中需要导入mapper层,service是供我们使用的方法(提供controller层调用的方法)。 dao层即mapper层，对数据库进行持久化操作，该层的方法是针对数据库操作的，基本用到的就是增删改查。它只是个接口，只有方法名字，具体实现在mapper.xml中。 controller层即控制器，导入service层，因为service中的方法是我们使用到的，controller通过接收前端传过来的参数进行业务操作，再返回一个指定的路径或者数据表。 MySQL就不用说了,最流行的关系型数据库管理系统。 MyBatis首先Mybatis是一个优秀的持久化框架,它支持自定义SQL查询、存储过程,和很好的一个映射。第二,Mybatis减少了大部分JDBC的代码,避免了手动设置参数和结果集的映射。第三,Mybatis用简单的XML配置文件或注解来配置映射关系,将接口和POJO对象映射到数据库记录中。(看不懂也没关系,我也不太清楚,慢慢学!) 一.项目构建1.通过IDEA创建工程:打开IDEA-&gt;file-&gt;New-&gt;Project-&gt;Spring Initializr2.next之后添加如图依赖(红框部分) 3.MySQL部分:打开Navicat,选择数据库,新建查询,DDL如下:CREATE TABLE `user` ( `id` int(11) NOT NULL, `name` varchar(255), `age` int(11), PRIMARY KEY (`id`) ) 刷新表之后可以看到刚刚新建的表,继续新建查询,DDL如下:INSERT INTO t_msg (id, NAME, age) VALUES (1, &#39;小黄&#39;, 9); 刷新表之后可以看到刚刚插入的数据,如下图所示: 4.构建项目目录,如图所示: 构建数据库对应的实体类TMsg，这个类放在entity,代码如下:1234567891011121314151617181920212223package com.example.demo.entity;import lombok.Data;import java.io.Serializable;/** * Created by HJY on 2019/10/21. */@Datapublic class TMsg implements Serializable &#123; private Integer id; private String name; private Integer age; public String getMessage()&#123; return &quot;id:&quot;+id+&quot;,name:&quot;+name+&quot;,age:&quot;+age; &#125;&#125; 构建构建对应的Mapper接口,代码如下:1234567891011121314package com.example.demo.mapper;import com.example.demo.entity.TMsg;import org.apache.ibatis.annotations.Mapper;/** * Created by HJY on 2019/10/21. */@Mapperpublic interface TMsgMapper &#123; public TMsg findById(Integer id);&#125; Mapper接口与TMsgMapper.xml文件对应关系,代码如下:1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.TMsgMapper&quot;&gt; &lt;select id=&quot;findById&quot; resultType=&quot;com.example.demo.entity.TMsg&quot;&gt; SELECT id,name,age from user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; service层接口与其实现,代码如下:123456789101112package com.example.demo.service;import com.example.demo.entity.TMsg;/** * Created by HJY on 2019/10/21. */public interface TMsgService &#123; public TMsg findById(Integer id);&#125; 1234567891011121314151617181920212223package com.example.demo.service.impl;import com.example.demo.entity.TMsg;import com.example.demo.mapper.TMsgMapper;import com.example.demo.service.TMsgService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * Created by HJY on 2019/10/21. */@Servicepublic class TMsgServiceImpl implements TMsgService &#123; @Autowired private TMsgMapper tMsgMapper; @Override public TMsg findById(Integer id) &#123; return tMsgMapper.findById(id); &#125;&#125; 在controller层构建一个get方法，通过id获取信息,代码如下:123456789101112131415161718192021222324252627package com.example.demo.controller;import com.example.demo.entity.TMsg;import com.example.demo.service.TMsgService;import org.apache.ibatis.annotations.Param;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * Created by HJY on 2019/10/21. */@RestController@RequestMapping(&quot;/msg&quot;)public class TMsgController &#123; @Autowired private TMsgService tMsgService; @GetMapping(&quot;/getMsg&quot;) public String getMsg(@Param(&quot;id&quot;) Integer id)&#123; TMsg tMsg = tMsgService.findById(id); return tMsg.getMessage(); &#125;&#125; 修改application.properties文件后缀为application.yml,复制如下代码到该文件中,此处填写数据库信息,还有mybatis的数据库映射地址,实体类地址.(password如果是数字需要用单引号引起来):123456789spring: datasource: url: jdbc:mysql://localhost:3306/test?useSSL=true&amp;serverTimezone=Asia/Shanghai username: root password: &#x27;1234567&#x27; driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath*:mapper/*Mapper.xml type-aliases-package: com.example.demo.entity 二.项目运行启动项目,打开浏览器,输入http://localhost:8080/msg/getMsg?id=1 此时可以看到我们在数据库中插入的数据,至此完成.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"黄金时代——读书笔记","slug":"读书笔记--黄金时代","date":"2019-09-25T14:36:08.000Z","updated":"2021-08-07T05:59:13.553Z","comments":true,"path":"2019/09/25/读书笔记--黄金时代/","link":"","permalink":"http://example.com/2019/09/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 说句实话，初看这本书时，我直接被王小波大胆的描写给震住了，文字露骨却也坦率，话语幽默却也深刻。 每个人都有自己的黄金时代，王二在他的似水流年里或许真的可以说是放荡不羁，做了很多人想做却不敢做的事，我觉得他并非消遣，是在享受人生。他身上有着一些超凡的东西，或许可以说是勇气，当然也不仅仅勇气。他不在意大环境如何，在他二十岁出头的年纪，惦记上了有夫之妇的陈清扬，并以友谊之名付诸行动，之后就有了这看似色情却拥有了更多内在情感和讽刺意味的写作素材，虽然在现在看来有些荒唐，但我也并不怀疑它的真实性。 我相信王小波先生的风流，也喜欢他妙趣横生里的”真知灼见”。字里行间里能看出他的文学才华，他的文字总是能够让我在不经意间惊喜万分，”那一天我21岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失。”我也曾有这样光怪陆离的想法，那时不懂，直到后来才明白这也是我自己时代里美好的事物，说幻想倒也可以，我宁愿叫的好听些，哈哈。 岁月如流这词一点也不错，年岁渐长，王二也正经许多，但仍然有着他那些天马行空的想法，像年轻的时候。真好。 [========] 2020-02-23补充: 每每看到”不怕贼偷就怕贼惦记”这句话，我总会想起王二，王二是贼吗，他偷了什么吗，也惦记着陈清扬，陈清扬对他大抵也是心动过的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"我们仨——读书笔记","slug":"读书笔记--我们仨","date":"2019-08-20T12:16:08.000Z","updated":"2021-08-07T05:59:13.609Z","comments":true,"path":"2019/08/20/读书笔记--我们仨/","link":"","permalink":"http://example.com/2019/08/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E6%88%91%E4%BB%AC%E4%BB%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 通读全书后，我为杨绛先生真挚深厚的情感深深感动。字里行间没有情话，却处处透露一家三口的亲密无间，守望相助。一家三口皆为学者，偏爱读书，有时候我看着书，会联想到他们仨围坐着一张不高不低的桌子，低头认真读书，一间屋子里只有呼吸声和翻阅书籍的声音，真好。 在现实生活里，我很少见识到这般感情，也许是我还年轻，也许是我接触的人还少，像他们仨这样的相处模式我很羡慕，和最亲近的人一起做着自己最热爱的东西，不被生活琐事所破坏，当然，这也是在一定程度上的完全可接受琐事，哈哈！ “世间好物不坚牢，彩云易散琉璃脆”说的就是杨先生对这份家庭感情的万分留恋，文章结尾处杨先生写到”家在哪里，我不知道，我还在寻觅归途”，心里一酸，她在家人生病这段时期的心里得有多难受啊，几十年的陪伴，如今家人不在，我不敢去想那是怎样的心情。如果有来生，如果有机会，我想杨老先生一定还会来寻觅她的这个家。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"风起陇西 —— 读书笔记","slug":"读书笔记--风起陇西","date":"2019-08-10T10:09:00.000Z","updated":"2021-08-07T05:59:13.543Z","comments":true,"path":"2019/08/10/读书笔记--风起陇西/","link":"","permalink":"http://example.com/2019/08/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%A3%8E%E8%B5%B7%E9%99%87%E8%A5%BF/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 这是我第一次看谍战小说，感觉这本书当真是有意思，作者创造性地把三国志和西方悬疑小说相结合，以三国时代为背景，架空历史人物，融悬疑于史实，以个人独特的想法来进行写作。 从头到尾读下来，令我吃惊并加以欣赏，强行安利给朋友的原因是作者对于细节的把握，把人物的心理抽丝剥茧，完完全全分析透彻，虽情节有些漏洞，但也不妨碍我佩服作者的丝丝入扣。 对于书中描述的众多官僚机构，倒是让我有点烦恼，一方面是记不住，一方面却是作者功力的展现，他让我反感浓厚的官僚气氛，这一点既无奈又让我自己暗自发笑。 间谍，情报，家国情怀……是这本小说的关键词，小说的最后是各奔天涯，都有了自己的归宿，却没有人知道这片土地上发生过那些令人惊心动魄却意义非凡的事情。世事变迁，沧海桑田，时间抹掉了所有痕迹，我相信真实的历史不乏有小说中千回百转的事件，小说也未必没有写到一些在历史长河中我们应该思考的东西。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"协议","slug":"协议","permalink":"http://example.com/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"解决方案","slug":"解决方案","permalink":"http://example.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"},{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"网络攻击","slug":"网络攻击","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"编程原理相关","slug":"编程原理相关","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"},{"name":"关系型数据库","slug":"关系型数据库","permalink":"http://example.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}