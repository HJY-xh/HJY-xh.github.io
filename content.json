{"meta":{"title":"可乐加冰","subtitle":"","description":"","author":"HJY","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-07T06:13:07.313Z","updated":"2021-08-07T06:13:07.313Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-08-07T06:13:07.340Z","updated":"2021-08-07T06:13:07.340Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-08-07T06:13:07.354Z","updated":"2021-08-07T06:13:07.354Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-07T06:13:07.361Z","updated":"2021-08-07T06:13:07.361Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-08-07T06:13:07.329Z","updated":"2021-08-07T06:13:07.329Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2021-08-07T06:11:15.550Z","updated":"2021-08-07T06:11:15.549Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-08-07T06:13:32.748Z","updated":"2021-08-07T06:13:32.748Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue 和 React 区别","slug":"Vue和React区别","date":"2023-05-22T12:45:44.000Z","updated":"2023-08-03T13:27:33.356Z","comments":true,"path":"2023/05/22/Vue和React区别/","link":"","permalink":"http://example.com/2023/05/22/Vue%E5%92%8CReact%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Vue 和 React 和共通之处在于： 数据驱动视图 组件化 Virtual DOM 不同之处在于： 核心思想 写法 Diff 算法 响应式原理 数据驱动视图数据变化的时候，相应的视图会得到更新，开发者只需要关注数据的变化而不用再去手动的操作DOM Vue 数据驱动是通过 MVVM 这种框架来实现的，MVVM框架主要包含3个部分:Model、View和 ViewModel Model:指的是数据部分，对应到前端就是 JavaScript 对象 View:指的是视图部分，对应前端就是 DOM ViewModel:就是连接视图与数据的中间件（getter/setter） 再来看 React， 需要先了解以下概念 pending：当前所有等待更新的state队列 isBatchingUpdates：React中用于标识当前是否处理批量更新状态，默认false dirtyComponent：当前所有待更新state的组件队列 React 通过setState实现数据驱动视图，通过setState来引发一次组件的更新过程从而实现页面的重新渲染(除非shouldComponentUpdate返回false)： setState()首先将接收的第一个参数state存储在pending队列中（state） 判断当前React是否处于批量更新状态，是的话就将需要更新state的组件添加到dirtyComponents中（组件） 不是的话，它会遍历dirtyComponents的所有组件，调用updateComponent方法更新每个dirty组件（开启批量更新事务） 响应式原理Vue Vue 依赖手机，自动优化，数据可变 Vue 递归监听 data 的所有属性，直接修改 当数据发生改变，自动找到引用数据的组件，进行重新渲染 React React 基于状态机，手动优化，数据不可变，需要 setState 驱动新的 State 替换老的 State 当数据改变时，以组件为根目录，默认全部重新渲染 组件化 组件是独立和可复用的代码组织单元，它能够大幅提高应用开发效率、测试性、复用性，使开发者使用小型、独立和通常可复用的组件构建大型应用 调试方便，可维护性高，使得整个应用的耦合度降低 Vue 和 React 通过将页面拆分成一个一个小的可复用单元来提高代码的复用率和开发效率 React 推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 HTML、CSS、JS 写在同一个文件(vue也支持JSX写法) 虚拟DOM虚拟 DOM（Virtual DOM）本质上是JS 和 DOM 之间的一个映射缓存，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象，它主要存储在内存中。主要来说： 虚拟dom是一个js对象，存储在内存之中。 虚拟dom能够描述真实dom（存在一个对应关系） 当数据变化的时候，生成新的DOM，对比新旧虚拟 DOM 的差异，将差异更新到真实 DOM 上（也就是Diff过程） 减少直接操作 DOM（框架给我们提供了屏蔽底层 DOM 书写的方式，减少频繁的整更新 DOM ，同时也使得数据驱动视图） 为函数式UI编程提供可能 可以跨平台，渲染到DOM（web）之外的平台。比如ReactNative，Weex Vue 和 React 通用流程：vue template/react jsx -&gt; render函数 -&gt; 生成VNode -&gt; 当有变化时，新老VNode Diff -&gt; Diff算法对比，并真正去更新真实 DOM 两者对Diff算法的优化基本上思路是相同的（Diff 算法借助元素的 Key 判断元素是新增、删除、修改，从而减少不必要的元素重渲染）： tag不同认为是不同节点 只比较同一层级，不跨级比较 同一层级的节点用key唯一标识，tag和key都相同则认为是同一节点 DOM 的更新策略不同： React 会自顶向下全 Diff 当状态发生改变时，组件树就会自顶向下的全 Diff, 重新 render 页面， 重新生成新的虚拟 DOM TREE, 新旧 DOM TREE 进行比较， 进行 patch 打补丁方式，局部更新 DOM Vue 会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树 把这些 data 属性 全部转为 getter/setter。同时 watcher 实例对象会在组件渲染时，将属性记录为dep，当 dep 项中的 setter 被调用时，通知 watcher 重新计算，使得关联组件更新 核心思想Vue 的核心思想是尽可能的降低前端开发的门槛，是一个灵活易用的渐进式双向绑定的MVVM框架。它的整体思想仍然是拥抱经典的 HTML (结构)+ CSS (表现)+ JS (行为)的形式，通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能 React 的特色在于函数式编程、数据不可变以及单向数据流的理念。函数式编程最大的好处是其稳定性（无副作用）和可测试性（输入相同，输出一定相同），所以通常大家说的React适合大型应用，根本原因还是在于其函数式编程 核心思想不同导致的一些差异主要是写法和API差异 Vue 推崇 template模板、options API，这样更契合传统 Web 开发者的直觉和习惯，但也不可避免的引入了更多概念和API，比如template模板中需要理解slot、filter、指令等概念和api，options API中需要理解watch、computed（依赖收集）等概念和api 而 React 推崇 JSX、 HOC、 all in JS，其本身由于 FP 的特性，本质上核心只有一个Virtual DOM + Diff算法，所以API非常少 组件通信方法Vue: 父-&gt;子 props: 父组件使用props属性向子组件传递数据 slot $refs $children 子-&gt;父 事件形式：子$emit，父监听 $parent 兄弟组件 中央总线new Bus()，发布/订阅模式，其实此方法也可以用在跨级、父子间通讯 借助同一父组件通过props传递数据，也就是利用父组件实现中转传递(会增加子组件和父组件之间的耦合度) 跨级组件 层层组件传递props provide/inject React: 父-&gt;子 props: 父组件使用props属性向子组件传递数据 ref: 获取整个子组件对象，可以调用子组件中的函数 子-&gt;父 利用回调函数：父组件使用props属性向子组件传递一个函数，子组件携带自己的数据并通过调用该函数向父组件传递数据 兄弟组件 自定义事件机制：发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件之间的通信 借助同一父组件通过props传递数据，也就是利用父组件实现中转传递(会增加子组件和父组件之间的耦合度) 跨级组件 层层组件传递props 使用context：生产/消费者模式 事件机制Vue: 原生事件使用标准 Web 事件 Vue组件自定义事件机制，是父子组件通信基础 React: 自身实现了一套自己的事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等 所有事件并没有绑定到具体的dom节点上而是绑定在了document 上，然后由统一的事件处理程序来处理，同时也是基于浏览器的事件机制（冒泡），所有节点的事件都会在 document 上触发","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"}]},{"title":"HTTPS工作原理和流程","slug":"HTTPS工作原理和流程","date":"2023-05-13T13:37:42.000Z","updated":"2023-08-12T09:54:24.731Z","comments":true,"path":"2023/05/13/HTTPS工作原理和流程/","link":"","permalink":"http://example.com/2023/05/13/HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 HTTP 存在的问题提到 HTTP ，大家的第一印象就是不安全，那它到底是哪里不安全呢？ 先说说 HTTP 的基本信息：它属于应用层的协议， 基于TCP/IP，通过 TCP 协议进行传输，依靠 IP 协议进行寻址 网络中的数据是以包的形式在网络模型各层之间传递的，而 HTTP 的数据报文在这些层之间都是没有加密的明文，那么它就会引发以下的一些问题： 内容可能被窃听 通信时，中间会经历很多个阶段，而每个阶段报文内容都有可能会被窃听 无法验证接收报文的完整性（可能会被篡改） 无法验证接收到报文是否被篡改，比如说被删除了一部分或者新增了一部分 没有验证通信双方的身份（可能被冒充） 无法判断请求是来自何方，出自谁手 什么是 HTTPS？HTTPS 中的 S 代表“安全”。HTTPS 使用 TLS（或 SSL）来加密HTTP 请求和响应 TLS 使用一种称为公钥加密的技术：密钥有两个，即公钥和私钥，其中公钥通过服务器的 SSL 证书与客户端设备共享。当客户端打开与服务器的连接时，这两个设备使用公钥和私钥商定新的密钥（称为会话密钥），以加密它们之间的后续通信。 然后，所有 HTTP 请求和响应都使用这些会话密钥进行加密，使任何截获通信的人都只能看到随机字符串，而不是明文 HTTPS 做了什么？HTTPS 解决了 HTTP 存在的问题，也就是它解决了三个问题： 加密：HTTPS 通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动，访问记录等，从而窃取用户信息 数据一致性：数据在传输的过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接收的就是什么 身份认证：是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别），它可以防止中间人攻击并建立用户信任。 HTTPS 采用混合加密机制，也就是对称加密与非对称加密混用来实现加密机制 首先得先了解几个概念： 加密：将明文变换为密文的过程 解密：加密的逆过程，即由密文恢复出原明文的过程 密钥：指某个用来完成加密、解密、完整性验证等密码学应用的秘密信息 对称加密：加密和解密采用同一个密钥 非对称加密：加密和解密的时候采用的是不同的密钥 加密非对称加密相比对称加密更加复杂，效率更低，在前端业务中一般都是存在大量的 HTTP 请求，所以非对称加密的低效是无法被接受的。此外，非对称加密的场景只在服务端保存私钥，也就是说一对公私钥只能单向传输数据，因此可以用来确认通信安全以及服务端返回证书。确认安全之后，传输数据采用的就是速度更快的对称加密，因此可以简单记忆如下阶段： 证书交换验证阶段–&gt;非对称加密 客户端发起 HTTPS 请求 服务端返回 HTTPS 证书 客户端验证证书是否合法，不合法则提示警告 数据传输阶段–&gt;对称加密 当证书验证合法后，在本地生成随机密码串 通过公钥加密随机密码串，并把结果传给服务器端 服务端通过撕咬对接机密码解密 服务端通过客户端传入的随机密码穿构建对称加密算法，对返回结果内容进行加密后传输 数据完整性确保数据完整性，也就意味着数据安全没有被第三方篡改，这时候就需要通过 数字签名 数字签名是一段由发送者生成的特殊加密校验码，用于传输过程中确认报文的完整性。数字签名涉及到了两种技术：非对称加密 和 数字摘要。生成数字摘要的算法通过 MD5 和 SHA 这种不可逆算法，将不定长的报文内容提取出定长的数字摘要 假设现在有通信双方A和B，两者之间使用两套非对称加密机制 现在A向B发消息，那么，如果在发送过程中，有人修改了里面密文消息，B拿到的密文，解密之后得到明文，并非A所发送的，信息不正确 要解决两个问题 A的身份认证 A发送的消息完整性 那么就要进行以下操作： 将明文进行摘要运算后得到摘要（消息完整性） 再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B B收到报文后，使用相同的摘要算法提取出摘要，将数字签名用A的公钥进行解密后，得到正确的摘要 证书上面加密的过程也存在一个问题，安全的本质是使用密钥进行加密。但是如果密钥本身就有问题，那么安全也就无从谈起，因此这个密钥必须是通信双方认可的。这个工作不能交给客户端做，也不能服务端做，一半交给第三方权威机构 – 数字证书认证机构（CA，Certificate Authority） 认证机关的公开密钥必须安全地转交给客户端，使用通信方式是，如何安全转交是一件很困难的事，因此多数浏览器发布版本时，都会是现在内置常用认证机关的公钥 浏览器是如何确保 CA 证书的合法性？浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证： 验证域名、有效期等信息 判断证书来源是否合法 每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证 判断证书是否被篡改 需要与 CA 服务器进行校验 判断证书是否已吊销 通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率 HTTPS 工作流程HTTPS 的整个通信过程可以分为两大阶段： 证书验证 数据传输阶段 非对称加密 对称加密 客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口) 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等 客户端解析证书并对其进行验证 如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信 如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密 客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥 服务器在收到随机码 KEY 之后会使用私钥B将其解密 经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了 双方使用对称加密愉快地传输所有数据 HTTPS 绝对安全吗HTTPS 也会被抓包，只不过内容被加密过 但是用户可以主动对证书进行授权，如果用户授权通过，那么代理软件是可以对传输内容进行解密的","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"}]},{"title":"HTTP2新特性","slug":"HTTP2新特性","date":"2023-04-20T14:43:25.000Z","updated":"2023-08-12T09:51:26.626Z","comments":true,"path":"2023/04/20/HTTP2新特性/","link":"","permalink":"http://example.com/2023/04/20/HTTP2%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"概述HTTP/2 基于 SPDY 协议，该协议是谷歌自行开发的，主要是为了解决 HTTP/1.1 效率不高的问题，该协议在 Chrome 浏览器上证明可行后，就被当做 HTTP/2 的基础 HTTP/2是 HTTP 协议自 1999年 HTTP/1.1 发布后的首个更新版本，2015 年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3 HTTP/2 的优势与 HTTP/1.1 相比，HTTP/2 有着很多优势： HTTP/2 采用二进制格式而非文本格式 HTTP/2 是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行 HTTP/2 使用报头压缩，降低了开销 HTTP/2 让服务器可以将响应主动“推送”到客户端缓存中 总的来说，HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以借由新特性得到更好的速度 HTTP/2 基于 SPDY 协议，不同的地方在于： HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP/2 消息头的压缩算法采用HPACK，而 SPDY 采用 DEFLATE 二进制传输 HTTP/1.1 的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制 HTTP/2 是一个彻底的二进制，头信息和数据体都是二进制，并且统称为帧 头信息帧 数据帧 HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了 HTTP/1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量 在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码，其中 HTTP/1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 `DATA frame`` 里面 二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多 多路复用 (Multiplexing)/ 二进制分帧多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息 在 HTTP/1.1 中浏览器客户端在同一时间，针对同一域名下的请求由一定的数量限制。因而超过限制数目的请求会被阻塞，这也是一些站点有多个静态资源 CDN 域名的原因之一 多路复用的特性就避免了建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个个的帧，这些帧对应着逻辑流中的消息，并行地在同一个TCP连接上双向交换信息 帧和流的关系 帧是最小的数据单位 每个请求/响应的所有数据包，称为一个数据流，每个流都有独一无二的编号（数据流ID） 客户端发送的数据流ID为奇数，服务端发出的为偶数 每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流 多路复用的本质在一个 TCP 连接中存在多个流，也就是可以同时发送多个请求，对端可以通过帧中的标识知道该帧属于哪个请求 在客户端，这些帧乱序发送，到对端后可以通过帧首部的流标识符重新组织，这样就避免了旧版的队头阻塞问题，极大提升了传输性能 传输细节数据流发送一半时，客户端/服务器可以发送信号（RST_STEAM帧），取消这个流，而 HTTP/1.1取消数据流的唯一方式就是关闭 TCP 连接 客户端还可以指定数据流的优先级，优先级越高，服务器就会越早回应 给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。但是 TCP 层面的队首阻塞是 HTTP/2 无法解决的（HTTP 只是应用层协议，TCP 是传输层协议），TCP 的阻塞问题是因为传输阶段可能会丢包，一旦丢包就会等待重新发包，阻塞后续传输，这个问题虽然有滑动窗口（Sliding Window）这个方案，但是只能增强抗干扰，并没有彻底解决 首部压缩（Header Compression）当一个客户端向相同服务器请求许多资源时，将有大量请求看上去一样的，加之 HTTP 协议无状态，每次请求都必须附上所有信息，所以很多字段都是重复的，每次都传输，会浪费很多带宽且影响速度，故而 HTTP/2 维护了一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源 服务端推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送 比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能 Nginx 实现123456789101112131415161718192021server &#123; listen 443 ssl http2; server_name localhost; ssl on; ssl_certificate /etc/nginx/certs/example.crt; ssl_certificate_key /etc/nginx/certs/example.key; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root /usr/share/nginx/html; index index.html index.htm; http2_push /style.css; http2_push /example.png; &#125;&#125; 最后多了两行http2_push命令。它的意思是，如果用户请求根路径/，就推送style.css和example.png 缓存问题服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。 一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问: 1234567891011121314151617181920server &#123; listen 443 ssl http2 default_server; ssl_certificate ssl/certificate.pem; ssl_certificate_key ssl/key.pem; root /var/www/html; http2_push_preload on; location = /demo.html &#123; add_header Set-Cookie &quot;session=1&quot;; add_header Link $resources; &#125;&#125;map $http_cookie $resources &#123; &quot;~*session=1&quot; &quot;&quot;; default &quot;&lt;/style.css&gt;; as=style; rel=preload&quot;;&#125; 参考HTTP 的发展 HTTP/2 服务器推送（Server Push）教程","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"}]},{"title":"HTTP的演变","slug":"HTTP的演变","date":"2023-04-10T11:33:44.000Z","updated":"2023-08-12T09:51:59.535Z","comments":true,"path":"2023/04/10/HTTP的演变/","link":"","permalink":"http://example.com/2023/04/10/HTTP%E7%9A%84%E6%BC%94%E5%8F%98/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 HTTP 概述超文本传输协议（HyperText Transfer Protocol）是一种用于分布式、协作式和超媒体信息系统的应用层协议，它为 Web 浏览器与 Web 服务器之间的通信而设计，是万维网的数据通信的基础 HTTP 具备几个特征： 遵循经典的客户端—服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应 无状态，这意味着服务器不会在两个请求之间保留任何数据（状态） 演变过程万维网的发明1989 年，当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 Mesh，在随后的 1990 年项目实施期间被更名为万维网（World Wide Web）。它在现有的 TCP 和 IP 协议基础之上建立，由四个部分组成： 一个用来表示超文本文档的文本格式，超文本标记语言（HTML）。 一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。 一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 WorldWideWeb。 一个服务器用于提供可访问的文档，即 httpd 的前身。这四个部分完成于 1990 年底，且第一批服务器已经在 1991 年初在 CERN 以外的地方运行了。1991 年 8 月 16 日，Tim Berners-Lee 在公开的超文本新闻组上发表的文章被视为是万维网公共项目的开始。 HTTP 在应用的早期阶段非常简单，后来被称为 HTTP/0.9，有时也叫做单行（one-line）协议。 HTTP/0.9——单行协议最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位为0.9，以区分后来的版本 HTTP/0.9 极其简单，请求由单行指令构成，以唯一可用的GET方法开头，其后跟资源的路径 1GET /mypage.html 而响应也非常简单：只有响应文档本身： 123&lt;html&gt; 这是一个非常简单的 HTML 页面&lt;/html&gt; HTTP/0.9 的响应内容不包含 HTTP 头，这意味着只有 HTML 文件可以传送，无法传输其它类型的文件，也没有状态码和错误代码 HTTP/1.0——构建可拓展性在 1991-1995 年，这些新扩展并没有被引入到标准中以促进协助工作，而仅仅作为一种尝试。服务器和浏览器添加这些新扩展功能，但出现了大量的互操作问题。直到 1996 年 11 月，一份新文档（RFC 1945）被发表出来，文档 RFC 1945 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。新增了一下主要内容： 协议版本信息现在会随着每个请求发送（HTTP/1.0 被追加到了 GET 行） 状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，，并相应调整行为（如更新或使用本地缓存） 引入了 HTTP 头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性 具备了传输除纯文本 HTML 文件以外其他类型文档的能力 除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段 请求格式如下： 1234567891011GET /mypage.html HTTP/1.0User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:31 GMTServer: CERN/3.0 libwww/2.17Content-Type: text/html&lt;HTML&gt;一个包含图片的页面 &lt;IMG SRC=&quot;/myimage.gif&quot;&gt;&lt;/HTML&gt; 一些常见的头信息字段 Content-Type 服务器回应客户端时，需要告知其数据格式（MIME type）： text/html text/css image/png image/gif application/javascript application/octet-stream Content-Encoding 由于传输的数据可能比较大，可以将数据进行压缩： content-encoding: gzip Content-Encoding: compress Content-Encoding: deflate 而客户在请求时，可以通过Accept-Encoding字段说明自己可以接受哪些压缩方法：Accept-Encoding: gzip, deflate HTTP/1.1——标准化的协议HTTP/1.0 多种不同的实现方式在实际运用中显得有些混乱。自 1995 年开始，即 HTTP/1.0 文档发布的下一年，就开始修订 HTTP 的第一个标准化版本。在 1997 年初，HTTP1.1 标准发布 HTTP/1.1 消除了大量歧义内容并引入了多项改进： 连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间(Connection: keep-alive) 增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟 举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求 一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是 Content-length 字段的作用，声明本次回应的数据长度:Contene-Length: 3000,在 1.0 版中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了 支持响应分块(Transfer-Encoding: chunked) 引入额外的缓存控制机制 引入内容协商机制，包括语言、编码、类型等，并允许客户端和服务器之间约定以最合适的内容进行交换 凭借Host标头，能够使不同域名配置在一个 IP 地址的服务器上(虚拟主机的兴起) 一个典型的请求流程，所有请求都通过一个连接实现，看起来就像这样: 123456789101112131415161718192021222324252627282930313233343536373839404142GET /zh-CN/docs/Glossary/Simple_header HTTP/1.1Host: developer.mozilla.orgUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brReferer: https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header200 OKConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Wed, 20 Jul 2016 10:55:30 GMTEtag: &quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;Keep-Alive: timeout=5, max=1000Last-Modified: Tue, 19 Jul 2016 00:59:33 GMTServer: ApacheTransfer-Encoding: chunkedVary: Cookie, Accept-Encoding(content)GET /static/img/header-background.png HTTP/1.1Host: developer.mozilla.orgUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brReferer: https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header200 OKAge: 9578461Cache-Control: public, max-age=315360000Connection: keep-aliveContent-Length: 3077Content-Type: image/pngDate: Thu, 31 Mar 2016 13:34:46 GMTLast-Modified: Wed, 21 Oct 2015 18:27:50 GMTServer: Apache(image content of 3077 bytes) HTTP/1.1 在 1997 年 1 月以 RFC 2068 文件发布 超过15年的拓展由于 HTTP 协议的可扩展性使得创建新的头部和方法是很容易的。即使 HTTP/1.1 协议进行过两次修订，RFC 2616 发布于 1999 年 6 月，而另外两个文档 RFC 7230-RFC 7235 发布于 2014 年 6 月（在 HTTP/2 发布之前）。HTTP/1.1 协议已经稳定使用超过 15 年了 HTTP 用于安全传输通过加密来保证服务器和客户端之间交换消息的真实性 额外的加密传输层：SSL SSL 在标准化道路上最终成为了 TLS HTTP 用于复杂应用在 2000 年，一种新的使用 HTTP 的模式被设计出来：具象状态传输（representational state transfer） (或者说 REST)，RESTful API 在 2010 年变得非常流行 自 2005 年以来，可用于 Web 页面的 API 大大增加，其中几个 API 为特定目的扩展了 HTTP 协议，大部分是新的特定 HTTP 头： Server-sent events，服务器可以偶尔推送消息到浏览器 WebSocket，一个新协议，可以通过升级现有 HTTP 协议来建立 放松安全措施——基于当前的 Web 模型HTTP 和 Web 安全模型——同源策略是互不相关的。事实上，当前的 Web 安全模型是在 HTTP 被创造出来后才被发展的！这些年来，已经证实了它如果能通过在特定的约束下移除一些这个策略的限制来管的宽松些的话，将会更有用。这些策略导致大量的成本和时间被花费在通过转交到服务端来添加一些新的 HTTP 头来发送。这些被定义在了跨源资源共享（CORS）和内容安全策略（CSP）规范里。 不只是这大量的扩展，很多的其他的头也被加了进来，有些只是实验性的。比较著名的有 DNT（Do Not Track）来控制隐私，X-Frame-Options，还有很多 HTTP/2——为了更优异的表现这些年来，网页愈渐变得的复杂，甚至演变成了独有的应用，可见媒体的播放量，增进交互的脚本大小也增加了许多：更多的数据通过 HTTP 请求被传输。HTTP/1.1 链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是 5 到 8 个），带来的成本和复杂性堪忧。比如，HTTP 管线化（pipelining）就成为了 Web 开发的负担。为此，在 2010 年早期，谷歌通过实践了一个实验性的 SPDY 协议。这种在客户端和服务器端交换数据的替代方案引起了在浏览器和服务器上工作的开发人员的兴趣。明确了响应数量的增加和解决复杂的数据传输，SPDY 成为了 HTTP/2 协议的基础。 HTTP/2 在 HTTP/1.1 有几处基本的不同： HTTP/2 采用二进制格式而非文本格式 这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。 压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。 让服务器可以将响应主动“推送”到客户端缓存中 后 HTTP/2 进化随着 HTTP/2.的发布，就像先前的 HTTP/1.x 一样，HTTP 没有停止进化，HTTP 的扩展性依然被用来添加新的功能。特别的，我们能列举出 2016 年里 HTTP 的新扩展： 对 Alt-Svc 的支持允许了给定资源的位置和资源鉴定，允许了更智能的 CDN 缓冲机制。 客户端提示（client hint） 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。 在 Cookie 头中引入安全相关的的前缀，现在帮助保证一个安全的 Cookie 没被更改过。 HTTP/2 不足之处 建立连接时间长(本质上是TCP的问题) 队头阻塞问题 HTTP/3——基于 QUIC 的 HTTPHTTP 的下一个主要版本，HTTP/3 有这与 HTTP 早期版本的相同语义，但在传输层部分使用 QUIC (en-US) 而不是 TCP。到 2022 年 10 月，26% 的网站正在使用 HTTP/3。 QUIC 旨在为 HTTP 连接设计更低的延迟。类似于 HTTP/2，它是一个多路复用协议，但是 HTTP/2 通过单个 TCP 连接运行，所以在 TCP 层处理的数据包丢失检测和重传可以阻止所有流。QUIC 通过 UDP 运行多个流，并为每个流独立实现数据包丢失检测和重传，因此如果发生错误，只有该数据包中包含数据的流才会被阻止。 RFC 9114 定义的 HTTP/3 被大多数主流浏览器所支持，包括 Chromium（及其他的变体，例如 Chrome 和 Edge）和 Firefox。 参考MDN HTTP 协议入门 HTTP 的发展","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"}]},{"title":"如何取消请求发送","slug":"如何取消请求发送","date":"2023-03-30T12:55:22.000Z","updated":"2023-08-20T09:24:43.003Z","comments":true,"path":"2023/03/30/如何取消请求发送/","link":"","permalink":"http://example.com/2023/03/30/%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81/","excerpt":"","text":"速记根据使用的发送网络请求的API不同，取消方式也不同 XMLHttpRequest -&gt; XMLHttpRequest.abort() fetch -&gt; AbortController axios -&gt; 原理和fetch一致（CancelToken） XHR 使用 xhr.abort()123456const xhr = new XMLHttpRequest();xhr.open(&#x27;GET&#x27;,&#x27;https://test/api&#x27;, true);xhr.send();// 取消发送请求xhr.abort(); fetch 使用 AbortController步骤如下： 发送请求时使用一个single选项控制fetch请求 control.abort()用以取消请求发送 取消请求发送之后会得到异常AbortError 12345678910111213141516171819const controller = new AbortController();const single = controller.single;const downloadBtn = document.querySelector(&#x27;.download&#x27;);const abortBtn = document.querySelector(&#x27;.abort&#x27;);downloadBtn.addEventListener(&#x27;click&#x27;, fetchData);abortBtn.addEventListener(&#x27;click&#x27;, function() &#123; controller.abort();&#125;)function fetchData() &#123; fetch(url, &#123; signal &#125;).then(function(res) &#123; // ... &#125;).catch(function(e)&#123; console.log(&#x27;Download error: &#x27; + e.message) &#125;)&#125; Axios 使用 CancelToken1234567891011121314151617181920212223242526const CancelToken = axios.CancelToken;const source = CancelToken.source();const CancelToken = axios.CancelToken;const source = CancelToken.source();axios.get(&quot;/test/api&quot;, &#123; cancelToken: source.token, &#125;).catch(function (thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&quot;Request canceled&quot;, thrown.message); &#125; else &#123; // handle error &#125; &#125;);axios.post( &#x27;/test/api&#x27;, &#123; name: &#x27;name&#x27;, &#125;, &#123; cancelToken: source.token, &#125;);// cancel the request (the message parameter is optional)source.cancel(&quot;Operation canceled by the user.&quot;);","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"二进制数据处理（尚未完成）","slug":"二进制数据处理","date":"2023-03-22T13:45:32.000Z","updated":"2023-07-19T01:25:53.608Z","comments":true,"path":"2023/03/22/二进制数据处理/","link":"","permalink":"http://example.com/2023/03/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 ArrayBuffer，二进制数组在web开发中，经常要用到二进制数据来处理文件相关的操作，比如上传、下载各种文档和图像 在JS中基本的的二进制对象是ArrayBuffer，它本质上是一段固定长度的连续内存空间的引用","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"探究Safari对于canvas的限制","slug":"探究Safari对于canvas的限制","date":"2023-03-07T03:32:52.000Z","updated":"2023-08-20T09:23:11.813Z","comments":true,"path":"2023/03/07/探究Safari对于canvas的限制/","link":"","permalink":"http://example.com/2023/03/07/%E6%8E%A2%E7%A9%B6Safari%E5%AF%B9%E4%BA%8Ecanvas%E7%9A%84%E9%99%90%E5%88%B6/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 探究起因之前使用canvas做了一个绘制水印的功能，可以简单理解成进入A页面后，从接口获取绘制水印的配置，然后在A页面的某个区域使用canvas加盖一层水印 开发和测试都在chrome浏览器上进行，期间均表现正常，直到交付给客户几个月后接到反馈，其APP内嵌我们开发的H5页面，先后出现了以下问题： Android机型正常进入页面，偶尔水印不加载 在IOS下打开页面后无法正常加载，控制台有报错 在华为鸿蒙系统下APP直接闪退 嚯，问题还挺多，一个比一个严重- -！那接下来看看，是什么问题导致以上现象 下文使用我另外写的一个demo做演示 排查过程第一个问题相对来说比较简单，这里简单说说使用Android机型进行测试，确实是偶现不加载的情况，经过反复调试，发现在弱网情况下，没有请求接口，这里调整了请求的顺序就解决了 第二个问题一开始在chrome和Firefox下均未复现，后来发现仅在iPhone真机Safari下才能复现，报错如下： 难道ctx是null吗，结合部分代码调试后查看确实没有获取到渲染上下文 12345const canvas = document.getElementById(&quot;canvas&quot;);canvas.width = 10000;canvas.height = 10000;const ctx = canvas.getContext(&quot;2d&quot;);ctx.font = &quot;20px Microsoft YaHei&quot;; 这时想起来Safari对于canvas的使用有一些限制（或者说是优化），印象中该浏览器对于canvas的数量有一定限制，emmm，我的代码中只有一个canvas，应该和这个限制没有关系 然后我开始搜索Safari对于使用canvas有什么限制/webkit内核对于canvas的限制，好的，没找到什么蛛丝马迹。于是开始面向google编程，翻一翻有没有人遇到过相似的问题 在一篇文章中有人提到 Safari对于画布大小有限制，于是我修改宽高，均缩小10倍，也就是渲染的区域缩小了100倍，刷新页面后正常加载了！ 12canvas.width = 1000;canvas.height = 1000; 问题解决了是针不戳啊，那具体的尺寸是多少等解决完所有问题再研究下 第三个问题APP闪退，刚开始初步判断可能是客户环境webview做了某些处理，和我们H5页面没有什么关系，于是请教APP开发大佬，大佬一顿排查后得出结论：在华为鸿蒙系统下，H5页面渲染太久了，导致闪退 好家伙，那这个情况还是因为受到了画布大小影响？！ 于是让测试同学在响应系统上通过APP打开H5页面，确实是没有再发生闪退… 那至此bug全部解决 探究Safari对于canvas的限制已知：Safari采用webkit内核 解：去github上clone一份源码瞅瞅 1git clone https://github.com/WebKit/WebKit.git （下面贴的源码均在Source/WebCore/html/HTMLCanvasElement.cpp文件中，可以直接翻阅，clone下来太久啦） Safari 在实现canvas时对内存进行了限制，在不同设备上允许使用的内存不同，具体根据设备 RAM 的大小计算，一旦超出限制，使用 getContext(‘2d’) 将会返回 null C++源码如下： 12345678910111213141516171819202122CanvasRenderingContext2D* HTMLCanvasElement::createContext2d(const String&amp; type, CanvasRenderingContext2DSettings&amp;&amp; settings)&#123; ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type); ASSERT(!m_context); // Make sure we don&#x27;t use more pixel memory than the system can support. size_t requestedPixelMemory = 4 * width() * height(); if (activePixelMemory() + requestedPixelMemory &gt; maxActivePixelMemory()) &#123; auto message = makeString(&quot;Total canvas memory use exceeds the maximum limit (&quot;, maxActivePixelMemory() / 1024 / 1024, &quot; MB).&quot;); document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, message); return nullptr; &#125; m_context = CanvasRenderingContext2D::create(*this, WTFMove(settings), document().inQuirksMode());#if USE(IOSURFACE_CANVAS_BACKING_STORE) // Need to make sure a RenderLayer and compositing layer get created for the Canvas. invalidateStyleAndLayerComposition();#endif return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());&#125; 可以看到 canvas 的内存占用空间为 4 * width * height，这里的4指每个像素的RGBA 允许使用的最大内存空间由 maxActivePixelMemory 这个函数计算，这个函数计算规则如下: 1234567891011121314151617size_t HTMLCanvasElement::maxActivePixelMemory()&#123; if (maxActivePixelMemoryForTesting) return *maxActivePixelMemoryForTesting; static size_t maxPixelMemory; static std::once_flag onceFlag; std::call_once(onceFlag, [] &#123;#if PLATFORM(IOS_FAMILY) maxPixelMemory = ramSize() / 4;#else maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);#endif &#125;); return maxPixelMemory;&#125; 再查找源码对于画布大小的限制： 1234567891011121314static inline size_t maxCanvasArea()&#123; if (maxCanvasAreaForTesting) return *maxCanvasAreaForTesting; // Firefox limits width/height to 32767 pixels, but slows down dramatically before it // reaches that limit. We limit by area instead, giving us larger maximum dimensions, // in exchange for a smaller maximum canvas size. The maximum canvas size is in device pixels.#if PLATFORM(IOS_FAMILY) return 4096 * 4096;#else return 16384 * 16384;#endif&#125; 经过实际测试，在iPhone的Safari中，canvas的最大可用宽高确实是4096 具体可以看参考文章中的Safari难道是下一个IE？兼容性这么“差” 其它另外在chrome、Firefox中，过大的宽高（100000），也无法正常展示，如下所示： 没有探讨释放canvas占用的内存，大家有兴趣可以尝试一下 参考MDN stackoverflow Safari难道是下一个IE？兼容性这么“差”","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"事件总线机制","slug":"事件总线机制","date":"2023-01-12T14:19:22.000Z","updated":"2023-07-19T01:24:30.830Z","comments":true,"path":"2023/01/12/事件总线机制/","link":"","permalink":"http://example.com/2023/01/12/%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 介绍事件总线(EventBus) 是一种消息传递的方式 它可以让两个没有关联的组件进行通信，起到数据传输的作用 举个例子，当module N发布了Event 1消息，订阅该消息的module 1就会收到相关消息（过程如下所示） 场景举例现在有一所学校，学校里面有一些事件发生，学生能够根据事件类型做出相应的动作 用代码表述 1234567891011121314151617181920212223242526272829// EventBus就是事件总线，这里可以思考一下它应该具备什么功能以及如何编写let EB = new EventBus();// 学生对事件类型做出的反应EB.$on(&#x27;上课&#x27;, (name) =&gt; &#123; console.info(`学生$&#123;name&#125;到上课地点`);&#125;)EB.$on(&quot;教室上课&quot;, (name, course) =&gt; &#123; console.info(`学生$&#123;name&#125;去教室上$&#123;course&#125;课`);&#125;)let id = EB.$on(&quot;户外上课&quot;, (name, course) =&gt; &#123; console.info(`学生$&#123;name&#125;去户外上$&#123;course&#125;课`);&#125;)EB.$once(&quot;献血&quot;, (name) =&gt; &#123; console.info(`学生$&#123;name&#125;去献血`);&#125;)// 学校中事件发生EB.$emit(&#x27;上课&#x27;, &#x27;张三&#x27;); // 学生张三到上课地点EB.$emit(&#x27;上课&#x27;, &#x27;李四&#x27;); // 学生李四到上课地点EB.$emit(&#x27;教室上课&#x27;, &#x27;张三&#x27;, &#x27;编程&#x27;); // 学生张三去教室上编程课EB.$emit(&#x27;户外上课&#x27;, &#x27;张三&#x27;, &#x27;田径&#x27;); // 学生张三去户外上田径课EB.$off(&#x27;户外上课&#x27;, id);EB.$emit(&#x27;户外上课&#x27;, &#x27;李四&#x27;, &#x27;足球&#x27;);EB.$emit(&#x27;献血&#x27;, &#x27;王五&#x27;); // 学生王五去献血EB.$emit(&#x27;献血&#x27;, &#x27;马六&#x27;);// console.log(EB)EB.$clear()// console.log(EB) 从上面的代码可以大概了解到，事件总线应该具备五种方法，对应着下一部分的API设计 API设计 发布消息（emit） 能够表示消息类型，可能还携带参数 订阅消息（on） 能够知道具体的消息类型，并执行回调，回调的参数就是发布消息时携带的参数 取消订阅（off） 能够知道具体的消息类型，取消订阅该消息类型，即回调函数不再执行 仅订阅一次消息（once） 能够知道具体的消息类型，执行一次回调后，再次接收相同消息，不再执行回调 清除某个或所有事件（clear） 如果指定了某个消息类型，则清除该消息类型的回调，否则全部清除 代码实现基础实现（仅包含订阅和发布）1234567891011121314151617181920212223242526272829303132333435363738class EventBus &#123; constructor() &#123; this.eventObj = &#123;&#125;; // interface EveneObj &#123; [name: string]: Function[] &#125; &#125; $on(name, callback) &#123; if (!this.eventObj[name]) &#123; // 如果尚未注册，用数组来收集回调函数 this.eventObj[name] = []; &#125; this.eventObj[name].push(callback); &#125; $emit(name) &#123; const eventList = this.eventObj[name]; for (const callback of eventList) &#123; // 执行回调 callback(arguments); &#125; &#125;&#125;let EB = new EventBus();// 订阅事件EB.$on(&#x27;上课&#x27;, () =&gt; &#123; console.info(&quot;该上课了&quot;);&#125;)EB.$on(&quot;上课&quot;, () =&gt; &#123; console.info(&quot;做笔记&quot;);&#125;)EB.$on(&quot;下课&quot;, () =&gt; &#123; console.info(&quot;下课啦！&quot;);&#125;)// 发布事件EB.$emit(&#x27;上课&#x27;);EB.$emit(&#x27;下课&#x27;); 如何在发布消息时携带参数12345678910111213$on(name, callback) &#123; if (!this.eventObj[name]) &#123; this.eventObj[name] = []; &#125; this.eventObj[name].push(callback);&#125;$emit(name, ...args) &#123; const eventList = this.eventObj[name]; for (const callback of eventList) &#123; callback(...args); &#125;&#125; 一次订阅123456789// 添加新的数据结构this.onceObj = &#123;&#125;; // interface OnceEventObj &#123; [key: string]: Function[] &#125;$once(eventName, callback) &#123; if (!this.onceObj[eventName]) &#123; this.onceObj[eventName] = [] &#125; this.onceObj[eventName].push(callback)&#125; 取消订阅1234567891011121314// 这里引入一个id参数，标识每个回调，同时修改eventObj的结构// interface EventObj &#123; [key: string]: &#123; [id: number]: Function &#125; &#125;$off(eventName, id) &#123; if (id) &#123; // 传入了id则删除对应的回调 delete this.eventObj[eventName][id]; if (!Object.keys(this.eventObj[eventName]).length) &#123; delete this.eventObj[eventName]; &#125; &#125; else &#123; // 否则删除整个事件的所有回调 delete this.eventObj[eventName]; &#125;&#125; 清除事件123456789$clear(eventName: string = &#x27;&#x27;) &#123; // 未提供事件名称，默认清除所有事件 if (!eventName) &#123; this.eventObj = &#123;&#125;; return; &#125; // 清除指定事件 delete this.eventObj[eventName];&#125; 终版（TS版本）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102interface EventObj &#123; [key: string]: &#123; [id: number]: Function &#125;&#125;interface OnceEventObj &#123; [key: string]: Function[]&#125;class EventBus &#123; eventObj: EventObj /** 每个函数的ID */ callbcakId: number onceObj: OnceEventObj constructor() &#123; this.eventObj = &#123;&#125;; this.callbcakId = 0; this.onceObj = &#123;&#125;; &#125; $on(eventName: string, callback: Function) &#123; if (!this.eventObj[eventName]) &#123; this.eventObj[eventName] = &#123;&#125;; &#125; const id = this.callbcakId++; this.eventObj[eventName][id] = callback; return id; &#125; $emit(eventName: string, ...args: any) &#123; const eventList = this.eventObj[eventName]; for (const id in eventList) &#123; typeof eventList[id] === &#x27;function&#x27; &amp;&amp; eventList[id](...args); &#125; const onceEvent = this.onceObj[eventName]; if (onceEvent) &#123; onceEvent.forEach((callback) =&gt; callback(...args)); delete this.onceObj[eventName]; &#125; &#125; $off(eventName: string, id: number) &#123; if (id) &#123; // 传入了id则删除对应的回调 delete this.eventObj[eventName][id]; if (!Object.keys(this.eventObj[eventName]).length) &#123; delete this.eventObj[eventName]; &#125; &#125; else &#123; // 否则删除整个事件的所有回调 delete this.eventObj[eventName]; &#125; &#125; $once(eventName: string, callback: Function) &#123; if (!this.onceObj[eventName]) &#123; this.onceObj[eventName] = []; &#125; this.onceObj[eventName].push(callback); &#125; $clear(eventName: string = &#x27;&#x27;) &#123; // 未提供事件名称，默认清除所有事件 if (!eventName) &#123; this.eventObj = &#123;&#125;; return; &#125; // 清除指定事件 delete this.eventObj[eventName]; &#125;&#125;let EB = new EventBus();// 订阅事件EB.$on(&#x27;上课&#x27;, (name: string) =&gt; &#123; console.info(`学生$&#123;name&#125;到上课地点`);&#125;)EB.$on(&quot;教室上课&quot;, (name: string, course: string) =&gt; &#123; console.info(`学生$&#123;name&#125;去教室上$&#123;course&#125;课`);&#125;)let id = EB.$on(&quot;户外上课&quot;, (name: string, course: string) =&gt; &#123; console.info(`学生$&#123;name&#125;去户外上$&#123;course&#125;课`);&#125;)EB.$once(&quot;献血&quot;, (name: string) =&gt; &#123; console.info(`学生$&#123;name&#125;去献血`);&#125;)// 发布事件EB.$emit(&#x27;上课&#x27;, &#x27;张三&#x27;);EB.$emit(&#x27;上课&#x27;, &#x27;李四&#x27;);EB.$emit(&#x27;教室上课&#x27;, &#x27;张三&#x27;, &#x27;编程&#x27;);EB.$emit(&#x27;户外上课&#x27;, &#x27;张三&#x27;, &#x27;田径&#x27;);EB.$off(&#x27;户外上课&#x27;, id);EB.$emit(&#x27;户外上课&#x27;, &#x27;李四&#x27;, &#x27;足球&#x27;);EB.$emit(&#x27;献血&#x27;, &#x27;王五&#x27;);EB.$emit(&#x27;献血&#x27;, &#x27;马六&#x27;);console.log(EB)EB.$clear()console.log(EB) 为什么不被推荐使用事件总线使用起来非常简单，但是！ 随着事件的推移，注册的事件可能越来越多，如果没有及时清理相关事件，整个对象占用的内存会越来越大 当逻辑变得复杂时大量使用事件总线，会让数据流混乱，难以预测，这样在调试代码时难以定位或修改 替代方式 状态提升 有时我们需要在兄弟组件间传递数据，这种情况可以把共享状态提升到最近的共同父组件中去 使用状态管理工具 主流前端开发框架都有相应的状态管理方案，比如redux、mobx、Vuex","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"替代chrome中的Event.path","slug":"替代chrome中的Event.path","date":"2022-12-22T09:39:41.000Z","updated":"2023-07-19T01:25:51.882Z","comments":true,"path":"2022/12/22/替代chrome中的Event.path/","link":"","permalink":"http://example.com/2022/12/22/%E6%9B%BF%E4%BB%A3chrome%E4%B8%AD%E7%9A%84Event.path/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 Event.path和Event.composedPath在开发过程时，有时需要获取事件冒泡/捕获过程的所有元素，在不同的浏览器中，获取的方法可能不一样 chrome作为常用的浏览器，可以通过event.path属性来获取，示例如下： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;event.path测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;组织/部门&lt;/p&gt; &lt;ul class=&quot;department&quot;&gt; &lt;li id=&quot;dev&quot;&gt;研发组&lt;/li&gt; &lt;li id=&quot;administrative&quot;&gt;行政组&lt;/li&gt; &lt;li&gt;公关组&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; const target = document.getElementById(&quot;dev&quot;) target.onclick = function(evt) &#123; const path = evt.path; console.log(&#x27;研发组点击事件的path:&#x27;, path) &#125;&lt;/script&gt;&lt;/html&gt; Chrome(版本：108.0.5359.124)操作结果： Firefox(版本：108.0.1)操作结果： 该属性返回事件路径，但并不是一个标准属性，不过在 chrome 浏览器中存在，而Firefox不存在 当 Event.path 取不到值时就取 Event.composedPath Event.composedPath的兼容性如下： 在2021年12月份，chrome官方团队发布issue，将要移除event.path 现有项目如何处理现有项目和依赖的第三方库/包都有可能受到影响，在这种情况下可以添加polyfill作为成本较小的解决方案： 1234567if (!Event.prototype.path) &#123; Object.defineProperty(Event.prototype, &quot;path&quot;, &#123; get() &#123; return this.composedPath(); &#125;, &#125;);&#125; 其它如何支持IE？ 123456789101112131415161718(function(e, d, w) &#123; if(!e.composedPath) &#123; e.composedPath = function() &#123; if (this.path) &#123; return this.path; &#125; var target = this.target; this.path = []; while (target.parentNode !== null) &#123; this.path.push(target); target = target.parentNode; &#125; this.path.push(d, w); return this.path; &#125; &#125;&#125;)(Event.prototype, document, window);","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Chrome","slug":"Chrome","permalink":"http://example.com/tags/Chrome/"}]},{"title":"浏览器渲染流程","slug":"浏览器渲染流程","date":"2022-11-19T13:43:54.000Z","updated":"2023-08-20T09:23:44.225Z","comments":true,"path":"2022/11/19/浏览器渲染流程/","link":"","permalink":"http://example.com/2022/11/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/","excerpt":"","text":"在为什么打开一个页面，会有4个进程？文章中提及了浏览器的几个主要进程，这回来说明一下渲染流程 渲染进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，由于渲染机制过于复杂，所以渲染模块在执行的过程中会被划分成很多子阶段，通过输入 HTML 经过这些子阶段最后输出像素，我们把这样一个处理流程叫做渲染流水线 按照渲染时间的顺序，流水线可以分为以下几个子阶段: 构建 DOM 树 样式计算 布局 分层 绘制 分块 光栅化 合成 构建 DOM 树在渲染引擎内部，有个叫 HTML解析器（HTMLParser）的模块，负责将 HTML 字节流转换成 DOM 结构 通过分词器将字节流转换为Token；Token分为Tag Token和文本Token。Tag Token又可分为StartTag和EndTag，对应着标签的开和闭，eg：、 将Token解析为DOM节点（图中的Node），并将DOM节点添加到DOM树中。HTML解析器维护了一个Token栈结构，用来计算节点之间的父子关系。类似于用栈来匹配带括括号的表达式”3*(7+(4÷2))”，不再详细展开 样式计算样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这一阶段大致可分三步来完成： 把CSS转换为浏览器能够理解的结构 渲染引擎无法直接理解CSS文件的内容，所以需要将其解析成渲染引擎能够理解的结构，即styleSheets。在浏览器的控制台输入document.styleSheets就可以查看其结构 CSSOM（CSS Object Model）是一组允许用JavaScript操纵CSS的API。CSSOM有两个作用 提供给JavaScript操作样式表的能力 为布局树的合成提供基础的样式信息 转换样式表中的属性值，使其标准化 有一些CSS属性，像font-size: 2em、coler: blue、font-weight: bold，不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化 计算出DOM树中每个节点的具体样式 CSS的继承规则和层叠规则 布局有了 DOM 树和 DOM 树中元素的样式，但还不能显示页面，因为还缺少了 DOM 元素的几何位置信息，计算出 DOM 树中可见元素的几何位置，这个过程叫布局 布局阶段需要完成的两个任务： 创建布局树 布局树的基本结构就是复制 DOM 树的结构，循环遍历 DOM 树中所有可见节点，并把这些节点加到布局树中，而不可见的节点会被忽略掉（不可见的元素例如标签下的全部内容，被设为display: none的元素） 布局计算 分层页面中有很多复杂的效果，如3D变换、页面滚动、或者使用z-index做z轴排序等，为了更方便的实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的图层树 通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层 当满足以下条件时，元素就可以被提升为一个单独的图层： 拥有层叠上下文属性的元素会被提升为单独的一层 从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性 需要剪裁的地方也会被创建为图层 绘制构建完图层树之后，渲染引擎会对图层树中的每个图层进行绘制，把图层的绘制拆分成一个个小的绘制指令，如先画个矩形、再画个边框、画个背景，这些绘制指令组成一个绘制列表 光栅化光栅化就是按照绘制列表中的指令生成图片，每一个图层都对应一张图片 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的，当图层的绘制列表准备好之后，主线程会把绘制列表提交给合成线程 结合下图来看下渲染主线程和合成线程之间的关系： 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？ 一个页面通常很大，但用户只能看到其中的一部分，这部分叫做视口，看不到的部分是没有必要绘制出来的，因此，合成线程会把图层分为图块 合成线程会按照视口附近的图块优先生成位图，实际生成位图的操作由栅格化来执行，所谓栅格化，是指将图块转换为位图，而图块是栅格化执行的最小单位 渲染进程维护了一个栅格化的线程池，所有图块栅格化都是在线程池内执行 通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫做快速栅格化，或者GPU栅格化，生成的位图会被保存在GPU中， 合成与显示在光栅化完成之后，每个图层都会对应一张图片，合成线程会将这些图片合成”一张“图片 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上 合成操作是在合成线程上完成，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这也是为什么经常主线程卡住了，但是CSS动画依然能执行的原因 Q:显示器是怎么显示图像的？ A:显示器有固定的刷新频率，通常是60HZ，也就是每秒更新60张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器会固定读取60次前缓冲区的图像，并将读取到的图像更新到屏幕上 Q:显卡做什么呢？ A:显卡的职责就是合成新图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样 参考浏览器工作原理与实践","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"canvas渲染上下文设置填充样式，在安卓机型上不生效","slug":"canvas渲染上下文设置填充样式，在安卓机型上不生效","date":"2022-11-03T08:50:03.000Z","updated":"2022-11-03T08:58:04.691Z","comments":true,"path":"2022/11/03/canvas渲染上下文设置填充样式，在安卓机型上不生效/","link":"","permalink":"http://example.com/2022/11/03/canvas%E6%B8%B2%E6%9F%93%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E6%A0%B7%E5%BC%8F%EF%BC%8C%E5%9C%A8%E5%AE%89%E5%8D%93%E6%9C%BA%E5%9E%8B%E4%B8%8A%E4%B8%8D%E7%94%9F%E6%95%88/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 探究起因在阅读一些框架源码（比方说Vue)时发现，开发者们使用Object.create(null)来初始化一个新对象，而我们一般在非面向工具链/基建开发时，惯常使用字面量，那么它们有什么区别呢？ 省流：当设置透明度时，尽量使用ctx.fillStyle = &#39;rgb(174, 238, 238, 0.5)&#39;;的形式，而非ctx.fillStyle = &#39;#AEEEEE80&#39;;后者在安卓真机（华为自带浏览器下必现）下无效 今天客户反馈在安卓机型下打开我们的签署页面，水印的颜色和透明度不管如何设置，都不生效，而IOS的表现正常 关键代码如下： 123456789101112131415161718192021222324252627const canvas = document.createElement(&#x27;canvas&#x27;);ctx.fillStyle = colorRgb(color, transparency); /** * 获取颜色的16进制 （颜色+透明度） * * @param color 颜色 * @param transparency 透明度 * @returns */const convertColor = (color: string, transparency: number) =&gt; &#123; const getPureColor = (color: string) =&gt; &#123; const plainColor = color?.substring(1); // 去掉# const isColorShort = plainColor?.length === 3; return isColorShort ? plainColor.split(&#x27;&#x27;).map(v =&gt; `$&#123;v&#125;$&#123;v&#125;`).join(&#x27;&#x27;) : plainColor; &#125;; const getAlpha = (transparency: number) =&gt; &#123; const alpha = parseInt(String(256 * transparency), 10).toString(16); return alpha.length &gt; 1 ? alpha : `0$&#123;alpha&#125;`; &#125;; return `#$&#123;getPureColor(color)&#125;$&#123;getAlpha(transparency)&#125;`;&#125;; 以 颜色：#AEEEEE，透明度：0.5 为例，转化后得到结果#AEEEEE80，将结果赋值给ctx.fillStyle，在PC端使用chrome浏览器调试表现正常，但是在安卓真机上无效 左图为透明度为1，右图透明度为0.2，在华为自带浏览器下测试结果对比图如下： 完整demo如下，可以用node起一个服务，在手机上打开： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;canvas颜色和透明度不生效&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/vconsole@latest/dist/vconsole.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; new window.VConsole(); const canvas = document.getElementById(&quot;canvas&quot;); canvas.width = 1000; canvas.height = 1000; const ctx = canvas.getContext(&quot;2d&quot;); ctx.font = &quot;20px Microsoft YaHei&quot;; // ctx.fillStyle = convertColor(&#x27;#AEEEEE&#x27;, 0.2); ctx.fillStyle = convertColor(&#x27;#AEEEEE&#x27;, 1); // 绘制文字水印 for (let i = 0; i &lt; 100; i++) &#123; for (let j = 0; j &lt; 100; j++) &#123; ctx.fillText(&quot;Hello world&quot;, 150 * (i), 50 * (j + 1)); &#125; &#125; &#125; /** * 获取颜色的16进制 （颜色+透明度） * * @param color 颜色 * @param transparency 透明度 * @returns */ const convertColor = (color, transparency) =&gt; &#123; const getPureColor = (color) =&gt; &#123; const plainColor = color?.substring(1); // 去掉# const isColorShort = plainColor?.length === 3; return isColorShort ? plainColor.split(&#x27;&#x27;).map(v =&gt; `$&#123;v&#125;$&#123;v&#125;`).join(&#x27;&#x27;) : plainColor; &#125;; const getAlpha = (transparency) =&gt; &#123; const alpha = parseInt(String(256 * transparency), 10).toString(16); return alpha.length &gt; 1 ? alpha : `0$&#123;alpha&#125;`; &#125;; return `#$&#123;getPureColor(color)&#125;$&#123;getAlpha(transparency)&#125;`; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JS继承的几种方式","slug":"JS继承的几种方式","date":"2022-10-25T13:32:01.000Z","updated":"2023-08-20T09:23:16.946Z","comments":true,"path":"2022/10/25/JS继承的几种方式/","link":"","permalink":"http://example.com/2022/10/25/JS%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"许多OO语言都支持两种继承方式： 接口继承 实现继承 而 ECMA 只支持实现继承，主要依靠原型链来实现 原型链继承核心思想：重写原型对象，代之以一个新类型的实例 123456789101112131415161718function Parent() &#123; this.name = &#x27;Parent&#x27;;&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child() &#123;&#125;// 继承Child.prototype = new Parent();const child1 = new Child();child1.getName(); // Parentconst child2 = new Child();child2.getName(); // Parent 优点： 父类新增原型方法/属性，子类都能访问到 简单，易于实现 缺点： 引用类型的属性被所有实例共享 创建子类实例时，不能像父类构造函数传参 借用构造函数继承（经典继承）12345678910111213141516function Parent(name) &#123; this.name = name; this.color = [&#x27;red&#x27;];&#125;function Child(name) &#123; Parent.call(this, name);&#125;const child1 = new Child(&#x27;Child1&#x27;);child1.color.push(&#x27;green&#x27;);console.log(child1); // Child &#123; name: &#x27;Child1&#x27;, color: [ &#x27;red&#x27;, &#x27;green&#x27; ] &#125;const child2 = new Child(&#x27;Child2&#x27;);child2.color.push(&#x27;blue&#x27;);console.log(child2); // Child &#123; name: &#x27;Child2&#x27;, color: [ &#x27;red&#x27;, &#x27;blue&#x27; ] &#125; 优点： 避免了引用类型的属性被所有子类实例所共享 可以在子类中向父类构造函数传参 缺点： 无法实现函数复用 在父类原型中定义的方法，对于子类不可见 组合继承这种方式的核心思想在于:通过结合原型链继承和经典继承两种方式，融合了二者的优点 1234567891011121314151617181920212223242526function Parent(name) &#123; this.name = name; this.color = [&#x27;red&#x27;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child(name, age) &#123; // 继承属性 Parent.call(this, name); this.age = age;&#125;// 继承方法Child.prototype = new Parent();Child.prototype.constructor = Child;const child1 = new Child(&#x27;Child1&#x27;, 18);child1.color.push(&#x27;green&#x27;);console.log(child1); // Child &#123; name: &#x27;Child1&#x27;, color: [ &#x27;red&#x27;, &#x27;green&#x27; ], age: 18 &#125;const child2 = new Child(&#x27;Child2&#x27;, 17);child2.color.push(&#x27;blue&#x27;);console.log(child2); // Child &#123; name: &#x27;Child2&#x27;, color: [ &#x27;red&#x27;, &#x27;blue&#x27; ], age: 17 &#125; 缺点： 调用了两次父类构造函数 原型式继承核心思想：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象 12345678910111213141516171819202122// 这是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型function createObj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;const person = &#123; name: &#x27;person&#x27;, friends: [&#x27;daisy&#x27;, &#x27;kelly&#x27;]&#125;const person1 = createObj(person);const person2 = createObj(person);person1.name = &#x27;person1&#x27;;console.log(person1); // &#123; name: &#x27;person1&#x27; &#125;person2.friends.push(&#x27;taylor&#x27;);console.log(person2); // &#123;&#125;console.log(person); // &#123; name: &#x27;person&#x27;, friends: [ &#x27;daisy&#x27;, &#x27;kelly&#x27;, &#x27;taylor&#x27; ] &#125; 缺点: 包含引用类型的属性值始终会共享相应的值 寄生式继承核心思想：创建一个仅用于封装继承过程的函数，并在该函数中以某种形式来增强对象，最后返回该对象（和原型式继承紧密相关） 123456789101112function createObj(o) &#123; let clone = Object.create(o); clone.sayHi = function() &#123; console.log(&#x27;Hi&#x27;); &#125; return clone;&#125;const person = &#123; name: &#x27;person&#x27;, friends: [&#x27;daisy&#x27;, &#x27;kelly&#x27;]&#125; 缺点： 不能复用函数而降低效率 无法传递参数 寄生组合式继承核心思想：结合借用构造函数产地参数和寄生模式实现 123456789101112131415161718192021222324252627282930313233343536373839function createObj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;function inheritPrototype(child, parent) &#123; const prototype = createObj(parent.prototype); // 创建对象 prototype.constructor = parent; // 增强对象 child.prototype = prototype; // 指定对象&#125;function Parent(name) &#123; this.name = name; this.color = [&#x27;red&#x27;];&#125;Parent.prototype.getName = function () &#123; console.log(this.name);&#125;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;inheritPrototype(Child, Parent);Parent.prototype.getAge = function () &#123; console.log(this.age);&#125;const child1 = new Child(&#x27;Child1&#x27;, 18);child1.color.push(&#x27;green&#x27;);console.log(child1); // Parent &#123; name: &#x27;Child1&#x27;, color: [ &#x27;red&#x27;, &#x27;green&#x27; ], age: 18 &#125;const child2 = new Child(&#x27;Child2&#x27;, 17);child2.color.push(&#x27;blue&#x27;);console.log(child2); // Parent &#123; name: &#x27;Child2&#x27;, color: [ &#x27;red&#x27;, &#x27;blue&#x27; ], age: 17 &#125; 优点： 高效率：只调用了一次父类构造函数 参考《JavaScript高级程序教程（第3版）》","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"深入探究Object.create（尚未完成）","slug":"深入探究Object.create","date":"2022-10-17T13:12:03.000Z","updated":"2022-10-25T06:32:23.764Z","comments":true,"path":"2022/10/17/深入探究Object.create/","link":"","permalink":"http://example.com/2022/10/17/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Object.create/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 探究起因在阅读一些框架源码（比方说Vue)时发现，开发者们使用Object.create(null)来初始化一个新对象，而我们一般在非面向工具链/基建开发时，惯常使用字面量，那么它们有什么区别呢？ 参考MDN stackoverflow","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"DNS基础知识","slug":"DNS基础知识","date":"2022-09-18T13:23:15.000Z","updated":"2023-08-12T09:41:44.714Z","comments":true,"path":"2022/09/18/DNS基础知识/","link":"","permalink":"http://example.com/2022/09/18/DNS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 DNSDNS 全称 Domain Name System，即域名系统 DNS 是网络请求要走的第一步，我们日常访问的网站使用的 HTTP/HTTPS`` 协议的下层是TCP/IP` ，而通过其中的 IP 协议，才能知道将数据包发送到何处 由于 IP 长且难记，通过 IP 访问网站不方便，后来通过发明了 DNS 服务器，这个时候我们访问网站输入网站域名，DNS服务器就解析我们的域名为 IP， 这样我们实际访问的就是对应的 IP 地址 它实质上是一个​​域名​​和 ​​IP​​相互映射的分布式数据库，有了它我们就可以通过域名更方便的访问互联网 域名的树状结构想要知道如何解析域名，还得从域名的树状结构说起 最顶层的域名是根域名（root），然后是顶级域名（top-level domain，简写 TLD），再是一级域名、二级域名、三级域名 根域名 所有域名的起点都是根域名，它写作一个点.，放在域名的结尾，可以省略不写（任何一个域名结尾加一个点，浏览器都可以正常解读） 根域名服务器全世界一共有13台（都是服务器集群） 顶级域名 根域名的下一级是顶级域名。它分成两种：通用顶级域名（gTLD，比如 .com 和 .net）和国别顶级域名（ccTLD，比如 .cn 和 .us） 一级域名 一级域名就是你在某个顶级域名下面，自己注册的域名 比如，a.b.com就是我在顶级域名，.b就是一级域名 二级域名 二级域名是一级域名的子域名，是域名拥有者自行设置的，不用得到许可 查询DNS解析分为递归查询与迭代查询： 主机向本地域名服务器的查询一般都是采用递归查询 如果主机向本地域名服务器查询的是未知的 IP 地址，那么本地域名服务器就以 DNS 客户的身份向其它根域名服务器继续发出查询请求报文，也就是替主机继续查询，而不是让主机自己进行下一步查询 本地域名服务器向根域名服务器的查询的迭代查询 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所查询的 IP 地址，要么告诉本地域名服务器下一步应该向哪个域名服务器查询（以便本地域名服务器进行后续查询） DNS缓存机制用户输入 URL 以后，浏览器首先要查询域名对应服务器的 IP 地址，这个操作一般需要耗费 20-120 毫秒时间，而DNS 查询完成之前，浏览器无法从服务器下载任何数据，因此基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制： IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置 Firefox 缓存 1 分钟，通过 network.dnsCacheExpiration 配置 Chrome 缓存 1 分钟，通过 chrome://net-internals/#dns 配置 DNS存在的问题 查询路径过长导致业务访问延时 缓存时间不统一 DNS 劫持（被黑客劫持信息，插入广告） 根服务器停止服务的风险 优化手段X-DNS-Prefetch-Control头控制着浏览器的 DNS 预解析功能: 1&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验 参考DNS 查询原理详解X-DNS-Prefetch-Control","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"}]},{"title":"CDN基础知识","slug":"CDN基础知识","date":"2022-09-11T13:13:14.000Z","updated":"2023-08-12T09:43:28.264Z","comments":true,"path":"2022/09/11/CDN基础知识/","link":"","permalink":"http://example.com/2022/09/11/CDN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 基本概念CDN 全称 Content Delivery Network，即内容分发网络，它的主要作用：为了加速网站的访问 它是一组分布在各个地区的服务器，这些服务器存储着数据副本，因此服务器可以根据服务器与用户的距离来判断使用使用哪些服务器最优，使用户就近获取所需内容 为什么有 CDN当下的互联网应用都包含大量的静态内容，但静态内容以及一些准动态内容又是最耗费带宽的，特别是针对全国甚至全世界的大型网站，如果这些请求都指向主站的服务器的话，不仅是主站服务器受不了，单端口500M左右的带宽也扛不住，所以大多数网站都需要CDN服务。 根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响（尤其是电商网站），任何的企业都渴望自己站点有更快的访问速度。而 HTTP 传输时延对 web 的访问速度的影响很大，在绝大多数情况下是起决定性作用的： 物理层上的原因是光速有限、信道有限 TCP/IP 协议的一些特点：协议上的原因有丢包、慢启动、拥塞控制等 前端开发中的应用在前端开发中，CDN允许快速传输加载互联网内容所需的资产，包括HTML页面、JavaScript文件、样式表、图像和视频，有以下几点好处： 通过 CDN 向用户分发传输相关库的静态资源文件，可以降低我们自身服务器的请求压力 大多数 CDN 在全球都有服务器，所以 CDNs 上的服务器在地理位置上可能比你自己的服务器更接近你的用户（地理距离会按比例影响延迟） CDNs 已经配置了恰当的缓存设置（使用 CDN 节省了在你的服务器中对静态资源文件的配置） CDN 的其它作用 跨运营商、跨地域的全网覆盖 互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速 保障网站安全 CDN 的负载均衡和分布式存储技术，可以增强网站的可靠性，相当于无形中给主站加了一道屏障，应对绝大部分的互联网攻击 异地备援 当某个服务器发生意外故障时，系统会调用其它临近的正常的服务器节点进行服务 节约成本 投入使用 CDN 加速可以实现网站的全国铺设，不用考虑购买服务器和后续托管运维，服务器之间的镜像同步，节省了人力、精力和财力 可以更专注业务本身 CDN 加速厂商一般都会提供一站式服务，业务不仅局限于 CDN，还有配套的云存储、大数据服务等，全天运维监控支持，保证网络随时畅通，能够放心使用 工作原理从上面的描述中不难看出 CDN 的工作原理：将主站的资源缓存在 CDN 的各节点，当请求命中某个节点的资源缓存时，就能立即返回客户端，这样不仅可以减轻主站服务器的压力，也能一定程度上避免网络拥塞，提高了用户访问资源的速度和体验 当用户访问某个URL，经过本地DNS系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。 CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。 CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址： 根据用户 IP 地址，判断哪一台服务器距用户最近； 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容； 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。 全局负载均衡设备把服务器的 IP 地址返回给用户。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。 参考MDN CDN原理简单介绍 CDN的加速原理是什么？","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://example.com/tags/CDN/"}]},{"title":"TypeScript中extends用法小结","slug":"TypeScript中extends用法小结","date":"2022-08-22T14:12:31.000Z","updated":"2022-08-31T09:17:36.455Z","comments":true,"path":"2022/08/22/TypeScript中extends用法小结/","link":"","permalink":"http://example.com/2022/08/22/TypeScript%E4%B8%ADextends%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 extends关键字在TS中有多种用法，单独使用时，常见有以下几种情况 继承/拓展 约束 条件判断 继承/扩展单个/多个接口这种用法和类的继承相似，看个🌰 12345678910111213interface Animal &#123; name: string;&#125;// Dog继承Animal并扩展一个run方法interface Dog extends Animal &#123; run: () =&gt; void;&#125;const dog: Dog = &#123; name: &#x27;狗子&#x27;, run: () =&gt; &#123;&#125;&#125; 也支持多重继承 123interface Blackdog extends Animal, Dog &#123; color: string;&#125; 扩展类的接口除了上面的常见用法，接口还可以继承类的私有成员和受保护成员，而不仅仅是公共成员 123456789101112131415161718192021class Animal &#123; private state: boolean;&#125;interface Runnable extends Animal &#123; run(): void&#125;class Dog extends Animal implements Runnable &#123; run() &#123; &#125;&#125;class Cat extends Animal implements Runnable &#123; run() &#123; &#125;&#125;class Bird extends Animal &#123; &#125;// Error: 缺少属性 stateclass Monkey implements Runnable &#123; run() &#123; &#125;&#125; 小结 一个接口可以继承/扩展一个或多个现有接口 一个接口也可以继承/扩展一个类。如果该类包含私有或受保护成员，则该接口只能由该类或其子类实现 约束此处说的约束，一般指泛型约束，即对泛型的类型进行约束控制 在编写方法的时候，可能会需要对参数的类型做一些限制，比方说入参有一个length属性 1234567891011// 没有约束function getLength&lt;T&gt;(arg: T): T &#123; // Error: 类型“T”上不存在属性“length” return arg.length;&#125;// 进行约束function getLength&lt;T extends &#123;length: number&#125;&gt;(arg: T): number &#123; return arg.length;&#125; 条件判断和三目表达式类似，看看官网的示例和说明 1SomeType extends OtherType ? TrueType : FalseType; When the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch). 如果extends前面的类型能够赋值给extends后面的类型，那么表达式判断为真，否则为假 常规使用12345678910111213interface A1 &#123; name: string&#125;interface A2 &#123; name: string age: number&#125;// A的类型为stringtype A = A2 extends A1 ? string : numberconst str: A = &#x27;this is string&#x27; A1，A2两个接口，满足A2的接口一定可以满足A1，所以条件为真，A的类型取string 结合泛型使用12345type A1 = &#x27;x&#x27; extends &#x27;x&#x27; ? string : number; // stringtype A2 = &#x27;x&#x27; | &#x27;y&#x27; extends &#x27;x&#x27; ? string : number; // numbertype P&lt;T&gt; = T extends &#x27;x&#x27; ? string : number;type A3 = P&lt;&#x27;x&#x27; | &#x27;y&#x27;&gt; // ? A1、A2的结果也就是常规的用法，很容易得出结果，但是A3结合了泛型，这里有一个Distributive Conditional Types的概念 When conditional types act on a generic type, they become distributive when given a union type 如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。 以上面的A3为例，进行推导 P中T是一个泛型参数。在A3的定义中，给T传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入P 12345P&lt;&#x27;x&#x27; | &#x27;y&#x27;&gt; =&gt; P&lt;&#x27;x&#x27;&gt; | P&lt;&#x27;y&#x27;&gt;// &#x27;x&#x27;代入得到&#x27;x&#x27; extends &#x27;x&#x27; ? string : number =&gt; string// &#x27;y&#x27;代入得到&#x27;y&#x27; extends &#x27;x&#x27; ? string : number =&gt; number 然后将每一项代入得到的结果联合起来，得到string | number 满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型 特殊的never12345// never是所有类型的子类型type A1 = never extends &#x27;x&#x27; ? string : number; // stringtype P&lt;T&gt; = T extends &#x27;x&#x27; ? string : number;type A2 = P&lt;never&gt; // never never被认为是空的联合类型，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以P&lt;T&gt;的表达式其实根本就没有执行，所以A2的定义也就类似于永远没有返回的函数一样，是never类型的 防止条件判断中的分配123type P&lt;T&gt; = [T] extends [&#x27;x&#x27;] ? string : number;type A1 = P&lt;&#x27;x&#x27; | &#x27;y&#x27;&gt; // numbertype A2 = P&lt;never&gt; // string 在条件判断类型的定义中，将泛型参数使用[]括起来，即可阻断条件判断类型的分配，此时，传入参数T的类型将被当做一个整体，不再分配 参考 How to Extend Interfaces in TypeScript TypeScript Generic Constraints TS关键字extends用法总结 Conditional Types","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"TypeScript中的any、unknown、never如何理解","slug":"TypeScript中的any、unknown、never如何理解","date":"2022-08-15T13:06:41.000Z","updated":"2022-08-31T02:51:25.326Z","comments":true,"path":"2022/08/15/TypeScript中的any、unknown、never如何理解/","link":"","permalink":"http://example.com/2022/08/15/TypeScript%E4%B8%AD%E7%9A%84any%E3%80%81unknown%E3%80%81never%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 any在TS中使用any类型，可以用来表示允许赋值给变量任意类型，这种方式与直接使用JS没有太大差别，无法享受到TS的类型检查，在可能出错的地方也不会发现错误。 any类型本质上是类型系统的一个逃逸舱，那我们在什么情况下会使用该类型呢？ 无法确定当前类型时 逐步向TS迁移时 而在编写代码的过程中，明确知道类型的时候，有时为了偷懒，使用了any，这是一种不好的行为。 而以下种种原因，可能都会对我们是否使用any有影响： 添加类型时，需要编写大量代码，而any工作量很少 已经通过必要的运行时检查以防御性的方式编写了代码，以确保没有错误 有些参数很难正确输入，但是any更容易 不知道参数是什么 类型增加了很多复杂性，有时any更简单 使用any还会造成类型污染的问题：即any类型的对象会导致后续的属性类型都会变成any。 12345let obj: any = &#123; name: &#x27;Cola&#x27;&#125;obj.name = 1; unknown在TS的3.0版本中，引入了unknown类型，它可以这样理解成：**unknown类型是any的类型安全版本。** 这意味着如果要在TS中使用unknown类型时，需要知道它所指的类型，也就自然地推导出使用该类型的变量前，需要对该变量的类型进行断言。 123456789101112function func(value: unknown) &#123; // @ts-ignore: Object is of type &#x27;unknown&#x27;. value.toFixed(1); // Type assertion: (value as number).toFixed(1); // OK // 缩小为更具体的类型范围，包括 typeof 运算符，instanceof 运算符和自定义类型保护函数 if (typeof value === &#x27;number&#x27;) &#123; value.toFixed(1); &#125;&#125; unknown类型只能被赋值给any类型和unknown类型本身。 因为只有能够保存任意类型值的容器才能保存unknown 类型的值，所以这个限制很合理。毕竟我们不知道变量中存储了什么类型的值。 nevernever类型表示的是那些永不存在的值的类型，never类型是任何类型的子类型，也可以赋值给任何类型。 然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）,never用于那些永不可发生的情况: 一个从来不会有返回值的函数（如：如果函数内含有 while(true) &#123;&#125;）； 一个总是会抛出错误的函数（如：function foo() &#123; throw new Error(&#39;Not Implemented&#39;) &#125;，foo 的返回类型是 never）； 与 void 的差异void表示没有任何类型，never表示永远不存在的值的类型 异同 any和unknown是TS中所谓的顶级类型：当把类型看作是值的集合时，any 和 unknown 是包含所有值的集合 never类型是TS中的底层类型：空集 以下或许是最佳实践 如果不是有意忽略类型检查，不使用any 如果要用any，可以考虑用unknown代替（进行断言后使用） 参考 understanding-any-and-unknown-in-typescript-difference-between-never-and-void The unknown Type in TypeScript 使用 TypeScript 中的 Any 类型前，你需要了解的一切","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"TypeScript中的一些小技巧","slug":"TypeScript中的一些小技巧","date":"2022-07-18T12:18:34.000Z","updated":"2023-07-19T01:28:11.643Z","comments":true,"path":"2022/07/18/TypeScript中的一些小技巧/","link":"","permalink":"http://example.com/2022/07/18/TypeScript%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 为什么通常来说类型声明的使用优先于类型断言 ：类型声明更够更有效地帮助我们进行类型检查 假设有如下定义： 123interface Person &#123; name: string;&#125; 当需要声明一个该类型变量时，可以有两种做法 1234567const student_1: Person = &#123; name: &#x27;John&#x27;,&#125;const student_2 = &#123; name: &#x27;Tom&#x27;&#125; as Person 在常规情况下声明变量类型，优先使用第一种方式，这样能够帮助我们进行类型检查，这种错误提示显然是非常有用的，而使用断言时，有可能出现某个属性并不在断言的类型中的情况，这种情况下并没有报错 123456789const student_3: Person = &#123; name: &#x27;John&#x27;, age: 10 // 报错：“age”不在类型“Person”中&#125;const student_4 = &#123; name: &#x27;John&#x27;, age: 10 // ok&#125; as Person 类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除，虽然最终转化出来的js能够运行正常，但这也会让同事感到迷惑 什么时候使用类型断言？ ：只有你比TypeScript知道得更多的时候 举个🌰： 1&lt;button class=&quot;submit-btn&quot;&gt;登录&lt;/button&gt; 1const el = document.querySelector(&#x27;.sign-confirm-button&#x27;)! as HTMLButtonElement; 由于TypeScript并不能访问到DOM，而作为开发者的我们，明确知道此处是一个按钮，这里就可以合理地断言成HTMLButtonElement，而非自动推断的Element | null 为什么尽量不使用包装类型 string 和 String number 和 Number boolean 和 Boolean symbol 和 Symbol bigint 和 BigInt 用string举例，当我们在在字符串字面量上访问诸如 charAt 之类的方法时，JavaScript 将其包装在一个 String 对象中，调用该方法，然后丢弃该对象: 12345678const originalCharAt = String.prototype.charAt;String.prototype.charAt = function(pos) &#123; console.log(this, typeof this, pos); return originalCharAt.call(this, pos);&#125;;console.log(&#x27;primitive&#x27;.charAt(3));//String &#123;&#x27;primitive&#x27;&#125; &#x27;object&#x27; 3// m 字符串和字符串对象不相等： 123&quot;John&quot; === &quot;John&quot;; // true&quot;John&quot; === new String(&quot;John&quot;); // falsenew String(&quot;John&quot;) === new String(&quot;John&quot;); // false 在 TypeScript 中，可以将字符串基本类型 string 赋值给包装类型 String，但无法反过来将 String 赋值给 string 12345678function getNameLength(studentName: String) &#123; return studentName.length; // ok&#125;getNameLength(&#x27;John&#x27;)function isStudent(studentName: String) &#123; return [&#x27;Jack&#x27;, &#x27;John&#x27;].includes(studentName); // 报错：类型“String”的参数不能赋给类型“string”的参数&#125; 运行时的值仍然是原始值，而不是对象，但是 TypeScript 允许这些声明，因为原始类型可以分配给对象包装器，这样看起来有些迷惑，所以最好统一使用原始类型","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"}]},{"title":"TCP 协议详解","slug":"TCP协议详解","date":"2022-06-21T12:17:32.000Z","updated":"2023-08-12T09:57:09.514Z","comments":true,"path":"2022/06/21/TCP协议详解/","link":"","permalink":"http://example.com/2022/06/21/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 除了三次握手，四次挥手，TCP 还有很多细节需要掌握，知其然知其所以然 TCP 为什么可靠？————连接确认！关闭确认！收到数据确认！各种确认！！ 因为网络或其他原因，对方收不到数据怎么办？–超时重试 网络情况千变万化，超时时间怎么确定？–根据RTT动态计算 反反复复，不厌其烦的重试，导致网络拥塞怎么办？—慢启动，拥塞避免，快速重传，快速恢复 发送速度和接收速度不匹配怎么办？–滑动窗口 滑动窗口滑的过程中，他一直告诉我处理不过来了，不让传数据了怎么办？–ZWP 滑动窗口滑的过程中，他处理得慢，就理所当然的每次让我发很少的数据，导致网络利用率很低怎么办？—Nagle 基本概念TCP 连接的特点 面向连接 可靠传输 提供字节流服务 TCP 如何保证可靠性 分块传输：数据被分割成最合适的数据块（UDP的数据长度不变） 等待确认：通过定时器等待接收端发送确认请求，收不到确认则重发 确认回复：收到确认后发送确认回复 数据校验：保持首部和数据的校验和，检测数据传输过程有无变化 乱序重排：接收端能重排序数据，以正确的顺序交给应用端 重复丢弃：接收端能丢弃重复的数据包 流量缓冲：两端有固定大小的缓冲区（滑动窗口），防止速度不匹配造成数据丢失 首部格式TCP 数据被封装在 IP 数据报中 TCP 首部数据通常包含20个字节（不包括任选字段） 第1-2两个字节：源端口号 第3-4两个字节：目的端口号 源端口号+ip首部中的源ip地址+目的端口号+ip首部中的目的ip地址，唯一的确定了一个 TCP 连接，对应编码级别的socket 第5-8四个字节：32位序号。TCP 提供全双工服务，两端都有各自的序号，编号：解决网络包乱序的问题 序号如何生成：TCP 基于时钟生成一个序号，每4微秒加一，到2^32-1时又从0开始(不能是固定写死的，否则断网重连时序号重复使用会乱套) 第9-12四个字节：32位确认序列号。上次成功收到数据字节序号加1，ack为1才有效，确认号：解决丢包的问题 第13位字节：首部长度。因为任选字段长度可变 后面6bite：保留 随后6bite：标识位。控制各种状态 URG：为1时，表示紧急指针有效 ACK：确认标识，连接建立成功后，总为1。为1时确认号有效 PSH：接收方应尽快把这个报文交给应用层 RST：复位标识，重建连接 SYN：建立新连接时，该位为0 FIN：关闭连接标识 第15-16两个字节：窗口大小。接收端期望接收的字节数。解决流量控制的问题 第17-18两个字节：校验和。由发送端计算和存储，由接收端校验。解决数据正确性问题 第19-20两个字节：紧急指针 连接的建立与释放三次握手、四次挥手TCP 连接是全双工的，数据在两个方向上能同时传递，这是决定握手和挥手次数一个基本原因 Q: 为什么是三次握手？ A: 要确保双方，同时能发数据和收数据 第一次握手：证明了发送方能发数据 第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据 第三次握手：确保了发送方能收数据 实际上是四个维度的信息交换，不过中间两步合并为一次握手了，四次握手浪费，两次握手不能保证“双方同时具备收发功能” Q: 为什么是四次挥手 A: TCP 支持半关闭（发送一方结束发送还能接收数据的功能），每个方向都要单独关闭，收到关闭通知需要发送确认回复 Q: 为什么要支持半关闭 A: 原因如下： 客户端需要通知服务端，它的数据已经传输完毕，同时仍要接收来自服务端的数据 使用半关闭的单连接效率要比使用两个TCP 连接更好 TCP 连接和关闭对应的状态 服务端等待客户端连接时，处于Listen监听状态 客户端主动打开请求，发送SYN时处于SYN_SENT发送状态 客户端收到syn和ack，并回复ack时，处与Established状态等待发送报文 服务端收到ack确认后，也处于Established状态等待发送报文 客户端发送fin后，处于fin_wait_1状态 服务端收到fin并发送ack时，处于close_wait状态 客户端收到ack确认后，处于fin_wait_2状态 服务端发送fin后，处于last_ack状态 客户端收到fin后发送ack，处于time_wait状态 服务端收到ack后，处于closed状态 time_wait状态 也称为2MSL等待状态，MSL：Maximum Segment LifetIme，报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间，根据不同的tcp实现自行设定(常用值为30s，1min，2min。linux一般为30s) 主动关闭的一方发送最后一个ack所处的状态 这个状态必须维持2MSL等待时间 预留足够的时间给接收端收ack。设想一个场景，最后这个ack丢失了，接收方没有收到，这时候接收方会重新发送fin给发送方，这个等待时间就是为了防止这种情况发生，让发送方重新发送ack 在这2MSL等待时间内，该连接（socket，ip+port）将不能被使用 复位报文段一个报文段从源地址发往目的地址，只要出现错误，都会发出复位的报文段，首部字段的RST是用于“复位”的。这些错误包括以下情况： 端口没有在监听 异常中止：通过发送RST而不是fin来中止连接 数据的传输TCP 传输的数据分类TCP 处理的数据包括两类，有不同的特点，需要不同的传输技术： 交互数据传输：量小，报文段为微小分组，大量微小分组，在广域网传输会增加拥堵的出现 成块数据传输：量大，报文段常常满 交互数据的传输技术 经受时延的确认 TCP 收到数据后，并不会立马发送ack确认，会与将要发送的数据一起发送，以减少开销 Nagle算法 解决什么问题：微小分组导致在广域网出现的拥堵问题 核心：减少了通过广域网传输的小分组数目 原理：要求一个 TCP 连接上最多只能有一个未被确认的未完成的分组，该分组的确认到达之前，不能发送其他分组。TCP 收集这些分组，确认到来之前以一个分组的形式发出去 优点：自适应。确认到达的快，数据发送越快。确认慢，发送更少的组 使用注意：局域网很少使用该算法。且有些特殊场景需要禁用该算法 成块数据传输主要使用滑动窗口协议，该协议解决了发送方和接收方速率不匹配时，保证可靠传输和包乱序的问题 机制： 接收方根据目前缓冲区大小，通知发送方目前能接收的最大值 发送方根据接收方的处理能力来发送数据 接收方给发送方的这个值成为窗口大小 tcp缓冲区的数据结构如下： 拥塞窗口是为了防止出现发送方发送速度过快，导致中转路由器拥堵的问题 机制： 发送方增加一个拥塞窗口（cwnd），每次收到ack，窗口值加1, 取拥塞窗口和接收方发来的窗口大小取最小值发送 这个机制存在的问题： 零窗口 当接收方处理速度慢，发送方发送速度快，窗口大小就慢慢被调为0 糊涂窗口综合征 接收方太忙，取不完数据，导致发送方越来越小，这是因为数据比tcp和ip头小太多，网络利用率太低 此时避免对小的窗口大小做响应 发送端：使用前面说到的Nagle算法 接收端：窗口大小小于某个值，直接ack（0），阻止发送数据，等到窗口变大后再发 参考一文彻底搞懂 TCP三次握手、四次挥手过程及原理","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://example.com/tags/TCP/"}]},{"title":"lodash常用方法","slug":"lodash常用方法","date":"2022-05-18T13:08:44.000Z","updated":"2023-07-19T01:27:24.348Z","comments":true,"path":"2022/05/18/lodash常用方法/","link":"","permalink":"http://example.com/2022/05/18/lodash%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 数组操作chunk将数组（array）拆分成多个 size 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块 入参 array (Array): 需要处理的数组 [size=1] (number): 每个数组区块的长度 返回值 (Array): 返回一个包含拆分区块的新数组（注：相当于一个二维数组） 123const arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;];const result = _.chunk(arr, 3);console.log(result); // [ [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ], [ &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; ], [ &#x27;g&#x27; ] ] compact创建一个新数组，包含原数组中所有的非假值元素。例如false, null,0, &quot;&quot;, undefined, 和 NaN 都是被认为是“假值” 入参 array (Array): 需要处理的数组 返回值 (Array): 返回过滤掉假值的新数组 123const arr = [&#x27;a&#x27;, &#x27;&#x27;, 0, false, true, undefined, NaN];const result = _.compact(arr);console.log(result); // [ &#x27;a&#x27;, true ] difference创建一个具有唯一array值的数组，每个值不包含在其他给定的数组中。（注：即创建一个新数组，这个数组中的值，为第一个数字（array 参数）排除了给定数组中的值。）该方法使用SameValueZero做相等比较。结果值的顺序是由第一个数组中的顺序确定 入参 array (Array): 要检查的数组 [values] (…Array): 排除的值 返回值 (Array): 返回过滤掉假值的新数组 123const arr1 = [&#x27;可乐&#x27;, &#x27;雪碧&#x27;];const arr2 = [&#x27;雪碧&#x27;];console.log(_.difference(arr1, arr2)); // [ &#x27;可乐&#x27; ] 1234// 如果想要比较引用类型，可以使用`differenceBy`const arr1 = [&#123; name: &#x27;可乐&#x27; &#125;, &#123; name: &#x27;雪碧&#x27; &#125;];const arr2 = [&#123; name: &#x27;雪碧&#x27; &#125;];console.log(_.difference(arr1, arr2)); // [ &#123; name: &#x27;可乐&#x27; &#125;, &#123; name: &#x27;雪碧&#x27; &#125; ] 123const arr1 = [&#123; name: &#x27;可乐&#x27; &#125;, &#123; name: &#x27;雪碧&#x27; &#125;];const arr2 = [&#123; name: &#x27;雪碧&#x27; &#125;];console.log(_.differenceBy(arr1, arr2, (item) =&gt; item.name)); // [ &#123; name: &#x27;可乐&#x27; &#125; ] flattenDeep将array递归为一维数组 入参 array (Array): 需要处理的数组 返回值 (Array):返回一个的新一维数组 123const arr = [0, 1, 2, [3, 4, [5]]];const result = _.flattenDeep(arr);console.log(result); // [ 0, 1, 2, 3, 4, 5 ] uniq创建一个去重后的array数组副本。使用了SameValueZero 做等值比较。只有第一次出现的元素才会被保留 入参 array (Array): 要检查的数组 返回值 (Array):返回新的去重后的数组 123const arr = [1, 2, 1];const result = _.uniq(arr);console.log(result); // [ 1, 2 ] 123// 如果想要去重引用类型，可以使用`unionBy`const arr1 = [&#123; name: &#x27;可乐&#x27; &#125;, &#123; name: &#x27;可乐&#x27; &#125;];console.log(_.unionBy(arr1, (item) =&gt; item.name)); // [ &#123; name: &#x27;可乐&#x27; &#125; ] groupBy创建一个对象，key 是 iteratee 遍历 collection(集合) 中的每个元素返回的结果。 分组值的顺序是由他们出现在 collection(集合) 中的顺序确定的。每个键对应的值负责生成 key 的元素组成的数组。iteratee 调用 1 个参数： (value) 入参 1.collection (Array|Object): 一个用来迭代的集合。 2.[iteratee=_.identity] (Array|Function|Object|string): 这个迭代函数用来转换key 返回值 (Array):返回新的去重后的数组 对象操作omit这个对象由忽略属性之外的object自身和继承的可枚举属性组成 入参 object (Object): 来源对象。 [props] (…(string|string[])): 要被忽略的属性 返回值 (Object): 返回一个组成聚合的对象 12const object = &#123; &#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: 3 &#125;;console.log(_.omit(object, [&#x27;a&#x27;, &#x27;c&#x27;])); // &#123; b: &#x27;2&#x27; &#125; omitBy这个对象忽略 predicate（断言函数）判断不是真值的属性后，object自身和继承的可枚举属性组成。predicate调用与2个参数：*(value, key)* 入参 object (Object): 来源对象 [predicate=_.identity] (Function): 调用每一个属性的函数 返回值 (Object): 返回新对象 12const object = &#123; &#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: 3 &#125;;console.log(_.omitBy(object, (key, value) =&gt; typeof object[value] === &#x27;number&#x27;)); // &#123; b: &#x27;2&#x27; &#125; pick创建一个从 object 中选中的属性的对象 入参 object (Object): 来源对象。 [props] (…(string|string[])): 要被选中的属性 返回值 (Object): 返回新对象 12const object = &#123; &#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: 3 &#125;;console.log(_.pick(object, [&#x27;a&#x27;, &#x27;c&#x27;])); // &#123; a: 1, c: 3 &#125; pickBy创建一个对象，这个对象组成为从 object 中经 predicate 判断为真值的属性。 predicate调用2个参数：*(value, key)*。 入参 object (Object): 来源对象。 [predicate=_.identity] (Function): 调用每一个属性的函数 返回值 (Object): 返回新对象 12const object = &#123; &#x27;a&#x27;: 1, &#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: 3 &#125;;console.log(_.pickBy(object, _.isNumber)); // &#123; a: 1, c: 3 &#125; get根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代 入参 object (Object): 要检索的对象 path (Array|string): 要获取属性的路径 [defaultValue] (*): 如果解析值是 undefined ，这值会被返回 返回值 (*): 返回解析的值 12345const object = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;; _.get(object, &#x27;a[0].b.c&#x27;); // 3_.get(object, [&#x27;a&#x27;, &#x27;0&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); // 3_.get(object, &#x27;a.b.c&#x27;, &#x27;default&#x27;); // &#x27;default&#x27;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"React生命周期","slug":"React生命周期","date":"2022-04-03T12:55:22.000Z","updated":"2023-08-20T09:28:41.911Z","comments":true,"path":"2022/04/03/React生命周期/","link":"","permalink":"http://example.com/2022/04/03/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"React 在V16版本中，分别废弃和新增了一些生命周期的钩子函数 新旧生命周期对比old lifecycle挂载： constructor componentWillMount render componentDidMount 更新： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载： componentWillUnmount new lifecycle（React v16.4） 挂载： constructor getDeviedStateFromProps render componentDidMount 更新： getDeviedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate 卸载： componentWillUnmount React 在v16.3版本中将 componentWillMount, componentWillReceiveProps 以及componentWillUpdate 加上了UNSAFE_前缀，这些钩子将在React 17.0废除： UNSAFE_componentWillMount UNSAFE_componentWillReceiveProps UNSAFE_componentWillUpdate 同时React引入两个钩子函数来替代它们，分别是： getDerivedStateFromProps getSnapshotBeforeUpdate 为什么要这么做 componentWillMount 该钩子在页面初始化render之前会执行一次或多次(async rendering) 并且这个钩子完全可以使用componentDidMount和constructor来代替 componentWillReceiveProps 在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWillReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的状态，但很多情况下，业务需求会要求从外部跳转至列表时，根据传入的某个值，直接定位到某个 Tab 为了解决这些问题，React引入了一个新的生命周期: static getDerivedStateFromProps(nextProps, prevState) //返回一个对象 和调用setState一样 componentWillUpdate 与 componentWillReceiveProps 类似，许多开发者也会在 componentWillUpdate 中根据 props 的变化去触发一些回调。但不论是 componentWillReceiveProps 还是 componentWillUpdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentDidMount 类似，componentDidUpdate 也不存在这样的问题，一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中的回调迁移至 componentDidUpdate 就可以解决这个问题 static getDerivedStateFromProps(nextProps, prevState) 在 render 前调用，在初始挂载以及后续更新时都会被调用 返回值：返回一个对象来更新 state, 如果返回 null 则不更新任何内容 需要注意的是，getDerivedStateFromProps 是一个静态函数，不能使用this, 也就是只能作一些无副作用的操作，每当父组件引发当前组件的渲染过程时，getDerivedStateFromProps会被调用，这样我们有一个机会可以根据新的props和之前的state来调整新的state 123static getDerivedStateFromProps(nextProps, prevState) &#123; //根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState&#125; getSnapshotBeforeUpdate(prevProps, prevState) 这函数会在render之后执行，而执行之时DOM元素还没有被更新，给了一个机会去获取DOM信息，计算得到一个snapshot，这个snapshot会作为componentDidUpdate的第三个参数传入 12345678getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log(&#x27;#enter getSnapshotBeforeUpdate&#x27;); return &#x27;foo&#x27;;&#125;componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log(&#x27;#enter componentDidUpdate snapshot = &#x27;, snapshot);&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"Sass、Less的区别","slug":"Sass、Less的区别","date":"2022-03-27T13:32:01.000Z","updated":"2023-08-03T13:26:43.022Z","comments":true,"path":"2022/03/27/Sass、Less的区别/","link":"","permalink":"http://example.com/2022/03/27/Sass%E3%80%81Less%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"预处理器带来了什么CSS (Cascading Style Sheets，层叠样式表)，是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言 CSS 预处理器通过引入一些特性，让 CSS 具备了编程的潜力，使 CSS 的编写更加动态 二者相似之处Sass、Less 在语法上有些共性，比如下面这些： 支持变量 支持混入 支持运算 区别编译环境 Less 基于 JavaScript ，是在客户端处理的 Sass 基于 Ruby ,是在服务端处理的 变量符号Less 用 @，Sass 用 $ 1@color: #00c; /* 蓝色 */ 1$color: #00c; /* 蓝色 */ SCSS 支持条件语句，LESS 不支持12345678910111213141516@if 条件 &#123;&#125; @else &#123;&#125;@for $i from 1 to 10&#123;&#125; // 不包含10;@for $i from 1 through 10&#123;&#125; // 包含10;@each item in a, b, c, d&#123; //item表示每一项&#125; 引用外部 CSS 文件方式不同如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线 例如，将文件命名为 _colors.scss，便不会编译_colors.css 文件 1@import &quot;colors&quot;; 颜色函数调整色相时，SCSS 使用adjust_hue()，LESS 使用spin() 一些常见的疑问Sass 与 Scss 是什么关系? Sass的缩排语法并不直观，也不能将 CSS 代码加入到 Sass 里面，因此 Sass 语法进行了改良，Sass 3 就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"网络相关常见知识点汇总","slug":"网络相关常见知识点汇总","date":"2022-02-19T08:11:41.000Z","updated":"2022-02-25T06:55:39.576Z","comments":true,"path":"2022/02/19/网络相关常见知识点汇总/","link":"","permalink":"http://example.com/2022/02/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 思维导图 参考「2021」高频前端面试题汇总之计算机网络篇","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"思维导图","slug":"思维导图","permalink":"http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"},{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"React事件机制","slug":"React事件机制","date":"2022-01-10T11:45:24.000Z","updated":"2023-08-20T09:33:26.803Z","comments":true,"path":"2022/01/10/React事件机制/","link":"","permalink":"http://example.com/2022/01/10/React%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"概述React 基于浏览器的事件机制实现了一套自身的事件机制，它符合W3C规范，包括事件触发、事件冒泡、事件捕获、事件合成和事件派发等 原生事件机制在原生Web应用开发时，执行事件动作的回调函数通常是绑定在要监听的 DOM 节点上的。 DOM 节点与 DOM 节点之间存在包含关系时，如果一个 DOM 节点被点击，它的父节点、祖先结点实际上是都被点击了的，绑定在上面的点击事件监听函数均应该被执行，那么各个事件监听函数的执行顺序应该是什么样的呢？ DOM 事件标准描述了事件传播的 3 个阶段: 捕获阶段（Capturing phase）—— 事件（从 Window）向下走近元素 目标阶段（Target phase）—— 事件到达目标元素 冒泡阶段（Bubbling phase）—— 事件从元素上开始冒泡 React 事件机制为了在底层磨平不同浏览器的差异，React 实现了统一的事件机制，开发者不再需要处理浏览器事件机制方面的兼容问题，在上层面向开发者暴露出稳定、统一的、与原生事件相同的事件接口 事件池React 事件池仅支持在 React 16 及更早版本中，在 React 17 已经不使用事件池 在React 16中，为了减少频繁创建和销毁事件对象，提高React的性能，引入了事件池的概念 事件池内的对象是复用的，在一个事件对象使用完毕后，并不会将这个事件对象销毁，而是将其重置（各个属性均设置为null）之后放回事件池 在React 16中，事件对象不能直接在异步执行的代码中调用，需要先执行事件对象的SyntheticEvent.pertsist方法对事件对象进行持久化，移除事件池不再复用之后才能在异步执行的代码块中使用事件对象 事件池对性能带来提升在现代浏览器中非必要，所以在React 17中，已经移除了事件池的概念，事件对象不会再复用，虽然事件对象仍然有pertsist方法，但是该方法执行之后并不会有什么影响 事件代理机制原生事件绑定中，事件是通过dom.addEventListener直接绑定到对应的节点上的 React 中的事件机制与原生的事件机制有较大的区别:React 内部自己实现了一套事件绑定机制，并没有直接将事件的回调函数绑定到对应的节点上，而是利用了浏览器的事件冒泡和捕获机制,在React的root节点(React v16版本为document对象) 上添加了所有浏览器原生冒泡事件和捕获事件的代理，当root节点内部某个事件被触发： 事件被 React 的 root 节点捕获之后，就会执行 React 的捕获事件代理，合成事件对象并模拟浏览器的捕获事件机制将合成事件对象分发给对应的React捕获事件监听执行 事件被冒泡到 root 节点之后，就会执行 React 的冒泡事件代理，将合成事件对象分发给对应的React冒泡事件监听执行 React 17 与 React 16 不同之处如下： 简单描述一下v17事件系统的改版： 事件统一绑定container上，ReactDOM.render(app， container);而不是document上，这样好处是有利于微前端的，微前端一个前端系统中可能有多个应用，如果继续采取全部绑定在document上，那么可能多应用下会出现问题 对齐原生浏览器事件 React 17 中终于支持了原生捕获事件的支持， 对齐了浏览器原生标准 onScroll 事件不再进行事件冒泡 onFocus 和 onBlur 使用原生 focusin， focusout 合成 取消事件池 事件代理机制React 在 root 节点上添加了各个委托事件的监听器，分别监听对应事件的捕获和冒泡事件，然后将监听到的捕获或者冒泡事件通过dispatchEvent等函数将浏览器原生事件合成为SyntheicEvent，并收集事件的触发路径，然后分别模拟浏览器原生事件的捕获和冒泡，按照一定的顺序执行对应节点的事件回调函数 事件合成React 在构造 SyntheticEvent 对象时，会将浏览器的原生事件对象保存在SyntheticEvent.nativeEvent属性中，在需要时可以通过该属性获取浏览器原生的事件对象来进行一些操作 事件链路收集简而言之就是收集从触发事件的节点开始向上直到最外层所有的需要执行的事件回调函数 以点击click事件为例，React会根据当前事件的target属性，也就是触发click事件的原生dom节点，找到 最近的fiber节点，然后沿着这个fiber节点逐层向上，收集每一层上对应的事件回调，click事件时就是onClick事件回调，将其push到 listeners 数组中，直到最外层的root节点为止，然后将listeners数组以及合成事件对象组成的对象push到 dispatchQueue队列 中 事件回调函数执行收集到事件的执行路径之后，接下来就是要模拟浏览器原生事件冒泡/捕获，按照一定的顺序执行 dispatchQueue队列 中的回调函数，React收集fiber节点上绑定的回调函数的顺序是从内层到外层的，与事件冒泡的顺序类似，所以要模拟事件冒泡过程就是将 dispatchQueue 中的 listeners 正序遍历执行，模拟事件捕获就是按照相反的顺序，将 dispatchQueue 中的 listeners 倒序遍历执行 如果某个事件回调函数内部调用了event对象的 stopPropagation() 方法，事件的链路就会中断执行，后面的事件回调将不在被触发 合成事件与原生事件区别 事件名称命名方式不同 原生事件命名为纯小写（onclick, onblur），而 React 事件命名采用小驼峰式（camelCase），如 onClick 等 12345// 原生事件绑定方式&lt;button onclick=&quot;handleClick()&quot;&gt;button&lt;/button&gt; // React 合成事件绑定方式const button = &lt;button onClick=&#123;handleClick&#125;&gt;button&lt;/button&gt; 事件处理函数写法不同 原生事件中事件处理函数为字符串，在 React JSX 语法中，传入一个函数作为事件处理函数 12345// 原生事件 事件处理函数写法&lt;button onclick=&quot;handleClick()&quot;&gt;button&lt;/button&gt; // React 合成事件 事件处理函数写法const button = &lt;button onClick=&#123;handleClick&#125;&gt;button&lt;/button&gt; 阻止默认行为方式不同 在原生事件中，可以通过返回 false 方式来阻止默认行为，但是在 React 中，需要显式使用 preventDefault() 方法来阻止 123456789101112131415// 原生事件阻止默认行为方式&lt;a href=&quot;https://www.baidu.com&quot; onclick=&quot;console.log(&#x27;阻止原生事件~&#x27;); return false&quot;&gt; button&lt;/a&gt;// React 事件阻止默认行为方式const handleClick = e =&gt; &#123; e.preventDefault(); console.log(&#x27;阻止原生事件~&#x27;);&#125;const clickElement = &lt;a href=&quot;https://www.baidu.com&quot; onClick=&#123;handleClick&#125;&gt; button&lt;/a&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"JavaScript 如何实现单例模式","slug":"JavaScript如何实现单例模式","date":"2022-01-05T14:56:59.000Z","updated":"2022-01-06T01:29:52.988Z","comments":true,"path":"2022/01/05/JavaScript如何实现单例模式/","link":"","permalink":"http://example.com/2022/01/05/JavaScript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 定义单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 思考全局变量符合单例模式吗？ 不是。但我们经常会把变量当成单例来使用，看个例子： 1var person = &#123;&#125;; 通过字面量创建对象时，对象person确实是独一无二的，如果该变量在全局作用域下声明，就可以在代码中的任何地方使用它。 但是全局变量存在一些问题： 污染命名空间（变量名冲突） 不易维护 (被覆盖) 并且随着项目的体积和功能增大，出现问题的概率也会增大。 实现首先我们要清楚 JS 是一门没有类的语言，ES6 出现类也是原型的语法糖。也正因为没有类，在 JS 中实现单例模式也只需要一个唯一的对象，这是很自然的做法。 这里以一个登录弹窗为例，实践一下单例模式。 假设现在有一个登录按钮，点击后能够出现登录弹窗： 1&lt;button id=&quot;loginBtn&quot;&gt;登录&lt;/button&gt; 先来写创建登录弹窗的方法： 1234567var doCreateLoginModal = function () &#123; var modal = document.createElement(&quot;div&quot;); modal.style.display = &quot;none&quot;; modal.textContent = &quot;登录弹窗&quot;; document.body.appendChild(modal); return modal;&#125;; 接下来就是单例模式的重点了： 12345678var getInstance = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;;&#125;;var createLoginModal = getInstance(doCreateLoginModal); 这里可以发现返回的结果被封装在闭包（内部的函数被保存到了外部）产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命名污染。 先看这段代码中产生的闭包： 最后一行外部的createLoginModal变量保存了getInstance中的匿名函数，该拥有getInstance作用域的访问权限。 再仔细看return result || (result = fn.apply(this, arguments));这条语句： 第一次调用方法时，result为undefined,会执行result = fn.apply(this, arguments),这里利用传入的fn调用生成登录弹窗的方法生成登录弹窗，并被赋值给result，使得之后createLoginModal再被调用时，返回第一次创建的登录弹窗。 最后给按钮绑定点击事件： 123456var loginBtn = document.getElementById(&quot;loginBtn&quot;);loginBtn.onclick = function () &#123; var loginModal = createLoginModal(); loginModal.style.display = &quot;block&quot;;&#125;; 完整代码 惰性单例惰性单例指的是在需要的时候菜创建对象实例。 参考单例模式-维基百科 书目 JavaScript 设计模式与开发实践 JavaScript 设计模式","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"React Hook解析","slug":"React Hook解析","date":"2021-12-28T12:23:54.000Z","updated":"2022-01-25T08:34:05.040Z","comments":true,"path":"2021/12/28/React Hook解析/","link":"","permalink":"http://example.com/2021/12/28/React%20Hook%E8%A7%A3%E6%9E%90/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 问题列表带着以下问题学习： Hook解决了什么问题？ Hook有哪些优势？ 为什么有Hook？ useState方括号有什么用？ 为什么每次更新的时候都要运行 Effect? useMemo 和 shouldComponentUpdate 有什么区别？ Hook概述 React 16.8的新增特性 它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性（是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数） Hook的动机 在无需修改组件结构的情况下复用状态逻辑 在组件之间复用状态逻辑很难 Hook出现之前，将可复用性行为”附加“到组件的解决方案有render props和高阶组件，但是这类方案需要重新组织组件结构，可能会很麻烦，进而让代码难以理解。 Hook将组件中相互关联的部分拆分成更小的函数（比如监听事件、请求数据），而并非强制按照生命周期划分 组件期初很简单，但是逐渐会被状态逻辑和副作用充斥，相关关联且需要对照修改的代码被拆分（监听事件），不相关的代码在同一个方法中（componentDidMount、componentWillUnmount)组合在一起，容易产生bug。 降低学习门槛 对class的学习（需要理解JS中的this工作方式） Hook使用规则 只能在函数最外层调用Hook。不要在循环、条件判断或者子函数中调用 这样能够确保Hook在每一次渲染中都按照同样的顺序被调用 只能在React的函数组件中调用Hook（包括自定义的Hook） 常见的Hook 基础 Hook useState useEffect 说明 - 可以把该Hook看做是`componentDidMount`、`componentDidUpdate`、`componentWillUnmout`三个函数的组合 - React保证了每次运行effect的同时，DOM都已经更新完毕 - 与`componentDidMount`或`componentDidUpdate`不同，使用useEffect调度的effect不会阻塞浏览器更新屏幕，这让应用看起来响应更快 - effect中可选的清除机制在组件卸载的时候触发 使用技巧 - 使用多个 Effect 实现关注点分离（按照代码的用途分离它们），React将按照effect声明的顺序一次调用组建的每一个effect - 跳过 Effect 进行性能优化（第二个参数） useContext接收一个 context 对象（`React.createContext` 的返回值）并返回该 context 的当前值 额外的 Hook useReduceruseState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法 useCallbackuseCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) useMemo可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证可以使用它缓存一些相对耗时的计算，也非常适合用于存储引用类型的数据，可以传入对象字面量，匿名函数等，甚至是 React Element useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue） useImperativeHandle useImperativeHandle 可以在使用 ref 时自定义暴露给父组件的实例值 在大多数情况下，应当避免使用 ref 这样的命令式代码 useImperativeHandle 应当与 forwardRef 一起使用 useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染 useDebugValueuseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签,它接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值 自定义Hook通过自定义 Hook，可以将组件逻辑提取到可重用的函数中 字应该始终以 use 开头，这样可以一眼看出其符合 Hook 的规则 自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性 原理 函数组件执行函数renderWithHooks 作用它是调用function组件函数的主要函数，从源码中看，它首先会置空即将调和渲染的workInProgress树的memoizedState和updateQueue，把新的hooks信息挂载到这两个属性上，然后在组件commit阶段，将workInProgress树替换成current树，替换真实的DOM元素节点。并在current树保存hooks信息。 步骤 执行函数组件 改变ReactCurrentDispatcher对象 初始化hooks 相关hook实际执行的函数: 1234567useState: mountState, // 初始化useStateuseEffect: mountEffect, // 初始化useEffectuseLayoutEffect: mountLayoutEffect, // 初始化useLayoutEffectuseMemo: mountMemo, // 初始化useMemouseReducer: mountReducer, // 初始化useReduceruseRef: mountRef, // 初始化useRefuseCallback: mountCallback, // 初始化useCallback mountWorkInProgressHook生成hook链表 在一个函数组件第一次渲染时，每个hook执行，都会产生一个hook对象，并形成链表结构，绑定在workInProgress的memoizedState属性上 hook上的状态，绑定在当前hook对象的memoizedState属性上 对于effect副作用钩子，会绑定在workInProgress.updateQueue上，等到commit阶段，dom树构建完成，再执行每个 effect 副作用钩子。 更新hooks 相关hook实际执行的函数: 1234567useState: updateState, // 得到最新的stateuseEffect: updateEffect, // 更新updateQueueuseLayoutEffect: updateLayoutEffect,useMemo: updateMemo,useReducer: updateReducer,useRef: updateRef, // 获取ref对象useCallback: updateCallback updateWorkInProgressHook更新hook链表，找到对应的hooks 参考官方文档 React Hooks 最佳实践 react-hooks如何使用？ 一文吃透react-hooks原理","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"常见的排序算法","slug":"常见的排序算法","date":"2021-12-19T02:41:09.000Z","updated":"2021-12-23T07:18:00.697Z","comments":true,"path":"2021/12/19/常见的排序算法/","link":"","permalink":"http://example.com/2021/12/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 常见的排序 冒泡排序说明：重复遍历要排序的数列，一次比较两个元素，按排序顺序交换元素值，不断遍历直到没有再需要交换 1234567891011121314151617const bubbleSort = (input) =&gt; &#123; const output = [...input]; const length = output.length; let hasSwap = false; for(let i = 1; i &lt;= length - 1; i++) &#123; for (let j = 0; j &lt; length - 1; j++) &#123; if (output[j] &gt; output[j + 1]) &#123; let temp = output[j]; output[j] = output[j + 1]; output[j + 1] = temp; hasSwap = true; &#125; &#125; if (!hasSwap) break; &#125; return output;&#125; 插入排序说明：遍历数组，找到数据应该插入的位置将其插入即可 1234567891011121314const insertSort = (input) =&gt; &#123; const output = [...input]; const length = output.length; for (let i = 1; i &lt;= length - 1; i++) &#123; const temp = output[i]; let j = i - 1; while (j &gt;= 0 &amp;&amp; output[j] &gt; temp) &#123; output[j + 1] = output[j]; j--; &#125; output[j + 1] = temp; &#125; return output;&#125; 选择排序说明: 每一次从待排序的数据元素中选出最小（或最大）的一个元素，放到已排序数组的末尾 123456789101112131415161718const selectSort = (input) =&gt; &#123; const output = [...input]; const length = output.length; let minIndex = 0; let temp = 0; for (let i = 0; i &lt; length; i++) &#123; minIndex = i; for (let j = i + 1; j &lt; length; j++) &#123; if (output[j] &lt; output[minIndex]) &#123; minIndex = j; &#125; &#125; temp = output[i]; output[i] = input[minIndex]; output[minIndex] = temp; &#125; return output;&#125; 归并排序说明：归并的的核心思想是分治。它把数组从中间划分成两个数组，一直递归把子数组划分成更小的数组，知道数组中元素个数为1时进行排序。按大小顺序合并两个数组，接着按照递归的顺序返回，不断合并排好序的数组。 12345678910111213141516171819202122232425262728const mergeSort = (input) =&gt; &#123; const length = input.length; if (length &lt; 2) &#123; return input; &#125; const middle = Math.floor(length / 2); const left = input.slice(0, middle); const right = input.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;const merge = (left, right) =&gt; &#123; const result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt; right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) &#123; result.push(left.shift()); &#125; while (right.length) &#123; result.push(right.shift()); &#125; return result;&#125; 快速排序说明：它是冒泡排序的一种改进，通过元素之间的比较和交换位置来达到排序的目的。快排在每一轮\b挑选一个基准元素，把剩下的元素同它进行比较，大于它的放到数列的一边，小于它的放到数列的另一边，一轮比较完成后，整个序列以选取的基准元素位为界，左侧均小于基准元素，右侧均大于基准元素。但左右两侧内部并不是有序的(左右两侧关键字个数也不一定相同)。进而继续将左右两侧分别再以这种方式进行排序，直到将序列拆分的剩余一个关键字为止，整个序列即变成有序。 123456789101112const quickSort = (input) =&gt; &#123; if (input.length &lt;= 1) &#123; return input; &#125; const left = []; const right = []; const middle = input.splice(Math.round(input.length / 2), 1)[0]; for (let i = 0; i &lt; input.length; i++) &#123; (middle &gt; input[i] ? left : right).push(input[i]); &#125; return [...quickSort(left), middle, ...quickSort(right)];&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"TypeScript思维导图","slug":"TypeScript思维导图","date":"2021-12-09T13:34:11.000Z","updated":"2022-01-06T01:31:21.439Z","comments":true,"path":"2021/12/09/TypeScript思维导图/","link":"","permalink":"http://example.com/2021/12/09/TypeScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 思维导图 参考深入理解 TypeScript https://www.typescriptlang.org/ https://www.tslang.cn/index.html https://stackoverflow.com/questions/28818849/how-do-the-different-enum-variants-work-in-typescript","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"思维导图","slug":"思维导图","permalink":"http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"}]},{"title":"JS中数据类型的检测方法","slug":"JS中数据类型的检测方法","date":"2021-11-27T13:32:01.000Z","updated":"2023-08-03T13:25:30.412Z","comments":true,"path":"2021/11/27/JS中数据类型的检测方法/","link":"","permalink":"http://example.com/2021/11/27/JS%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95/","excerpt":"","text":"JS中数据类型检测有哪些 typeof [value] ：检测数据类型的运算符 [example] instanceof [class] ： 检测某一个实例是否属于这个类 [example].constructor === [class] ：检测实例和类关系的，从而检测数据类型 Object.prototype.toString.call([value])：检测数据类型 typeof该关键字使用起来简单，基本数据类型和引用数据类型基本上都可以有效检测 123456789console.log(typeof 1); // numberconsole.log(typeof 1n); // bigintconsole.log(typeof &#x27;1&#x27;); // stringconsole.log(typeof []); // objectconsole.log(typeof null); // objectconsole.log(typeof a); // undefinedconsole.log(typeof true); // booleanconsole.log(typeof function() &#123;&#125;); // functionconsole.log(typeof Symbol(&#x27;1&#x27;)); // symbol 一些需要注意的地方： NaN / Infinity 都是数字类型的，检测结果都是 number typeof null 的结果是 object 所有的值在计算中都以二进制编码储存，浏览器中把前三位000的当作对象，而null的二进制前三位是000，所以被识别为对象，但是他不是对象，他是空对象指针，是基本类型值 instanceof该关键字用来检测某个实例是否属于这个类， 即类的原型只要出现在了实例的原型链上就返回 true，基于这种方式，可以弥补 typeof 无法细分对象类型的缺点（想检测这个值是否为数组，只需要看他是否为Array类的实例即可） 1234let arr = [];console.log(arr instanceof Array); // trueconsole.log(arr instanceof Object); // trueconsole.log(arr instanceof Date); // false 一些需要注意的地方： 被检测的实例必须是引用类型，对基本数据类型值操作无效 constructor该关键字判断当前实例的 constructor 属性是不是预估的类 1234567let arr = [];console.log(arr.constructor === Array); // trueconsole.log(arr.constructor === Array.prototype.constructor); // truelet obj = &#123;&#125;;console.log(obj.constructor instanceof Object); // trueconsole.log(obj.constructor instanceof Object.prototype.constructor); // true 一些需要注意的地方： 有可能不准确， constructor 属性能够被用户修改 null 和 undefined 不适用 Object.prototype.toString.call()每种数据类型的构造函数的原型上都有toString方法 1234567891011121314let toString = Object.prototype.toString;console.log(toString.call(10)); //[object Number]console.log(toString.call(NaN)); //[object Number]console.log(toString.call(&#x27;xxx&#x27;)); //[object String]console.log(toString.call(true)); //[object Boolean]console.log(toString.call(null)); //[object Null]console.log(toString.call(undefined)); //[object Undefined]console.log(toString.call(Symbol())); //[object Symbol]console.log(toString.call(BigInt(10))); //[object BigInt]console.log(toString.call(&#123;xxx:&#x27;xxx&#x27;&#125;)); //[object Object]console.log(toString.call([10,20])); //[object Array]console.log(toString.call(/^\\d+$/)); //[object RegExp]console.log(toString.call(function()&#123;&#125;)); //[object Function] 一些需要注意的地方： 自定义类返回的都是 [object Object]","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"DOM基本操作思维导图","slug":"DOM基本操作","date":"2021-11-16T13:01:11.000Z","updated":"2022-01-06T01:33:50.961Z","comments":true,"path":"2021/11/16/DOM基本操作/","link":"","permalink":"http://example.com/2021/11/16/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"思维导图","slug":"思维导图","permalink":"http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"}]},{"title":"关于懒加载","slug":"关于懒加载","date":"2021-11-05T12:35:12.000Z","updated":"2023-08-20T09:33:54.065Z","comments":true,"path":"2021/11/05/关于懒加载/","link":"","permalink":"http://example.com/2021/11/05/%E5%85%B3%E4%BA%8E%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 懒加载概念懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。 用户滚动到它们之前不加载，也就是在可视区域之外的图像不会加载。 使用场景和优势在一些电商类的项目中，往往存在大量的图片，比如广告图、商品图等等。图片的数量和体积会影响页面加载速度，而进行图片懒加载优化可以大幅提升用户体验 减少无效资源的加载 防止并发加载的资源过多会阻塞JS的加载 可以看出来，懒加载的核心目的就是提升用户的体验 实现思路一将页面上的图片的 src 属性设置为项目中引入一个默认的图片路径，而图片的真实路径则设置在自定义数据属性中，比如说data-original， 同时监听scroll事件，在scroll事件的回调中，判断需要进行懒加载的图片是否进入可视区域，如果图片在可视区内将图片的 src 属性设置为data-original 的值 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/1.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/2.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/3.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/4.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/5.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/6.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/7.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/8.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/9.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/10.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/11.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/12.png&quot; /&gt; &lt;script&gt; // 获取可视区高度 const viewHeight = document.body.clientHeight; // 懒加载 function lazyload() &#123; const imgs = document.querySelectorAll(&quot;img[data-src][lazyload]&quot;); Array.prototype.forEach.call(imgs, function (item, index) &#123; let rect = null; if (item.dataset.original === &quot;&quot;) return; // 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置 rect = item.getBoundingClientRect(); if (rect.bottom &gt;= 0 &amp;&amp; rect.top &lt; viewHeight) &#123; const img = new Image(); img.src = item.dataset.original; img.onload = function () &#123; item.src = img.src; &#125;; // 移除属性，下次不再遍历 item.removeAttribute(&quot;data-src&quot;); // 标记已懒加载 item.removeAttribute(&quot;lazyload&quot;); &#125; &#125;); &#125; // 节流，性能优化 function throttle(fn, delay) &#123; let tiemr = null; return function (args) &#123; let that = this; let _args = args; if (!tiemr) &#123; timer = setTimeout(function () &#123; fn.call(that, _args); timer = null; &#125;, delay); &#125; &#125; &#125; // 刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片 lazyload(); document.addEventListener(&quot;scroll&quot;, throttle(lazyload, 200)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 思路二思路一需要去监听 scroll 事件，虽然通过函数节流的方式来阻止高频率的执行函数，但是还是需要去计算高度等属性，而 IntersectionObserver 接口提供了一种异步观察目标元素与其祖先元素或顶级文档视口（viewport）交叉状态（可见）的方法。 相关API介绍 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Lazyload&lt;/title&gt; &lt;style&gt; .image-item &#123; display: block; margin-bottom: 50px; height: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/1.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/2.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/3.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/4.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/5.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/6.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/7.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/8.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/9.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/10.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/11.png&quot; /&gt; &lt;img src=&quot;./images/loading.png&quot; class=&quot;image-item&quot; lazyload=&quot;true&quot; data-src=&quot;images/12.png&quot; /&gt; &lt;script&gt; const imgs = document.querySelectorAll(&#x27;img[data-src]&#x27;) const config = &#123; rootMargin: &#x27;0px&#x27;, threshold: 0, &#125; let observer = new IntersectionObserver((entries, self) =&gt; &#123; entries.forEach((entry) =&gt; &#123; if (entry.isIntersecting) &#123; let img = entry.target let src = img.dataset.src if (src) &#123; img.src = src img.removeAttribute(&#x27;data-src&#x27;) img.removeAttribute(&quot;lazyload&quot;); &#125; // 解除观察 self.unobserve(entry.target) &#125; &#125;) &#125;, config) imgs.forEach((image) =&gt; &#123; observer.observe(image) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"深入了解eval","slug":"深入了解eval","date":"2021-10-26T11:29:04.000Z","updated":"2022-01-11T07:50:24.600Z","comments":true,"path":"2021/10/26/深入了解eval/","link":"","permalink":"http://example.com/2021/10/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3eval/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 相关定义和描述eval 是全局对象上的一个函数，会把传入的字符串当做 JavaScript 代码执行，它通常被用来执行动态创建的代码。 语法很简单： 1&gt;eval(string) // 一个表示 JavaScript 表达式、语句或一系列语句的字符串。表达式可以包含变量与已存在对象的属性。 举个🌰 12const string = &quot;console.log(&#x27;hello, eval&#x27;)&quot;;window.eval(string); 先提出问题：eval这个方法很强大，且兼容性很好，但是为什么很少使用？ 一些特性返回最后一个表达式的值1console.log(eval(&#x27;1+1+1&#x27;)); // 3 12345678910let string1 = &#x27;let x; x = 1;&#x27;;let string2 = &#x27;let x, y; x = 1; y = 2;&#x27;;function test(str) &#123; let result = eval(str); console.log(result);&#125;test(string1); // 1test(string2); // 2 函数作为字符串被定义时需要”(“和”)“作为前缀和后缀1234const funcStr1 = &#x27;function test() &#123;&#125;&#x27;;const funcStr2 = &#x27;(function test() &#123;&#125;)&#x27;;console.log(eval(funcStr1)); // undefinedconsole.log(eval(funcStr2)); // [Function: test] 直接调用和间接调用12345678910let x = 1, y = 1;function test() &#123; let x = 2, y = 2; console.log(eval(&#x27;x + y&#x27;)); // 直接调用，使用本地作用域，结果是 4 const geval = eval; // 等价于在全局作用域调用 console.log(geval(&#x27;x + y&#x27;)); // 间接调用，使用全局作用域，结果是 2 console.log((0, eval)(&#x27;this&#x27;)); // 另一个间接调用的例子&#125;test(); 1(0, eval)(&#x27;this&#x27;) 逗号操作符：对它的每个操作数求值（从左到右），并返回最后一个操作数的值 这里使用逗号操作符，于是返回表达式中的最后一项，然后为eval传入’this’字符串，来立即执行这个表达式，这里其实就是把全局对象给打印出来 黑魔法欺骗词法作用域原理：JavaScript中的eval(str)函数可以接受一个字符串为参数，并将字符串内容视为好像在书写时就存在于eval()函数所在位置的代码。 12345678function foo(str, a) &#123; eval(str); // 欺骗 console.log(a, b);&#125;var b = 2;foo(&quot;var b = 3;&quot;, 1); // 1, 3 这个例子中var b = 3;这条语句会被当做本来就在那里，因此foo函数内部的变量b遮蔽了外部的变量b 严格模式下的表现在严格模式下，eval在运行时会有自己的词法作用域，意味着其中的声明无法修改所在的作用域 1234567function foo(str, a) &#123; &quot;use strict&quot; eval(str); console.log(a); // undefined&#125;foo(&quot;var a = 2;&quot;); 使用时有哪些坑eval不容易调试调试困难，且可读性非常差（没有行号） 用chromeDev、VSCode等工具无法打断点调试 性能问题JavaScript 通常被认为是一门解释型的语言，但是现代的 JavaScript 引擎不再只是解释 JavaScript，也会对其进行编译。 V8 为了提高 JS的运行性能，在运行之前会先将JS编译为本地的机器码，然后再去执行机器码（JIT）。 现代JavaScript解释器将javascript转换为机器代码。 这意味着任何变量命名的概念都会被删除。 因此，任意一个eval的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。 另外，新内容将会通过 eval() 引进给变量， 比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。 eval破坏了JS引擎优化 安全问题当使用来源不可靠的第三方代码时，无法保证不碰到恶意代码 参考MDN JavaScript深入之词法作用域和动态作用域 V8 JavaScript 引擎 《你不知道的JavaScript》 上卷","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"网络攻击","slug":"网络攻击","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"}]},{"title":"Redux和Mobx的异同","slug":"Redux和Mobx的异同","date":"2021-10-10T11:53:01.000Z","updated":"2022-02-16T10:07:31.941Z","comments":true,"path":"2021/10/10/Redux和Mobx的异同/","link":"","permalink":"http://example.com/2021/10/10/Redux%E5%92%8CMobx%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 二者主要概念MobX Redux 函数式编程相关知识读书笔记:Javascript函数式编程指南（一） 读书笔记:Javascript函数式编程指南（二） 读书笔记:Javascript函数式编程指南（三） 读书笔记:Javascript函数式编程指南（四） 异同点 设计思想：函数式 VS 面向对象 Redux遵循函数式编程思想，MobX则更多从面向对象和响应式编程的角度来考虑问题 可以从Redux的reducer中看出来，它就是一个纯函数，只依赖入参： 12345(state, action) =&gt; &#123; return Object.assign(&#123;&#125;, state, &#123; ... &#125;)&#125; MobX将状态包装成可观察对象，一但状态对象变更，就重新渲染视图 对store管理：单一store VS 多个store store是应用管理数据的地方，在Redux中，应用的所有数据都集中在一个大的store中；MobX则通常是按照模块来将应用状态划分，在多个独立的store中管理 数据可变性：不可变 VS 可变 Redux状态对象通常是不可变的，一般是在原来的状态对象基础上返回一个新的状态对象；MobX则可以直接使用新的值更新状态对象 整体差异 Redux提供可以进行时间回溯的开发工具，同时因为它使用纯函数以及更少的抽象，让调试变得更加容易；MobX使用起来相对简单，但是其中有更多的抽象和封装，所以调试起来会更加复杂，同时结果也更难以预测 参考Redux 中文官网 Redux 中文文档 你需要Mobx还是Redux？ 我为什么从Redux迁移到了Mobx","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"MobX记录","slug":"MobX记录","date":"2021-09-23T14:56:31.000Z","updated":"2022-02-16T10:07:20.179Z","comments":true,"path":"2021/09/23/MobX记录/","link":"","permalink":"http://example.com/2021/09/23/MobX%E8%AE%B0%E5%BD%95/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 说明简单、可扩展的状态管理 优势 简单直接 编写无模板的极简代码来精准描述意图 轻松实现最优渲染 所有对数据的变更和使用都会在运行时被追踪到，并构成一个截取所有状态和输出之间关系的依赖树。这样保证了那些依赖于状态的计算只有在真正需要的时候才会运行，就像React组件一样。无需使用记忆化或选择器之类容易出错的次优技巧来对组件进行手动优化。 架构自由 它可以让你在任意UI框架之外管理你的应用状态。这样会使你的代码低耦合、可移植和更加容易测试 浏览器支持 Mobx &gt;= 5 版本运行在任何支持 ES6 proxy的浏览器。 Mobx 4 可以运行在任何支持ES5的浏览器上，而且也讲进行持续地维护。MobX 4 和 5 的API是相同的，并且语义上也能达到相同的效果，只是Mobx 4 存在一些局限性 Observable 数组不是真正的数组，所以它们无法通过Array.isArray() 的检查。最常见的处理方法是在传递给第三方库之前，你经常需要先对其进行.slice()操作，从而得到一个浅拷贝的真正数组 向一个已存在的 observable 对象中添加属性不会被自动捕获。要么使用 observable 映射来替代，要么使用工具函数中方法来对想要动态添加属性的对象进行读/写/迭代 核心概念 State(状态) 状态是驱动应用的数据。 可以用任何数据结构来存储状态，如JS基本数据类型、引用类型、普通对象、类实例、数组和映射 通常有像待办事项列表数据这样的领域特定状态，还有像当前已选元素的视图状态（状态就像是有数据的excel表格） Action(动作) Action(动作)是任意可以改变State(状态)的代码,比如用户事件处理、后端推送数据处理、调度器事件处理等 使用Action可以更好地组织代码，并防止在无意中修改State 如果是在严格模式下使用 MobX的话，MobX 会强制只有在动作之中才可以修改状态 Derivations(派生) 任何来源是State并且不需要进一步交互的东西都是Derivation 多种形式： 用户界面 派生数据，比如剩下的待办事项的数量 后端集成，比如把变化发送到服务器端两种类型： Computed values（计算值） 它们是永远可以使用纯函数从当前可观察状态中衍生出的值 Reactions（反应）他们是当状态改变时需要自动发生的副作用 (命令式编程和响应式编程之间的桥梁，或者说得更明确一些，它们最终都需要实现I / O 操作) 黄金法则：如果想创建一个基于当前状态的值时，使用computed 原则MobX使用单向数据流，利用Action改变State，进而更新所有受影响的View 所有的Derivations将在State改变时自动且原子化的更新，引测不可能观察中间值 所有的Derivations默认将会同步更新，这意味着Action可以在State改变之后安全的直接获取computed值 Computed value的更新是惰性的，任何Computed value在需要它们的副作用发生之前都是不激活的 所有的Computed value都应该是纯函数，它们不应该修改State 工作原理MobX使用Object.defineProperty来拦截对数据的访问，一旦值发生变化，就会调用React的render方法重新渲染视图或者触发autorun 常用API Autorun 用法：autorun(effect: (reaction) =&gt; void) 说明：autorun 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。 当你自己创建 autorun 时，它也会运行一次 Reaction 用法： 5：reaction(() =&gt; data, (data, reaction) =&gt; { sideEffect }, options?) 6：reaction(() =&gt; value, (value, previousValue, reaction) =&gt; { sideEffect }, options?) 说明： reaction 类似于 autorun，但可以让你更加精细地控制要跟踪的可观察对象。 它接受两个函数作为参数：第一个，data 函数，其是被跟踪的函数并且其返回值将会作为第二个函数，effect 函数，的输入。 重要的是要注意，副作用只会对 data 函数中被访问过的数据做出反应，这些数据可能少于 effect 函数中实际使用的数据 一般的模式是在 data 函数中返回你在副作用中需要的所有数据， 并以这种方式更精确地控制副作用触发的时机。 与 autorun 不同，副作用在初始化时不会自动运行，而只会在 data 表达式首次返回新值之后运行 When 用法： when(predicate: () =&gt; boolean, effect?: () =&gt; void, options?) when(predicate: () =&gt; boolean, options?): Promise 说明：when 会观察并运行给定的 predicate 函数，直到其返回 true。 一旦 predicate 返回了 true，给定的 effect 函数就会执行并且自动执行器函数将会被清理掉。 集成ReactMobX 可以独立于 React 运行, 但是他们通常是结合在一起使用 常用的两个包： mobx-react mobx-react-lite mobx-react中引用了mobx-react-lite包，它提供了很多在新项目中不再需要的特性，其中有： 对于React class components的支持 Provider 和 inject ，MobX的这些东西在有React.createContext替代后变得不必要了 特殊的观察对象 propTypes 要注意 mobx-react 是全量包，也会暴露 mobx-react-lite包中的任何方法,其中包含对函数组件的支持。 如果你使用 mobx-react，那就不要添加 mobx-react-lite 的依赖和引用了 注意事项 区分computed和auturun如果想响应式的产生一个可以被其它observer使用的值，使用@compouted;如果想要达到一个效果，使用autorun（打印日志，发起网络请求等这样命令式的副作用） 参考MobX 中文文档 MobX","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"MobX","slug":"MobX","permalink":"http://example.com/tags/MobX/"}]},{"title":"React中Fiber的简单实现","slug":"React中Fiber的简单实现","date":"2021-09-11T15:14:54.000Z","updated":"2022-02-21T07:04:30.815Z","comments":true,"path":"2021/09/11/React中Fiber的简单实现/","link":"","permalink":"http://example.com/2021/09/11/React%E4%B8%ADFiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 传送门","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"类数组转换成数组的几种方式","slug":"类数组转换成数组的几种方式","date":"2021-08-25T13:44:29.000Z","updated":"2022-02-21T07:00:45.191Z","comments":true,"path":"2021/08/25/类数组转换成数组的几种方式/","link":"","permalink":"http://example.com/2021/08/25/%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 概括 Array.prototype.slice.call() Array.from() 拓展运算符 Array.prototype.slice.call()这种方法是借用了数组原型中的slice方法，返回一个数组 slice()返回一个新的数组对象，这一对象是一个由begin和end决定的原数组的浅拷贝（包括 begin，不包括end），且原始数组不会被改变，语法如下： 1arr.slice([begin[, end]]) 这里看看slice()方法的内部实现： 123456789Array.prototype.slice = function (start, end) &#123; const result = new Array(); start = start || 0; end = end || this.length; for (let i = start; i &lt; end; i++) &#123; result.push(this[i]); &#125; return result;&#125; Array.from()Array.from()方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例 1Array.from(arrayLike[, mapFn[, thisArg]]) arrayLike 想要转换成数组的伪数组对象或可迭代对象 mapFn 可选 如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg 可选 可选参数，执行回调函数 mapFn 时 this 对象。 拓展运算符ES6中的扩展运算符…也能将某些数据结构转换成数组，这种数据结构必须有遍历器接口 1var args = [...arguments]; 参考MDN","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"前端模块化的前世今生","slug":"前端模块化的前世今生","date":"2021-08-19T12:23:54.000Z","updated":"2022-01-06T01:28:03.543Z","comments":true,"path":"2021/08/19/前端模块化的前世今生/","link":"","permalink":"http://example.com/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 近年来 Web 应用变得更加复杂与庞大，Web 前端技术的应用范围也更加广泛。通过直接编写 JavaScript、CSS、HTML 开发 Web 应用的方式已经无法应对当前 Web 应用的发展。 站在巨人的肩膀往回看，好在 JavaScript 模块化出现，解决了前端痛点，并且推动前端工程化。 那什么是模块化呢？ 为什么需要它呢？模块化可以理解成是将一个复杂的系统分解为多个模块以方便组织和编码。 很久以前，网页开发要通过命名空间的方式来组织代码。像 jQuery 就是将他的 API 都放在 window.$ 下，在加载完 jQuery 后，其它模块再通过 window.$ 去使用。 那这么做会有一些问题，其中包括： 命名空间冲突 无法合理地管理项目地依赖和版本 无法方便地控制依赖的加载顺序 可以预见，当项目越大，维护成本也越高，因此用模块化的思想来组织代码。 回顾前端模块化的前世今生，按时间先后可以总结为以下几个过程 刀耕火种时代 CommonJS 模块规范及在 Node.js 里的实现 AMD 异步模块定义 ESM ECMAScript 模块系统 刀耕火种时代我们都知道 HTML 的 &lt;script&gt; 元素用于嵌入或引用可执行脚本。 在互联网早期，Web1.0 时代，页面比较简单，大多时候只是展示内容，使用内嵌的方式或者引用单个 JavaScript 文件就可以满足业务需求。 当功能变得复杂时，单个 JavaScript 文件代码量也变多，此时可以将 JavaScript 分为多个文件，但需要处理好各个 &lt;script&gt; 标签的书写顺序。 这个时期针对 JavaScript 源码的组织，谈不上模块化。即便采用了文件拼接（concat）这样的处理技术，其先后顺序也需要人工维护。 CommonJS 模块规范及在 Node.js 里的实现这是一种被广泛使用的 JavaScript 模块化规范，其核心思想是通过require方法来同步加载依赖的其他模块，通过module.export导出需要暴露的接口。 它的流行得益于 Node.js 采用了这种方法。 它的优点在于： 代码可复用于 Node.js 环境下并运行 有很多遵循此规范的 Npm 包 它的缺点在于： 代码无法直接运行在浏览器环境下，需要通过工具转换成标准的 ES5 CommonJS 还可以细分为 CommonJS1 和 CommonJS2，区别在于 CommonJS1 只能通过export.xx = xx的方式导出，而 CommonJS2 在 CommonJS1 的基础上加入了module.export = xx的导出方式。CommonJS 通常指 CommonJS2。 Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 Node.js 在解析与执行每个模块之前，会先加上一层包装，类似于： 123(function (exports, require, module, __filename, __dirname) &#123; // 模块代码...&#125;); 所以，模块作用域实际上是一个函数作用域；而 __dirname、__filename、require、module 等模块常量/变量都是外部传入的参数。 AMD 异步模块定义AMD（Asynchronous Module Definition）即异步模块定义。AMD 规范中，各个依赖可以异步加载而不影响正常逻辑，非常适用于浏览器环境。AMD 规范的核心 API 只有一个简单的 define()函数。 AMD 模块系统的经典实现库是 require.js。 例子: 123define(id?: String, dependencies?: String[], factory: Function|Object);define(function(require, exports, module) &#123;&#125;) id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]。 factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。 AMD 规范平时用得很少，这里举一个例子： 123456define(&quot;myModule&quot;, [&quot;jquery&quot;], function ($) &#123; // $ 是 jquery 模块的输出 $(&quot;body&quot;).text(&quot;hello world&quot;);&#125;);// 使用require([&quot;myModule&quot;], function (myModule) &#123;&#125;); 这里我们再来看看它的优点： 可在不转换代码的情况下直接在浏览器中运行 可异步加载依赖 可并行加载多个依赖 代码可运行在浏览器环境和 Node.js 环境下 AMD 的缺点在于 JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。 ESM ECMAScript 模块系统前面所提到的所有模块化解决方案，都是利用 JavaScript 语言本身的特性，实现的封装。而鉴于模块系统的重要性、必要性，TC39 委员会也对其标准化极为上心。2015 年推出的 ECMAScript 6 标准正式定义了 JavaScript 的模块系统。 需要记住的是： 它在语言层面上实现了模块化。 浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS、AMD 规范，成为浏览器和服务器通用的模块解决方法 它的工作原理是模块文件只加载、执行一次。 虽然 ES6 模块是终极模块化方案，但它目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"webpack笔记","slug":"webpack笔记","date":"2021-08-05T13:09:33.000Z","updated":"2022-01-10T07:59:19.154Z","comments":true,"path":"2021/08/05/webpack笔记/","link":"","permalink":"http://example.com/2021/08/05/webpack%E7%AC%94%E8%AE%B0/","excerpt":"","text":"问题列表 webpack是用来解决什么问题的 ？ 它有什么亮点 ？ loader 和 plugin 有什么区别 ？ 运行原理 ？ 如何编写 Loader? Webpack 和 Rollup 有什么相同点与不同点？ webpack 作用 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 根据官网的高度概述，我们可以简单理解webpack是一个针对JavaScript项目的打包工具。 简单浏览一遍官方文档，再看看上面这张图，就会发现webpack的关键点在于模块处理和打包,在webpack构建的流程中，通过loader处理非 JS 文件，将其转换为 webpack 能够处理的有效模块，使用各式各样的plugin在构建时的关键步骤进行一些操作（比如按需加载，代码压缩等），最终输出浏览器能使用的静态资源。 这里思考一下为什么需要模块化呢？答案 那怎么理解模块化呢？在webpack中，核心思想就是一切皆模块，比如说一张图片，一个SCSS文件。 这样做的好处就是能够清晰地描述出各个模块之间依赖关系，便于webpack对模块进行组合、打包。 为什么是 webpack这些年前框框架、工具非常多，那为什么webpack更受青睐呢？ 这里来分析一下其它的工具 基于任务执行的工具 比如说：gulp、grunt 这些工具能够自动执行指定的任务。它们简单高效，社区活跃，有着丰富的插件，可以方便打造各种工作流。 基于模块化打包的工具 比如说：browserify、webpack、rollup 在 Node 环境下，如果需要引用组件，使用require关键字即可，这类工具就是这个模式，还可以实现按需加载、异步加载模块 整合型工具 比如说：FIS3、cooking 这类工具使用了多种技术栈实现的脚手架工具，好处是即开即用，缺点就是它们约束了技术选型，并且学习成本相对较高。 为什么选用 webpack 大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，webpack可以为这些新项目提供一站式的解决方案 webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量 webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享 核心概念 entry: 入口 webpack执行构建的第一步就从入口开始，可以抽象理解为输入 module: 模块 在webpack中一切皆模块，一个文件就是一个模块，webpack会从入口开始递归遍历找出所有依赖的模块 chunk: 代码块 一个Chunk由多个模块组合而成，它是代码合并、分割的产物 loader: 模块转换器 webpack使用它把原内容转换成浏览器能够使用的文件 plugin: 插件拓展 webpack在构建流程中的特定时机注入扩展逻辑来改变构建结果 output: 输出结果 webpack经过一系列处理后，输出的最终结果 loaderwebpack 只能理解JavaScript和JSON文件，这是webpack开箱可用的自带能力。 loader让webpack能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。 用法处理文件时可以使用多个loader,loader的执行顺序和配置中的顺序是相反的。也就是说最后一个loader先执行，它接收源文件作为参数，处理之后把处理结果传给下一个loader 常用的 loader css-loader 加载CSS、支持模块化、压缩、文件导入等特性 style-loader 把CSS代码注入到JavaScript中，通过DOM操作去加载CSS file-loader 把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件 url-loader 它和 filr-loader 类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中 babel-loader 让开发者能够在项目中使用新的JavaScript特性 plugin插件是webpack的支柱功能。 插件目的在于解决loader无法实现的其他事。 webpack自身也是构建于插件系统之上。 原理在webpack运行的生命周期中会广播出许多事件，插件可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果，在这个过程中插件可以访问到compile和compilation，通过钩子拦截webpack的执行。 常用的 plugin clean-webpack-plugin 每次打包后自动清理output.path内的文件，只保留本次构建的结果 html-webpack-plugin 创建一个html文件，并把webpack打包后的静态文件自动插入到这个html文件当中 DefinePlugin 这是一个定义全局变量的插件,定义的变量可以在webpack打包范围内任意JavaScript环境内访问 MiniCssExtractPlugin 将CSS单独打包成一个文件，它为每个包含CSS和JavaScript文件都创建一个CSS文件，结合html-webpack-plugin插件，以link的形式插入到html文档中 babel-loader 让开发者能够在项目中使用新的JavaScript特性 webpack-merge 该插件用于合并配置 webpack-bundle-analyzer 项目打包后进行性能分析 构建流程和原理构建之前先了解几个名词： Compiler：编译管理器，webpack启动后会创建compiler对象，该对象一直存活直到结束退出 Complilation：单次编译过程的管理器，比如watch=true时，运行过程中只有一个compiler，但每次文件变更触发重新编译时，都会创建一个新的compilation对象 Dependence：依赖对象，webpack基于该类型记录模块间依赖关系 Module：webpack内部所有资源都会以module对象形式存在，所有关于资源的操作、转译、合并都是以module为基本单位进行的 Chunk：编译完成准备输出时，webpack会将module按特定的规则组织成一个一个的chunk，这些chunk某种程度上跟最终输出一一对应 构建流程： 初始化阶段 初始化参数：从配置文件、配置对象、Shell参数中读取，进行错误检查，与默认配置结合得出最终的参数 创建编译器对象：用上一步得到的参数创建Compiler对象 初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化RuleSet集合、加载配置的插件等 开始编译：执行compiler对象的run方法 确定入口：根据配置中的entry找出所有的入口文件，调用compilition.addEntry将入口文件转换为dependence对象 构建阶段 编译模块：根据entry对应的dependence创建module对象，调用loader将模块转移为标准JS内容，调用JS解释器将内容转换为AST对象，从中找出该模块依赖的模块，再递归这个步骤直到所有入口依赖的文件都经过了本步骤的处理 完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的依赖关系图 生成阶段 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表。这个步骤是可以修改输出内容的最后机会 写入文件系统：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 源码中的一些重要方法： webpack_require: 我们在模块化开发的时候，通常会使用ES Module或者CommonJS规范导入导出以来的模块，webpack在打包的时候，会统一替换成自己的__webpack_require__来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性 __webpack_modules__：存放了编译后的各个文件模块的JS内容 __webpack_module_cache__：用来做模块缓存 配置优化webpack配置虽然简单，但是配置项非常多，每个配置项的取值可能也有很多的选择，故而优化的空间很大。 讲一些平常用的多的配置优化： 使用webpack-bundle-analyzer插件 可以看到项目各模块大小，进行按需优化 stat表示文件的输入大小，parsed表示文件的输出大小，gzip表示通过gzip压缩运行解析的包/模块大小 使用tree shaking擦除无用代码 移除JavaScript上下文中的未引用代码 开启scope hosting减少函数申明和内存开销 这个名词直译过来就是作用域提升，它把所有的代码按照引用顺序放在一个函数作用域里面，适当的重命名变量防止冲突 使用splitChunksPlugin分离页面公共文件，抽取公共代码 使用多进程多实例解析资源 使用DLLPlugin对基础依赖库进行分包，减少编译次数 DllPlugin动态链接库插件，其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。 总结来看，可以使用大量插件对编译过程进行优化。 参考官网 当面试官问Webpack的时候他想知道什么 一文吃透 Webpack 核心原理 构建工具 书目： 深入浅出 Webpack","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"}]},{"title":"React中render的实现","slug":"React中render的实现","date":"2021-07-19T14:03:04.000Z","updated":"2022-02-21T07:06:17.619Z","comments":true,"path":"2021/07/19/React中render的实现/","link":"","permalink":"http://example.com/2021/07/19/React%E4%B8%ADrender%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 传送门","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]},{"title":"数组去重常见的方法","slug":"数组去重常见的方法","date":"2021-07-07T13:32:01.000Z","updated":"2023-08-03T13:25:41.556Z","comments":true,"path":"2021/07/07/数组去重常见的方法/","link":"","permalink":"http://example.com/2021/07/07/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"利用ES6中的 Set 去重Set 是 ES6 新增的一种数据结构，允许存储任何类型（原始值或引用值）的唯一值，使用这种方式非常简洁 123456function unique(arr) &#123; return Array.from(new Set(arr));&#125;let array = [1, 2, 1, false, false, &#x27;true&#x27;, &#x27;true&#x27;, NaN, NaN];console.log(unique(array)); // [1, 2, false, &#x27;true&#x27;, NaN] 利用ES6中的 Map 去重Set 是 ES6 新增的一种数据结构，创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果 12345678910111213141516function unique(arr) &#123; let map = new Map(); let result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!map.has(arr[i])) &#123; map.set(arr[i], false); result.push(arr[i]); &#125; else &#123; map.set(arr[i], true); &#125; &#125; return arr.filter((item, index) =&gt; index === arr.indexOf(item));&#125;let array = [1, 2, 1, false, false, &#x27;true&#x27;, &#x27;true&#x27;, NaN, NaN];console.log(unique(array)); // [1, 2, false, &#x27;true&#x27;] 利用数组的 includes 方法includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false 123456789101112function unique(arr) &#123; const result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if (!result.includes(arr[i])) &#123; result.push(arr[i]); &#125; &#125; return result;&#125;let array = [1, 2, 1, false, false, &#x27;true&#x27;, &#x27;true&#x27;, NaN, NaN];console.log(unique(array)); // [1, 2, false, &#x27;true&#x27;, NaN] 利用数组的 filter、indexOf 方法123456function unique(arr) &#123; return arr.filter((item, index) =&gt; index === arr.indexOf(item));&#125;let array = [1, 2, 1, false, false, &#x27;true&#x27;, &#x27;true&#x27;, NaN, NaN];console.log(unique(array)); // [1, 2, false, &#x27;true&#x27;] 利用数组的 splice 方法注意 NaN 12345678910111213function unique(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = 0; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j] &amp;&amp; i!== j) &#123; arr.splice(j, 1); &#125; &#125; &#125; return arr;&#125;let array = [1, 2, 1, false, false, &#x27;true&#x27;, &#x27;true&#x27;, NaN, NaN];console.log(unique(array)); // [1, 2, false, &#x27;true&#x27;, NaN, NaN] 利用递归去重注意 NaN 123456789101112131415161718192021222324function unique(arr) &#123; let array = arr; let len = array.length; //排序后更加方便去重 array.sort(function (a, b) &#123; return a - b; &#125;) function loop(index) &#123; if (index &gt;= 1) &#123; if (array[index] === array[index - 1]) &#123; array.splice(index, 1); &#125; //递归loop，然后数组去重 loop(index - 1); &#125; &#125; loop(len - 1); return array;&#125;let array = [1, 2, 1, false, false, &#x27;true&#x27;, &#x27;true&#x27;];console.log(unique(array)); // [1, 2, false, &#x27;true&#x27;]","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"数组扁平化常见的方法","slug":"数组扁平化常见的方法","date":"2021-07-04T11:31:11.000Z","updated":"2023-08-03T13:25:57.821Z","comments":true,"path":"2021/07/04/数组扁平化常见的方法/","link":"","permalink":"http://example.com/2021/07/04/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"数组扁平化的意思就是将多维数组降维 12345678// 原数组是一个“三维”数组const array = [1, 2, [3, 4, [5, 6], 7], 8, 9]// 可以降成二维newArray1 = [1, 2, 3, 4, [5, 6], 7, 8, 9]// 也可以降成一维newArray2 = [1, 2, 3, 4, 5, 6, 7, 8, 9] 原生 flat 方法（ES2019）flat() 方法扁平数组的同时，还能移除数组中的空位（Empty Slots） 12const array = [1, 2, [3, 4, [5, 6], 7], 8, 9];console.log(array.flat()); // [ 1, 2, 3, 4, [ 5, 6 ], 7, 8, 9 ] flat 仿写12345678910111213function MyFlat(arr = [], depth = 1) &#123; let result = []; arr.forEach(item =&gt; &#123; if (Array.isArray(item) &amp;&amp; depth ) &#123; result.push(...MyFlat(item, depth - 1)); &#125; else &#123; result.push(item); &#125; &#125;) return result;&#125;const array = [1, 2, [3, 4, [5, 6], 7], 8, 9];console.log(MyFlat(array)); // [ 1, 2, 3, 4, [ 5, 6 ], 7, 8, 9 ] 递归实现 （全量）1234567891011121314function fn(arr) &#123; let result = []; arr.forEach(item =&gt; &#123; if (item instanceof Array) &#123; result = result.concat(fn(item)); &#125; else &#123; result.push(item); &#125; &#125;); return result;&#125;const array = [1, 2, [3, 4, [5, 6], 7], 8, 9];console.log(fn(array)); // [1, 2, 3, 4, 5, 6, 7, 8, 9] reduce 实现 （全量）12345678function fn(arr) &#123; return arr.reduce((prev, cur) =&gt; &#123; return prev.concat(Array.isArray(cur) ? fn(cur) : cur); &#125;, []);&#125;const array = [1, 2, [3, 4, [5, 6], 7], 8, 9];console.log(fn(array)); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 拍平一层的方式ES6 解构： 123const array = [1, 2, [3, 4, [5, 6], 7], 8, 9];const flattened = [].concat(...array);console.log(flattened); // [ 1, 2, 3, 4, [ 5, 6 ], 7, 8, 9 ] ES6 之前： 123const array = [1, 2, [3, 4, [5, 6], 7], 8, 9];const flattened = [].concat.apply([], array);console.log(flattened); // [ 1, 2, 3, 4, [ 5, 6 ], 7, 8, 9 ]","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript 中的作用域","slug":"JavaScript中的作用域","date":"2021-06-11T11:16:33.000Z","updated":"2022-01-06T01:30:53.576Z","comments":true,"path":"2021/06/11/JavaScript中的作用域/","link":"","permalink":"http://example.com/2021/06/11/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 作用域的定义 当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。如果一个变量或者其他表达式不 “在当前的作用域中”，那么它就是不可用的。作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。 从上面的定义出发，可以简单概括为：作用域决定了变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。 作用域分类作用域分为两种 全局作用域 函数作用域 全局作用域特性 全局作用域在当 JavaScript 开始要解释执行代码的时候被创建，整个程序结束的时候被销毁 全局对象在不同的宿主环境下是不同的，在浏览器环境下，全局对象即为window，代表一个浏览器窗口，由浏览器创建，可以直接调用 全局作用域中声明的变量和函数会作为window对象的属性和方法保存，作用域为全局，在任何地方都能访问到 局部作用域特性 调用函数时，函数作用域被创建，函数执行完毕，其作用域被销毁 每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的 在函数作用域中可以访问到全局作用域的变量，在函数外无法直接访问到函数作用域内的变量 在函数作用域中访问变量，会现在自身作用域中查找，如果没有找到，则回到函数的上一级作用域中查找，一直到全局作用域 作用域链(Scope Chain)当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 总结：Javascript 引擎会沿着作用域链(Scope Chain) 寻找需要的变量。 作用域的深层次理解执行上下文JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 在执行函数前，会创建一个执行上下文的内部对象 AO（作用域） 这个内部对象时预编译时被创建出来的，在函数被调用时，会先进行预编译 在全局代码执行前会创建一个执行上下文的对象 GO 预编译函数作用域预编译 创建 AO 对象 找形参和变量声明，将函数内的变量和形参名作为 AO 对象的属性名，值为 undefined 将实参和形参相统一 在函数体中找函数声明，值赋予函数体 全局作用域预编译 创建 GO 对象 找变量声明，将变量名作为 GO 对象的属性名，值为 undefined 找函数声明，值值赋予函数体 参考Scope（作用域） Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找 JavaScript 深入之词法作用域和动态作用域 JavaScript 深入之执行上下文栈 JavaScript 深入之作用域链","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"reduce实现map、forEach、filter方法","slug":"reduce实现map、forEach、filter方法","date":"2021-05-25T11:56:01.000Z","updated":"2022-02-21T07:02:11.044Z","comments":true,"path":"2021/05/25/reduce实现map、forEach、filter方法/","link":"","permalink":"http://example.com/2021/05/25/reduce%E5%AE%9E%E7%8E%B0map%E3%80%81forEach%E3%80%81filter%E6%96%B9%E6%B3%95/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 reduce如何工作reduce()方法对于数组中的每个元素执行一个用户提供的reducer函数（升序执行），将其结果汇总为单个返回值，语法如下： 1arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) reducer 函数接收4个参数: Accumulator (acc) (累计器) Current Value (cur) (当前值) Current Index (idx) (当前索引) Source Array (src) (源数组) 看个简单的例子： 12345678910const source = [1, 2, 3];// 0 + 1 + 2 + 3const initialValue = 0;const sum = source.reduce( (previousValue, currentValue) =&gt; previousValue + currentValue, initialValue);console.log(sum); // 6 可以看到，reduce()方法就是对传入的数组累计执行回调函数，并返回最终计算结果 实现mapmap()的定义：创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值 1234567891011Array.prototype._map = function (fn, callbackThis) &#123; // 最终返回的新数组 const result = []; // 重新定义this let cbThis = callbackThis || null; this.reduce((before, after, index, array) =&gt; &#123; result.push(fn.call(cbThis, array[index], index, array)) &#125;, null) return result;&#125; 1234// 验证const arr = [1, 2, 3];const res = arr._map((current) =&gt; current * 2);console.log(res); // [2, 4, 6] 实现forEachforEach()的定义：对数组的每个元素执行一次给定的函数 1234567Array.prototype._forEach = function (fn, callbackThis) &#123; // 重新定义this let cbThis = callbackThis || null; this.reduce((before, after, index, array) =&gt; &#123; fn.call(cbThis, array[index], index, array); &#125;, null)&#125; 1234567// 验证const arr = [1, 2, 3];const res = arr._forEach((current) =&gt; console.log(current * 2));console.log(res);// 2// 4// 6 实现filterfilter()的定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素 123456789Array.prototype._filter = function (fn, callbackThis) &#123; const result = []; // 重新定义this let cbThis = callbackThis || null; this.reduce((before, after, index, array) =&gt; &#123; fn.call(cbThis, array[index], index, array) ? result.push(array[index]) : null; &#125;, null) return result;&#125; 1234// 验证const arr = [1, 2, 3];const res = arr._filter((current) =&gt; current === 2);console.log(res); // [ 2 ] 参考MDN","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"首屏渲染优化","slug":"首屏渲染性能优化","date":"2021-05-04T14:01:13.000Z","updated":"2023-08-03T13:23:37.628Z","comments":true,"path":"2021/05/04/首屏渲染性能优化/","link":"","permalink":"http://example.com/2021/05/04/%E9%A6%96%E5%B1%8F%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 基本概念优化首次加载页面，使得用户能够更快速和页面进行交互 常见指标FP: First Paint，首次绘制，表示浏览器首次绘制出像素的时间点FCP: First Content Paint，首次内容绘制，表示浏览器首次渲染内容，内容可以是文本，图片等（空白的canvas或者SVG不算）FP 和 FCP 是衡量白屏的主要指标。 FP 指的是绘制像素，比如说页面的背景色是灰色的，那么在显示灰色背景时就记录下了 FP 指标。但是此时 DOM 内容还没开始绘制，可能需要文件下载、解析等过程，只有当 DOM 内容发生变化才会触发，比如说渲染出了一段文字，此时就会记录下 FCP 指标。 FMP: First Meaningful Paint，首次有效绘制，表示首次渲染有意义的内容的时间，这是一个较为重要的指标，对于什么是有意义因项目而定，而从FP到FMP这个过程均为白屏LCP：Largest Content Paint，最大内容区域绘制，指页面中最大的内容模块被渲染出来的时间，一般会是内容最多，视口内最大元素渲染出来的时间TTI：Time to Interactive，可交互时间，表示用户能与界面进行交互的时间点（点击、输入）介绍TTI之前，需要讲一下长任务，一个任务耗时超过50ms，就可以被认为是长任务，而执行用户交互的操作也在主线程执行，因而当发生长任务时，用户的输入很可能无法及时执行，此时用户就会感受到卡顿（页面响应时间超过100ms时，用户就能感受到） FID：First Input Delay，首次输入延迟，表示用户首次与页面进行交互是，页面给予反馈的耗时记录在FCP和TTI之间用户与页面交互时响应的延迟，这个延迟出现的原因是浏览器主线程可能在忙于其它工作，比方说解析JS文件 优化手段 提升用户体验 网络层面 图片优化 减少体积 代码层面 提升用户体验白屏可以进行 loading 提示或者股价平，让用户感知到页面存在 如果项目使用了 webpack ，那么可以添加插件html-webpack-plugin，进行loading的配置 网络层面 开启 HTTP2 HTTP2 采用二进制分帧的方式进行通信，而 HTTP1.x 是用文本，HTTP2 的效率更高 HTTP2 可以进行多路复用，即跟同一个域名通信，仅需要一个 TCP 建立请求通道，请求与响应可以同时基于此通道进行双向通信，而 HTTP1.x 每次请求需要建立 TCP ，多次请求需要多次连接，还有并发限制，十分耗时 HTTP2 可以头部压缩,能够节省消息头占用的网络的流量,而HTTP1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源 开启浏览器缓存（配对使用以下响应头字段） If-Modified-Since 和 Last-Modified Etag 和 If-None-Match 静态资源使用 CDN 图片优化对图片进行懒加载处理，或者对小图片进行 base64 编码处理，可以减少网络请求 减少体积 按需加载在项目中往往会使用到各种UI组件，可以进行按需引入 Tree Shaking通过程序流分析找出你代码中无用的代码并剔除 路由懒加载当打包构建应用时，JS 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效 代码层面 使用节流、防抖 减少DOM操作 使用Web Worker 避免重排与重绘","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"读书笔记:Javascript函数式编程指南（四）","slug":"读书笔记:Javascript函数式编程指南（四）","date":"2021-04-16T02:13:29.000Z","updated":"2022-01-11T07:51:22.196Z","comments":true,"path":"2021/04/16/读书笔记:Javascript函数式编程指南（四）/","link":"","permalink":"http://example.com/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 四.函数式编程——针对复杂应用的设计模式（读书笔记：JavaScript函数式编程指南） 今日分享 命令式错误处理异常方式的问题 使用容器，以防访问无效数据 用 Functor 的实现来做数据转换 空引用是一个价值数十亿美元的错误。——Tony Hoare，InfoQ 命令式错误处理的不足在许多情况下都会发生 JavaScript 错误，特别是在与服务器通信时，或是在试图访问一个为 null 对象的属性时。 因此，开发者在编程时总是需要做好最坏的打算。在命令式编程世界中，异常是通过 try-catch 处理的。 用 try-catch 处理错误JavaScript 的异常处理机制通常会以大多数现代语言都有的 try-catch 语句来完成： 12345try &#123; // 可能会抛出异常的代码&#125; catch (e) &#123; console.log(&quot;ERROR&quot; + e.message);&#125; 以该语句包裹住你认为不太安全的代码，一旦有异常发生，JavaScript 会立即终止程序，并创建导致该问题的指令的函数调用堆栈跟踪。有关错误的具体细节，如消息、行号和文件名，被填充到 Error 类型的对象中，并传递到 catch 块中。 12345try &#123; const student = findStudentById(&quot;666&quot;);&#125; catch (e) &#123; console.log(&quot;ERROR&quot; + e.message);&#125; 使用 try-catch 后的代码将不能组合或连在一起，对于函数式编程来说，这将会严重影响代码设计。 函数式程序不应抛出异常命令式的 JavaScript 代码结构有很多缺陷，而且也会与函数式的设计有兼容性问题。会抛出异常的函数存在以下问题： 难以与其他函数组合或链接 违反了引用透明性，因为抛出异常会导致函数调用出现另一出口，所以不能确保单一的可预测的返回值 会引起副作用，因为异常会在函数调用之外对堆栈引发不可预料的影响 违反非局域性的原则，因为用于恢复异常的代码与原始的函数调用渐行渐远。当发生错误时，函数离开局部栈与环境 不能只关注函数的返回值，调用者需要负责声明 catch 块中的异常匹配类型来管理特定的异常 当有多个异常条件时会出现嵌套的异常处理块 1234567891011121314151617181920try &#123; try &#123; throw new Error(&quot;oops&quot;); &#125; catch (ex) &#123; console.error(&quot;inner&quot;, ex.message); throw ex; &#125; finally &#123; console.log(&quot;finally&quot;); &#125;&#125;catch (ex) &#123; console.error(&quot;outer&quot;, ex.message);&#125;// Output:// &quot;inner&quot; &quot;oops&quot;// &quot;finally&quot;// &quot;outer&quot; &quot;oops&quot; 那函数式编程真的不需要抛出异常吗？ 该作者不这么认为。在实践中，很多因素是在控制范围之外的，而且依赖库也有抛出异常的可能。对于某些边缘情况，使用异常可能颇有效率。异常应该由一个地方抛出，而不应该随处可见。 空值（null）检查问题另一种跟抛出异常一样烦人的错误是 null 返回值。虽然 null 返回值保证了函数的出口只有一个，但是也并没有好到哪去——给使用函数的用户带来需要 null 检查的负担。比如获取学生地址与国家的 getCountry 函数： 123456789101112function getUserCountry(student) &#123; let school = student.getSchool(); if (school !== null) &#123; let addr = school.getAddress(); if (addr !== null) &#123; let country = addr.getCountry(); return country; &#125; return null; &#125; throw new Error(&quot;Error extracting country info&quot;);&#125; 这个函数很容易实现，但是需要大量的判空检查。不管是使用 try-catch 还是 null 检查，都是被动的解决方式。 一种更好的解决方案——Functor函数式以一种完全不同的方法应对软件系统的错误处理。其思想说起来也非常简单，就是创建一个安全的容器，来存放危险代码,比方说 try-catch 就可以看作存放着会抛出异常的函数的保险箱。而保险箱可以看作一种容器。 在函数式编程中，仍然会包裹这些危险代码，但可以不用 try-catch 块。使用函数式数据类型是解决不纯性的主要手段。不过，首先从最简单的类型开始。 包裹不安全的值将值包裹起来是函数式编程的一个基本设计模式，因为它直接地保证了值不会被任意篡改。这有点像把值保护起来，只能通过 map 操作来访问该容器中的值。实际上数组的 map，而数组也是值的容器。我们将继续扩展更广义的 map 的概念。 其实，可以映射函数到更多类型，而不仅仅是数组。在函数式 JavaScript 中，map 只不过是一个函数，由于引用透明性，只要输入相同，map 永远会返回相同的结果。当然，还可以认为 map 是可以使用 lambda 表达式变换容器内的值的途径。比如，对于数组，就可以通过 map 转换值，返回包含新值的新数组。 下面用 Wrapper 解释一下这个概念 1234567891011121314class Wrapper &#123; constructor(value) &#123; // 存储任意类型值的简单类型 this.value = value; &#125; // map :: A -&gt; B map(f) &#123; // 用一个函数来 map 该类型（就像数组一样） return f(this.value); &#125;; toString() &#123; return &#x27;Wrapper (&#x27; + this.value + &#x27;)&#x27;; &#125;&#125;// wrap :: A -&gt; Wrapper(A)const wrap = (val) =&gt; new Wrapper(val); // 能够根据值快速创建 Wrapper 的帮助函数 要访问包裹内的对象，唯一办法是 map 一个 Ramda 的 identity 函数（注意，Wrapper 类型并没有 get 方法）。虽然 JavaScript 允许用户方便地访问这个值，但重要的是，一旦该值进入容器，就不应该能被直接获取或转化（就像一个虚拟的屏障），如图1 所示： Wrapper 类型使用 map 安全地访问和操作值。在这种情况下，通过映射 identity 函数就能在容器中提取值。 下面是获取值的例子： 12const wrappedValue = wrap(&#x27;Get Functional&#x27;);wrappedValue.map(R.identity); // &#x27;Get Functional&#x27; &lt;--- 值的提取 其实还可以映射任何函数到该容器，比如变换该值： 1wrappedValue.map(R.toUpper); // &#x27;GET FUNCTIONAL&#x27; &lt;--- 对内部值应用函数 如此一来，所有对值的操作都必须借助 Wrapper.map “伸入”容器，从而使值得到一定的保护。但是 null 或者 undefined 的情况仍然存在，还是需要在映射的函数中去处理。接下来看看解决的方法： 12const wrappedNull = wrap(null);wrappedNull.map(doWork); // doWork 被赋予了空值检查的责任 就像这个例子，由于直接调用函数，完全可以交给 Wrapper 类型来做错误处理。换句话说，可以在调用函数之前，检查 null、空字符串或者负数，等等。因此，Wrapper.map 的语义就由具体的 Wrapper 类型来确定。 继续来看看 map 的变种——fmap： 1234// fmap :: (A -&gt; B) -&gt; Wrapper[A] -&gt; Wrapper[B]Wrapper.prototype.fmap = function (f) &#123; return wrap(f(this.valve)); // &lt;--- 先将返回值包裹到容器中，再返回给调用者&#125;; fmap 知道如何在上下文中应用函数值。它会先打开该容器，应用函数到值，最后把返回的值包裹到一个新的同类型容器中。拥有这种函数的类型称为 Functor。 Functor 定义从本质上讲，Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。下面是 fmap 的一般定义： 1fmap :: (A -&gt; B) -&gt; Wrapper(A) -&gt; Wrapper(B) // &lt;--- Wrapper 可以是任何容器类型 fmap 函数接受一个从 A-&gt;B 的函数，以及一个 Wrapper(A) Functor，然后返回包裹着结果的新 Functor —— Wrapper(B)。图 2 显示了用 increment 函数作为 A-&gt;B 的映射函数，只是这里的 A 和 B 为同一类型。 图 2 Wrapper 内的值 1，在应用函数 increment 后再次包裹成新的容器。 要注意的是，fmap 在每次调用都会返回一个新的副本，是不可变的。 在开始解决更实际的问题之前，再来看一个简单的例子。试用 Functor 来完成简单的 2 + 3 = 5。首先柯里化 add 函数，这样就得到了 plus3 的函数： 12const plus = R.curry((a, b) =&gt; a + b);const plus3 = plus(3); 现在可以把数字 2 放到 Wrapper 中： 1const two = wrap(2); 再调用 fmap 把 plus3 映射到容器上： 12const five = two.fmap(plus3); //-&gt; Wrapper(5) &lt;--- 返回一个具有上下文包裹的值five.map(R.identity); //-&gt; 5 fmap 返回同样类型的结果，可以通过映射 R.identity 来提取它的值。不过需要注意的是，值会一直在容器中，因此可以 fmap 任意次函数来转换值。 1two.fmap(plus3).fmap(plus10); //-&gt; Wrapper(15) 光看代码可能不够直观，图 3 更清楚地解释了如何 fmapplus3。 图 3 Wrapper 容器中的值是 2。Functor 会将其打开，应用 fmap 的函数，再包裹函数的返回值到新的容器中。fmap 函数会返回同样的类型，这样就可以链式地继续使用 fmap。 12const two = wrap(2);const isFive = two.fmap(plus3).fmap(R.equals(5)); //-&gt; Wrapper(true) &lt;--- 返回一个具有上下文包裹的值 这种链式的函数调用是不是非常眼熟？其实很多人一直在使用 Functor 却没有意识到而已。比如 Array的 map 和 filter 方法： 12map :: (A -&gt; B) -&gt; Array(A) -&gt; Array(B)filter :: (A -&gt; Boolean) -&gt; Array(A) -&gt; Array(A) map 和 filter 都返回同样类型的 Functor，因此可以不断地链接。来看看另一个 Functor：compose。正如之前分享提到的，这是从一个函数到另一个函数的映射（也保持类型不变）： 1compose :: (B -&gt; C) -&gt; (A -&gt; B) -&gt; (A -&gt; C) Functor 有如下一些重要的属性约束: 必须是无副作用的。 若映射 R.identity 函数可以获得上下文中相同的值，即可证明 Functor 是无副作用的： 1wrap(&#x27;Get Functional&#x27;).fmap(R.identity); //-&gt; Wrapper(&#x27;Get Functional&#x27;) 必须是可组合的。 这个属性的意思是 fmap 函数的组合，与分别 fmap 函数是一样的。 1two.fmap(R.compose(plus3, R.add(5))).map(R.identity); //-&gt; 10 Functor 的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。其实际目的只是创建一个上下文或一个抽象，以便可以安全地应用操作到值，而又不改变原始值。这也是 map 可以将一个数组转换到另一个数组，而不改变原数组的原因。而 Functor 就是这个概念的推广。 Functor 本身并不需要知道如何处理 null。例如 Ramda 中的 R.compose，在收到为 null 的函数引用时就会抛出异常。这完全是预期的行为，并不是设计上的缺陷。因为 Functor 映射从一个类型到另一类型的函数。还有一个更为具体化的函数式数据类型——Monad。Monad 可以简化代码中的错误处理，进而更流畅地进行函数组合。但是它跟 Functor 有什么关系呢？其实，Monad 就是 Functor“伸入”的容器。 如果写过 jQuery 代码，那么应该觉得 Monad 很面熟。 Monad 只是给一些资源提供了抽象，例如一个简单的价值，一个 DOM 元素、事件或 AJAX 调用，这样就可以安全地处理其中包含的数据。比如，jQuery 就可以看作 DOM 的 Monad： 1$(&#x27;#student-info&#x27;).fadeIn(3000).text(student.fullname()); 这段代码的行为之所以像 Monad，是因为 jQuery 可以将 fadeIn 和 text 行为安全地应用到 DOM 上。如果 student-info 面板不存在，将方法应用到空的 jQuery 对象上只会什么也不发生，而不会抛出任何异常。Monad 旨在安全地传送错误，这样应用才具有较好的容错性。 使用 Monad 函数式地处理错误Monad 用于函数式地解决传统错误处理的问题。但在深入这个话题之前，先来了解使用 Functor 的局限性。使用 Functor 可以安全地应用函数到其内部的值，并且返回一个不可变的新 Functor。但如果它遍布在代码中，就会有一些让人不那么顺心的地方。下面来看一个通过 id 获取学生地址的例子。对于这个例子，大概需要两个函数——findStudent 和 getAddress，这两个函数都给值包裹上一个安全的上下文： 123456const findStudent = R.curry(function(db, id) &#123; return wrap(find(db, id)); // &lt;--- 包裹对象获取逻辑，以避免找不到对象所造成的问题 &#125;);const getAddress = function(student) &#123; return wrap(student.fmap(R.prop(&quot;address&quot;))); // 用 Ramda 的 R.prop()函数来 map 对象以获取其地址， 再将结果包裹起来&#125; 然后把这两个函数组合在一起： 1234const studentAddress = R.compose( getAddress, findStudent(DB(&#x27;student&#x27;))); 虽然成功地避免了所有的错误处理代码，但是结果却出乎意料。返回的值是被包裹了两层的 address对象： 1studentAddress(&#x27;666&#x27;); //-&gt; Wrapper(Wrapper(address)) 为了提取这个值，需要两次应用 R.identity 函数： 1studentAddress(&#x27;666&#x27;).map(R.identity).map(R.identity); 在自己的代码中见到两层这样的代码还可以勉强接受，如果出现三四层呢？这个时候，Monad 可以成为更好的解决方案。 Monad：从控制流到数据流Monad 和 Functor 类似，但在处理某些情况时可以带来一些特殊的逻辑。下面就用简单的例子来看看Monad 到底有什么特殊的功能。假如有一个函数 half::Number -&gt;Number（见图 4）： 12Wrapper(2).fmap(half); //-&gt; Wrapper(1)Wrapper(3).fmap(half); //-&gt; Wrapper(1.5) 图 4 Functor 可以将函数应用到包裹的值上。例子中包裹的值会被 2 除。不过，Functor 只管应用函数到值并将结果包裹起来，并不能加额外的逻辑。如果想要限制 half 只应用到偶数，而输入是一个奇数，该怎么办？或许可以返回 null 或抛出异常，但更好的策略是让该函数能给合法的数字返回正确的结果，并忽略不合法的数字。现在假设有一个名为 Empty 的类似 Wrapper 的容器： 1234567const Empty = function (_) &#123; ; // 无操作。 Empty 不会存储任何值，其代表着“空”或“无”的概念&#125;;// map :: (A -&gt; B) -&gt; A -&gt; BEmpty.prototype.map = function() &#123; return this; &#125;; // &lt;--- 类似，将函数 map 到 Empty 上会跳过该操作// empty :: _ -&gt; Emptyconst empty = () =&gt; new Empty(); 为了实现 half 以满足新的需求，可以通过以下方式完成（见图 5）： 1234const isEven = (n) =&gt; Number.isFinite(n) &amp;amp;&amp;amp; (n % 2 == 0); // &lt;--- 区分奇偶数的工具函数const half = (val) =&gt; isEven(val) ? wrap(val / 2) : empty(); // &lt;--- half 函数只会操作偶数，否则会返回一个空的容器half(4); //-&gt; Wrapper(2)half(3); //-&gt; Empty 图 5 函数 half 可以根据输入返回一个包裹好的值或空容器。Monad 用于创建一个带有一定规则的容器，而 Functor 并不需要了解其容器内的值。Functor 可以有效地保护数据，然而当需要组合函数时，即可以用Monad 来安全并且无副作用地管理数据流。在前面的例子中，对于奇数会返回 Empty 而不是 null。所以此后如果想应用函数，就不必在意可能会出现的异常： 12half(4).fmap(plus3); //-&gt; Wrapper(5)half(3).fmap(plus3); //-&gt; Empty &lt;--- 容器知道该如何应用函数，即便其值是非法的 除此之外，Monad 还适用于解决其他问题。这里只讨论如何使用 Monad 来解决命令式错误处理的问题，从而使代码更可读、更易于推理。 以下两个概念非常重要。 Monad:为 Monadic 操作提供抽象接口。 Monadic 类型: 该接口的具体实现。 Monadic 类型类似于上面提到的的 Wrapper 对象。不过每个 Monad 都有不同的用途，可以定义不同的语义便于确定其行为（例如 map 或 fmap）。使用这些类型可以进行链式或嵌套操作，但都应遵循下列接口定义。 类型构造函数: 创建 Monadic 类型（类似于 Wrapper 的构造函数）。 unit 函数: 可将特定类型的值放入 Monadic 结构中（类似于 wrap 和前面看到的 empty 函数）。对于 Monad 的实现来说，该函数也被称为 of 函数。 bind 函数: 可以链式操作，后文将使用更简短的 map。 join 函数: 将两层 Monadic 结构合并成一层。这会对嵌套返回 Monad 的函数特别有用。将这一个接口应用到 Wrapper 类型，就可以重构成以下这种形式。 123456789101112131415161718192021222324class Wrapper &#123; constructor(value) &#123; this.value = value; &#125; // unit 函数 static of(a) &#123; return new Wrapper(a); &#125; // bind 函数（ Functor） map(f) &#123; return Wrapper.of(f(this.value)); &#125; // 压平嵌套的 Wrapper join() &#123; if(!(this.value instanceof Wrapper)) &#123; return this; &#125; return this.value.join(); &#125; // 返回一个当前结构的文本描述 toString() &#123; return `Wrapper ($&#123;this.value&#125;)`; &#125;&#125; Wrapper 使用 Functor 的 map 将数据提升到容器中，这样就可以无任何副作用。通常还可以用_.identity 函数来检查其内容： 123Wrapper.of(&#x27;Hello Monads!&#x27;).map(R.toUpper).map(R.identity); //-&gt; Wrapper(&#x27;HELLO MONADS!&#x27;) map 操作被视为一种中立的 functor，因为它无非只是映射函数到对象，然后关闭它。之后，Monad 给map 加入特殊的功能。join 函数用于逐层扁平化嵌套结构，就像剥洋葱一样。这可以用来消除之前用functor 时发现的问题，如下 所示。扁平化 Monadic 结构 12345678910// findObject :: DB -&gt; String -&gt; Wrapperconst findObject = R.curry(function(db, id) &#123;return Wrapper.of(find(db, id));&#125;);// getAddress :: Student -&gt; Wrapperconst getAddress = function(student) &#123;return Wrapper.of(student.map(R.prop(&#x27;address&#x27;)));&#125;const studentAddress = R.compose(getAddress, findObject(DB(&#x27;student&#x27;)));studentAddress(&#x27;444-44-4444&#x27;).join().get(); // Address 该代码返回一组嵌套的 wrapper，其中 join 操作用于将这种嵌套结构压平成单一的层： 12Wrapper.of(Wrapper.of(Wrapper.of(&#x27;Get Functional&#x27;))).join();//-&gt; Wrapper(&#x27;Get Functional&#x27;) 图 6 为 join 操作的示意图，递归扁平化嵌套结构的 Monad，像剥洋葱一样： Monad 通常有更多的操作，这里提及的最小接口只是其整个 API 的子集。一个 Monad 本身只是抽象，没有任何实际意义。只有实际的实现类型才有丰富的功能。大多数函数式编程的代码只用一些常用的类型就可以消除大量的样板代码，同时还能完成同样的工作。 Monad 实例丰富，例如：Maybe、Either 和 IO，大家有兴趣可以自行查看。 总结 面向对象抛异常的机制让函数变得不纯，把大部分的责任都推到了调用者的尝试——try-catch逻辑上 把值包裹到容器中的模式是为了构建无副作用的代码，把可能不纯的变化包裹成引用透明的过程 使用Functor将函数应用到容器中的值，这是无副作用地、不可变地访问和修改操作 Monad是函数式中用来降低应用复杂度的设计模式，通过这种模式可以将函数编排成安全的数据流程 交错的组合函数和Monadic类型是非常有弹性而且强大的，如Maybe、Either和IO 阮一峰：图解 Monad阮一峰：函数式编程入门教程","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"为什么打开一个页面，会有4个进程？","slug":"为什么打开一个页面，会有4个进程？","date":"2021-03-22T05:07:12.000Z","updated":"2022-01-20T03:06:49.445Z","comments":true,"path":"2021/03/22/为什么打开一个页面，会有4个进程？/","link":"","permalink":"http://example.com/2021/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BC%9A%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 简单回答因为打开1个页面，至少需要1个浏览器进程、1个网络进程、1个GPU进程以及1个渲染进程 相关思维导图 前置知识：线程和进程进程资源分配的最小单元，线程是CPU调度的最小单元。 二者都是一个时间段的描述，是CPU工作时间段的描述，是运行中的程序指令的一种描述，这需要与程序中的代码区别开来。 原因这个问题与浏览器的发展相关，浏览器是从单进程时代发展到多进程时代。 单进程时代顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，其中包含JS引擎、渲染引擎、网络进程、插件进程、GPU进程等等。 如此之多的功能模块在一个进程中，使得浏览器面临以下的窘境： 不稳定 插件容易崩溃 不流畅 所有功能模块都在一个进程中，从线程和进程的关系得知，这意味着同一时刻只有一个模块可以运行，效率不高 不安全 恶意插件、恶意脚本 多进程时代这里以Chrome浏览器为例，它也是第一个采用多进程架构的浏览器，这个架构能容许许多个程序同事运行而互不影响 虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题： 更高的资源占用 更复杂的体系结构 关于安全沙箱采用多进程架构的好处之一是可以使用安全沙箱，沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源， 各个进程的作用这里仍以Chrome浏览器为例 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储功能 渲染进程：核心任务就是将HTML、CSS和JavaScript转换为用户可以与之交互的网页(排版引擎Blink、JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程，出于安全考虑，渲染进程都是运行在沙箱模式下) GPU进程：该进程的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器的普遍需求。最后，Chrome在其多进程架构上也引入了GPU进程。 网络进程：主要负责页面的网络资源加载 插件进程：主要负责插件的运行，因为插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程不会对浏览器和页面造成影响 标题的答案打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。 参考进程和线程的概念、区别及进程线程间通信 Chrome为什么打开一个页面，会有4个进程? Chrome架构：仅仅打开了1个页面，为什么有4个进程？","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"读书笔记:Javascript函数式编程指南（三）","slug":"读书笔记:Javascript函数式编程指南（三）","date":"2021-03-05T06:33:22.000Z","updated":"2022-01-11T07:51:26.450Z","comments":true,"path":"2021/03/05/读书笔记:Javascript函数式编程指南（三）/","link":"","permalink":"http://example.com/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 三.函数式编程——模块化且可重用的代码（读书笔记：JavaScript函数式编程指南） 今日分享 方法链与函数管道的比较 管道函数的兼容条件 柯里化的函数求值 部分应用和函数绑定（略） 1 方法链与函数管道的比较之前提到了连接一系列函数的方法链，从而揭示了一种与众不同的函数式编程风格。还有一种称为管道的方法也可以用来连接函数。 函数的输入和输出对于了解函数本身是十分重要的。Haskell（发音为/ˈhæskəl/）中使用一种符号来描述函数。如图一： 在函数式编程中，函数是输入和输出类型之间的数学映射。举例来说，一个简单的函数 isEmpty，它接收一个字符串并返回一个布尔值，就像这样表示： 1isEmpty :: String -&gt; Boolean 如图二： 该函数是所有 String 类型输入值到所有 Boolean 值之间的引用透明映射。该函数JavaScript的lambda描述形式如下： 12// isEmpty :: String -&gt; Booleanconst isEmpty = (s) =&gt; !s || !s.trim(); 了解函数作为类型映射的性质是理解如何将函数链接和管道化的关键: 方法链接（紧耦合，有限的表现力） 函数的管道化（松耦合，灵活） 1.1 方法链接map和filter函数都以一个数组作为输入并返回一个新的数组。这些函数都可以通过Lodash封装的隐式对象紧密地连接在一起，从而在后台实现对新数据结构的创建。这是上一次分享中一个栗子： 12345678_.chain(names) //&lt;--- 初始化函数链（创建惰性计算函数链来处理给定的数组） .filter(isValid) //&lt;--- 去除非法值 .map((s) =&gt; s.replace(/_/, &quot; &quot;)) //&lt;--- 规范化值 .uniq() // &lt;---去掉重复元素 .map(_.startCase) //&lt;--- 大写首字母 .sort() .value(); //&lt;--- 执行函数链中的所有函数//-&gt; [&#x27;Alonzo Church&#x27;, &#x27;Haskell Curry&#x27;, &#x27;Jon Von Neumann&#x27;, &#x27;Stephen Kleene&#x27;] 比较命令式代码，这的确是一个能够极大提高代码可读性的语法改进。然而，它与方法所属的对象紧紧地耦合在一起，限制链中可以使用的方法数量，也就限制了代码的表现力。这样就只能够使用由Lodash提供的操作，而无法轻松地将不同函数库的（或自定义的）函数连接在一起。(尽管使用 mixin 的方法可以扩展一个对象的功能，但这就需要自己去管理 mixin 对象本身。这里不做讨论) 从高阶函数角度来看，可以一组对数组操作的简单方法序列表示为图三所示的形式。打破函数链的约束就能够自由地排列所有独立的函数操作，而可以使用函数管道来实现这一目的。 1.2 函数的管道化函数式编程能够消除方法链中存在的限制，使得任何函数的组合都更加灵活。管道是松散结合的有向函数序列，一个函数的输出会作为下一个函数的输入。图四抽象地说明了以不同类型对象作为输入的函数的连接方式。 这也是面向对象设计模式中的管道与过滤器模式，它是从函数式编程衍变而来的（其中的过滤器就是各个函数）。 比较图三和图四就会发现一个关键的区别：方法链接通过对象的方法紧密连接；而管道以函数作为组件，将函数的输入和输出松散地连接在一起。但是，为了实现管道，被连接的函数必须在元数（arity）和类型上相互兼容。 2 管道函数的兼容条件面向对象的编程在一些特定情况下（其中之一是认证与授权）偶尔会使用管道。而函数式编程将管道视为构建程序的唯一方法。 通常来说，对于不同的任务，问题的定义与解决方案间总是存在很大的差异。因此，特定的计算必须在特定的阶段进行。这些阶段由不同的函数表征，而所选函数的输入和输出需要满足以下两个兼容条件。 类型——函数的返回类型必须与接收函数的参数类型相匹配。 元数——接收函数必须声明至少一个参数才能处理上一个函数的返回值。 2.1 函数的类型兼容条件在设计函数管道时，函数的返回类型与函数的接收参数之间具有一定程度的兼容性是极其重要的。 由于JavaScirpt是弱类型语言，因此从类型角度来看，无须像使用一些静态类型语言一样太过关注类型。因此，如果一个对象在应用中表现得像某个特定类型，那么它就是该类型。这也被称为鸭子类型：“如果走起来像鸭子，并且像鸭子一样叫，那这就是一只鸭子。” JavaScript的动态调度机制会尝试在对象中查找属性与方法，而不关注类型信息。虽然这非常灵活，但开发者仍然需要了解一个函数所期望的参数类型。使用清晰的定义（例如在代码中使用 Haskell 符号标记）可以使程序更易理解。 正式地讲，仅当 f 的输出类型等同于函数 g 的输入时，两个函数 f 和 g 是类型兼容的。举例来说，一个处理用户输入的简单程序： 12trim :: String -&gt; String &lt;--- 截掉首末空白符normalize :: String -&gt; String &lt;--- 去除横线 此时，normalize的输入与trim的输出服从兼容性的对应关系，因此可以在一个简单的管道序列中调用它们: 123456// trim :: String -&gt; Stringconst trim = (str) =&gt; str.replace(/^\\s*|\\s*$/g, &quot;&quot;);// normalize :: String -&gt; Stringconst normalize = (str) =&gt; str.replace(/\\-/g, &quot;&quot;);normalize(trim(&quot; 444-44-4444 &quot;));//-&gt; &#x27;444444444&#x27; &lt;--- 手动构建系列管道调用两个函数（之后会涉及如何自动化这一过程）。使用带有首末空白符的输入测试 类型固然重要，但在JavaScript中，更关键的是函数元数的兼容性。 2.2 函数与元数：元组的应用元数定义为函数所接收的参数数量，也被称为函数的长度（length）。尽管在其他编程范式中，元数是最基本的，但在函数式编程中，引用透明的必然结果就是，声明的函数参数数量往往与其复杂性成正比。例如，操作一个字符串的函数很可能比具有 3 个或 4 个参数的函数简单得多： 12345678// isValid :: String -&gt; Booleanfunction isValid(str) &#123; &lt;--- 使用简单 ···&#125;// makeAsyncHttp:: String, String, Array -&gt; Booleanfunction makeAsyncHttp (method, url, data) &#123; //&lt;--- 难以使用，因为必须先计算出所有参数 ···&#125; 只具有单一参数的纯函数是最简单的，因为其实现目的非常单纯，也就意味着职责单一。因此，应该尽可能地使用具有少量参数的函数，这样的函数更加灵活和通用。然而，总是使用一元函数并非那么容易。例如，在真实世界中，isValid 函数可能会额外返回一个描述错误信息的值： 12isValid :: String -&gt; (Boolean, String) // &lt;--- 返回含有验证状态或错误信息的结构体isValid(&#x27; 444-444-44444&#x27;); //-&gt; (false, &#x27;Input is too long!&#x27;) 但如何返回两个不同的值呢？函数式语言通过一个称为元组的结构来做到这一点。元组是有限的、有序的元素列表，通常由两个或三个值成组出现，记为(a, b,c)。由此，可以使用一个元组作为isValid函数的返回值——它将状态与可能的错误消息捆绑，作为单个实体返回，并随后传递到另一个函数中（如果需要的话）。 下面详细探讨一下元组。元组是不可变的结构，它将不同类型的元素打包在一起，以便将它们传递到其他函数中。将数据打包返回的方式还包括字面对象或数组等： 1234return &#123;status : false, or return [false, &#x27;Input is too long!&#x27;];message: &#x27;Input is too long!&#x27;&#125;; 但当涉及函数间的数据传输时，元组能够具有更多的优点。 不可变的——一旦创建，就无法改变一个元组的内部内容。 避免创建临时类型——元组可以将可能毫不相关的数据相关联。而定义和实例化一些仅用于数据分组的新类型使得模型复杂并令人费解。 避免创建异构数组——包含不同类型元素的数组使用起来颇为困难，因为会导致代码中充满大量的防御性类型检查。传统上，数组意在存储相同类型的对象。 JavaScript并不原生地支持Tuple数据类型。例如，给定一个Scala中的元组定义： 1var t = (30, 60, 90); 可以像这样访问各个元素： 1var sumAnglesTriangle = (t._1 + t._2 + t._3 = 180); 但是JavaScript已经提供了实现元组所需的所有工具,实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const Tuple = function (/* types */) &#123; const typeInfo = Array.prototype.slice.call(arguments, 0); // &lt;--- 读取参数作为元组的元素类型 const _T = function (/* values */) &#123; // &lt;--- 声明内部类型_T，以保障类型与值匹配 const values = Array.prototype.slice.call(arguments, 0); // &lt;--- 提取参数作为元组内的值 if ( values.some( ( val // &lt;--- 检查非空值。函数式数据类型不允许空值 ) =&gt; val === null || val === undefined ) ) &#123; throw new ReferenceError(&quot;Tuples may not have any null values&quot;); &#125; if (values.length !== typeInfo.length) &#123; // &lt;--- 按照定义类型的个数检查元组的元数 throw new TypeError(&quot;Tuple arity does not match its prototype&quot;); &#125; values.map(function (val, index) &#123; // &lt;--- 使用 checkType 检查每一个值都能匹配其类型定义。其中的元素都可以通过_n 获取， n 为元素的索引（注意是从 1 开始） this[&quot;_&quot; + (index + 1)] = checkType(typeInfo[index])(val); &#125;, this); Object.freeze(this); // &lt;--- 让元组实例不可变 &#125;; _T.prototype.values = function () &#123; // &lt;--- 提取元组中的元素，也可以使用 ES6 的解构赋值把元素赋值到变量上 return Object.keys(this).map(function (k) &#123; return this[k]; &#125;, this); &#125;; return _T;&#125;;// checkType :: Type -&gt; Type -&gt; Type | TypeErrorconst checkType = curry2(function (typeDef, actualType) &#123; if (R.is(typeDef, actualType)) &#123; // &lt;--- 使用 R.is()检查类型信息 return actualType; &#125; else &#123; throw new TypeError( &quot;Type mismatch. Expected [&quot; + typeDef + &quot;] but found [&quot; + typeof actualType + &quot;]&quot; ); &#125;&#125;);checkType(String)(&quot;Curry&quot;); //-&gt; StringcheckType(Number)(3); //-&gt; NumbercheckType(Date)(new Date()); //-&gt; DatecheckType(Object)(&#123;&#125;); //-&gt; ObjectcheckType(String)(42); //-&gt; Throws TypeError 上面定义的元组对象是不可变且长度固定的数据结构，是可用于在函数间通讯的存储了 n 个不同类型值的异构集合。举例来说，可以用元组来快速构建如Status这样的值对象： 1const Status = Tuple(Boolean, String); 下面利用元组来完成用户输入验证：使用了元组的 isValid 函数 12345678910111213// trim :: String -&gt; Stringconst trim = (str) =&gt; str.replace(/^\\s*|\\s*$/g, &quot;&quot;);// normalize :: String -&gt; Stringconst normalize = (str) =&gt; str.replace(/\\-/g, &quot;&quot;);// isValid :: String -&gt; Statusconst isValid = function (str) &#123; if (str.length === 0) &#123; return new Status(false, &quot;Invald input. Expected non-empty value!&quot;); // &lt;--- 声明包含状态（ Boolean）和消息（ String）的类型Status &#125; else &#123; return new Status(true, &quot;Success!&quot;); &#125;&#125;;isValid(normalize(strim(&quot;444-44-4444&quot;))); //-&gt; (true, &#x27;Success!&#x27;) 在软件开发过程中，二元组出现得非常频繁，将其设定为一等的对象非常具有实际意义。在ES6解构赋值特性的支持下，可以简明地将元组值映射到变量中。如下代码使用元组创建了一个名为StringPair的对象。 123456const StringPair = Tuple(String, String);const name = new StringPair(&quot;Barkley&quot;, &quot;Rosser&quot;);[first, last] = name.values();first; //-&gt; &#x27;Barkley&#x27;last; //-&gt; &#x27;Rosser&#x27;const fullname = new StringPair(&quot;J&quot;, &quot;Barkley&quot;, &quot;Rosser&quot;); // &lt;--- 抛出元素不匹配的错误 元组是减少函数元数的方式之一，但还可以使用更好的方式去应对那些不适于元组的情况。通过引入函数柯里化不仅可以降低元数，还可以增强代码的模块化和可重用性。 3 柯里化的函数求值将函数的返回值作为参数传递给一元函数是十分容易的，但如果目标函数需要更多参数呢？ 为了理解JavaScript的柯里化，首先必须了解柯里化的求值和常规（非柯里化的）求值之间的区别。 JavaScript是允许在缺少参数的情况下对常规或非柯里化函数进行调用的。换句话说，如果定义一个函数f(a, b, c)，并只在调用时传递a，JavaScript运行时的调用机制会将b和c设为undefined。如图五： 再看柯里化函数，它要求所有参数都被明确地定义，因此当使用部分参数调用时，它会返回一个新的函数，在真正运行之前等待外部提供其余的参数。图六能够直观地表现这一点： 柯里化是一种在所有参数被提供之前，挂起或“延迟”函数执行，将多参函数转换为一元函数序列的技术。具有三个参数的柯里化函数的定义如下： 1curry(f) :: (a,b,c) -&gt; f(a) -&gt; f(b)-&gt; f(c) 以上符号描述表明，curry是一种从函数到函数的映射，将输入(a, b, c)分解为多个分离的单参数调用。在纯函数式编程语言中（如Haskell），柯里化是原生特性，是任何函数定义中的组成部分。由于JavaScript原生不支持柯里化函数，因此需要编写一些代码来实现它。 我们先从二元参数的手动柯里化例子开始，代码如下所示。 123456789function curry2(fn) &#123; return function (firstArg) &#123; // &lt;--- 第一次调用 curry2，获得第一个参数 return function (secondArg) &#123; // &lt;--- 第二次调用获得第二个参数 return fn(firstArg, secondArg); // &lt;--- 将两个参数应用到函数 fn 上 &#125;; &#125;;&#125; 柯里化是一种词法作用域（闭包），其返回的函数只不过是一个接收后续参数的简单嵌套函数包装器。以下是一个简单应用： 1234567const name = curry2(function (last, first) &#123; return new StringPair(&quot;Barkley&quot;, &quot;Rosser&quot;);&#125;);[first, last] = name(&quot;Curry&quot;)(&quot;Haskell&quot;).values(); // &lt;--- 当给定两个参数时，函数会完全求值first; //-&gt; &#x27;Curry&#x27;last; //-&gt; &#x27;Haskell&#x27;name(&quot;Curry&quot;); //-&gt; Function &lt;--- 当只提供一个参数时，返回一个函数，而不是将第二个参数当作 undefined curry2 能够胜任简单的任务，但是当构建更复杂的功能时，就需要能够自动处理任意数量参数的柯里化函数。 curry是一个很长且复杂的函数，因此与其去解释它令人头疼的实现，不如讨论更为有用的东西（者可以在Lodash和Ramda中找到curry及其另两个版本curryRight和curryN的实现）。可以使用R.curry对任意数量参数的函数进行自动的柯里化。 可以将自动柯里化想象为基于声明参数的数量人工创建对应嵌套函数作用域的过程。柯里化fullname函数如下所示： 1234// fullname :: (String, String) -&gt; Stringconst fullname = function (first, last) &#123; ...&#125; 多个参数会被通过如下形式转换成多个一元函数： 123456// fullname :: String -&gt; String -&gt; Stringconst fullname =function (first) &#123; return function (last) &#123; ... &#125;&#125; 现在来看一些柯里化的实际应用。尤其是，它可以用于实现以下两种流行的设计模式。 仿真函数接口 实现可重用模块化函数模板 3.1 仿真函数工厂在面向对象世界中，接口是用于定义子类必须实现的契约抽象类型。如果创建的接口包含函数findStudent(id)，那么实体类必须实现此函数。下面这段Java示例代码说明了这一点： 123456789101112131415161718192021public interface StudentStore &#123; Student findStudent(String id);&#125;public class DbStudentStore implements StudentStore &#123; public Student findStudent(String ssn) &#123; // ... ResultSet rs = jdbcStmt.executeQuery(sql); while(rs.next())&#123; String id = rs.getString(&quot;id&quot;); String name = rs.getString(&quot;firstname&quot;) + rs.getString(&quot;lastanme&quot;); return new Student(id, name); &#125; &#125;&#125;public class CacheStudentStore implements StudentStore &#123; public Student findStudent(String id) &#123; // ... return cache.get(id); &#125;&#125; 这段代码显示了同一个接口的两个实现：一个从数据库读取；另一个从缓存读取。 但是从调用代码的角度来看，它只关心方法的调用而并不关心来自哪个对象。这就是面向对象设计模式中工厂方法模式的美妙之处。只要使用一个函数工厂就可以了： 12StudentStore store = getStudentStore();store.findStudent(&quot;444-44-4444&quot;); 当然，函数式编程的实现是不容错过的，其解决方案就是柯里化。通过分别创建在存储数据和数组中查找学生对象的函数，就能够将这段Java代码翻译为JavaScript： 12345678910// fetchStudentFromDb :: DB -&gt; (String -&gt; Student)const fetchStudentFromDb = R.curry(function (db, ssn) &#123; // &lt;--- 在 DB对象中查找 return find(db, ssn);&#125;);// fetchStudentFromArray :: Array -&gt; (String -&gt; Student)const fetchStudentFromArray = R.curry(function (arr, ssn) &#123; // &lt;--- 在数组中查找 return arr[ssn];&#125;); 由于这两个函数都是柯里化的，因此可以使用一个通用工厂方法findStudent将函数的定义与求值分离，而其具体的实现细节可能是任意一个查找函数： 12const findStudent = useDb ? fetchStudentFromDb(db) : fetchStudentFromArray(arr);findStudent(&quot;444-44-4444&quot;); 现在findStudent可以传递给其他模块，而其调用者无须了解其具体实现。从可重用的角度来看，柯里化也能够帮助开发者创建函数模板。 3.2 创建可重用的函数模板假设开发者需要配置不同的日志函数来处理应用程序中的不同状态，比如错误、警告以及调试信息等。函数模板会根据创建时的参数数量来定义一系列的相关函数。这里用一个日志相关的库Log4js举例子。以下是一些基本设置： 12const logger = new Log4js.getLogger(&quot;StudentEvents&quot;);logger.info(&quot;Student added successfully!&quot;); 在Log4js的辅助下，还可以做到更多。假设需要在弹出的窗口中显示消息，可以通过配置一个appender来实现： 1logger.addAppender(new Log4js.JSAlertAppender()); 也可以通过配置一个布局，使其输出 JSON 而不是纯文本格式： 1appender.setLayout(new Log4js.JSONLayout()); 开发者可能设置很多的配置，而将这些代码复制并粘贴到每个文件中会导致大量重复。使用柯里化来定义一个可重用的函数模板（如下所示的日志函数模板），将带来最大的灵活性和重用性。 123456789101112131415161718const logger = function (appender, layout, name, level, message) &#123; const appenders = &#123; // &lt;--- 预设 appenders alert: new Log4js.JSAlertAppender(), console: new Log4js.BrowserConsoleAppender(), &#125;; const layouts = &#123; // &lt;--- 预设布局layouts basic: new Log4js.BasicLayout(), json: new Log4js.JSONLayout(), xml: new Log4js.XMLLayout(), &#125;; const appender = appenders[appender]; appender.setLayout(layouts[layout]); const logger = new Log4js.getLogger(name); logger.addAppender(appender); logger.log(level, message, null); // &lt;--- 使用配置好的logger 打印消息&#125;; 通过柯里化 logger，可以集中管理和重用适用于任何场合的日志配置： 123const log = R.curry(logger)(&quot;alert&quot;, &quot;json&quot;, &quot;FJS&quot;);log(&quot;ERROR&quot;, &quot;Error condition detected!!&quot;);// -&gt; this will popup an alert dialog with the requested message 如果要在一个函数或文件中记录多条错误日志，可以灵活地设置除最后一个参数之外的其他参数： 123const logError = R.curry(logger)(&quot;console&quot;, &quot;basic&quot;, &quot;FJS&quot;, &quot;ERROR&quot;);logError(&quot;Error code 404 detected!!&quot;);logError(&quot;Error code 402 detected!!&quot;); curry函数的后续调用在后台被执行，最终生产一个一元函数。事实上，可以通过现有的函数创建新函数，并将任意数量的参数传递给它们，从而逐步实现函数构建。除了能够有效提升代码的可重用性之外，将多元函数转换为一元函数才是柯里化的主要动机。 柯里化的可替代方案是部分应用和函数绑定，它们受到JavaScript语言的适度支持，以产生更小的功能，在插入功能管道时也能很好地工作。 4 部分应用和函数绑定部分应用是一种通过将函数的不可变参数子集初始化为固定值来创建更小元数函数的操作。简单来说，如果存在一个具有五个参数的函数，给出三个参数后，就会得到一个、两个参数的函数。和柯里化一样，部分应用也可以用来缩短函数的长度，但又稍有不同。因为柯里化的函数本质上是部分应用的函数，所以这两种技术往往会被互相混淆。它们的主要区别在于参数传递的内部机制与控制。 柯里化在每次分步调用时都会生成嵌套的一元函数。在底层，函数的最终结果是由这些一元函数的逐步组合产生的。同时，curry 的变体允许同时传递一部分参数。因此，可以完全控制函数求值的时间与方式。 部分应用将函数的参数与一些预设值绑定（赋值），从而产生一个拥有更少参数的新函数。该函数的闭包中包含了这些已赋值的参数，在之后的调用中被完全求值。 现在，既然已经明确两者的不同，下面继续研究partial函数可能的实现方式，如下所示。 1234567891011121314151617function partial() &#123; let fn = this, boundArgs = Array.prototype.slice.call(arguments); let placeholder = &lt;&lt;partialPlaceholderObj&gt;&gt;; // &lt;--- 库中的具体占位符实现，像 Lodash 会使用下画线对象作为占位符。其他的实现使用 undefined 来表示应该略过该参数 let bound = function() &#123; // &lt;--- 使用部分应用的参数创建新的函数 let position = 0, length = args.length; let args = Array(length); for (let i = 0; i &lt; length; i++) &#123; args[i] = boundArgs[i] === placeholder // &lt;--- 其中 placeholder 对象略过了定义函数的参数 ? arguments[position++] : boundArgs[i]; &#125; while (position &lt; arguments.length) &#123; args.push(arguments[position++]); &#125; return fn.apply(this, args); // &lt;--- 使用 fn.apply()给定函数合适的上下文，并将参数列表应用到函数的参数上 &#125;; return bound;&#125;); 对于部分应用和函数绑定的讨论，再次使用Lodash，因为它对函数绑定提供了比Ramda更好的支持。然而从表面来看，_.partial与R.curry的使用方式非常相似，并且都支持使用各自的占位符对象对参数进行占位。应用于之前看到的 logger 函数，就通过部分应用部分参数来创建更具体的行为： 1const consoleLog = _.partial(logger, &quot;console&quot;, &quot;json&quot;, &quot;FJS Partial&quot;); 下面用该函数加强对curry与partial之间差异的认识。在应用了三个参数之后，生成的consoleLog函数会在调用时接收另外的两个参数（一次性的，而不是一步一步地传入）。与柯里化不同，只使用一个参数调用consoleLog并不会返回一个新的函数，而是会以undefined作为最后一个参数来执行。但是，可以像下面这样继续使用_.partial 将部分参数应用于consoleLog： 12const consoleInfoLog = _.partial(consoleLog, &quot;INFO&quot;);consoleInfoLog(&quot;INFO logger configured with partial&quot;); 柯里化是一种部分应用的自动化使用方式，这是它与partial本身的主要区别。另一种类似的JavaScript原生技术称为函数绑定，即Function.prototype.bind()。但其作用与partial有所不同： 12const log = _.bind(logger, undefined, &quot;console&quot;, &quot;json&quot;, &quot;FJS Binding&quot;);log(&quot;WARN&quot;, &quot;FP is too awesome!&quot;); _.bind的第二个参数undefined是什么呢？使用绑定能够创建绑定函数，该函数可在一个所属对象的上下文中执行（传递undefined表示该函数将在全局作用域中运行）。来看看_.partial和_.bind的一些实际用途： 核心语言扩展 惰性函数绑定 4.1 核心语言扩展在增强语言的表现力方面，部分应用可用于扩展如 String 或 Number 这样的核心数据类型的实用功能。注意，如果语言中加入了可造成冲突的新方法，以这种方式扩展语言可能会使代码很难在平台升级的过程中移植。考虑下面的例子： 12345678910111213141516171819// Take the first N charactersString.prototype.first = _.partial(String.prototype.substring, 0, _); // &lt;--- 使用占位符，可以部分应用 substring 一个参数 0，从而创建期待一个偏移量参数的函数&quot;Functional Programming&quot;.first(3); // -&gt; &#x27;Fun&#x27;// Convert any name into a Last, First formatString.prototype.asName = _.partial( String.prototype.replace, /(\\w+)\\s(\\w+)/, &quot;$2, $1&quot;); // &lt;--- 部分应用参数来创建具体的行为&quot;Alonzo Church&quot;.asName(); //-&gt; &#x27;Church, Alonzo&#x27;// Converts a string into an arrayString.prototype.explode = _.partial(String.prototype.match, /[\\w]/gi); // &lt;--- 部分应用 match 方法，给定具体的正则表达式，得到能将字符串转换成数组的函数&quot;ABC&quot;.explode(); //-&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]// Parses a simple URLString.prototype.parseUrl = _.partial( String.prototype.match, //&lt;--- 部分应用 match 方法，给定具体的正则表达式，得到能将字符串转换成数组的函数 /(http[s]?|ftp):\\/\\/([^:\\/\\s]+)\\.([^:\\/\\s]&#123;2,5&#125;)/);&quot;http://example.com&quot;.parseUrl(); // -&gt; [&#x27;http&#x27;, &#x27;example&#x27;, &#x27;com&#x27;] 在实现自己的函数之前，首先要进行存在性检查，以便适用于新的语言版本升级： 123if (!String.prototype.explode) &#123; String.prototype.explode = _.partial(String.prototype.match, /[\\w]/gi);&#125; 在一些特定情况下，部分应用会失效，例如当用于（如setTimeout）延迟函数时。这时就需要使用函数绑定来实现。 4.2 延迟函数绑定当期望目标函数使用某个所属对象来执行时，使用函数绑定来设置上下文对象就变得尤为重要。 例如，浏览器中的setTimeout和setInterval等函数，如果不将 this 的引用设为全局上下文，即window对象，是不能正常工作的。传递 undefined 在运行时正确设置它们的上下文。例如，setTimeout可用于创建一个简单的调度对象来执行延迟的任务。以下是使用_.bind 和_.partial的示例： 123456789101112const Scheduler = (function () &#123; const delayedFn = _.bind(setTimeout, undefined, _, _); return &#123; delay5: _.partial(delayedFn, _, 5000), delay10: _.partial(delayedFn, _, 10000), delay: _.partial(delayedFn, _, _), &#125;;&#125;)();Scheduler.delay5(function () &#123; consoleLog(&quot;Executing After 5 seconds!&quot;);&#125;); 使用Scheduler，可以将任何一段代码包含在函数体中延迟的执行（运行时是无法确保计时器的精准的，但这是另一个问题）。由于 bind 和 partial 都是返回另一个函数的函数，因此可以很容易地嵌套使用。如前面的代码所示，每一个延迟操作都基于函数绑定和部分应用函数的合。在函数式编程中，函数绑定并不像部分应用那么有用，而且使用起来也比较投机，因为它会重新设置函数的上下文。 部分应用和柯里化都是十分有用的技术。柯里化技术使用得非常广泛，通常用于创建可抽象函数行为的函数包装器，可预设其参数或对其部分求值。其优势源于具有较少参数的纯函数比较多参数的函数更易使用。两种方法都有助于向函数提供正确的参数，这样函数就不必在减少为一元函数时公然地访问其作用域之外的对象。这种分离参数获取逻辑的方式使得函数具有更好的可重用性。更重要的是，它简化了函数的组合。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript 中的 var，let 和 const 有什么区别","slug":"JavaScript 中的 var，let 和 const 有什么区别","date":"2021-02-05T13:09:05.000Z","updated":"2023-08-12T10:10:55.709Z","comments":true,"path":"2021/02/05/JavaScript 中的 var，let 和 const 有什么区别/","link":"","permalink":"http://example.com/2021/02/05/JavaScript%20%E4%B8%AD%E7%9A%84%20var%EF%BC%8Clet%20%E5%92%8C%20const%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 区别概述 变量提升 暂时性死区 块级作用域 重复声明 修改声明的变量 变量提升var 声明的变量存在提升，即变量可以在声明之前调用，提升时不做初始化操作，故只为 undefined let、const 不存在变量提升，故而用这两个关键字时，一定要在声明后使用 暂时性死区var 不存在暂时性死区 let、const 存在暂时性死区，在变量被声明之后，才可以获取或使用该变量 块级作用域var 不存在块级作用域 let、const 存在块级作用域 重复声明var 允许重复声明变量 let 和 const 在同一作用域不允许重复声明变量 修改变量var 和 let 可以随意修改声明的变量的值 const 一般用来声明一个只读的常量，一旦声明，常量的值就不能改变。但实际上 const 保证的是变量指向的内存地址不变 对于简单类型的数据，值就保存在变量指向的内存地址，因此等同于常量。 对于复杂类型的数据，变量指向的内存地址保存的是一个指向实际数据的指针，const 只能保证这个指针是固定的，至于实际指向的数据是可以变的 参考面试官：说说 var、let、const 之间的区别let 和 const 命令JavaScript 中的 Var，Let 和 Const 有什么区别块级作用域：var 缺陷以及为什么要引入 let 和 const","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"读书笔记:Javascript函数式编程指南（二）","slug":"读书笔记:Javascript函数式编程指南（二）","date":"2021-01-15T03:33:09.000Z","updated":"2022-02-21T07:05:44.204Z","comments":true,"path":"2021/01/15/读书笔记:Javascript函数式编程指南（二）/","link":"","permalink":"http://example.com/2021/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 今日分享: 如何创建易于推断的代码 轻数据结构，重操作理解程序中控制流程序为实现业务目标所要进行的路径被成为控制流。 命令式程序需要通过暴露所有的必要步骤才能极其详细地描述其控制流。这些步骤通常涉及大量的循环和分支，以及随语句执行变化的各种变量。 简单的命令式程序大致可以这样描述: 1234567891011var loop = optC();while (loop) &#123; var condition = optA(); if (condition) &#123; optB1(); &#125; else &#123; optB2(); &#125; loop = optC();&#125;optD(); 如下图所示： 然而，声明式程序，特别是函数式程序，则多使用以简单拓扑连接的独立黑盒操作组合而成的较小结构化控制流，从而提升程序的抽象层次。 这些连接在一起的操作只是一些能够将状态传递至下一个操作的高阶函数，如下图所示。使用函数式开发风格操作数据结构，其实就是将数据与控制流视为一些高级组件的简单连接。 使用这种方式可以形成类似这样的代码： 1optA().optB().optC().optD(); 采用这种链式操作能够使程序简洁、流畅并富有表现力，能够从计算逻辑中很好地分离控制流，因此可以使得代码和数据更易推理。 链接方法方法链是一种能够在一个语句中调用多个方法的面向对象编程模式。当这些方法属于同一个对象时，方法链又称为方法级联。 尽管该模式大多出现在面向对象的应用程序中，但在一些特定条件下，如操作不可变对象时，也能很好地用于函数式编程中。 既然在函数式代码中是禁止修改对象的，又如何能使用这种方法链模式呢？让我们来看一个字符串处理的例子： 1&quot;Functional Programming&quot;.substring(0, 10).toLowerCase() + &quot; is fun&quot;; 在这个中，substring 和 toLowerCase 都是（通过 this）在隶属的字符串对象上操作并返回一个新字符串的方法。JavaScript 中字符串的加号（+）运算符被重载为连接字符串操作的语法糖，它也会返回一个新的字符串。通过一系列变换后的结果与原先字符串毫无引用关系，而原先的字符串也不会有任何变化。 这种行为是理所当然的，因为按照设计，字符串是不可变的。从面向对象的角度来看，这没有什么特别的。但从函数式编程的角度来看，这是一种理想行为。 如果用更加函数式的风格重构上面的代码，它会像这样： 1concat(toLowerCase(substring(&#x27;Functional Programming&#x27;, 1, 10))),&#x27; is fun&#x27;); 这段代码符合函数式风格，所有参数都应在函数声明中明确定义，而且它没有副作用，也不会修改的原有对象。 但可以说，这样的代码写起来并没有方法链流畅。而且它也更难阅读，因为需要一层层地剥离外部函数，才能知晓内部真正发生的事情。 只要遵守不可变的编程原则，函数式中也会应用这种隶属于单个对象实例的方法链。能用该模式来处理数组变换吗？ 函数链面向对象程序将继承作为代码重用的主要机制。子类继承了父类的所有状态和方法，例如在 Java 中，有一大堆继承于基础接口 List 的各种实体 List 类，如 ArrayList、LinkedList、DoublyLinkedList、CopyOnWrite ArrayList 等，它们都源自共同的父类，并各自添加了一些特定的功能。 函数式编程则采用了不同的方式。它不是通过创建一个全新的数据结构类型来满足特定的需求，而是使用如数组这样的普通类型，并施加在一套粗粒度的高阶操作之上，这些操作是底层数据形态所不可见的。 这些操作会作如下设计: 接收函数作为参数，以便能够注入解决特定任务的特定行为。 代替充斥着临时变量与副作用的传统循环结构，从而减少所要维护以及可能出错的代码。 继续之前，我们先看一些东西并暂时记住它 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Person classclass Person &#123; constructor(firstname, lastname, ssn) &#123; this._firstname = firstname; this._lastname = lastname; this._ssn = ssn; this._address = null; this._birthYear = null; &#125; get ssn() &#123; return this._ssn; &#125; get firstname() &#123; return this._firstname; &#125; get lastname() &#123; return this._lastname; &#125; get address() &#123; return this._address; &#125; get birthYear() &#123; return this._birthYear; &#125; set birthYear(year) &#123; this._birthYear = year; &#125; set address(addr) &#123; this._address = addr; &#125; toString() &#123; return `Person($&#123;this._firstname&#125;, $&#123;this._lastname&#125;)`; &#125;&#125;const p1 = new Person(&quot;Haskell&quot;, &quot;Curry&quot;, &quot;111-11-1111&quot;);p1.address = new Address(&quot;US&quot;);p1.birthYear = 1900;const p2 = new Person(&quot;Barkley&quot;, &quot;Rosser&quot;, &quot;222-22-2222&quot;);p2.address = new Address(&quot;Greece&quot;);p2.birthYear = 1907;const p3 = new Person(&quot;John&quot;, &quot;von Neumann&quot;, &quot;333-33-3333&quot;);p3.address = new Address(&quot;Hungary&quot;);p3.birthYear = 1903;const p4 = new Person(&quot;Alonzo&quot;, &quot;Church&quot;, &quot;444-44-4444&quot;);p4.address = new Address(&quot;US&quot;);p4.birthYear = 1903; lambda 表达式lambda 表达式（在 JavaScript 中也被称为箭头函数）源自函数式编程，比起传统的函数声明，它可以采用相对简洁的语法形式来声明一个匿名函数。 尽管 lambda 函数也可以写成多行形式，但单行是最普遍的形式。使用 lambda 表达式或普通函数声明语法一般只会影响到代码的可读性，其本质是一样的。 下面是一个可用于提取个人姓名的示例函数： 12const name = (p) =&gt; p.fullname;console.log(name(p1)); //-&gt; &#x27;Haskell Curry&#x27; (P) =&gt; p.fullname 这种简洁的语法糖表明它只接收一个参数 p 并隐式地返回 p.fullname。 lambda 表达式适用于函数式的函数定义，因为它总是需要返回一个值。对于单行表达式，其返回值就是函数体的值。 另一个值得注意的是一等函数与 lambda 表达式之间的关系。函数名代表的不是一个具体的值，而是一种（惰性计算的）可获取其值的描述。换句话说，函数名指向的是代表着如何计算该数据的箭头函数。这就是在函数式编程中可以将函数作为数值使用的原因。之后会深入讨论惰性计算函数。 很多函数式的 JavaScript 代码都需要处理数据列表，这也就是衍生 JavaScript 的函数式语言鼻祖起名为 LISP（列表处理）的原因。JavaScript 5.1 本身就提供特定版本的该类操作——称为函数式array extras,也就是forEach、map``reduce 以及 filter 这些函数，它们都能够与 lambda 表达式良好地配合使用。 代码推理“代码推理”到底是什么意思呢？ 之前的章节用“松散”这个词来表征分析一个程序任何一个部分，并建立相应心智模型的难易程度。 该模型分为两部分：动态部分包括所有变量的状态和函数的输出，而静态部分包含可读性以及设计的表达水平。 两个部分都很重要。不可变性和纯函数会使得该模型的构建更加容易。之前的内容强调将高阶操作链接起来构成程序的价值。 命令式的程序流与函数式的程序流有着本质的不同。函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的。 声明式惰性计算函数链之前提到，函数式程序是由一些简单函数组成的，尽管每个函数只完成一小部分功能，但组合在一起就能够解决很多复杂的任务。 函数式编程的声明式模型将程序视为对一些独立的纯函数的求值，从而在必要的抽象层次之上构建出流畅且表达清晰的代码。这样就可以构成一个能够清晰表达应用程序意图的本体或词汇表。使用如map、reduce 和 filter 这样的基石来搭建纯函数，可使代码易于推理并一目了然。 这个层次的抽象的强大之处在于，它会使开发者开始认识到各种操作应该对所采用的底层数据结构不可见。从理论上说，无论是使用数组、链表、二叉树还是其他数据结构，它都不应该改变程序原本的语义。正是出于这个原因，函数式编程选择更关注于操作而不是数据结构。 例如，假设需要对一组姓名进行读取、规范化、去重，最终进行排序。首先写一个命令式的版本，然后再重构成函数式的风格。 1234567const names = [ &quot;alonzo church&quot;, &quot;Haskell curry&quot;, &quot;stephen_kleene&quot;, &quot;John Von Neumann&quot;, &quot;stephen_kleene&quot;,]; 12345678910111213141516171819let result = [];for (let i = 0; i &lt; names.length; i++) &#123; //&lt;--- 遍历数组中的所有名字 let n = names[i]; if (n !== undefined &amp;amp;&amp;amp; n !== null) &#123; //&lt;--- 检查所有词是否都合法 let ns = n.replace(/_/, &quot; &quot;).split(&quot; &quot;); //&lt;--- 数组包含格式不一致的数据。这是规范化（修复）元素的步骤 for (let j = 0; j &lt; ns.length; j++) &#123; let p = ns[j]; p = p.charAt(0).toUpperCase() + p.slice(1); ns[j] = p; &#125; if (result.indexOf(ns.join(&quot; &quot;)) &lt; 0) &#123; //&lt;--- 检查是否已存在于结果中，以去除重复的元素 result.push(ns.join(&quot; &quot;)); &#125; &#125;&#125;result.sort(); // &lt;--- 数组排序 命令式代码的缺点是限定于高效地解决某个特定的问题。例如，这段代码用于解决上述的问题。比起函数式代码，其抽象水平要低得多。抽象层次越低，代码重用的概率就会越低，出现错误的复杂性和可能性就会越大。此外，函数式的实现不过是将各种黑盒组件连接在一起，将重任赋予如map、reduce 和 filter这些成熟且经过测试的 API。请注意，级联排列的函数调用可以使该代码更易阅读。 123456789_.chain(names) //&lt;--- 初始化函数链（创建惰性计算函数链来处理给定的数组） .filter(isValid) //&lt;--- 去除非法值 .map((s) =&gt; s.replace(/_/, &quot; &quot;)) //&lt;--- 规范化值 .uniq() &lt; ---去掉重复元素 .map(_.startCase) //&lt;--- 大写首字母 .sort() .value(); //&lt;--- 执行函数链中的所有函数//-&gt; [&#x27;Alonzo Church&#x27;, &#x27;Haskell Curry&#x27;, &#x27;Jon Von Neumann&#x27;, &#x27;Stephen Kleene&#x27;] 这样的代码看起来舒服很多，不仅是因为代码量的减少，还因为其结构简单明了。 现在我们可以更深刻明白为什么函数式的程序是如此优越。能够写得如此流畅与函数式编程中的纯性以及无副作用的基本原则息息相关。链中的每个函数都以一种不可变的方式来处理由上一个函数构建的新数组。Lodash 利用函数链这种模式，通过调用_.chain()提供了一种基础功能，以满足各种需求。这有助于过渡到对 point-free 编程风格的理解。pointfree 是函数式编程的特色，会在之后分享。 能够惰性地定义程序的管道不止有可读性这一个好处。由于以惰性计算方式编写的程序会在运行前定义好，因此可以使用数据结构重用或者方法融合等技术对其进行优化。这些优化不会减少执行函数本身所需的时间，但有助于消除不必要的调用。之后会更详细解释。 类 SQL 的数据：函数即数据比如map、reduce、filter等。将这些函数组成一个列表，可用来梳理数据相关的信息。如果在更高层面细细思考，就会发现这些函数与SQL相似，这不是偶然的。 123SELECT p.firstname, p.birthYear FROM Person pWHERE p.birthYear &gt; 1903 and p.country IS NOT &#x27;US&#x27;GROUP BY p.firstname, p.birthYear 事实证明，在构建程序时，使用查询语言来思考与函数式编程中操作数组类似——使用通用关键字表或代数方法来增强对数据及其结构的深层次思考。 Lodash 支持一种称为 mixins 的功能，可以用来为核心库扩展新的函数，并使得它们可以以相同的方式连接： 123456_.mixin(&#123; select: _.pluck, from: _.chain, where: _.filter, groupBy: _.sortByOrder,&#125;); 编写类似 SQL 的 JavaScript 代码: 123456_.from(persons) .where((p) =&gt; p.birthYear &gt; 1900 &amp;amp;&amp;amp; p.address.country !== &quot;US&quot;) .groupBy([&quot;firstname&quot;, &quot;birthYear&quot;]) .select(&quot;firstname&quot;, &quot;birthYear&quot;) .value();//-&gt; [&#x27;Alan&#x27;, &#x27;Barkley&#x27;, &#x27;John&#x27;] 上面的代码创建了一个 SQL 关键字到对应别名函数的映射，从而可以更深刻地理解一个查询语言的函数式特性。 递归另一种用于替换循环的常见技术是递归，尤其当处理一些“自相似”的问题时，可以用其来抽象迭代。对于这些类型的问题，序列函数链会显得效率低下或不适用。而递归实现了自己的处理数据的方式，从而大大缩短了标准循环的执行时间。 在 JavaScript 中，递归具有许多应用场景，例如解析 XML、HTML 文档或图形等。 什么是递归？递归是一种旨在通过将问题分解成较小的自相似问题来解决问题本身的技术，将这些小的自相似问题结合在一起，就可以得到最终的解决方案。递归函数包含以下两个主要部分。 基例（终止条件） 递归条件 基例是能够令递归函数计算出具体结果的一组输入，而不必再重复下去。递归条件则处理函数调用自身的一组输入（必须小于原始值）。如果输入不变小，那么递归就会无限期地运行，直至程序崩溃。 随着函数的递归，输入会无条件地变小，最终到达触发基例的条件，以一个值作为递归过程的终止。 栗子：递归求和 12345678function sum(arr) &#123; if(_.isEmpty(arr)) &#123; &lt;---// 基例（终止条件） return 0; &#125; return _.first(arr) + sum(_.rest(arr)); //&lt;--- 递归条件：使用更小一些的输入集调用自身。这里通过_.first和_.rest缩减输入集&#125;sum([]); //-&gt; 0sum([1,2,3,4,5,6,7,8,9]); //-&gt;45 递归定义的数据结构person 对象示例数据中的那些名字。20 世纪 20 年代，函数式编程（lambda 演算、范畴论等）背后的数学社区非常活跃。大部分发表的研究成果都是融合一些由 Alonzo Church 这样的知名大学教授提出的思想和定理。事实上，许多数学家，如 Barkley Rosser、Alan Turing 和 Stephen Kleene 等，都是 Church 的博士生。后来他们也有了自己的博士生。下图为这种师徒关系（的一部分）的示意图。 这种结构在软件中是很寻常的，它可用于建模 XML 文档、文件系统、分类法、种别、菜单部件、逐级导航、社交图谱等，所以学习如何处理它们至关重要。图 3.8 显示了一组节点，其连线表示了导师-学生这一关系。到目前为止，我们已经利用函数式技术解析过一些扁平化的数据结构，如数组。但这些操作对树形数据是无效的。因为 JavaScript 没有内置的树型对象，所以需要基于节点创建一种简单的数据结构。节点是一种包含了当前值、父节点引用以及子节点数组的对象。 节点对象的定义 123456789101112131415161718192021222324252627282930class Node &#123; constructor(val) &#123; this._val = val; this._parent = null; this._children = []; &#125; isRoot() &#123; return isValid(this._parent); &lt;--- 之前创建的函数 &#125; get children() &#123; return this._children; &#125; hasChildren() &#123; return this._children.length &gt; 0; &#125; get value() &#123; return this._val; &#125; set value(val) &#123; this._val = val; &#125; append(child) &#123; child._parent = this; //&lt;--- 设置父节点 this._children.push(child); //&lt;--- 将孩子节点加入孩子列表中 return this; //&lt;--- 返回该节点（便于方法级联） &#125; toString() &#123; return `Node (val: $&#123;this._val&#125;, children: $&#123;this._children.length&#125;)`; &#125;&#125; 可以这样创建一个新节点： 1const church = new Node(new Person(&quot;Alonzo&quot;, &quot;Church&quot;, &quot;111-11-1111&quot;)); // &lt;--- 重复树中的所有节点 树是包含了一个根节点的递归定义的数据结构： 1234567891011121314151617181920212223class Tree &#123; constructor(root) &#123; this._root = root; &#125; static map(node, fn, tree = null) &#123; //&lt;--- 使用静态方法以免与Array.prototype.map 混淆。静态方法也能像单例函数一样高效 node.value = fn(node.value); //&lt;--- 调用遍历器函数，并更新树中的节点值 if (tree === null) &#123; tree = new Tree(node); //&lt;--- 与 Array.prototype.map 类似。结果是一个新的结构 &#125; if (node.hasChildren()) &#123; //&lt;--- 如果节点没有孩子，则返回（基例） _.map(node.children, function (child) &#123; //&lt;--- 将函数应用到每一个孩子节点 Tree.map(child, fn, tree); //&lt;--- 递归地调用每一个孩子节点 &#125;); &#125; return tree; &#125; get root() &#123; return this._root; &#125;&#125; 节点的主要逻辑在于 append 方法。要给一个节点追加一个子节点，需要将该节点设置为子节点的 parent 引用，并把子节点添加至该节点的子节点列表中。通过从根部不断地将节点链接到其他子节点来填充一棵树，由 church 开始： 1234church.append(rosser).append(turing).append(kleene);kleene.append(nelson).append(constable);rosser.append(mendelson).append(sacks);turing.append(gandy); 每个节点都包裹着一个 person 对象。递归算法执行整个树的先序遍历，从根开始并且下降到所有子节点。由于其自相似性，从根节点遍历树和从任何节点遍历子树是完全一样的，这就是递归定义。为此，可以使用与 Array.prototype.map 语义类似的高阶函数 Tree.map——它接收一个对每个节点求值的函数。可以看出，无论用什么数据结构来建模（这里是树形数据结构），该函数的语义应该保持不变。从本质上讲，任何数据类型都可以使用 map 并保持其结构不变。 树的先序遍历按照以下步骤执行，从根节点开始。 显示根元素的数据部分。 通过递归地调用先序函数来遍历左子树。 以相同的方式遍历右子树。 下图显示了算法采用的路径： 函数 Tree.map 有两个必需的输入：根节点（即树的开始）以及转换每个节点数值的迭代函数： 1Tree.map(church, (p) =&gt; p.fullname); 它以先序方式遍历树，并将给定的函数应用于每个节点，输出以下结果： 12&#x27;Alonzo Church&#x27;, &#x27;Barkley Rosser&#x27;, &#x27;Elliot Mendelson&#x27;, &#x27;Gerald Sacks&#x27;, &#x27;AlanTuring&#x27;, &#x27;Robin Gandy&#x27;, &#x27;Stephen Kleene&#x27;, &#x27;Nels Nelson&#x27;, &#x27;Robert Constable&#x27; 总结 使用map、reduce和filter等高阶函数来编写高可扩展的代码。 使用 Lodash 进行数据处理，通过控制链创建控制流与数据变换明确分离的程序。 使用声明式的函数式编程能够构建出更易理解的程序。 将高阶抽象映射到 SQL 语句，从而深刻地认识数据。 递归能够解决自相似问题，并解析递归定义的数据结构。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript数据类型","slug":"JavaScript数据类型","date":"2021-01-09T12:11:11.000Z","updated":"2022-02-21T07:05:05.942Z","comments":true,"path":"2021/01/09/JavaScript数据类型/","link":"","permalink":"http://example.com/2021/01/09/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 思维导图","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"思维导图","slug":"思维导图","permalink":"http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"}]},{"title":"Redux记录","slug":"Redux记录","date":"2020-12-03T13:51:44.000Z","updated":"2022-01-24T10:27:17.219Z","comments":true,"path":"2020/12/03/Redux记录/","link":"","permalink":"http://example.com/2020/12/03/Redux%E8%AE%B0%E5%BD%95/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 说明Redux是一个使用叫做action的事件来管理和更新应用状态的模式和工具库，它以集中式Store的方式对整个应用中使用的状态进行集中管理，其规则确保状态只能以可预测的方式更新。 三大原则 单一的数据源 整个应用的state被存储在一棵object tree中，并且这个object tree只存在于唯一一个store中 State 是只读的 改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象 使用纯函数来执行修改 为了描述action如何改变state tree，需要编写reducers 一些重要的概念 Action Action是把数据从应用传到store的有效载荷。它是store数据的唯一来源 一般来说会通过store.dispatch()将action传到store Action本质上JavaScript普通对象，约定action内必须使用一个字符串对象type字段来表示将要执行的动作 Action创建函数 Action创建函数就是生成action的方法,这样做将使action创建函数更容易被移植和测试 123456function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125; Reducer Reducers指定了应用状态的变化如何响应actions并发送到store的,记住actions只是描述了有事情发生了这一事实，并没有描述如何更新state reducer就是一个纯函数，接收旧的state和action，返回新的state:(previousState, action) =&gt; newState StoreStore有以下职责： 维持应用的state 提供getState()方法获取state 提供dispatch(action)方法更新state 通过subscribe（listener)注册监听器，并能够能够其返回的函数注销监听器 Middleware 相对于Express或者Koa的middleware，Redux middleware被用于解决不同的问题，但其中的概念是类似的。它提供的是位于action被发起之后，到达reducer之前的扩展点。 你可以利用Redux middleware来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。 数据流Redux使用单向数据流 State描述了应用程序在特定时间点的状况 基于state来渲染UI 当发生某些事情时（例如用户点击按钮），state会根据发生的事情进行更新 基于新的state重新渲染UI 将这些步骤分解为更详细的内容: 初始启动 使用最顶层的 root reducer 函数常见 Redux store store 调用一次root reducer，并将返回值保存为它的初始 state 当UI首次渲染时，UI组件访问 Redux store 的当前 state，并使用该数据来决定要呈现的内容。同时监听 store 的更新，以便它们可以知道 state 是否已更改 更新环节 应用程序中发生了某些事情，例如用户点击按钮 dispatch 一个 action 到 React store store 用之前的 state 和当前的 action 再次运行 reducer 函数，并将返回值保存为新的 state store 通知所有订阅过的UI，通知它们 store 发生更新 每个订阅过 store 数据的UI组件都会检查它们需要的 state 部分是否被更新 发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页 一些疑问 Reducer的规则 Reducer必须符合以下规则： 仅使用state和action参数计算新的状态值 禁止直接修改state。必须通过复制现有的state并对复制的值进行更改的方式来做不可变更新 禁止任何异步逻辑、依赖随机值或导致其它副作用的代码 为什么这些规则很重要？ Redux的目标之一是使代码可预测。当函数的输出仅根据输入参数计算时，更容易理解该代码的工作原理并对其进行测试 如果一个函数依赖于自身之外的变量，或者行为随机，你永远不知道运行时它会发生什么 如果一个函数 mutate 了其它对象，比如它的参数，这可能会意外地改变应用程序的工作方式 Redux DevTools 的一些功能取决于你的 reducer 是否正确遵循这些规则 参考Redux 中文官网 Redux 中文文档","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://example.com/tags/Redux/"}]},{"title":"读书笔记:Javascript函数式编程指南（一）","slug":"读书笔记:Javascript函数式编程指南（一）","date":"2020-11-20T09:49:02.000Z","updated":"2022-02-21T07:05:19.363Z","comments":true,"path":"2020/11/20/读书笔记:Javascript函数式编程指南（一）/","link":"","permalink":"http://example.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 &gt; 面向对象编程（OO）通过封装变化是的代码更易理解。&gt; 函数式编程（FP）通过最小化变化使得代码更易理解。 Michael Feathers 是世界级面向对象技术专家，以丰富的软件项目开发经验著称。 简明扼要，可见函数式编程的优点。 什么是函数式编程？简单来说：函数式是一种强调以函数使用为主的软件开发风格。 这听起来很平常，好像我们平常也都是这么做的。 先讲概念：函数式编程的目标是使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变。 没有栗子就是在耍流氓: 1document.getElementById(&quot;#msg&quot;).innerHTML = &quot;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&quot;; 代码很简单，但是写死了，也就不能动态显示消息。 如果想改变消息的格式，内容或者目标 DOM 元素，需要重写整个表达式。 我们给它改进一下: 1234const printMessage = (elementId, NodeType, message) &#123; document.getElementById(elementId).innerHTML = `&amp;lt;$&#123;NodeType&#125;&amp;gt;$&#123;message&#125;&amp;lt;/$&#123;NodeType&#125;&amp;gt;`;&#125;printMessage(&quot;msg&quot;, &quot;h1&quot;, &quot;Hello world&quot;); 这样好一点，但是重用性仍然不高，接下来改成函数式: 1234// 函数定义const printMessage = run(addToDOM(&quot;msg&quot;), h1, echo);printMessage(&quot;Hello world&quot;); 这段代码与之前的完全不同: h1不再是一个量值，它与addToDOM,echo都是函数，这样看上去像是用一些较小的函数构建成一个新的函数。 代码写成这样的原因是什么？ 将代码分解成一些更可重用，更可靠且易于理解的部分，再将其组合起来，形成一个更易推理的程序整体。 上面的代码有一个神奇的函数run，它序列地调用一系列函数。 在后台，run函数基本上是通过将一个函数的返回值作为下一个函数的输入，以这张方式将各个函数连接起来。这样，由echo返回字符串，被传递到h1中，其结果最终又被传递到addToDOM。run函数的细节之后会解释。 上面比较了函数式和非函数式的编程方案，尽管他们结果相同，但是实现过程截然不同。这是源于函数式编程开发中固有的声明模式，为了充分理解函数式编程，我们先来了解一些基本概念: 声明式编程 纯函数 引用透明 不可变性 声明式编程函数式编程属于声明式编程范式:这种范式会描述一系列的操作，但并不会暴露它们是如何实现的或是数据流如何穿过它们。 目前更加主流的是命令式或者过程式的编程范式，如 Java、C#、C++和其他大多数结构化语言和面向对象语言都对其提供支持。 命令式编程将计算机视为一系列自上而下的断言，通过修改系统的的各个状态来计算最终的结果。 看个栗子: 12345let array = [0, 1, 2, 3, 4, 5, 6];for (let i = 0; i &amp;lt; array.length; i++) &#123; array[i] = Math.pow(array[i], 2);&#125;// [ 0, 1, 4, 9, 16, 25, 36] 命令式编程很具体地告诉计算机如何执行某个任务。 而声明式编程将程序的描述与求值分离开来。它关注于如何用各种表达式来描述程序逻辑，而不一定要指明其控制流或者状态的变化。 函数式: 12let array = [0, 1, 2, 3, 4, 5, 6];array.map((num) =&amp;gt; Math.pow(num, 2)); 函数式编程只需要对应用在每个数组元素上的行为予以关注，将循环交给系统的其他其他部分去控制。 副作用带来问题和纯函数函数式编程基于一个前提:即使用纯函数构建具有不变性的程序。 它具有以下性质: 仅取决于提供的输入，而不依赖于任何在函数求值期间或调用间隔时可能变化的隐藏状态或外部状态 不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数 栗子： 123456let counter = 0;const add = () =&amp;gt; ++counter;add(); // 1counter++; // 2add(); // 3 这个函数是不纯的，因为它读取并修改了一个外部变量，即函数作用域外的 counter。 一般来说，函数在读取或写入外部资源时都会产生副作用，例如上面的代码中，counter可以在调用间隔的任何时间发生改变。 另一个常见的函数是Date.now(),它的输出是不可预见的，并且不一致，因为它依赖于一个不断变化的因素–时间。 常见的副作用: 改变一个全局的变量、属性或数据结构 改变一个参数的原始值 处理用户输入 屏幕打印 查询 cookie 如果没有这些操作，那程序会有什么实用价值？ 事实上，在一个充满了动态行为与变化的世界里，纯函数确实很难使用。 但是，函数式编程在实践上并不限制一切状态的改变，它只是提供了一个框架来帮助管理和减少可变状态，同时让你能够将纯函数从不纯的部分中分离出来。 栗子:假设有一段程序，它能够通过身份证(ID)来找到一个人的记录并渲染在浏览器中 123456789101112131415const showPerson = (ID) =&amp;gt; &#123; // 查询数据库 const person = db.get(ID); // 判断是否有这个人 if (person !== null) &#123; // 渲染操作 document.getElementById( `$&#123;elementId&#125;` ).innerHTML = `$&#123;person.ID&#125;:$&#123;person.name&#125;`; &#125; else &#123; throw new Error(&quot;404&quot;); &#125;&#125;;showPerson(123); 分析代码: 该函数访问数据，与外部变量db进行了交互，因为该函数签名中并没有声明该参数，在任意时间，这个引用可能为null,或在调用间隔内改变，从而导致完全不同的结果并破坏了程序的完整性 全局变量elementId可能随时改变，难以控制 HTML 元素被直接修改了，HTML 文档（DOM）本身是一个可变的、共享的全局资源 如果没有找到记录，该函数可能为抛出异常，导致整个程序的栈回退并突然结束 用函数式思想改进: 将这个长函数分离成多个具有单一职责的短函数 通过显示地将完成功能所需的依赖都定义为函数参数来减少副作用的数量 首先通过分离显示与获取数据的行为。 当然，与外部存储系统和 DOM 交互所产生的副作用是不可避免的，但至少可以通过将其从主逻辑中分离出来的方式使它们更易于管理。 这里需要引入一种常见的函数式编程技巧–柯里化，使用它，可以允许部分地传递函数参数，以便将函数的参数减少为一个，之后会再介绍。 12345678910111213141516171819202122232425// 分离函数const find = () =&amp;gt; &#123; curry((db, id) =&amp;gt; &#123; const obj = db.get(id); if (obj === null) &#123; throw new Error(&quot;404&quot;); &#125; return obj; &#125;);&#125;;const message = (person) =&amp;gt; &#123; return `$&#123;person.ID&#125;:$&#123;person.name&#125;`;&#125;;const append = () =&amp;gt; &#123; curry((elementId, info) =&amp;gt; &#123; document.getElementById(elementId).innerHTML = info; &#125;);&#125;;const showPerson = run(append(&quot;msg&quot;), message, find(db));showPerson(123); 尽管这个程序只有些许改进，但是它开始展现出许多优势: 灵活很多，因为有了三个可以被复用的组件 这种细粒度函数的重用是提高工作效率的一种手段，因为可以大大减少需要主动维护的代码量 声明式代码风格提供了程序需要执行的那些高阶步骤的一个清晰试图，增强了代码的可读性 将纯函数从不纯的行为中分离出来 由于一些我们会在后续了解到的原因，能够确保一个函数有相同的返回值是一个优点，它使得函数的结果是一致的和可预测的。这是纯函数的一个特质，称为引用透明 引用透明和可置换性引用透明是定义一个纯函数正确的方式。纯度在这个意义上表明了一个函数的参数和返回值之前映射的纯的关系。 因此，如果一个函数对于相同输入始终产生相同的结果，那么就说它是引用透明的。 12let counter = 0;const add = () =&amp;gt; ++counter; 这个函数不是引用透明的，因为其返回值严重依赖外部变量 counter。改造: 1const add = (counter) =&amp;gt; ++counter; 为了引用透明，需要删除其依赖的外部变量这一状态，使其成为函数签名中显示定义的参数。 现在这个函数是稳定的，对于相同输入每次都返回相同的输出结果。 之所以追求这种函数的特质，是因为它不仅能让代码更易于测试，还可以让开发人员更容易推理整个程序。 假设现在要求一个数组中的平均值: 123456789const input = [20, 30, 40];const sum = (total, current) =&amp;gt; total + current;const total = (arr) =&amp;gt; arr.reduce(sum);const size = (arr) =&amp;gt; arr.length;const divide = (a, b) =&amp;gt; a / b;const average = (arr) =&amp;gt; divide(sum(arr), size(arr));average(input); 由于函数sum和size都是引用透明的，对于如下给定输入，可以很容易重写这个表达式。 123divide(90, 3);90 / 3 = 30; 存储不可变数据不可变数据是指那些被创建后不能更改的数据。 与许多其他语言一样，JavaScript 中的所有基本类型（String、Number 等）从本质上是不可变的。但是其他对象，例如数组，都是可变的——即使他们作为输入传递给另一个函数，仍然可以通过改变原有内容的方式产生副作用。 123456789const sortDesc = (arr) =&amp;gt; &#123; return arr.sort((a, b) =&amp;gt; b - a);&#125;;let input = [1, 2, 3, 4, 5, 6, 7];let output = sortDesc(input);console.log(input); // [7, 6, 5, 4, 3, 2, 1]console.log(output); // [7, 6, 5, 4, 3, 2, 1] 排序的目的达到了，但是产生了副作用，即改变了输入。 小结现在我们已经了解了函数式编程的一些基本原则（如声明式的、纯的和不可变的），那可以这么描述它: 函数式编程是指为创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程。 函数式编程的优点 促使开发人员将任务分解成更小的任务(函数) 使用流式的调用链来处理数据 通过响应式范式降低是将驱动代码的复杂性 复杂任务的分解从宏观上讲，函数式编程实际上是分解（将程序拆分成小片段）和组合（将小片段连接到一起）之间的相互作用。正是这种二元性，使得函数式如此模块化和高效。 这里的模块化就是函数本身，函数式思维的学习通常始于将特定任务分解为逻辑子任务（函数）的过程。 1234567891011121314151617181920212223const find = () =&amp;gt; &#123; curry((db, id) =&amp;gt; &#123; const obj = db.get(id); if (obj === null) &#123; throw new Error(&quot;404&quot;); &#125; return obj; &#125;);&#125;;const message = (person) =&amp;gt; &#123; return `$&#123;person.ID&#125;:$&#123;person.name&#125;`;&#125;;const append = () =&amp;gt; &#123; curry((elementId, info) =&amp;gt; &#123; document.getElementById(elementId).innerHTML = info; &#125;);&#125;;const showPerson = run(append(&quot;msg&quot;), message, find(db));showPerson(123); 123 findshowPerson → message append 如果需要，这些子任务可以进一步分解，直到成为一个个简单的，相互独立的纯函数功能单元。 可以看出，函数式编程的模块化概念与单一职责原则息息相关，也就是说，函数都应该拥有单一的目的。纯度和引用透明会促使我们这样思考问题。 还记得上面说的那个run函数吗？ 现在揭秘这个黑魔法:实际上run函数是一个极为重要的技术的别名 —— 组合 。 两个函数的组合是一个新的函数，它拿到一个函数的输出，并传递到另一个函数中。讲述有两个函数f和g，形式上，组合可以如下描述: 1f · g = f(g(x)) 这个公式读作“f 组合上 g”,它在 g 的返回值与 f 的参数之间构建了一个松耦合的且类型安全的联系。 两个函数能够组合的条件是，它们必须在参数数目及参数类型上形成一致。 现在用compose构建组合函数showPerson: 12const showPerson = compose(append(&quot;#msg&quot;), message, find(db));showPerson(123); 关于组合，先了解这么多。 到此为此，我们可以看到:函数式的组合提高了抽象的层次，可以清晰地够勾勒代码的所有步骤，但又不暴露任何底层细节在此代码执行的所有步骤。 由于compose接受其他函数为参数，这被称为高阶函数，但组合并不是构建流式的、模块化的代码的唯一方式。 使用流式链来处理函数除了map，我们还可以通过导入一些函数式类库来获得更多高阶函数，比方说lodash。 假设一个场景:需要计算那些选择多门课程的学生的平均分 12345const data = [ &#123; number: 2, grade: 100 &#125;, &#123; number: 3, grade: 80 &#125;, &#123; number: 1, grade: 89 &#125;,]; 命令式代码可能是这样的: 1234567891011121314let totalGrade = 0;let totalStudentsFound = 0;for (let i = 0; i &amp;lt; data.length; i++) &#123; let student = data[i]; if (student !== null) &#123; if (student.number &amp;gt; 1) &#123; totalGrade += student.grade; totalStudentsFound++; &#125; &#125;&#125;const average = totalGrade / totalStudentsFound; 用函数式思维来分解这个问题: 选择合适的学生（选课数量大于 1 的） 获取他们的成绩 计算平均值 通过lodash把这些操作连接起来: 12345_.chain(data) .filter((student) =&amp;gt; student.number &amp;gt; 1) .pluck(&quot;grade&quot;) .average() .value(); // 执行链式队列并提取解链后的值。 我们先不用太在意发生了什么，与命令式版本比较，并注意如何消除变量的声明和变化，以及循环和判断语句。 诸如循环和逻辑分支这样的很多命令式控制流机制，会提高函数的复杂程度，因为它们会根据某些条件不同而执行不同的行为，难以测试。 上面代码略过了一些错误处理代码，我们可以利用一些纯函数式的设计模式来处理它，这个以后再说。 复杂异步应用中的响应大家经历过回调地狱吗？ 它打破了线性的代码结构，使代码变得难以阅读，因为它的成功处理和失败处理的逻辑混杂在一起。 我们经常要处理在服务端或者客户端的异步和事件驱动代码，可以用响应式编程来大幅降低这些代码的复杂性 响应式是一种范式，是函数式编程应用之一，采用它的好处在于能够提高代码的抽象级别，从而更专注业务逻辑。这种范式能够充分利用函数式编程中函数链和组合的样式。 事件有很多种:鼠标点击、文本变化、焦点变化、HTTP 请求处理或者文件写入等等。假设现在根据输入的 ID 号码查询用户是否存在，命令式代码可能是这样的: 123456789101112131415let valid = false;const element = document.getElementById(&quot;#input&quot;);element.onkeyup = (event) =&amp;gt; &#123; let val = element.value; if (val !== null &amp;amp;&amp;amp; val.length !== 0) &#123; // 可能进行的裁剪或者清理输入，直接改变数据 val = val.replace(/^[a-zA-Z0-9_-]&#123;4,16&#125;$/, &quot;&quot;); // 可能存在的嵌套逻辑分支 if (val.length === 9) &#123; valid = true; &#125; &#125; else &#123; console.log(&quot;404&quot;); &#125;&#125;; 我刚学编程那会写过类似结构的代码，一大段逻辑塞在一起。但是对于这样一个简单的任务，编码从一开始就变得复杂，这样除了增加心智负担，代码也无法重用。 来康康响应式，这种白痴南横范式使用了一个叫做observable的概念，它能够订阅一个数据流，让开发者通过使用组合和链式操作来优雅地处理数据。 代码: 12345Rx.Observable.fromEvent(document.getElementById(&quot;#input&quot;), &quot;keyup&quot;) .map((input) =&amp;gt; input.srcElement.value) .filter((val) =&amp;gt; val !== null &amp;amp;&amp;amp; val.length !== 0) .skipWhile((val) =&amp;gt; length === 9) .subscribe(() =&amp;gt; console.log(&quot;404&quot;)); 它和前面的例子相像，这说明，无论是处理集合元素序列或者用户输入序列，一切都被抽象出来，这使得可以用相同的方式去处理数据。 上面的代码的操作是不可变的，并且所有业务逻辑被分割成单独的函数。并不是必须要响应式地使用函数，但函数式的思维会迫使开发者这么做。 总结 使用纯函数的代码绝不会更改或破坏全局状态，有助于提高代码的可测试性和可维护性 函数式编程采用声明式的风格，易于推理。这提高了应用程序的整体可读性，通过使用组合和 lambda 表达式使函数更加精简 集合中数据元素可以通过链接如 map 和 reduce 这样的函数来实现 函数式编程将函数视为积木，通过一等高阶函数来提高代码的模块化和可重用性 可以利用响应式编程组合各个函数来降低驱动程序的复杂性","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Promise规范翻译","slug":"PromisesA+规范翻译","date":"2020-11-09T13:30:40.000Z","updated":"2021-08-07T05:59:13.910Z","comments":true,"path":"2020/11/09/PromisesA+规范翻译/","link":"","permalink":"http://example.com/2020/11/09/PromisesA+%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 原文 一个开放标准,通用的 JavaScript promise ,由开发者制定，供开发者使用。 Promise 用于表示一个异步操作的最终结果。与 Promise 交互的主要方式为then方法,该方法注册回调函数以接收 promise 的成功的结果或者失败的原因。 该规范详细说明了then方法的行为,所有基于 Promise/A+规范实现的 Promise 都必须以此为基础实现。因此规范应该非常稳定。尽管 Promises/A+组织可能会偶尔修改此规范以向后兼容,只有经过仔细考虑，讨论和测试后，我们才会集成大型或不向后兼容的更改。 从其发展过程来看，Promises/A+其实是把之前的Promises/A提案归纳总结为标准。扩展了一些现有的行为规范，并删除了一些有问题的、未明确的部分。 最终，Promises/A+规范核心内容不包括怎样处理 promises 的创建（create）,完成（fulfill）和拒绝（reject），而是选择专注于提供一个通用的，具备可互操作的then方法。上述的操作方法可能会在未来修改该规范时提及。 1. 术语1.1 “promise” 是一个拥有then方法的对象或函数，其行为符合本规范1.2 “thenable” 是一个定义了then方法的对象或函数1.3 “value” 可以是任何 JavaScript 的合法值（包括 undefined, thenable 和 promise）1.4 “exception” 是一个使用throw语句抛出的值。1.5 “reason”是一个表示 promise 失败的原因 2. 要求2.1 Promise 要求一个 Promise 必须处于以下三种状态中的其中一种: pending（等待）, fulfilled（完成）, 或 rejected（拒绝）。 2.1.1 当 promise 处于 pending 状态 2.1.1.1. 可以转换到 fulfilled 或 rejected 的状态。 2.1.2 当 promise 处于 fulfilled 状态 2.1.2.1 不能再转换状态。 2.1.2.2 必须有一个值(value),且不可改变。 2.1.3 当 promise 处于 rejected 状态 2.1.3.1 不能再转换状态。 2.1.3.2 必须有一个原因(reason),且不可改变。 这里的不可改变指的是恒等（即 === ），而不是意味着其内部的不可变（即仅仅是其引用地址不变，但属性值可被更改）。 2.2 then 方法一个 promise 必须提供一个then方法以读取其当前值、终值和失败原因。一个 promise 的then方法接收两个参数: 1promise.then(onFullfilled, onRejected); 2.2.1 onFulfilled和onRejected都是可选的参数: 2.2.1.1 如果onFullfilled不是一个函数，则它会被忽略 2.2.1.2 如果onRejected不是一个函数，则它会被忽略 2.2.2 如果onFulfilled是一个函数 2.2.2.1 必须在 promise 执行结束后执行，promise的 value 作为第一个参数 2.2.2.2 在 promise 执行结束前不可被调用 2.2.2.3 不能被多次调用 2.2.3 如果onRejected是一个函数 2.2.3.1 必须在 promise 被拒绝后执行,promise的 reason 作为第一个参数 2.2.3.2 在 promise 执行结束前不可被调用 2.2.3.3 不能被多次调用 2.2.4 onFulfilled和onRejected只有在执行环境堆栈仅包含平台代码时才可被调用 3.1 2.2.5 onFulfilled和onRejected必须被作为函数调用（即没有 this 值） 3.2 2.2.6 then方法可以被同一个 promise 调用多次 2.2.6.1 如果/当 promise是 fulfilled 状态，则所有相应的onFulfilled回调必须按注册顺序执行then方法 2.2.6.2 如果/当 promise是 rejected 状态，则所有相应的onRejected回调必须按注册顺序执行then方法 2.2.7 then方法必须返回一个 promise 对象3.3 1promise2 = promise1.then(onFulfilled, onRejected); 2.2.7.1 如果onFulfilled或者onRejected返回一个值x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x) 2.2.7.2 如果onFulfilled或者onRejected抛出一个异常e ，则promise2必须拒绝执行，并将e作为拒绝原因 2.2.7.3 如果onFulfilled不是一个函数并且promise1已经完成，则promise2必须使用与promise1相同的 value 来 fulfilled 2.2.7.4 如果onRejected不是一个函数并且promise1已经完成，则promise2必须使用与promise1相同的 reason 来 rejected 2.3 Promise 解决过程Promise 解决过程是一个抽象的操作,其需输入一个 promise 和一个值,我们表示为[[Resolve]](promise, x),如果 x 是一个 thenable(promise),它会尝试采用 x 的状态,前提是x行为至少有点像 promise。否则，它作为promise的 fulfilled 的 value 返回。对 thenables 的这种处理允许 promise 实现进行更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与不冲突的实现能良好共存。 要运行[[Resolve]](promise, x), 需遵循以下步骤： 2.3.1 如果promise和x指向同一对象，以TypeError为拒绝原因拒绝执行promise 2.3.2 如果x为 Promise,则使 promise 接受 x 的状态3.4 2.3.2.1 如果x处于 pending,promise 需保持 pending,直至x被执行或拒绝 2.3.2.2 如果x执行完毕,用相同的值执行promise 2.3.2.3 如果x被拒绝,用相同的原因拒绝promise 2.3.3 如果x为对象或者函数 2.3.3.1 把x.then赋值给then3.5 2.3.3.2 如果取x.then的值时抛出错误e,则用e作为 promise 的拒绝原因 2.3.3.3 如果then是函数,将x作为函数的作用域this调用之。传递两个回调函数作为参数,第一个参数叫做resolvePromise,第二个参数叫做rejectPromise: 2.3.3.3.1 如果resolvePromise以值y为参数被调用，则运行 [[Resolve]](promise, y) 2.3.3.3.2 如果rejectPromise以拒绝原因r为参数被调用,则以r拒绝promise 2.3.3.3.3 如果resolvePromise和rejectPromise均被调用,或者被同一参数调用了多次,则优先采用首次调用并忽略其余调用 2.3.3.3.4 如果调用then方法时抛出异常e, 2.3.3.3.4.1 如果resolvePromise或rejectPromise已经被调用,就忽略它 2.3.3.3.4.2 否则以e为原因拒绝promise 2.3.3.4 如果then不是函数,以x为参数执行promise 2.3.4 如果x不为对象或者函数,以x为参数执行promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而[[Resolve]](promise, thenable)的递归性质导致其被再次调用,根据上述的算法将会陷入无限递归。规范鼓励施者检测这样的递归是否存在,但不强制,如果检测到存在则以一个可识别的TypeError为原因来拒绝 promise。3.6 3. 备注3.1这里的“平台代码”指的是引擎,环境和 promise 实现代码。实践中要确保onFulfilled和onRejected方法异步执行,且应该在then方法被调用的那一轮事件循环之后的新执行栈中执行。这可以用“宏任务”机制实现,例如setTimeout或者setImmediate,或者用“微任务”机制,例如MutationObserver或process.nextTick。由于 promise 实现被认为是平台代码,因此它本身可能包含一个任务调度队列或“trampoline”的处理程序。 3.2也就是说在严格模式（strict）中，this的值为undefined;在非严格模式中其为全局对象。 3.3代码实现在满足所有要求的情况下可以允许promise2 === promise1。每个实现都要文档说明其是否允许以及在何种条件下允许 promise2 === promise1。 3.4一般来说,x如果它来自当前的实现,那么它是一个真正的 promise。该子句允许使用特定于实现的方法来采用已知符合的 promise 的状态。 3.5此过程首先存储引用x.then,然后测试,调用该引用,避免多次访问该x.then属性。这么做的原因是防止每次获取该值时,返回不同的情况（ES5 的 getter 特性可能会产生副作用） 3.6实现不应该对 thenable 链的深度设限,并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致TypeError异常；如果一条无限长的链上 thenable 均不相同,那么递归下去永远是正确的行为。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"margin 合并","slug":"margin合并","date":"2020-10-26T10:42:31.000Z","updated":"2022-01-11T07:43:39.331Z","comments":true,"path":"2020/10/26/margin合并/","link":"","permalink":"http://example.com/2020/10/26/margin%E5%90%88%E5%B9%B6/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 什么是 margin 合并MDN 定义 块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距,其大小为单个边距的最大值(或如果它们相等,则仅为其中一个),这种行为称为边距折叠. 举个 🌰 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;style&gt; body &#123; writing-mode: vertical-lr; &#125; div &#123; margin: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;hello&lt;/div&gt; &lt;div&gt;world&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 块级元素,但不包括浮动和绝对定位元素(他们可以让元素块状化) 只发生在垂直方向(不考虑writing-mode的情况,严格来说应该是只发生在和当前文档流方向的相垂直方向上,默认的文档流是水平流) margin 合并三种场景 相邻兄弟元素 margin 合并 父级和第一个/最后一个子元素 空的块级元素的 margin 合并 相邻兄弟元素 margin 合并例子如上 父级和第一个/最后一个子元素1234567891011&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot; style=&quot;margin-top: 30px;&quot;&gt;hello world&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;father&quot; style=&quot;margin-top: 30px;&quot;&gt; &lt;div class=&quot;son&quot;&gt;hello world&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;father&quot; style=&quot;margin-top: 30px;&quot;&gt; &lt;div class=&quot;son&quot; style=&quot;margin-top: 30px;&quot;&gt;hello world&lt;/div&gt;&lt;/div&gt; 如何阻止这里margin合并的发生?可以进行的操作(满足一个条件即可): 父元素设置块状格式化上下文元素 父级和第一个/最后一个子元素之间添加内联元素进行分隔 父元素设置border 父元素设置padding 空的块级元素的 margin 合并123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 如何阻止这里margin合并的发生?可以进行的操作(满足一个条件即可): 设置height或者min-height 添加内联元素进行分隔 父元素设置border 父元素设置padding margin 合并的计算规则 同向取极值 12&lt;div style=&quot;margin-bottom: 50px;&quot;&gt;a&lt;/div&gt;&lt;div style=&quot;margin-top: 20px;&quot;&gt;b&lt;/div&gt; 此时两个div的间距为50px 123&lt;div style=&quot;height: 100px; background-color: antiquewhite;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;margin-bottom: -50px;&quot;&gt;a&lt;/div&gt; &lt;div style=&quot;margin-top: -20px;&quot;&gt;b&lt;/div&gt; 此时两个div的间距为-50px,视觉上非50px 反向取差值 12&lt;div style=&quot;margin-bottom: 50px;&quot;&gt;a&lt;/div&gt;&lt;div style=&quot;margin-top: -20px;&quot;&gt;b&lt;/div&gt; 此时两个div的间距为30px,即 50px+(-20px) margin 合并的意义为什么会有margin最初CSS的设计本意就是为了图文信息的展示,有了默认的margin,图文就不会挤在一起,垂直方向上就可以层次分明.比如说&lt;p&gt;&lt;/p&gt;,其margin默认单位为em,为什么使用相对单位?浏览器的字号大小可以自定义,当我们自定义为较大值时,margin跟随变化,能够保持合适的排版. margin 合并的意义对于兄弟元素的margin合并其作用和em类似,都是为了让图文信息打得排版更舒服自然. 对于父子元素的margin合并的意义在于:在页面中任何地方插入和嵌套&lt;div&gt;&lt;/div&gt;都不会影响原来的块状布局. 1&lt;div style=&quot;margin-top: 20px;&quot;&gt;&lt;/div&gt; 现在在该元素外嵌套一层&lt;div&gt;&lt;/div&gt;标签,如果没有合并规则,该元素和兄弟节点的间距可能就会变大,也就影响了原来的布局. 对于自身的margin合并的意义在于可以避免空标签的影响 123456&lt;p&gt;a&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b&lt;/p&gt; 因为规则的存在,它和底下的代码是一样的效果 12&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"JavaScript 中的 instanceof 和 typeof","slug":"JavaScript 中的 instanceof 和 typeof","date":"2020-09-25T12:44:01.000Z","updated":"2022-01-20T07:32:30.442Z","comments":true,"path":"2020/09/25/JavaScript 中的 instanceof 和 typeof/","link":"","permalink":"http://example.com/2020/09/25/JavaScript%20%E4%B8%AD%E7%9A%84%20instanceof%20%E5%92%8C%20typeof/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 instanceof instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上 当然，instanceof也可以判断一个实例是否是其祖先类型的实例。 12345678910function Car(make, model, year) &#123; this.make = make; this.model = model; this.year = year;&#125;const auto = new Car(&#x27;Honda&#x27;, &#x27;Accord&#x27;, 1998);console.log(auto instanceof Car); // trueconsole.log(auto instanceof Object); // true 根据原型和原型链的相关知识，这里进行一个实现： 123456789101112131415function myInstanceof(obj, target) &#123; let targetPrototype = target.prototype; let objPrototype = obj.__proto__; while(true) &#123; if(objPrototype === null) &#123; return false; &#125; if(objPrototype === targetPrototype) &#123; return true; &#125; objPrototype = objPrototype.__proto__; &#125;&#125; typeof typeof操作符返回一个字符串，表示未经计算的操作数的类型 这里用一张表来总结typeof的使用情况： 类型 结果 Undefined ‘undefined’ Null ‘object’ Boolean ‘boolean’ Number ‘number’ BigInt ‘bigint’ String ‘string’ Symbol ‘symbol’ Function ‘function’ 其它任何对象 ‘object’ 眼尖的小伙伴肯定发现了该操作符对于null的执行结果有些奇怪， 12// JavaScript 诞生以来便如此typeof null === &#x27;object&#x27;; // true 在JavaScript最初的实现中，底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息： 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 由于null代表的空指针（大多数平台下值为0X00, 所有机器码均为0），因此typeof null 也因此返回 &#39;object&#39;。 这也是 JavaScript 的历史遗留bug。 从上面的分析看出，在使用typeof来判断变量类型时，需要避免对null的判断。还有一个不错的判断类型的方法，就是Object.prototype.toString: 1234567891011121314151617Object.prototype.toString.call(0) // &quot;[object Number]&quot;Object.prototype.toString.call(&#x27;hi&#x27;) // &quot;[object String]&quot;Object.prototype.toString.call(&#123;food:&#x27;cola&#x27;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call([1,&#x27;a&#x27;]) // &quot;[object Array]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(() =&gt; &#123;&#125;) // &quot;[object Function]&quot;Object.prototype.toString.call(null) // &quot;[object Null]&quot;Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot; 参考浅谈 instanceof 和 typeof 的实现原理 typeof mdn instanceof mdn","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Babel转译下的装饰器","slug":"Babel转译下的装饰器","date":"2020-08-16T11:40:50.000Z","updated":"2022-01-11T07:48:21.416Z","comments":true,"path":"2020/08/16/Babel转译下的装饰器/","link":"","permalink":"http://example.com/2020/08/16/Babel%E8%BD%AC%E8%AF%91%E4%B8%8B%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 装饰器概念它是一个函数，它会通过返回一个新函数来修改传入的函数或方法的行为 装饰器用法 装饰类方法或属性(类成员) 装饰类 123456789101112131415161718192021222324252627282930const log = (target, name, descriptor) =&gt; &#123; let oldValue = descriptor.value; if (typeof descriptor.value === &quot;function&quot;) &#123; descriptor.value = function (...args) &#123; return console.log(oldValue.apply(this, args)); &#125; &#125; else &#123; console.log(descriptor.value) &#125;&#125;const foodCategory = (target, name, descriptor) =&gt; &#123; target.category = &quot;food&quot;;&#125;@foodCategoryclass Cola &#123; constructor(name) &#123; this.name = name; &#125; @log color() &#123; return `red`; &#125;&#125;let cola = new Cola(&quot;Coca Cola&quot;);cola.color(); // redconsole.log(Cola.category); // food 装饰方法本质上是通过 Object.defineProperty() 来实现的 经过babel转换之后(底下有babel详细操作): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&quot;use strict&quot;;/** * @function * 该函数的作用就是将数组中的方法添加到构造函数或者构造函数的原型中 * 最后返回这个构造函数。 */var _createClass = function () &#123; /** * 将props数组上的每一个对象都通过Object.defineProperty()方法 * 定义到目标对象target上去 */ function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; // 类的内部所有定义的方法,都是不可枚举的 descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; /** * @param &#123;protoProps&#125; 原型属性数组 * @param &#123;protoProps&#125; 静态属性数组 */ return function (Constructor, protoProps, staticProps) &#123; // 为构造函数prototype添加属性 // (即为用构造函数生成的实例原型添加属性,可以被实例通过原型链访问到) if (protoProps) defineProperties(Constructor.prototype, protoProps); // 为构造函数添加属性 if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;;&#125;();var _class, _desc, _value, _class2;/** * @function * 作用是检查 Person 是否是通过 new 的方式调用 * 防止构造函数被当做普通函数执行 */function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125;&#125;function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) &#123; var desc = &#123;&#125;; // 这里对 descriptor 属性做了一层拷贝 Object[&#x27;keys&#x27;](descriptor).forEach(function (key) &#123; desc[key] = descriptor[key]; &#125;); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; // 没有 value 或者 initializer 属性的,表明是 get 和 set 方法 // initializer是 Babel 的 Class 为了与 decorator 配合而产生的一个属性 if (&#x27;value&#x27; in desc || desc.initializer) &#123; desc.writable = true; &#125; // 这里处理多个 decorator 的情况,由类内向类外执行 desc = decorators.slice().reverse().reduce(function (desc, decorator) &#123; return decorator(target, property, desc) || desc; &#125;, desc); // void其实是javascript中的一个函数,接受一个参数,返回值永远是undefined if (context &amp;&amp; desc.initializer !== void 0) &#123; desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; &#125; if (desc.initializer === void 0) &#123; Object[&#x27;defineProperty&#x27;](target, property, desc); desc = null; &#125; return desc;&#125;var log = function log(target, name, descriptor) &#123; var oldValue = descriptor.value; if (typeof descriptor.value === &quot;function&quot;) &#123; descriptor.value = function () &#123; for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) &#123; args[_key] = arguments[_key]; &#125; return console.log(oldValue.apply(this, args)); &#125;; &#125; else &#123; console.log(descriptor.value); &#125;&#125;;var foodCategory = function foodCategory(target, name, descriptor) &#123; target.category = &quot;food&quot;;&#125;;var Cola = foodCategory(_class = (_class2 = function () &#123; function Cola(name) &#123; _classCallCheck(this, Cola); this.name = name; &#125; _createClass(Cola, [&#123; key: &quot;color&quot;, value: function color() &#123; return &quot;red&quot;; &#125; &#125;]); return Cola;&#125;(), (_applyDecoratedDescriptor(_class2.prototype, &quot;color&quot;, [log], Object.getOwnPropertyDescriptor(_class2.prototype, &quot;color&quot;), _class2.prototype)), _class2)) || _class;var cola = new Cola(&quot;Coca Cola&quot;);cola.color();console.log(Cola.category); babel详细操作使用npm init初始化项目:生成文件pakeage.json,它会将记录项目开发中所要用到的包,以及项目的详细信息 babel-cli是一种在命令行下使用Babel编译文件的简单方法,主要用于文件的输入输出安装babel命令行工具: 1npm install --global babel-cli 安装装饰器依赖: 1npm i --save-dev babel-plugin-transform-decorators-legacy 项目中创建**.babelrc**文件: 12345678&#123; &quot;presets&quot;: [ &quot;es2015&quot; ], &quot;plugins&quot;: [ &quot;transform-decorators-legacy&quot; ] &#125; 文件说明: .babelrcbabel所有的操作基本都会来读取这个配置文件,除了一些在回调函数中设置options参数的,如果没有这个配置文件,会从package.json文件的babel属性中读取配置 presets可以简单的把它视为 Babel Plugin 的集合 pluginsbabel中的插件,通过配置不同的插件告诉babel,代码中有哪些是需要转译的 使用babel命令转码: 1babel [fileName].js","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中offset、client、scroll","slug":"JavaScript中offset、client、scroll","date":"2020-06-10T13:49:20.000Z","updated":"2022-01-11T07:44:17.740Z","comments":true,"path":"2020/06/10/JavaScript中offset、client、scroll/","link":"","permalink":"http://example.com/2020/06/10/JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 写在前面在web前端开发中经常会碰到offset、client、scroll,容易混乱,这里记录一番.先放两张图,未来好查阅 :smile: offsetoffset: 偏移量它包括元素在屏幕上占用的所有可见的空间.元素的可见大小由其高度、宽度决定,包括所有的内边距padding,滚动条和边框border大小(注意:不包括外边距). 通过以下4个属性可以取得元素的偏移量: offsetHeight: offsetHeight = border-width * 2 + padding-top + padding-bottom + height offsetWidth: offsetWidth = border-width * 2 + padding-left + padding-right + width offsetLeft: offsetLeft = offsetParent 的padding-left + 中间元素的offsetWidth + 当前元素的margin-left offsetTop: offsetParent 的padding-top + 中间元素的offsetHeight + 当前元素的margin-top 它们都是只读属性,每次访问都要重新计算,如果经常访问,可以用变量存起来,以提高性能 clientclient: 客户区大小它包括元素内容及其内边距所占据的空间大小. 通过以下2个属性可以取得元素的客户区: clientHeight: padding-top + padding-bottom + height clientWidth: padding-left + padding-right + width 它们也是只读属性,每次访问都要重新计算 scrollscroll: 滚动大小它指的是滚动内容的元素的大小.有些元素(比如&lt;html&gt;),即使没有执行任何代码也能自动地添加滚动条;有些元素需要通过设置CSS的overflow属性才能滚动. 通过以下4个属性可以取得滚动的相关属性: scrollHeight: 在没有滚动条的情况下,元素实际内容的总高度 scrollWidth: 在没有滚动条的情况下,元素实际内容的总宽度 scrollLeft: 被隐藏在内容区域左侧的像素数,设置该属性可以改变元素的滚动位置 scrollTop: 被隐藏在内容区域上方的像素数,设置该属性可以改变元素的滚动位置 通常认为&lt;html&gt;元素是在web浏览器的视口中滚动的元素,所以带有垂直滚动条的页面总高度就是document.documentElement.scrollHeight.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"简单爬虫的实现","slug":"简单爬虫的实现","date":"2020-06-05T13:31:17.000Z","updated":"2022-01-11T07:59:14.496Z","comments":true,"path":"2020/06/05/简单爬虫的实现/","link":"","permalink":"http://example.com/2020/06/05/%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 背景介绍本着自娱自乐的心态做的一个仓库，方便以后总结归纳 我为什么做这个东西每次手动更新过于繁琐，使用该脚本用于自动该仓库相关 Issue 的问答信息同步到源码中，解放双手，爱护键盘 ⌨️ u1s1，就是太懒了 主要模块 cheerio superagent 爬取流程1234567891011121314s=&gt;start: 开始op1=&gt;operation: 输入需要同步的Issue编号op2=&gt;operation: 确认是否改动相关源码op3=&gt;operation: 爬取页面信息cond1=&gt;condition: 判断该Issue是否填写相关信息op4=&gt;operation: 脚本改动源码op5=&gt;operation: Git提交相关操作exit=&gt;operation: 脚本退出e=&gt;end: 结束s-&gt;op1-&gt;op2-&gt;op3-&gt;cond1-&gt;op4-&gt;op5-&gt;econd1(yes)-&gt;op4cond1(no)-&gt;exitexit-&gt;e 核心实现 获取 DOM 节点的内容 更新目标文件 定制 （硬编码） 提交记录","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"关于HSTS","slug":"关于HSTS","date":"2020-05-11T14:41:08.000Z","updated":"2022-01-10T08:50:17.605Z","comments":true,"path":"2020/05/11/关于HSTS/","link":"","permalink":"http://example.com/2020/05/11/%E5%85%B3%E4%BA%8EHSTS/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 用途及用法HSTS的作用是强制客户端（比如浏览器）使用HTTPS网络协议与服务器进行通信。也就是说如果一个网站使用该策略，浏览器必须拒绝所有的HTTP连接，并组织用户接受不安全的SSL证书。 启用的方法也很简单，服务器在响应头中添加Strict-Transport-Security字段即可： 1Strict-Transport-Security: max-age=31536000; includeSubDomains 其中max-age的值表示在客户端收到这个请求后的31536000秒的时间凡是范文这个域名下的请求都要使用HTTPS协议。 工作细节网站第一次通过HTTPS请求时，服务器响应Strict-Transport-Security头，浏览器记录下该信息，之后尝试访问这个网站的请求都会自动把HTTP替换成HTTPS。 当HSTS设置的过期时间到了，后面通过HTTP的访问恢复到正常模式，不会再自动跳转到HTTPS。 如果浏览器接收到使用HTTP加载资源的请求，则必须尝试使用HTTPS请求替代。如果HTTPS不可用，则必须终止连接。 此外，如果证书无效，将阻止用户建立连接。通常来说，如果HTTPS证书无效（比如过期、自签名、由未知CA签名等），浏览器会显示一个可以规避的警告。但如果使用了HSTS，浏览器就不会让你绕过警告。 不足用户首次访问某网站是不受HSTS保护的。 因为首次访问时，浏览器还没收到HSTS，所以仍然有可能通过明文HTTP来访问。 解决这个不足目前有两种方案： 浏览器预置HSTS域名列表，Google Chrome、Firefox、Internet Explorer和Microsoft Edge实现了这一方案 将HSTS信息加入到域名系统记录中。但这需要保证DNS的安全性，也就是需要部署域名系统安全扩展 预加载 HSTS谷歌维护着一个HSTS预加载服务，开启后，浏览器将会永不使用非安全的方式连接到你的域名 但这不是HSTS标准的一部分，也不该被当做正式的内容 参考你所不知道的 HSTS 什么是HSTS，为什么要使用它？ HTTP Strict Transport Security HTTP严格传输安全","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"call、apply、bind的模拟实现","slug":"call、apply、bind的模拟实现","date":"2020-05-04T12:11:23.000Z","updated":"2022-01-19T09:43:16.880Z","comments":true,"path":"2020/05/04/call、apply、bind的模拟实现/","link":"","permalink":"http://example.com/2020/05/04/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 方法用途和异同点先总结一下，这三个方法的主要作用是改变函数中this的指向。 关于this的指向，需要记住this永远指向最后调用它的那个对象。 那三个方法使用起来的异同点是什么呢？ 相同点： 第一个参数都是用来指定this，即上下文 都可以用后续参数进行传参 不同点： bind方法返回一个新的函数，call、apply则是立即调用 call和apply基本类似，区别在于除了第一个参数之外的其它参数不同。前者接收若干个参数列表，后者接收一个包含多个参数的数组 非严格模式下，call方法的第一个参数如果没传，或者是null、undefined时，this指向全局对象 模拟实现 call 12345678910111213Function.prototype.imitateCall = function (context) &#123; // 如果没有则默认为 window，即访问全局作用域对象 context = context || window; // 获取调用call的函数，用this可以获取 context.fn = this; // 截取作用域对象参数后面的参数 let args = [...arguments].slice(1); // 执行调用函数，记录返回值 let result = context.fn(...args); // 销毁调用函数，以免作用域污染 Reflect.deleteProperty(context, &#x27;fn&#x27;); return result;&#125; apply 123456789101112131415Function.prototype.myApply = function (context) &#123; // 如果没有则默认为 window，即访问全局作用域对象 context = context || window; // 获取调用call的函数，用this可以获取 context.fn = this; let result; if (arguments[1]) &#123; result = context.fn(...arguments[1]); &#125; else &#123; result = context.fn(); &#125; // 销毁调用函数，以免作用域污染 Reflect.deleteProperty(context, &#x27;fn&#x27;); return result;&#125; bind 123456789101112131415161718192021222324Function.prototype.myBind = function (context) &#123; // 获取绑定时的传参 let args = [...arguments].slice(1), // 定义中转构造函数，用于通过原型连接绑定后的函数和调用bind的函数 F = function () &#123; &#125;, // 记录调用函数，生成闭包，用于返回函数被调用时执行 self = this, // 定义返回(绑定)函数 bound = function () &#123; // 合并参数，绑定时和调用时分别传入的 let finalArgs = [...args, ...arguments] // 改变作用域，注:aplly/call是立即执行函数，即绑定会直接调用 // 这里之所以要使用instanceof做判断，是要区分是不是new xxx()调用的bind方法 return self.call((this instanceof F ? this : context), ...finalArgs) &#125;; // 将调用函数的原型赋值到中转函数的原型上 F.prototype = self.prototype; // 通过原型的方式继承调用函数的原型 bound.prototype = new F(); return bound;&#125; 参考this、apply、call、bind JavaScript深入之call和apply的模拟实现 JavaScript深入之bind的模拟实现 Understanding JavaScript Bind () JavaScript’s Apply, Call, and Bind Methods are Essential for JavaScript Professionals MDN","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"直击本质——读书笔记","slug":"读书笔记--直击本质","date":"2020-05-03T07:19:12.000Z","updated":"2022-01-11T07:51:34.403Z","comments":true,"path":"2020/05/03/读书笔记--直击本质/","link":"","permalink":"http://example.com/2020/05/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 这本书让我受益很多，思维导图分享给大家。以下再完善一些概念： 迁移思考：迁移思考是先找到经过抽象与当前问题“表面不同、本质相似”的问题，通过借用前面问题的解决方法，解决当下问题的思维方式。它的迁移对象主要是思维模型和底层逻辑。 升维思考：跳出眼前问题的限制和常规解法，通过层级、时间、视角、边界、位置、结构的变换，重新思考问题及其解决之道的思考方式。升维思考的本质是对价值观、人生观、世界观的重新审视，拓展及重塑。比如，层级思考法和时间轴思考法是对自我价值观的审视，视角思考法是对世界观的拓展和重塑，无边界思考法是对人生观的拓展和重塑。 逆向思维：它是对司空见惯的、似乎已成定论的事物或观点反过来思考的一种思维方式。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"JavaScript中Object常用方法","slug":"JavaScript中Object常用方法","date":"2020-04-30T14:34:24.000Z","updated":"2022-01-11T07:44:40.934Z","comments":true,"path":"2020/04/30/JavaScript中Object常用方法/","link":"","permalink":"http://example.com/2020/04/30/JavaScript%E4%B8%ADObject%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 写在前面本篇文章尚未完成!! 概述Object是JavaScript中标准内置对象，它非常强大，虽然在日常开发中却用的不多，但十分有必要深入学习。 Object.create()该方法创建一个新对象，使用现有的对象提供新创建对象的__proto__.Object.create(proto[, propertiesObject])参数： proto为新创建对象的原型对象 propertiesObject可选，如果没有指定为undefined，这样会添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及响应的属性名称。返回值： 一个新对象，带着指定原型对象和属性 Object.defineProperty()该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 先看看常用的对象定义属性并赋值的写法：密码，，，，，，，，，，，，，，，，，，。xcccccccccccccccccc.mpo[yup] 1234567891011121314151617let obj = &#123;&#125;;obj.name = &#x27;Cola&#x27;;console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;````这种方式简单粗暴，但是对象属性的值可以想改就改，想删就删：```javascriptlet obj = &#123;&#125;;obj.name = &#x27;Cola&#x27;;console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;obj.name = &#x27;Coca cola&#x27;;console.log(obj);// &#123; name: &#x27;Coca cola&#x27; &#125;delete obj.name;console.log(obj);// &#123;&#125; 再来看看Object.defineProperty(obj, prop, descriptor)参数： obj为要定义属性的对象 prop为要定义或修改的属性的名称或Symbol descriptor为要定义或修改的属性描述符返回值： 被传递给函数的对象 ES6新增Symbol类型，，由于它独一无二的特性，可以用该类型作为对象的key 123456789101112let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; value: &#x27;Cola&#x27;&#125;)console.log(obj);// &#123;&#125;console.log(obj.name);// Colaobj.name = &#x27;Coca cola&#x27;;console.log(obj.name);// Coladelete obj.name;console.log(obj.name);// Cola 通过实践发现以这样的写法定义的属性是无法被修改和删除的，且访问对象为空。要想和我们常规写法达到相同的效果，还需要修改属性描述符。对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符，用一张表来区分二者区别：| |configurable |enumerable |value |writable |get |set || ———— | ———— | ———— | ———— | ———— | ———— | ———— || 数据描述符 |√ |√ |√ |√ |× |× || 存取描述符 |√ |√ |× |× |√ |√ |如果一个描述符不具备value、enumerable、writable、configurable任意一个键，那么它会被认为是一个数据描述符；如果一个描述符同时拥有value或writable和get、set，则会产生一个异常。 下面再来看一个示例： 123456789101112131415let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; enumerable: true, configurable: true, writable: true, value: &#x27;Cola&#x27;&#125;)console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;console.log(obj.name);// Colaobj.name = &#x27;Coca cola&#x27;;console.log(obj.name);// Coca coladelete obj.name;console.log(obj.name);// undefined 可以看到obj对象和我们以常用写法达到的效果一样，这是因为enumerable描述符能够控制对象属性是否可枚举;writable描述符能够控制对象属性是否可写，也就是覆盖;configurable描述符能够控制对象属性是否可配置，也就是将属性从对象上删除。这里我们可以得出结论：除了value描述符，其他数据描述符的值默认为false。 那get和set呢，再看看以下的例子： 12345678910let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; enumerable: true, configurable: true, writable: true, value: &#x27;Cola&#x27;, get() &#123;&#125;, set() &#123;&#125;&#125;)// TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute 对照前文的表格，代码抛出异常，证实了value或writable和get、set不能同时出现。那怎么使用呢，按照异常提示信息，删掉value和writable描述符： 123456789101112131415let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; enumerable: true, configurable: true, get() &#123; console.log(&#x27;get!&#x27;); // return obj; &#125;, set(val) &#123; console.log(val); &#125;&#125;)console.log(obj);// &#123; name: [Getter/Setter] &#125;obj.name;// get!obj.name = &#x27;Coca cola&#x27;;// Coca cola 在上面代码中，每次访问obj.name总是返回同一个值，这是因为我们对这个属性做了特殊处理，也就是get方法做的事情；每次对obj.name进行赋值操作，控制台总是打印此次赋值的内容，也就是set方法做的事情。 Object.assign()该方法是ES6新添加的方法，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。Object.assign(target, ...sources)参数： target为目标对象 sources为源对象返回值： 目标对象用法示例： 123456789101112131415161718192021let manA = &#123; name: &#x27;manA&#x27;, age: 23&#125;Object.defineProperties(manA, &#123; &#x27;address&#x27;: &#123; enumerable: true, value: &#x27;China&#x27; &#125;, &#x27;height&#x27;: &#123; value: &#x27;1.8m&#x27; &#125;&#125;)let manB = &#123; name: &#x27;manB&#x27;, age: 13&#125;let manC = Object.assign(&#123;&#125;, manA, manB, null, undefined);console.log(manC);// &#123; name: &#x27;manB&#x27;, age: 13, address: &#x27;China&#x27; &#125; 实践后可以得出结论： 该方法只拷贝源对象自身的并且可枚举的属性到目标对象（其内部使用源对象存取描述符get()和目标对象的set()方法，因此它会调用相关方法）。 该方法不会因为sources参数为null或undefined而报错。 深拷贝问题：Object.assign()方法只能实现浅拷贝：假如源对象的属性值是一个对象的引用，那么返回值中该属性值也直指向这个引用 123456789101112let manA = &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;China&#x27; &#125;&#125;let manB = Object.assign(&#123;&#125;, manA);console.log(manB);// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;China&#x27; &#125; &#125;manB.address.nationality = &#x27;Japan&#x27;;console.log(manA)；// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;Japan&#x27; &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中的防抖和节流","slug":"JavaScript中的防抖和节流","date":"2020-04-28T14:18:41.000Z","updated":"2021-08-07T05:59:13.785Z","comments":true,"path":"2020/04/28/JavaScript中的防抖和节流/","link":"","permalink":"http://example.com/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 概述防抖和节流是优化前端性能的一种手段。以下情况可以考虑使用防抖和节流： DOM 频繁重绘 频繁请求后端接口 浏览器的 resize、scroll（适合用节流） 鼠标的 mounsemove、mouseover（适合用节流） input 输入框的 keypress（适合用防抖） 防抖(debounce)核心思想：当事件被触发，延迟 n 秒后执行回调函数，如果在 n 秒内再次被触发，则重新计时延迟时间。 代码实现： 1234567891011function debounce(fn, delay) &#123; var timer; return function () &#123; var that = this; var args = arguments; timer &amp;&amp; clearTimeout(timer); timer = setTimeout(function () &#123; fn.apply(that, args); &#125;, delay); &#125;;&#125; 节流核心思想：在规定的一个单位时间内只能触发一次函数，如果在这个单位时间内出发多次函数，只有一次生效。 代码实现: 123456789101112131415function throttle(fn, delay) &#123; var timer; return function () &#123; var that = this; var args = arguments; if (timer) &#123; return; &#125; timer = setTimeout(function () &#123; fn.apply(that, args); // 在执行完fn后清空timer,throttle触发可以进入计时器 timer = null; &#125;, delay); &#125;;&#125; 节流与防抖的异同相同：在一段时间内防止函数被频繁调用，减少资源浪费，提升性能。不同：防抖是固定时间内只执行一次，节流是间隔固定时间后执行。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"MQTT协议详解","slug":"MQTT协议详解","date":"2020-04-26T05:18:56.000Z","updated":"2022-01-11T07:42:46.858Z","comments":true,"path":"2020/04/26/MQTT协议详解/","link":"","permalink":"http://example.com/2020/04/26/MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 概述MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)，是一种基于发布/订阅(public/subscribe)模式的轻量级物联网消息推送协议。该协议构建于TCP/IP协议上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的协议。这让它成为新兴的”机器到机器（M2M)”，”物联网(IoT)”场景下的理想选择。 特点 MQTT协议是轻量、简单、开放和易于实现的 提供服务质量管理 采用发布/订阅模式，方便消息传递 基于TCP/IP网络连接，提供有序，无损的双向连接 假如数据不可知，不强求传输数据的类型与格式，保持灵活性 1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量 应用场景MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域: 物联网M2M通信，物联网大数据采集 Android消息推送，Web消息推送 移动即时消息，例如Facebook Messenger 智能硬件、智能家居 车联网通信、电动车站桩采集 电力、石油与能源等行业市场 主题和负载MQTT传输的消息分为：主题（Topic）和负载（payload）: Topic：可以理解为消息的类型，订阅者订阅（Subscribe)后，就会收到该主题的消息内容（payload） payload：可以理解为消息的内容，失致订阅者具体要使用的内容 三种消息发布服务质量 至多一次：消息发布完全依赖底层TCP/IP网络，qos=0。会发生消息丢失或重复的情况，这一级别可用于如下情况，环境传感器数据，丢失一次读记录影响不大 至少一次：确保消息到达，qos=1。但消息重复可能会发生 只有一次：确保消息到底一次，qos=2。 协议原理 实现方式MQTT协议具有三种身份：发布者（Publish)、代理（Broker)（服务器）、订阅者（Subscribe）其中，消息的发布者和订阅者都是客户端，消息代理是服务器。消息的发布者可以同时是订阅者 网络传输与应用消息MQTT会构建底层网络传输：它将简历客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关联。 MQTT客户端一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以： 发布其他客户端可能会订阅的消息 订阅其他客户端发布的消息 退订或删除应用程序的消息 断开与服务器连接 MQTT服务端MQTT服务器已称为”消息代理”(Broker)，可以是一个应用程序或一台设备。它位于消息发布者和订阅者中间，它可以： 接受来自客户的网络连接 接受客户发布的应用消息 处理来自客户端的订阅和退订请求 向订阅的客户转发应用程序消息 MQTT协议中的订阅、主题、会话 订阅（Subscription）订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每个会话中的每个订阅都有一个不同的主题筛选器。 会话（Session）每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。绘画存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。 主题名（Topic Name）连接到一个应用程序消息的标签，如果该标签与服务器的订阅相匹配，服务器就会将消息发送给订阅所匹配标签的客户端。 主题筛选器（Topic Filter）一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。 MQTT协议中的方法MQTT协议中定义了一些方法，也被称之为动作，来表示对于确定资源进行的操作。资源可以是预先存在的数据或者动态生成的数据，这取决于服务器的实现，通常来说，资源指服务器上的文件或输出。主要方法有： Connect：等待与服务器建立连接 Disconnect：等待MQTT客户端完成所作的工作，并与服务器断开TCP/IP会话 Subscribe:等待完成订阅 UnSubscribe:等待服务器取消客户端的一个或多个topics订阅 Publish：MQTT客户端发送消息请求，发送完成后返回应用程序线程 MQTT协议数据包结构在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Varibale header）、消息体（payload）三部分构成。 固定头（Fixed header）：存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识数据包类型为byte 1中bits7-4,相当于一个4位的无符号值，类型如下：标识位为byte 1中bits3-0,在不使用标识位的消息类型中，标识位被做为保留位。如果收到无效的标志时，接收端必须关闭网络连接： DUP：发布消息的副本，用来保证消息的可靠传输。如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送 QoS：发布消息的服务质量，即：保证消息传递的次数 00：最多一次，即：&lt;=1 01：至少一次，即：&gt;=1 10：一次，即：=1 11：预留 RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放剩余长度（Remaining Length）固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为 1时，表示长度不足，需要使用二个字节继续保存。 可变头（Varibale header）：存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识： 很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK 消息体（payload））：存在于部分MQTT数据包中，表示客户端收到的具体内容Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息： CONNECT:消息体内容主要是客户端的ClientID、订阅的Topic、Message以及用户名和密码 SUBSCRIBE:消息内内容是一系列要订阅的主题以及QoS SUBACK：消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复 UNSUBSCRIBE:消息体内容是要订阅的主题","categories":[{"name":"协议","slug":"协议","permalink":"http://example.com/categories/%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"霍乱时期的爱情——读书笔记","slug":"读书笔记--霍乱时期的爱情","date":"2020-04-20T13:12:03.000Z","updated":"2021-08-07T05:59:13.567Z","comments":true,"path":"2020/04/20/读书笔记--霍乱时期的爱情/","link":"","permalink":"http://example.com/2020/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 我相信爱情是有许多模样的，街头巷尾里互相搀扶的老夫老妻，小家里过着平平淡淡日子的夫妇，婚礼上很累却非常甜蜜的新人，还有拉着彼此的手在暴雨天一路奔跑的情侣等。当然，有积极正面的，热情似火的爱，也必然有阴暗扭曲，卑劣粗俗的爱，这本书让我看到关于爱情更多的细枝末节。当年轻的阿里萨第一次见到费尔明娜，一生内心的纠葛就此开始。从最初的懵懂羞涩，在花园装作看书看诗集，实则等待费尔明娜路过时的那一撇，那就是心动的第一个阶段吧。彼时费尔明娜乖巧懂事，对父亲言听计从，但在阿里萨鼓起勇气送出信件的那一天，她的心态悄然变化。虽然二人几乎没有或正式的面对面的对话，但是在信中从无话不谈到私定终身，看到这里我觉得有些荒诞，但也不可否认，在那个年代这是可能发生的事情，或许这不是靠谱的爱情，但它一定是两个少男少女勇敢无畏，憧憬爱情的表现。纸里包不住火，洛伦索发现女儿的地下情，愤怒之余却也拿女儿没什么办法，只能带着女儿出去旅行一场，以期让她忘记阿里萨。在经历时间和空间的考验之后，费尔明娜在代笔门廊处看见阿里萨的第一眼果断决定放弃这一段长达数年的感情，她完全没有想到阿里萨是这般模样。我想这是爱情的一种残酷，发现自己朝思暮想的另一半因为某种不合的观念，失望占据内心，想要迫切希望离开，以逃避给自己带来的情感冲击。而阿里萨也因此陷入漫长的相思之苦，在无数个日日夜夜幻想着未来继续和费尔明娜生活下去的可能。医生的出现，让故事更加戏剧化，他和阿里萨是完完全全两种不同的人。医生光鲜亮丽，才华横溢，医术高超，和阿里萨奇怪装束，一身为爱情诗歌所浸染的气息形成鲜明对比。费尔明娜嫁给了医生，甜蜜旅行之后是多年的不开心，期间偶尔穿插着过往蜜月的回忆。漫长岁月不过弹指间就过去了，阿里萨对她的感情日渐病态，一边心里装着她，一边勾搭成百上千的女人满足生理上需求。漫长岁月里，阿里萨也有那么几个中意的女人，奇怪的是他从来没有放弃一直盘踞在内心的念想，也从未对其他人提起，少年时的爱慕经受了五十多年岁月的考验，尽管这种感情面目全非，阿里萨还是坚持了下去，足够令人惊叹。阿里萨终于等到医生死亡的消息，不像他想象中的体面离世，跌倒死亡让阿里萨没有把竞争对手比下去的快感。即便如此，暮年的他没有浪费太多时间，再次向费尔明娜表明心意，在坚持不懈的努力下，费尔明娜意识到自己是对阿里萨那一份特殊感情。最终在他们剩下的生命里借助霍乱的掩护，阿里萨如愿和费尔明娜一起在海上漂流了下去。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"网络攻击-XSS攻击详解","slug":"网络攻击-XSS攻击详解","date":"2020-03-10T05:39:41.000Z","updated":"2022-01-11T07:50:17.048Z","comments":true,"path":"2020/03/10/网络攻击-XSS攻击详解/","link":"","permalink":"http://example.com/2020/03/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB-XSS%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 XSS 概念跨站脚本攻击(XSS),是最普遍的Web应用安全漏洞. 这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中,当正常用户访问该页面时,则可导致嵌入的恶意脚本代码的执行,从而达到恶意攻击用户的目的. 人们经常将跨站脚本攻击(Cross Site Scripting)缩写为 CSS ,但这会与层叠样式表(Cascading Style Sheet,CSS)的缩写混淆,因此将其改为 XSS . XSS 危害 盗用 cookie ,获取敏感信息 XSS 原理HTML 是一种超文本标记语言,通过特殊对待一些字符来区别文本和标记:小于符号(&lt;)被看作是 HTML 标签的开始,浏览器会将特定的字符误认为HTML 标签.当 HTML标签引入了 JavaScript 脚本时,浏览器就会执行.因此,当这些特殊字符不能被动态页面检查或检查出错的时候,就会产生 XSS 漏洞 XSS 类型 反射型(非持久型):指发生请求时,XSS代码出现在请求URL中,作为参数提交到服务器,服务器解析并响应,响应结果中包含XSS代码,最后被浏览器解析并执行.这个过程像一次反射,故叫做反射型XSS. 存储型(持久型):将XSS代码存储在服务器中. DOM跨站:指受害者端的网页脚本在修改本地页面DOM环境时未进行合理的处置,而使得攻击脚本被执行.在整个攻击过程中,服务器响应的页面并没有发生变化,引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用 具体示例 反射型XSS假如一个接口http://www.test.com/xss/reflect.php的代码如下: 123&lt;?phpecho &#x27;x&#x27;&gt; 这里的x值没有经过处理直接输出,当客户端提交请求http://www.test.com/xss/reflect.php?x=&lt;script&gt;alert(1)&lt;/script&gt;,此时浏览器会触发alert()函数. 存储型XSS最典型的例子就是留言板XSS,当用户提交了一条包含XSS代码的留言存储到数据库,目标用户查看留言板时,留言内容会从数据库提取并展示在页面上,浏览器发现有XSS代码,就当成HTML和JavaScript解析执行,从而触发XSS攻击.简单的可以是一个alert()弹窗,复杂一些的可以是盗用用户cookie等操作. DOM XSSDOM XSS攻击并不需要服务器参与,触发攻击靠浏览器的DOM解析,核心是运用DOM函数.我们知道eval()函数有一个作用是将一段字符串转换成JavaScript语句,因此在JavaScript中使用eval()是一件有风险的事情,容易造成XSS攻击. 1eval(&quot;alert(&#x27;Hello world&#x27;)&quot;) 可能触发DOM XSS攻击的属性有: document.referer属性 window.name属性 location属性 innerHTML属性 documen.write 防范手段 入参字符过滤对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤. 出参进行编码像一些常见的符号,如&lt;&gt;在输入的时候要对其进行转换编码,这样做浏览器是不会对该标签进行解释执行的,同时也不影响显示效果. 入参长度限制xss攻击要能达成往往需要较长的字符串,因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"网络攻击","slug":"网络攻击","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}]},{"title":"JavaScript中对象的拓展、密封及冻结三大特性","slug":"JavaScript中对象的拓展、密封及冻结三大特性","date":"2020-03-02T09:24:20.000Z","updated":"2022-01-11T07:44:57.960Z","comments":true,"path":"2020/03/02/JavaScript中对象的拓展、密封及冻结三大特性/","link":"","permalink":"http://example.com/2020/03/02/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95%E3%80%81%E5%AF%86%E5%B0%81%E5%8F%8A%E5%86%BB%E7%BB%93%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 属性描述符属性描述符是ES5引入的概念,它用于描述对象的特征. 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符. MDN中的描述：数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。 数据描述符和存取描述符均具有以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下) configurable: 可配置性.当且仅当该属性的 configurable 为 true 时,该属性描述符才能够被改变,同时该属性也能从对应的对象上被删除.默认为 false. enumerable: 可枚举性.当且仅当该属性的enumerable为true时,该属性才能够出现在对象的枚举属性中.默认为 false. 数据描述符同时具有以下可选键值： writable: 可写性.当且仅当该属性的writable为true时,value才能被赋值运算符改变.默认为 false. value: 属性值.该属性对应的值.可以是任何有效的 JavaScript 值(数值,对象,函数等).默认为 undefined. 存取描述符同时具有以下可选键值： get: 一个给属性提供 getter 的方法,如果没有 getter 则为 undefined.当访问该属性时.该方法会被执行,方法执行时没有参数传入,但是会传入this对象（由于继承关系,这里的this并不一定是定义该属性的对象）. set: 一个给属性提供 setter 的方法,如果没有 setter 则为 undefined.当属性值修改时,触发执行该方法.该方法将接受唯一参数,即该属性新的参数值. 描述符可同时具有的键值:| | configurable | enumerable | value | writable | get | set| ——– | —–: | :—-: | :—-: | :—-: | :—-: | :—-: || 数据描述符 | Yes | Yes | Yes | Yes | No | No || 存取描述符 | Yes | Yes | No | No | Yes | Yes | 如果一个描述符不具有value,writable,get 和 set 任意一个关键字,那么它将被认为是一个数据描述符.如果一个描述符同时有(value或writable)和(get或set)关键字,将会产生一个异常. 常用API Object.defineProperty(obj, prop, descriptor) obj:在其上定义或修改属性的对象. prop:要定义或修改的属性的名称. descriptor:将被定义或修改的属性描述符. Object.defineProperties(obj, props) obj:在其上定义或修改属性的对象. props:要定义其可枚举属性或修改的属性描述符的对象.对象中存在的属性描述符主要有两种:数据描述符和访问器描述符 Object.getOwnPropertyDescriptors(obj) obj:任意对象. Object.getOwnPropertyDescriptor(obj, prop) obj:需要查找的目标对象. prop:目标对象内属性名称 用法示例12345678910111213141516171819202122232425262728293031323334353637383940let obj = &#123;&#125;;Object.defineProperty(obj, &#x27;name&#x27;, &#123; configurable: false, enumerable: true, writable: true, value: &#x27;Cola&#x27;&#125;);Object.defineProperties(obj, &#123; color: &#123; configurable: false, enumerable: true, writable: true, value: &#x27;red&#x27; &#125;, price: &#123; configurable: false, enumerable: true, writable: true, value: &#x27;3.5&#x27; &#125;&#125;);Object.defineProperty(obj, &#x27;updatePrice&#x27;, &#123; configurable: false, enumerable: true, get: function () &#123; return this.capacity; &#125;, set: function (price) &#123; this.price = price; &#125;&#125;);console.log(obj);//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 3.5, updatePrice: [Getter/Setter] &#125;obj.updatePrice = 5;console.log(obj);//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 5, updatePrice: [Getter/Setter] &#125; 规则 如果属性不可配置,则不能修改它的可配置性和可枚举性,否则抛出异常 1234567891011121314151617181920212223242526let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: false, enumerable: false&#125;)try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: true &#125;)&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; enumerable: true &#125;)&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;color&#x27;));//&#123; value: undefined, writable: false, enumerable: false, configurable: false &#125; 如果存取器属性是不可配置的，则不能修改get和set方法，也不能将它转换为数据属性 123456789101112131415161718192021222324252627282930313233343536373839404142let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; configurable: false, enumerable: true, get: function () &#123; return this.name; &#125;, set: function (name) &#123; this.name = name; &#125;&#125;);try &#123; Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; get: function () &#123; return &#x27;Coca &#x27; + this.name; &#125; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: updateName&#125;try &#123; Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; set: function (val) &#123; this.name = val + this.name; &#125; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: updateName&#125;try &#123; Object.defineProperty(obj, &#x27;updateName&#x27;, &#123; value: &#x27;Coco Cola&#x27; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: updateName&#125; 如果数据属性是不可配置的,则不能将它转换为存取器属性;同时也不能将它的可写性从false修改成true，但可以从true修改为false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: false, writable: false, value: &#x27;red&#x27;&#125;);try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; writable: true &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; get: function () &#123; return this.name; &#125; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: false, writable: true, value: &#x27;3.5&#x27;&#125;);try &#123; Object.defineProperty(obj, &#x27;price&#x27;, &#123; writable: false, value: &#x27;5&#x27; &#125;);&#125; catch (e) &#123; console.log(e);&#125;try &#123; Object.defineProperty(obj, &#x27;price&#x27;, &#123; value: &#x27;6&#x27; &#125;);&#125; catch (e) &#123; console.log(e);&#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;color&#x27;)); //&#123; value: &#x27;red&#x27;, writable: false, enumerable: false, configurable: false &#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;price&#x27;)); //&#123; value: &#x27;5&#x27;, writable: false, enumerable: false, configurable: false &#125; 如果数据属性是不可配置且不可写的,就不能修改它的值;如果是可配置但不可写，则可以修改值 1234567891011121314151617181920212223242526272829303132333435363738394041let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; configurable: false, writable: false, value: &#x27;red&#x27;&#125;);try &#123; Object.defineProperty(obj, &#x27;color&#x27;, &#123; value: &#x27;blue&#x27; &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot redefine property: color&#125;Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: true, writable: false, value: &#x27;3.5&#x27;&#125;);//可以直接修改值Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: true, writable: false, value: &#x27;12&#x27;&#125;);console.log(obj.price); //5console.log(Object.getOwnPropertyDescriptor(obj, &#x27;price&#x27;)); //&#123; value: &#x27;12&#x27;, writable: false, enumerable: false, configurable: true &#125;//可以修改writable为true后再修改值Object.defineProperty(obj, &#x27;price&#x27;, &#123; configurable: true, writable: true, value: &#x27;3.5&#x27;&#125;);obj.price = 5;console.log(obj.price); //5 严格模式下,只指定get时,如果对该属性赋值将会抛出类型错误异常,只指定set时,如果读取该属性将返回undefined,非严格模式下都不抛出异常 1234567891011121314151617181920212223242526272829&#x27;use strict&#x27;let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.defineProperty(obj, &#x27;color&#x27;, &#123; get: function () &#123; return &#x27;Coca &#x27; + this.name; &#125;&#125;);try &#123; obj.color = &#x27;blue&#x27;;&#125; catch (e) &#123; console.log(e); //TypeError: Cannot set property color of #&lt;Object&gt; which has only a getter&#125;console.log(obj.color); //Coca ColaObject.defineProperty(obj, &#x27;price&#x27;, &#123; set: function (val) &#123; this.name = val; &#125;&#125;);try &#123; console.log(obj.price);//undefined&#125; catch (e) &#123; console.log(e); &#125; 扩展特性如果一个对象可以添加新的属性,那么这个对象是可扩展的.如何检验对象是否可扩展及如何让它变得不可扩展呢？ 常用API Object.isExtensible(obj) obj：需要检测的对象 Object.preventExtensions(obj) obj：将要变得不可扩展的对象 用法示例1234567891011121314151617181920212223242526272829303132333435let obj = &#123; name: &#x27;Cola&#x27;&#125;//新创建的对象默认是可扩展的console.log(Object.isExtensible(obj)); //trueObject.preventExtensions(obj);console.log(Object.isExtensible(obj)); //falseobj.color = &#x27;red&#x27;;console.log(obj); //&#123; name: &#x27;Cola&#x27; &#125;try &#123; Object.defineProperty(obj, &quot;name&quot;, &#123; value: &#x27;Coca Cola&#x27; &#125;); //使用`Object.defineProperty`方法为不可扩展对象添加新属性会抛出异常 Object.defineProperty(obj, &quot;price&quot;, &#123; value: 3.5 &#125;);&#125; catch (e) &#123; console.log(e); //TypeError: Cannot define property price, object is not extensible&#125; finally &#123; console.log(obj); //&#123; name: &#x27;Coca Cola&#x27; &#125;&#125;console.log(Object.getOwnPropertyDescriptor(obj, &#x27;name&#x27;));//&#123; value: &#x27;Coca Cola&#x27;, writable: true, enumerable: true, configurable: true &#125;//writable属性为false时，属性值不可修改Object.defineProperty(obj, &quot;name&quot;, &#123; value: &#x27;Coca Cola&#x27;, writable: false,&#125;);obj.name = &#x27;Sprite&#x27;;console.log(obj); 密封特性密封对象是指不可扩展，且自身所有属性都不可配置的对象. 也就是说密封对象要满足以下条件: 不能添加新属性 不能删除已有属性 不能修改已有属性的可枚举性、可配置性、可写性,但可能可以修改已有属性的值的对象 常用API Object.isSealed(obj) obj：需要检测的对象 Object.seal(obj) obj：需要被密封的对象 用法示例1234567891011121314151617let obj = &#123; name: &#x27;Cola&#x27;&#125;//新建的对象默认不是密封的console.log(Object.isSealed(obj)); //false//手动密封Object.preventExtensions(obj);Object.defineProperty(obj, &#x27;name&#x27;, &#123; configurable: false&#125;)console.log(Object.isSealed(obj)); //true//空对象的手动密封let obj2 = &#123;&#125;Object.preventExtensions(obj2);console.log(Object.isSealed(obj2));//true 12345678910111213141516let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.seal(obj);console.log(Object.isSealed(obj)); //true//密封后不再能够添加或删除属性obj.color = &#x27;red&#x27;;delete obj.name;console.log(obj); //&#123; name: &#x27;Coca Cola&#x27; &#125;//密封后如果writable为trueobj.name = &#x27;Coca Cola&#x27;;console.log(obj); //&#123; name: &#x27;Pepsi Cola&#x27; &#125; 冻结特性冻结对象要满足以下条件: 不能添加新属性 不能删除已有属性 不能修改已有属性的可枚举性、可配置性、可写性 即这个对象永远是不可变的. 常用API Object.isFrozen(obj) obj：需要检测的对象 Object.freeze(obj) obj：需要被冻结的对象 用法示例1234567891011121314let obj = &#123; name: &#x27;Cola&#x27;&#125;//新建的对象默认不是冻结的console.log(Object.isFrozen(obj)); //false//当对象变得不可扩展且无属性时，也成为冻结对象Object.preventExtensions(obj);delete obj.name;console.log(Object.isFrozen(obj));//true//不可扩展的空对象是一个密封对象，同时也是冻结对象console.log(Object.isSealed(Object.preventExtensions(&#123;&#125;))); //trueconsole.log(Object.isFrozen(Object.preventExtensions(&#123;&#125;))); //true 12345678910let obj = &#123; name: &#x27;Cola&#x27;&#125;Object.freeze(obj);console.log(Object.isFrozen(obj)); //true//对冻结对象的任何操作都会失败obj.name = &#x27;Coca Cola&#x27;;delete obj.name;console.log(obj); 注意:再严格模式下,对冻结对象的操作会抛出类型异常 浅冻结1234567891011let obj = &#123; name: &#x27;Cola&#x27;, color: &#123; CocaCola: &#x27;red&#x27;, PepsiCola: &#x27;blue&#x27; &#125;&#125;Object.freeze(obj);obj.name = &#x27;Sprite&#x27;obj.color.CocaCola = &#x27;white&#x27;;console.log(obj);//&#123; name: &#x27;Cola&#x27;, color: &#123; CocaCola: &#x27;white&#x27;, PepsiCola: &#x27;blue&#x27; &#125; &#125; 深冻结123456789101112function completelyFreezeObj(obj) &#123; if (Object.prototype.toString.call(obj) != &quot;[object Object]&quot;) &#123; console.error(&quot;obj不是对象&quot;); return; &#125; Object.freeze(obj); Object.keys(obj).forEach((key) =&gt; &#123; if (Object.prototype.toString.call(obj[key]) == &quot;[object Object]&quot;) &#123; completelyFreezeObj(obj[key]); &#125; &#125;);&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Google JavaScript 编码规范部分整理","slug":"Google JavaScript 编码规范部分翻译整理","date":"2020-02-17T08:54:50.000Z","updated":"2022-01-11T07:49:50.679Z","comments":true,"path":"2020/02/17/Google JavaScript 编码规范部分翻译整理/","link":"","permalink":"http://example.com/2020/02/17/Google%20JavaScript%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 写在前面本文参考: https://google.github.io/styleguide/jsguide.html http://alloyteam.github.io/JX/doc/specification/google-javascript.xml https://max.book118.com/html/2019/0202/7052110006002005.shtm https://segmentfault.com/a/1190000012916070#item-5-22 https://github.com/wayou/wayou.github.io/issues/21 因本人水平有限,如有错误,可及时联系作者修改. 背景JavaScript 是一种客户端脚本语言，Google 的许多开源工程中都有用到它。这份指南列出了编写 JavaScript 时需要遵守的规则，当且仅当 JavaScript 源文件遵守此处规则时，它才被描述为 Google 风格。 JavaScript 语言规范 局部变量声明 使用const 和let用 const或 let 声明所有局部变量，默认情况下使用const，除非需要重新分配变量。 一个变量一个声明每个局部变量声明仅声明一个变量。不使用诸如 let a = 1, b = 2; 这样的声明形式。 在需要时进行声明，并尽快初始化局部变量不是在其包含的块或类似块的结构的开头习惯性地声明的。而是将局部声明在接近首次使用它们的地方(在合理范围内)，以最大程度地减小其范围。 根据需要声明类型可以在声明的局部变量上方添加JSDoc类型注释，或者如果不存在其他JSDoc，则可以在变量名称之前内联。 例： 1234567const /**! Array &lt;number&gt; */ data = [];/** * 一些描述 * @type &#123;! Array &lt;number&gt;&#125; */ const data = []; 不允许混合使用内联和JSDoc样式：因为编译器将仅处理第一个JSDoc，即内联注释会丢失，例： 1/** 一些描述。*/ const /**！Array &lt;number&gt; */ 数据= []; 提示：在许多情况下，编译器可以推断出模板化类型，但不能推断其参数。当初始化字面量或构造函数调用不包含模板参数类型的任何值(例如，空数组，对象，Map和Set)或变量在闭包中修改时，在这些情况下，局部变量类型注释特别有用，否则编译器会将模板参数推断成未知。 数组字面量 使用逗号结尾如果最后一个元素和右括号之间有换行符，请在结尾加上逗号，例： 1234const values = [ &#x27;first value&#x27;, &#x27;second value&#x27;,]; 不要使用可变参数的 Array构造函数构造函数很容易因为传参不恰当而导致错误。请改用字面量形式。不建议的形式，例： 1234const a1 = new Array(x1, x2, x3);const a2 = new Array(x1, x2);const a3 = new Array(x1);const a4 = new Array(); 除了第三种情况外，这可以按照预期工作：如果x1为整数，那么a3则是一个长度为x1的数组，其所有元素均为undefined。如果x1为其他任何数字，则将引发异常。 建议的写法，例： 1234const a1 = [x1, x2, x3];const a2 = [x1, x2];const a3 = [x1];const a4 = []; 在适当的时候，允许用new Array(length)显示分配一个给定长度的数组。 非数字属性请勿在数组上定义或使用非数字属性（除了length）。使用Map（或Object）代替。 解构数组字面量可用于分配的左侧以执行解构（例如，从单个数组中解压缩多个值或可迭代时）。 可以包含最后一个rest元素（在…和变量名之间没有空格）,例： 123const [a, b, c, ...rest] = generateResults();//解构赋值还可以忽略某些元素let [, b,, d] = someArray 解构也可以用于函数参数（请注意，参数名称是必需的，但会被忽略）。如果解构数组的参数是可选的，要始终指定[]为默认值，并在左侧提供默认值，例： 12/** @param &#123;!Array&lt;number&gt;=&#125; param1 */function optionalDestructuring([a = 4, b = 2] = []) &#123; … &#125;; 错误的写法，例： 1function badDestructuring([a, b] = [4, 2]) &#123; … &#125;; 提示：对于将多个值（解包）到一个函数的参数或返回中，在可能的情况下，优先选择对象分解而不是数组分解，因为它允许命名单个元素并为每个元素指定不同的类型。 展开运算符数组字面量可以包含展开运算符（… ），以将元素从一个或多个可迭代对象中展开，而不是用更笨拙的构造Array.prototype 。变量紧跟在展开运算符后，没有空格。 对象字面量 不要使用Object构造函数虽然Object 构造器没有上述类似的问题, 但鉴于可读性和一致性考虑, 最好还是在字面上更清晰地指明，例： 123var o = &#123;&#125;;var o2 = &#123; a: 0, b: 1, c: 2 &#125; 请勿混用带引号和不带引号的键对象字面量可以表示结构（具有未加引号的键和/或符号）或字典（具有引号和/或计算的键）。不要将这两种键类型混合在单个对象字面量中，例： 1234let obj = &#123; width: 42,// struct风格的未加引号的键 &#x27;maxWidth&#x27;: 43 // dict风格的加引号的键&#125; 这还扩展到将属性名称传递给函数，例如 hasOwnProperty。特别是这样做会破坏编译后的代码，因为编译器无法重命名/混淆字符串文字。不建议的写法，例： 12345/** @type &#123;&#123;width: number, maxWidth: (number|undefined)&#125;&#125; */const o = &#123;width: 42&#125;;if (o.hasOwnProperty(&#x27;maxWidth&#x27;)) &#123;...&#125; 最好这样实现，例： 12345/** @type &#123;&#123;width: number, maxWidth: (number|undefined)&#125;&#125; */const o = &#123;width: 42&#125;;if (o.maxWidth != null) &#123;...&#125; 计算的属性名称允许使用计算的属性名称（例如&#123;[&#39;key&#39;+ foo（）]：42&#125;），并且将其视为dict样式（带引号的）键（即，不得与非引号的键混合使用），除非计算出的属性 是一个符号（例如[Symbol.iterator]）。 枚举值也可以用于计算键，但不应与同一字面量中的非枚举键混合使用,例： 1234567function foo()&#123; return &#x27;width&#x27;&#125;let obj = &#123; width: 42, [&#x27;max&#x27; + foo()] : 43&#125; 方法速记可以使用方法简写（&#123;method（）&#123;…&#125;&#125;）代替冒号后紧跟函数或箭头函数常量，从而在对象上定义方法。例： 123456let obj = &#123; width: 42, getWidth()&#123; return this.width; &#125;&#125; 速记属性对象字面量允许使用速记属性,例： 1234567const foo = 1;const bar = 2;const obj = &#123;foo,bar,method() &#123; return this.foo + this.bar; &#125;&#125;; 解构对象解构模式可以在分配的左侧使用，以执行解构并从单个对象解压缩多个值。分解后的对象也可以用作函数参数，但应保持尽可能的简单：单个级别的未引用速记属性。 参数解构中可能不使用更深层的嵌套和计算的属性。 在解构参数的左侧指定任何默认值（&#123;str =&#39;some default&#39;&#125; = &#123;&#125;，而不是&#123;str&#125; = &#123;str：&#39;some default&#39;&#125;），如果解构对象为本身是可选的，它必须默认为&#123;&#125;。 可以为分解结构参数的JSDoc指定任何名称（该名称未使用，但编译器需要）,例： 12345678910111213141516/*** @param &#123;string&#125; ordinary* @param &#123;&#123;num: (number|undefined), str: (string|undefined)&#125;=&#125; param1* num: The number of times to do something.* str: A string to do stuff to.*/function destructured(ordinary, &#123;num, str = &#x27;some default&#x27;&#125; = &#123;&#125;)不被允许的写法，例：/** @param &#123;&#123;x: &#123;num: (number|undefined), str: (string|undefined)&#125;&#125;&#125; param1 */function nestedTooDeeply(&#123;x: &#123;num, str&#125;&#125;) &#123;&#125;;/** @param &#123;&#123;num: (number|undefined), str: (string|undefined)&#125;=&#125; param1 */function nonShorthandProperty(&#123;num: a, str: b&#125; = &#123;&#125;) &#123;&#125;;/** @param &#123;&#123;a: number, b: number&#125;&#125; param1 */function computedKey(&#123;a, b, [a + b]: c&#125;) &#123;&#125;;/** @param &#123;&#123;a: number, b: string&#125;=&#125; param1 */function nontrivialDefault(&#123;a, b&#125; = &#123;a: 2, b: 4&#125;) &#123;&#125;; 枚举枚举是通过将@enum批注添加到对象字面量中来定义的。 定义枚举后，可能无法将其他属性添加到枚举中。 枚举必须是常量，并且所有枚举值都必须是不可变的,例： 12345678910111213141516171819/*** Supported temperature scales.* @enum &#123;string&#125;*/const TemperatureScale = &#123; CELSIUS: &#x27;celsius&#x27;, FAHRENHEIT: &#x27;fahrenheit&#x27;,&#125;;/*** An enum with two options.* @enum &#123;number&#125;*/const Option = &#123; /** The option used shall have been the first. */ FIRST_OPTION: 1, /** The second among two options. */ SECOND_OPTION: 2,&#125;; 类 构造函数构造函数是可选的,子类构造函数必须在设置任何字段或以其他方式访问this之前调用super（）。正确的写法,例: 1234constructor(name, age, height) &#123; super(name,age); this.height = height;&#125; 错误的写法,例: 12345constructor(name, age, height) &#123; this.height = height; super(name,age); //SyntaxError: &#x27;this&#x27; is not allowed before super()&#125; 字段在构造函数中设置所有具体对象的字段（即方法以外的所有属性）。使用 @const 修饰的字段代表常量，不能被重新赋值。 使用适当的可见性注释（@private，@protected，@package）注释非公共字段，并在所有@private字段的名称后面加上下划线。 字段永远不会设置在具体类的原型上,例: 123456789class Foo &#123;constructor() &#123; /** @private @const &#123;!Bar&#125; */ this.bar_ = computeBar(); /** @protected @const &#123;!Baz&#125; */ this.baz = computeBaz();&#125;&#125; 提示:类在初始化之后，就不能再向其添加或删除属性了，因为这会影响虚拟机对其进行优化。如果必要，可以将之后才进行初始化的字段先赋值为 undefined，这样先占位之后，防止后面再添加新属性。对象身上的@struct 注释可以对不存在的字段的访问进行检查。类自带了这一功能。 计算属性计算属性只能用于类的属性是 symbol 的情况。 Dict-style 类型的属性（带引号或非 symbol 的计算属性是不被允许的。对于可遍历的类，需要定义其 [Symbol.iterator] 方法。其他情况下少用 Symbol。 注意:使用其他内建的 symbol 时要格外小心（e.g. Symbol.isConcatSpreadable）,因为编译器没有对它进行垫片（向后兼容）处理，所以在旧版浏览器中会有问题 静态方法在不影响可读性的前提下，推荐使用模块内部的函数而不是静态方法。 静态方法应该只用于基类。静态方法不应该从一个保存了实例的变量身上调用，这个实例有可能是构造器或者子类的构造器初始化而来（静态方法应该使用 @nocollapse 来注释），而且如果子类没有定义该方法的话，不应该从子类直接调用。 错误的写法,例: 1234class Base &#123; /** @nocollapse */ static foo() &#123;&#125; &#125;class Sub extends Base &#123;&#125;function callFoo(cls) &#123; cls.foo(); &#125; // discouraged: don&#x27;t call static methods dynamicallySub.foo(); // illegal: don&#x27;t call static methods on subclasses that don&#x27;t define it themselves 声明类的旧方式ES6 方式的类声明是首选，但在某些情况下ES6类可能不可行。例如： 如果存在或将要存在子类，包括框架创建的子类，还不能立即使用 ES6 风格的类声明。因为如果基类使用 ES6 方式的话，所有子类代码都需要更改。 有些框架在调用子类构造器时需要显式提供 this，而 ES6 风格的类中在调用 super 前是获取不到 this 的。 此规则还应用于这些代码：let，const，默认参数，rest 和箭头函数。 通过 goog.defineClass 可以进行类 ES6 方式的类声明： 123456789101112131415161718let C = goog.defineClass(S, &#123;/*** @param &#123;string&#125; value*/constructor(value) &#123; S.call(this, 2); /** @const */ this.prop = value;&#125;,/*** @param &#123;string&#125; param* @return &#123;number&#125;*/method(param) &#123; return 0;&#125;,&#125;); 另外，尽管goog.defineClass所有新代码都应首选，但也可以使用更传统的语法,例: 123456789101112131415161718/*** @constructor @extends &#123;S&#125;* @param &#123;string&#125; value*/function C(value) &#123;S.call(this, 2);/** @const */this.prop = value;&#125;goog.inherits(C, S);/*** @param &#123;string&#125; param* @return &#123;number&#125;*/C.prototype.method = function(param) &#123;return 0;&#125;; 如果有基类的话，实例中的属性需要在基类的构造器中定义。而方法则需要在构造器的原型上定义。 一开始正确地定义构造器的继承关系并不是件容易的事！所以，最好使用 the Closure Library 提供的 goog.inherits 方法。 不要直接操作prototype通过 class 关键字定义类比操作 prototype 更加简洁和直观。一般情况下的代码并没有必要操作原型，尽管它们对于定义旧式类声明中定义的类仍然有用。明确禁止混入和修改内置对象的原型.例外:框架代码(例如Polymer或Angular)可能需要使用prototypes，否则实现起来会更加丑陋。 Getters and Setters不要使用 JavaScript getter和 setter属性。其行为不透明出问题难追查，编译器支持上也有局限。提供正常的方法来代替他们。 例外：在某些情况下不可避免地会定义getter或setter（例如Angular和Polymer等数据绑定框架，或者无法与调整的外部API的兼容时）。仅在这些情况下，使用getter和setter时要格外小心，前提是它们是通过get和set简写方法关键字定义的Object.defineProperties（或（不是 Object.defineProperty，这会干扰属性重命名））。Getters不得更改可观察状态。 不允许的写法,例: 123class Foo &#123;get next() &#123; return this.nextId++; &#125;&#125; 重写 toString可以重写 toString 方法，但始终应该返回成功，并且不产生副作用（side effects）。 提示:需要注意的是，特别是在 toString 中调用其他方法时，特殊情况可能导致死循环。 接口接口可以通过 @interface 或 @record 来声明。通过 @record 声明的接口能够被显式（i.e. 通过 @implements）或者隐式地被类或对象实现。接口上的所有非静态方法主体都必须为空块。 字段必须在类构造函数中声明为未初始化的成员,例: 12345678910111213141516/*** Something that can frobnicate.* @record*/class Frobnicator &#123;constructor() &#123; /** @type &#123;number&#125; The number of attempts before giving up. */ this.attempts;&#125;/*** Performs the frobnication according to the given strategy.* @param &#123;!FrobnicationStrategy&#125; strategy*/frobnicate(strategy) &#123;&#125;&#125; 抽象类适当时使用抽象类。抽象类和方法必须使用注释@abstract。不要使用goog.abstractMethod。请参阅抽象类和方法。 函数 顶级函数顶级函数可以直接在导出对象上定义，也可以在本地声明，也可以选择导出,例: 1234/** @param &#123;string&#125; str */exports.processString = (str) =&gt; &#123;// Process the string.&#125;; 123456/** @param &#123;string&#125; str */const processString = (str) =&gt; &#123;// Process the string.&#125;;exports = &#123;processString&#125;; 嵌套函数及闭包函数内可包含嵌套函数的定义。如果需要，可以赋值给一个 const 变量。 箭头函数箭头函数提供了简洁的函数语法，并简化了嵌套函数的作用域。 优先选择箭头函数而不是function关键字，特别是对于嵌套函数。 推荐使用箭头函数代替 f.bind(this)，特别是代替 goog.bind(f,this)。 避免const self = this这样的写法。箭头函数特别适合用于可能会传参回调。 箭头的左侧包含零个或多个参数。如果只有一个未分解的参数，则参数周围的括号是可选的。使用括号时，可以指定内联参数类型 提示:始终都写括号是种好的做法，因为后面如果一旦新加了参数又忘记写括号则会有语法错误。 箭头的右侧包含函数的主体。 默认情况下，主体为block语句（零个或多个用花括号括起来的语句）。 如果发生以下情况之一，则主体也可能是隐式返回的单个表达式：程序逻辑要求返回值，或者void运算符位于单个函数或方法调用之前（使用void确保未定义返回，防止泄漏值并传达意图）。 如果单一表达形式提高了可读性（例如，对于简短表达或简单表达），则它是首选,例: 12345678910111213141516171819202122232425/*** Arrow functions can be documented just like normal functions.* @param &#123;number&#125; numParam A number to add.* @param &#123;string&#125; strParam Another number to add that happens to be a string.* @return &#123;number&#125; The sum of the two parameters.*/const moduleLocalFunc = (numParam, strParam) =&gt; numParam + Number(strParam);// Uses the single expression syntax with `void` because the program logic does// not require returning a value.getValue((result) =&gt; void alert(`Got $&#123;result&#125;`));class CallbackExample &#123;constructor() &#123; /** @private &#123;number&#125; */ this.cachedValue_ = 0; // For inline callbacks, you can use inline typing for parameters. // Uses a block statement because the value of the single expression should // not be returned and the expression is not a single function call. getNullableValue((/** ?number */ result) =&gt; &#123; this.cachedValue_ = result == null ? 0 : result; &#125;);&#125;&#125; 不建议的写法,例: 123456/*** A function with no params and no returned value.* This single expression body usage is illegal because the program logic does* not require returning a value and we&#x27;re missing the `void` operator.*/const moduleLocalFunc = () =&gt; anotherFunction(); 生成器(Generators)生成器带来许多有用的抽象概念，必要时可以使用。 通过在function关键字后面加*号来定义一个生成器，后面加空格与生成器名称隔开。使用代理的yield时，在yield关键字后加*号,例: 12345678910111213141516/** @return &#123;!Iterator&lt;number&gt;&#125; */function* gen1() &#123; yield 42;&#125;/** @return &#123;!Iterator&lt;number&gt;&#125; */const gen2 = function*() &#123; yield* gen1();&#125;class SomeClass &#123;/** @return &#123;!Iterator&lt;number&gt;&#125; */* gen() &#123; yield 42; &#125;&#125; 参数和返回类型函数参数和返回类型通常应使用JSDoc注释记录。 默认参数参数列表中通过等号来指定可选参数。可选参数必须在=运算符的两侧都包含空格，命名上与正常参数一样（不使用 opt_ 前缀），JSDoc 指定类型时使用=后缀，顺序上置于正常参数之后，不要用初始化以确保代码明确。所有可选参数都需要指定默认值，哪怕它是undefined。 123456789101112131415/*** @param &#123;string&#125; required This parameter is always needed.* @param &#123;string=&#125; optional This parameter can be omitted.* @param &#123;!Node=&#125; node Another optional parameter.*/function maybeDoSomething(required, optional = &#x27;&#x27;, node = undefined) &#123;&#125;/** @interface */class MyInterface &#123;/*** Interface and abstract methods must omit default parameter values.* @param &#123;string=&#125; optional*/someMethod(optional) &#123;&#125;&#125; 尽量少地使用可选参数。参数不定的情况下推荐使用解构的方式，这样所定义出来的 API 更加可读。注意：与 Python 不同，初始化可选参数时返回新的非可变对象（[] 或 {}）是可以的。因为每次可选参数被使用时，都是重新赋值，不会与上一次的复用。包括函数调用的任何表达式都会用到初始化模块，所以初始化模块应该尽量简单。避免初始化模块暴露共享可变域，这容易导致函数调用之间的无意耦合。 剩余参数使用剩余参数而不是 arguments。JSDoc 中使用...标识剩余参数。剩余参数必需位于参数列表末尾。注意...与参数名间没有空格。也不要给剩余参数命名。千万不要给变量或参数取名arguments，这会覆盖内建的同名参数,例: 12345/*** @param &#123;!Array&lt;string&gt;&#125; array This is an ordinary parameter.* @param &#123;...number&#125; numbers The remainder of arguments are all numbers.*/function variadic(array, ...numbers) &#123;&#125; 泛型定义泛型函数或方法时需在JS注文中加上@template TYPE。 扩展运算符可使用展示操作符（...）来调用函数。当使用数组或可遍历对象解析后作为函数入参时，推荐使用展开操作符来替代 Function.prototype.apply。注意...后面没有空格,例: 12function myFunction(...elements) &#123;&#125;myFunction(...array, ...iterable, ...generator()); 字符串字面量 使用单引号常规字符串使用单引号(&#39;)而非双引号(&quot;)来定义。通常情况下，字符串不能跨行。 提示:如果字符串包含单引号字符，请考虑使用模板字符串，以避免不得不对引号进行转义。 模板字符串使用模板字符串（`` `）替代复杂的字符串拼接，特别是参与拼接的变量很多时。模板字符串是可以跨越多行的。模板字符串跨越多行时，可不受代码块缩进规则限制，如果加上缩进好看些的话也可以,例: 1234567function arithmetic(a, b) &#123;return `Here is a table of arithmetic operations:$&#123;a&#125; + $&#123;b&#125; = $&#123;a + b&#125;$&#123;a&#125; - $&#123;b&#125; = $&#123;a - b&#125;$&#123;a&#125; * $&#123;b&#125; = $&#123;a * b&#125;$&#123;a&#125; / $&#123;b&#125; = $&#123;a / b&#125;`;&#125; 不要使用多行接续无论是常规字符串还是模板字符串中都不要使用多行接续（即在行尾加反斜杠\\）。虽然 ES5 允许这么操作，但反斜杠后的空格会导致问题，并且这种形式也不易读。错误的写法,例: 123const longString = &#x27;This is a very long string that far exceeds the 80 \\column limit. It unfortunately contains long stretches of spaces due \\to how the continued lines are indented.&#x27;; 正确的写法,例: 123const longString = &#x27;This is a very long string that far exceeds the 80 &#x27; +&#x27;column limit. It does not contain long stretches of spaces since &#x27; +&#x27;the concatenated strings are cleaner.&#x27;; 数字字面量数字可有多种呈现形式：十进制，十六进制，八进制或二进制。分别使用小写的 0x，0o，0b 前缀表示十六进制，八进制以及二进制数字。除此之外不应该出现以0开头的数字。 控制结构 for循环ES6之后一共有三种for循环,推荐使用for-offor-in适用于字典类型（dist-style）而不要用于遍历数组。配合Object.prototype.hasOwnProperty来过滤掉非直接的属性。推荐使用for-of和Object.keys，其次才是 for-in。 异常异常是语言中重要的一部分，发生异常时应尽可能抛出。始终抛出Error或子类的Error，而不是抛出字符串或其他对象作为异常。使用 Error时始终通过new来创建新实例。 这种处理扩展到Promise拒绝值，因为在异步函数中Promise.reject（obj）等效于throw obj; 。 自定义类型的错误提供了非常好的方式展示函数中的异常。当原生错误类型不能满足需求时，应尽可能创建自定义的异常。 遇到错误后立即抛出优于将错误进行传递。 空的 catch 块 响应捕获到的异常，什么也不做是非常正确的。 当确实在catch块中不执行任何操作时，但记得加注释解释一下原因,例: 123456try &#123; return handleNumericResponse(response);&#125; catch (ok) &#123;// it&#x27;s not numeric; that&#x27;s fine, just continue&#125;return handleTextResponse(response); 错误的写法,例: 12345try &#123; shouldFail(); fail(&#x27;expected an error&#x27;);&#125; catch (expected) &#123;&#125; 提示:不像其他一些语言，上面示例行不通，因为会通过fail来捕获处理。所以使用assertThrows。 switch 语句术语解释：switch 语句体中其实是很多组的代码块。每一组又包含一个或多个 switch 标签（case Foo: 或 default:）以及标签后跟随的代码语句。 Fall-through：要加注释每个 switch 标签要么通过break，return，throw 结束，要么通过注释直接跳过到下一标签。在发生跳过的情况时，随便加个注释都行。如果是最后一个标签可以不加,例: 1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; default 是不能省的即使 default 标签中不包含逻辑，也不要省略。 this应该只在类的构造器或方法中使用this，或类中的箭头函数。其他情况下使用·this·需要在函数的 JSDoc 结尾处添加 @this 注释。不要使用this来引用全局对象，eval的执行上下文，事件的触发元素，以及函数这种不必要的用法中 call()，apply() 。 相等检查使用恒等运算符（=== /！==），但以下情况除外。 需要强制转换的异常捕捉null和undefined值： 1234if (someObjectOrPrimitive == null) &#123; // Checking for null catches both null and undefined for objects and primitives , // but does not catch other falsy values like 0 or the empty string.&#125; 禁止使用的特性 with杜绝使用with关键字。这样的代码不易读，而且 ES5 之后就禁止掉了。 代码的动态求值不要使用eval或Function(...string) 构造器代码加载器（code loader）中除外）。这些关键字很危险并且在 CSP 环境中是不工作的。 CSP 指 Content Security Policy (CSP) 自动分号添加始终以分号结束语句（类与函数的声明除外）。 非标准的特性不要使用还不是标准的特性。包括已经被移除的特性（e.g. WeakMap.clear），还未纳入标准的新特性（e.g. TC39 目前的草稿，提议，通过提议但还未完成标准制定），或一些只被部分浏览器所实现的特性。只使用包含在 ECMA-262 或 WHATWG standards 标签中的特性。但一些有自己规范的项目是可以使用这些特性的，比如 Chrome 插件或 Node.js。三方转译器提供的特性也是被禁止的。 原始类型的包装对象对于原始值的包装对象（Boolean, Number, String, Symbol）不能用new调用，也不能用来作类型声明。错误的写法,例: 12const /** Boolean */ x = new Boolean(false);if (x) alert(typeof x); // alerts &#x27;object&#x27; - WAT? 这些包装器可在需要类型转换时当作函数来调用（而不是使用拼接空字符串的方式来转成字符串），或用于创建 symbol。 12const /** boolean */ x = Boolean(0);if (!x) alert(typeof x); // alerts &#x27;boolean&#x27;, as expected 修改原生对象千万不要修改原生对象，向其构造器或原型添加方法都是不行的。进行了这些操作的三方库也要避免使用。编译器在编译时会尽可能提供这些原生对象的原始版本；所以原生对象的任何东西都不要去动。 不到万不得已，不要向全局对象添加属性（e.g. 三方库需要这样做）。 JavaScript 编码风格 JSDocJSDoc 使用在了所有的类，字段以及方法上。 通用形式JSDoc 基本的形式如下： 123456/*** Multiple lines of JSDoc text are written here,* wrapped normally.* @param &#123;number&#125; arg A number to do something to.*/function doSomething(arg) &#123; … &#125; 或者这种单行的形式： 12/** @const @private &#123;!Foo&#125; A short bit of JSDoc. */this.foo_ = foo; 如果单行形式长到需要折行，则需要切换到多行模式而不是使用单行形式。 有许多工具会对 JSDoc 文档进行解析以提取出有效的信息对代码进行检查和优化。所以这些注释需要好好写。 MarkdownJSDoc 支持 Markdown，所以必要时可包含 HTML。工具会自动提取 JSDoc 的内容，其中自己书写的格式会被忽略。比如如果你写成下面这个样子： 123456/*** Computes weight based on three factors:* items sent* items received* last timestamp*/ 最终提取出来是这样的： Computes weight based on three factors: items sent items received last timestamp 取而代之的是，我们应该按 markdown 的语法来格式化,例： 1234567/*** Computes weight based on three factors:** - items sent* - items received* - last timestamp*/ JSDoc标签本规则可使用 JSDoc tags 的一个子集。详细列表见附录。大部分 tags 独占一行。错误的写法,例： 12345/*** The &quot;param&quot; tag must occupy its own line and may not be combined.* @param &#123;number&#125; left @param &#123;number&#125; right*/function add(left, right) &#123; ... &#125; 简单的 tag 无需额外数据（比如 @private，@const，@final，@export），可以合并到一行。 123456789101112131415161718/*** Place more complex annotations (like &quot;implements&quot; and &quot;template&quot;)* on their own lines. Multiple simple tags (like &quot;export&quot; and &quot;final&quot;)* may be combined in one line.* @export @final* @implements &#123;Iterable&lt;TYPE&gt;&#125;* @template TYPE*/class MyClass &#123;/*** @param &#123;!ObjType&#125; obj Some object.* @param &#123;number=&#125; num An optional number.*/constructor(obj, num = 42) &#123; /** @private @const &#123;!Array&lt;!ObjType|number&gt;&#125; */ this.data_ = [obj, num];&#125;&#125; 关于合并及合并后的顺序没有明确的规范，代码中保持一致即可。 换行换行之后的 tag 块使用四个空格进行缩进。 12345678910/*** Illustrates line wrapping for long param/return descriptions.* @param &#123;string&#125; foo This is a param with a description too long to fit in* one line.* @return &#123;number&#125; This returns something that has a description too long to* fit in one line.*/exports.method = function(foo) &#123;return 5;&#125;; @fileoverview 换行时不缩进。 文件头部注释一个文件可以在头部有个总览。包括版权信息，作者以及默认可选的可见信息/visibility level等。文件中包含多个类时，头部这个总览显得很有必要。它可以帮助别人快速了解该文件的内容。如果写了，则应该有一个描述字段简单介绍文件中的内容以及一些依赖，或者其他信息。换行后不缩进,例: 12345/*** @fileoverview Description of file, its uses and information* about its dependencies.* @package*/ 类的注释类，接口以及 records 需要有描述，参数，实现的接口以及可见性或其他适当的 tags 注释。类的描述需要告诉读者类的作用及何时使用该类，以及其他一些可以帮助别人正确使用该类的有用信息。构造器上的文本描述可省略。@constructor 和 @extends 不与 class 一起使用，除非该类是用来声明接口 @interface 或者扩展一个泛型类。 123456789101112131415161718192021222324/*** A fancier event target that does cool things.* @implements &#123;Iterable&lt;string&gt;&#125;*/class MyFancyTarget extends EventTarget &#123;/*** @param &#123;string&#125; arg1 An argument that makes this more interesting.* @param &#123;!Array&lt;number&gt;&#125; arg2 List of numbers to be processed.*/constructor(arg1, arg2) &#123; // ...&#125;&#125;;/*** Records are also helpful.* @extends &#123;Iterator&lt;TYPE&gt;&#125;* @record* @template TYPE*/class Listable &#123;/** @return &#123;TYPE&#125; The next item in line to be returned. */next() &#123;&#125;&#125; 枚举和 typedef 注释所有枚举和typedef必须在上一行用适当的JSDoc标记（@typedef或@enum）进行记录。 公共枚举和typedef也必须有描述。 单个枚举项可能在上一行带有JSDoc注释的文档中。 123456789101112131415/*** A useful type union, which is reused often.* @typedef &#123;!Bandersnatch|!BandersnatchType&#125;*/let CoolUnionType;/*** Types of bandersnatches.* @enum &#123;string&#125;*/const BandersnatchType = &#123;/** This kind is really frumious. */FRUMIOUS: &#x27;frumious&#x27;,/** The less-frumious kind. */MANXOME: &#x27;manxome&#x27;,&#125;; Typedefs 可方便地用于定义 records 类型，或 unions 的别名，复杂函数，或者 泛型类型。Typedefs 不适合用来定义字段很多的 records，因为其不支持对每个字段进行文档书写，也不适合用于模板或递归引用中。对于大型 records 使用 @record。 方法与函数注释在方法和命名函数中，必须记录参数和返回类型，除非相同签名@overrides省略所有类型。必要时应记录此类型。如果函数没有非空的return语句，则可以省略返回类型。 如果方法，参数和返回描述（但不是类型）在方法的其余JSDoc或其签名中显而易见，则可以省略。 方法的描述应使用第三人称。 如果方法覆盖超类方法，则它必须包含@override注释。覆盖的方法从超类方法继承所有JSDoc注释（包括可见性注释），并且应在覆盖的方法中将其省略。但是，如果在类型注释中完善了任何类型，则必须显式指定所有@param和@return注释。 1234567891011121314151617181920212223/** A class that does something. */class SomeClass extends SomeBaseClass &#123;/*** Operates on an instance of MyClass and returns something.* @param &#123;!MyClass&#125; obj An object that for some reason needs detailed* explanation that spans multiple lines.* @param &#123;!OtherClass&#125; obviousOtherClass* @return &#123;boolean&#125; Whether something occurred.*/someMethod(obj, obviousOtherClass) &#123; ... &#125;/** @override */overriddenMethod(param) &#123; ... &#125;&#125;/*** Demonstrates how top-level functions follow the same rules. This one* makes an array.* @param &#123;TYPE&#125; arg* @return &#123;!Array&lt;TYPE&gt;&#125;* @template TYPE*/function makeArray(arg) &#123; ... &#125; 如果只需要记录函数的参数和返回类型，则可以选择在函数签名中使用内联JSDocs。 这些内联JSDocs指定不带标签的return和param类型,例: 1function /** string */ foo(/** number */ arg) &#123;...&#125; 如果需要描述或标签，请在方法上方使用单个JSDoc注释。 例如，返回值的方法需要@return标记。 1234567class MyClass &#123;/*** @param &#123;number&#125; arg* @return &#123;string&#125;*/bar(arg) &#123;...&#125;&#125; 以下写法是错误的: 1234567// Illegal inline JSDocs.class MyClass &#123;/** @return &#123;string&#125; */ foo() &#123;...&#125;&#125;/** Function description. */ bar() &#123;...&#125; 在匿名函数中，注释通常是可选的。 如果自动类型推断不足或显式注释提高了可读性，则对param进行注释并返回如下类型： 123456promise.then(/** @return &#123;string&#125; */(/** !Array&lt;string&gt; */ items) =&gt; &#123;doSomethingWith(items);return items[0];&#125;); 命名 适用于所有标识符的规则可用于标识符的有 ASCII 字符，数字，还有下划线 _ 以及不太常用的 $ (一些框架里面比如 Angular 会用)。 标识符取名尽量表意。不要怕名字太长，因为代码是给人看的，别人能看懂最重要。不要使用带歧义的缩写或者项目之外的人看不懂的缩写，也不要通过删除某个单词中的字符来发明缩写，例: 1234errorCount // No abbreviation.dnsConnectionIndex // Most people know what &quot;DNS&quot; stands for.referrerUrl // Ditto for &quot;URL&quot;.customerId // &quot;Id&quot; is both ubiquitous and unlikely to be misunderstood. 不建议的写法例： 1234567n // Meaningless.nErr // Ambiguous abbreviation.nCompConns // Ambiguous abbreviation.wgcConnections // Only your group knows what this stands for.pcReader // Lots of things can be abbreviated &quot;pc&quot;.cstmrId // Deletes internal letters.kSecondsPerDay // Do not use Hungarian notation. 标识符类型的命名规则 包名包名全是lowerCamelCase。例如，my.exampleCode.deepSpace但不是my.examplecode.deepspace或my.example_code.deep_space。 类名定义类，接口，记录和 typedef 名称时,使用大写开头的驼峰UpperCamelCase。 未被导出的类只本地使用，并没有用 @private 标识，所以命名上不需要以下划线结尾。 类型名称通常为名词或名词短语。比如，Request，ImmutableList，或者 VisibilityMode。此外，接口名有时会是一个形容词或形容短语（比如 Readable）。 方法名方法名使用小写开头的驼峰。私有方法需以下划线结尾。 方法名一般为动词或动词短语。比如sendMessage或者stop_。属性的 Getter 或 Setter 不是必需的，如果有的话，也是小写驼峰命名且需要类似这样 getFoo(对于布尔值使用 isFoo 或 hasFoo 形式)， setFoo(value)。 单元测试代码中的方法名会出现用下划线来分隔组件形式。一种典型的形式是这样的 test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如 testPop_emptyStack。对于这种测试代码中的方法，命名上没有统一的要求。 枚举名枚举使用大写开头的驼峰，和类相似，一般一个单数形式的名词。枚举中的元素写成CONSTANT_CASE。 常量名常量写成 CONSTANT_CASE：所有字母使用大写，以下划线分隔单词。私有静态属性可以用内部变量代替，所以不会有使用私有枚举的情况，也就无需将常量以下划线结尾来命名。 常量的定义每个常量都是 @const 标识的静态属性或模块内部通过const声明的变量，但并不是所有 @const 标识的静态属性或 const声明的变量都是常量。需要常量时，先想清楚该对象是否真的不可变。例如，如果该对象中可观察状态中任何一个可被改变，那么几乎可以肯定它不是常数。只是想着不去改变它的值是不够的，我们要求它需要从本质上来说应该一成不变,例: 12345678910111213// Constantsconst NUMBER = 5;/** @const */ exports.NAMES = ImmutableList.of(&#x27;Ed&#x27;, &#x27;Ann&#x27;);/** @enum */ exports.SomeEnum = &#123; ENUM_CONSTANT: &#x27;value&#x27; &#125;;// Not constantslet letVariable = &#x27;non-const&#x27;;class MyClass &#123; constructor() &#123; /** @const &#123;string&#125; */ this.nonStatic = &#x27;non-static&#x27;; &#125; &#125;;/** @type &#123;string&#125; */ MyClass.staticButMutable = &#x27;not @const, can be reassigned&#x27;;const /** Set&lt;string&gt; */ mutableCollection = new Set();const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);const Foo = goog.require(&#x27;my.Foo&#x27;); // mirrors imported nameconst logger = log.getLogger(&#x27;loggers.are.not.immutable&#x27;); 常量的名称通常是名词或名词短语。 本地别名 给导入的变量起别名来提高可读性是可行的。函数中也有使用别名的情况。别名必需是const类型。 非常量字段名非常量字段（静态或其他）使用小写开头的驼峰，如果是私有的私有的则以下划线结尾。 一般是名词或名词短语。例如 computedValues，index_。 参数名参数使用小写开头的驼峰形式。即使参数需要一个构造器来初始化时，也是这一规则。 公有方法的参数名不能只使用一个字母。 例外：如果三方库需要，参数名可以用 $ 开头。此例外不适用于其他标识符（e.g. 本地变量或属性）。 局部变量名如上所述，除了模块本地（顶级）常量外，本地变量名称都用lowerCamelCase形式编写。 函数作用域中的常量仍遵循lowerCamelCase形式。 请注意，即使变量包含构造函数，也将使用lowerCamelCase形式。 模板参数名模板参数力求简洁，用一个单词，一个字母表示，全部使用大写，例如 TYPE，THIS。 模板本地名未导出的模块本地名称是隐式私有的。 它们未被标记为@private，并且不以下划线结尾。这适用于类，函数，变量，常量，枚举和其他模块本地标识符。 驼峰：定义有时将一个英文短语转成驼峰有很多形式，例如首字母进行缩略，IPv6 以及 iOS 这种都有出现。为保证代码可控，本规范规定出如下规则。 将短语移除撇号转成ASCII表示。例如 Müller’s algorithm 表示成 Muellers algorithm。 将上述结果拆分成单词，以空格或其他不发音符号（中横线）进行分隔。 推荐的做法：如果其中包含一个已经常用的驼峰翻译，直接提取出来（e.g. AdWords 会成为 adwords）。需要注意的是 iOS 本身并不是个驼峰形式，它不属性任何形式，所以它不适用本条规则。 将所有字母转成小写，然后将以下情况中的首字母大写： 每个单词的首字母，这样便得到了大写开头的驼峰 除首个单词的其他所有单词的首字母，这样得到小写开头的驼峰 将上述结果合并。 过程中原来名称中的大小写均被忽略，例： 1234567Prose form | Correct | Incorrect------------- | ------------- | -------------&quot;XML HTTP request&quot; | XmlHttpRequest | XMLHTTPRequest&quot;new customer ID&quot; | newCustomerId | newCustomerID&quot;inner stopwatch&quot; | innerStopwatch | innerStopWatch&quot;supports IPv6 on iOS?&quot; | supportsIpv6OnIos | supportsIPv6OnIOS&quot;YouTube importe&quot; | YouTubeImporter | YoutubeImporter 可以接受，但不推荐。 注意：一些英文词汇通过中横线连接的方式是有歧义的，比如 “nonempty” 和 “non-empty” 都是正确写法，所以方法名 checkNonempty checkNonEmpty 都算正确。 格式化 术语解释：代码块（block-like construct）指类，函数，方法这些元素的正文部分，或花括号包裹的代码部分。参考数组字面量,对象字面量的定义，数组或对象也可以被视作一个类似于块的构造。提示:使用 clang-format。社区已经做了大量努力以使得 clang-format 能够很好地处理 JavaScript 文件。其中也集成了几位著名代码开发者的努力。 大括号(花括号) 括号用于各种流程控制结构括号用在各种控制结构中（譬如 if，else，for，do，while 等），即使结构中只包含一句代码。第一条指令的非空块状结构必须另起一行。错误的写法,例: 1234if (someVeryLongCondition()) doSomething();for (let i = 0; i &lt; foo.length; i++) bar(foo[i]); **例外:**如果指令可以完全地用写在一行里，那么可以不用大括号以增加可读性,例:’if (shortCondition()) foo();` 非空代码块：K&amp;R 风格非空代码块使用的花括号遵循 Kernighan and Ritchie 风格 (也即 Egyptian brackets)： 左花括号不另起新行 左花括号后紧跟换行 右花括号前需要换行 如果右花括号结束了语句，或者它是函数、类、类中的方法的结束括号，则其后面需要换行。如果后面紧跟的是 else，catch 或 while，或逗号，分号以及右括号，则不需要跟一个换行。例: 123456789101112131415class InnerClass &#123;constructor() &#123;&#125;/** @param &#123;number&#125; foo */method(foo) &#123; if (condition(foo)) &#123; try &#123; // Note: this might fail. something(); &#125; catch (err) &#123; recover(); &#125; &#125;&#125;&#125; 空代码块：应紧凑对于空代码块打开的时候就应立即闭合，中间不留空格，换行以及其他任何字符（&#123;&#125;），除非该代码块处于一个连续的声明语境中（譬如这些带有多个代码块的语句 if/else，try/catch/finally）,例:function doNothing() &#123;&#125;。错误的写法，例： 123456789if (condition) &#123;// …&#125; else if (otherCondition) &#123;&#125; else &#123;// …&#125;try &#123;// …&#125; catch (e) &#123;&#125; 代码块中的缩进：2个空格每当新开一个区块或块状结构，增加两个空格的缩进。区块结束之后，缩进恢复到前一级水平。缩进对该区块内的代码和注释同样有要求。 数组字面量：可作为块状结构任何数组都可以按块状结构的格式书写。例如，以下的写法都是有效（不代表全部写法）： 1234567891011121314const a = [ 0, 1, 2,];const b = [0, 1, 2]; const c = [0, 1, 2];someMethod(foo, [ 0, 1, 2,], bar); 允许其他组合，尤其是在强调元素之间的语义分组时，而不是只用来减小较大数组的垂直大小。 对象字面量：可作为块状结构对象字面量也可以当作代码块处理，规则与上面数组字面量类似。以下写法都是合法的： 12345678910111213const a = &#123; a: 0, b: 1,&#125;;const b = &#123;a: 0, b: 1&#125;; const c = &#123;a: 0, b: 1&#125;;someMethod(foo, &#123; a: 0, b: 1,&#125;, bar); 类类的声明（无论是内容声明[declarations]还是表达式声明[expressions]）都像块状结构一样缩进。在类的方法声明和类中的内容声明（表达式结束时仍然需要加分号）的右大括号（后一个大括号）之后不加分号。其中可以使用关键字extends，但是不要用@extends的JS注文（JSDoc），除非你继承了一个模板类型（templatized type）,例： 123456789101112class Foo &#123;constructor() &#123; /** @type &#123;number&#125; */ this.x = 42; &#125;/** @return &#123;number&#125; */method() &#123; return this.x; &#125;&#125;Foo.Empty = class &#123;&#125;; 12345678910111213/** @extends &#123;Foo&lt;string&gt;&#125; */foo.Bar = class extends Foo &#123;/** @override */method() &#123; return super.method() / 2; &#125;&#125;;/** @interface */class Frobnicator &#123;/** @param &#123;string&#125; message */ frobnicate(message) &#123;&#125;&#125; 函数表达式当声明匿名函数时，函数正文在原有缩进水平上增加两个空格的缩进，例： 1234567891011121314151617181920prefix.something.reallyLongFunctionName(&#x27;whatever&#x27;, (a1, a2) =&gt; &#123;// Indent the function body +2 relative to indentation depth// of the &#x27;prefix&#x27; statement one line above.if (a1.equals(a2)) &#123; someOtherLongFunctionName(a1); &#125; else &#123; andNowForSomethingCompletelyDifferent(a2.parrot); &#125;&#125;);some.reallyLongFunctionCall(arg1, arg2, arg3) .thatsWrapped() .then((result) =&gt; &#123; // Indent the function body +2 relative to the indentation depth // of the &#x27;.then()&#x27; call. if (result) &#123; result.use(); &#125; &#125;); Switch语句就像其他块状结构，该语句的缩进方式也是+2。 开始新的一条Switch标签，格式要像开始一个新的块状结构，新起一行，缩进+2。适当时候可以用块状结构来明确Switch全文范围。而到下一条Switch标签的开始行，缩进（暂时）还原到原缩进水平。 在break和下一条Switch标签之间可以适当地空一行。 例： 123456789101112switch (animal) &#123; case Animal.BANDERSNATCH: handleBandersnatch(); break; case Animal.JABBERWOCK: handleJabberwock(); break; default: throw new Error(&#x27;Unknown animal&#x27;);&#125; 声明语句 一个声明占一行每个声明语句后都跟换行。 分号是必需的语句后需用分号结束。不能依赖于编辑器的自动分号插入功能。 最大列宽：80对于 JavaScript 源码，规定其单行长度不超过 80 字符。除以下列出的情形外，超出的时候需要根据下面的换行规则来进行换行操作。例外的情形： goog.module，goog.require和goog.requireType语句 ES模块的import和export from语句 换行 术语解释：换行指将一个表达式拆分成多行展示。 并没有一个全面准确的的规则来指导每种场景下该如何换行，相反，对同一段代码往往存在多种合法的换行方式。 提示：尽管换行大多时候是为了满足列宽限制，但在满足的情况下，编码过程中每个人做法也不尽相同，这是可以的。抽取方法或变量有可能会规避掉换行的问题。 何处该换行换行的的准则是：尽量在优先级高的语法层面（higher syntactic level）进行，例： 123currentEstimate = calc(currentEstimate + x * currentEstimate) / 2.0; 不推荐的写法，例： 12currentEstimate = calc(currentEstimate + x * currentEstimate) / 2.0; 上面示例中，语法优先级从高到低依次为：赋值，除法，函数调用，参数，数字常量。 操作符的规则： 请在运算符之后换行（注意这和JAVA谷歌代码风格不同）。“.”并不是一个运算符，所以不适用上述规则。 方法和构造函数之后的左圆括号不能换行。 逗号紧跟前面的代码。 注意：换行首要目的是保持代码整洁，当最小行数能满足需求时，换行是不需要的。 换行后后续行至少有4个空格的缩进当发生换行时，第一行后面跟着的其他行至少缩进 4 个空格，除非满足代码块的缩进规则，可另说。 换行后后续跟随多行时，缩进可适当大于 4 个空格。通常，语法中低优先级的后续行以 4 的倍数进行缩进，如果只有两行并且处于同一优先级，则保持一样的缩进即可。 空格 垂直方向的空格以下场景需要有一个空行： 类或对象中的方法间例外的情形：对象中属性间的空行是可选的。如果有的话，一般是用来将属性进行分组。 方法体中，尽量少地使用空行来进行代码的分隔。函数体开始和结束都不要加空行。 类或对象中首个方法前及最后一个方法后的空行，既不提倡也不反对。 连续多个空行是允许的，但不鼓励这么做。 水平方向的空格水平方向的空格根据出现的位置不同分为三类：行首（一行的开始），行尾（一行的结束）以及行间（一行中除去行首及行尾的部分）。行首的空格（i.e. 缩进）无处不在。行尾的空格是禁止的。 除了 Javascript 本身及其他规则的要求，还有字面量，注释，JSDoc 等需要的空格外，单个的 ASCII 类型的空格在以下情形中也是需要的。 将关键字（比如 if，for，catch）与括号（(）分隔。 将关键字（else，catch）与闭合括号（&#125;） 分隔。 对于左花括号有两种例外： 作为函数首个参数的对象之前，数组中首个对象元素 （foo(&#123;a: [&#123;c: d&#125;]&#125;)）。 在模板表达式中，因为模板语法的限制不能加空格（abc$&#123;1 + 2&#125;def）。 二元，三元操作符的两边。 逗号或分号后，但其前面是不允许有空格的。 对象字面量中冒号后面。 双斜线（//）两边。这里可以使用多个空格，但也不是必需的。 JSDoc 注释及其两边 比如简写的类型声明this.foo = /** @type &#123;number&#125; */ (bar); 或 function(/** string */ foo) &#123;; 或 baz(/* buzz= */ true) 水平对齐:不鼓励 术语解释：水平对齐是在代码中添加可变数量的附加空格的一种做法，目的是使某些标记直接出现在前几行中其他标记的下面。 下面的示例中展示了正常的代码及带水平对齐的代码，后者是不推荐的: 12345678&#123;tiny: 42, // this is greatlonger: 435, // this too&#125;;&#123;tiny: 42, // permitted, but future editslonger: 435, // may leave it unaligned&#125;; 这种做法是允许的，但 Google 风格里面不推荐。甚至在已经存在的代码中也不鼓励继续使用这种方式进行维护。 注意：对齐可以增加可读性，但是对后续的维护增加了困难。考虑到后续改写代码可能只会该代码中的一行。修改可能会导致规则允许下格式的崩坏。这常常会错使代码编写者（比如你）调整附近几行的空格，从而导致一系列的格式重写。这样，只是一行的修改就会有一个“爆炸半径”（对附近代码的影响）。这么做最多会让你做一些无用功，但是至少是个失败的历史版本，降低了阅读者的速度，也会导致一些合并冲突。 函数参数本规则更倾向于把所有函数的参数放在函数名的同一行。如果这么做让代码超出了80字符的限制，那么就必须做基于可读性的自动换行。为了节约空间，最好每行都接近80字符，或者一个参数一行来增加可读性。缩进4个空格。允许和圆括号对齐，但是不推荐。下列就是最常见的函数参数对齐模式： 12345678910111213141516171819202122232425// Arguments start on a new line, indented four spaces. Preferred when the// arguments don&#x27;t fit on the same line with the function name (or the keyword// &quot;function&quot;) but fit entirely on the second line. Works with very long// function names, survives renaming without reindenting, low on space.doSomething( descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) &#123;// …&#125;// If the argument list is longer, wrap at 80. Uses less vertical space,// but violates the rectangle rule and is thus not recommended.doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo, tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) &#123;// …&#125;// Four-space, one argument per line. Works with long function names,// survives renaming, and emphasizes each argument.doSomething( veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo, tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) &#123;// …&#125; 分组括号（Grouping parentheses）：推荐的写法只有代码作者和审阅者都觉得如果不分组不会引起歧义，并且加了分组也不会让代码变得更易读，那么分组可以省略。因为，不是每个人都将操作符优先级熟记于心。 对于这些关键字，不要添加额外的分组 delete，typeof，void，return，throw，case，in，of 以及 yield。 类型转换时需要使用括号强制分组：/** @type &#123;!Foo&#125; */ (foo)。 注释本规则讨论注释的写法。JSDoc 相关的注释单独在上面已经讨论过了。 块注释风格块状注释与被注释代码保持相同缩进。/* ... */和 // 都是。对于多行的/* ... */注释，后续注释行以*开头且与上一行缩进保持一致。参数的注释紧随参数之后，用于在函数名或参数名无法完全表达其意思的情况,例： 123456789/** This is* okay.*/// And so// is this./* This is fine, too. */ 不要将JSDoc（/ **…* /）用于实现注释。 参数名称注释每当值和方法名称未能充分传达含义时，都应使用“参数名称”注释，并且将方法重构得更清晰是不可行的。 它们的首选格式是值之前使用=： 1someFunction(obviousParam, /* shouldRender= */ true, /* name= */ &#x27;hello&#x27;); 为了与周围的代码保持一致，可以将它们放在值后面，而不使用=： 1someFunction(obviousParam, true /* shouldRender */, &#x27;hello&#x27; /* name */); 写在最后保持一致性. 当你在编辑代码之前，先花一些时间查看一下现有代码的风格。比如，如果现有的代码给算术运算符添加了空格，你也应该添加。 代码风格中一个关键点是整理一份常用词汇表, 开发者认同它并且遵循, 这样在代码中就能统一表述。 这里提出了一些全局上的风格规则, 但也要考虑自身情况形成自己的代码风格。 但如果你添加的代码和现有的代码有很大的区别, 这就让阅读者感到很不和谐。 所以, 避免这种情况的发生。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"人生——读书笔记","slug":"读书笔记--人生","date":"2020-02-13T11:54:00.000Z","updated":"2022-01-11T07:51:54.696Z","comments":true,"path":"2020/02/13/读书笔记--人生/","link":"","permalink":"http://example.com/2020/02/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 如果此时此刻有人和我说：人生如梦，世事难料。我肯定请他坐下来喝两杯畅谈一下人生!必须承认,以往很多时候，年纪轻轻的我不曾真正好好珍惜眼前的一切,即便一些大道理烂熟于心。从某种程度上来说，我和高加林一样：受过教育,想要更好的生活。但生活常常和我或者说我们开玩笑，一切在惊喜和挫败往复循环，它教会我们很多东西,但大多情况下，我们会先失去一些东西，比如友情，或者一些物质上东西，然后再深刻地体会到某些道理，然而不是深切感受完就可以避免以后发生类似的事情给我们带来的伤害。高加林生于农村，长于县城，书中说多年的教育洗去他身上的泥土气息，我是认同的，他受教育的时间远多于在农村老家生活的时间，且几乎没有劳作，同时他能一眼看尽农村人的一生，这无疑坚定了他想扎根城市的决心。高明楼的儿子勉勉强强上完高中走后门夺走了高加林的教师工作，断了高加林的念想，高加林的父母老老实实本本分分一辈子，这样的受打击的事情让一家人感到怎样的无助和绝望，我无法想象。这里我是替他们一家打抱不平的；回归农民，高玉德把轻松的活交给儿子，儿子第一天上县城的表现让人唏嘘，却也因此开启了和巧珍的爱情。经历心里的麻木和生理上的痛苦，还有巧珍热烈且温柔的爱，高的心态渐渐平和，但身边人对于他想回到城里的想法清清楚楚。生活过得去，却失去了实现梦想的机会，这里我是同情他的，因为这也是真实生活中一些人真实的样子；而后高加林的叔叔坐着”大领导”的位置归来，马占胜又一手包办高加林的工作，高的前程似乎又得见光明。回到城里的他，生活和事业都有了很大的起色，我是高兴的。后来黄亚萍对他展开热烈的爱情攻势，一边是内心真正爱着的巧珍，一边是象征着梦想的未来，最终选择他选择和中学同学”私定终身”，抛弃巧珍。在更远更大的天地向他招手时候，再一次出现人生波折，高被检举，再次回到农村已然物是人非，巧珍已嫁为他人妇。此刻她仍然盼着高能够好好活下去，自己去为高谋出路，高也后悔不已。看到这里我也经历一系列情绪波折，开始非常佩服作者。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"跨域及解决方案","slug":"跨域及解决方案","date":"2020-02-12T09:24:11.000Z","updated":"2022-01-11T07:51:05.429Z","comments":true,"path":"2020/02/12/跨域及解决方案/","link":"","permalink":"http://example.com/2020/02/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 跨域问题的产生前端开发人员都知道,浏览器安全的基石是”同源策略”（same-origin policy）.同源策略是 1995 年由 Netscape 公司引入浏览器.目前所有浏览器都实行这个策略.它主要是为了防止XSS,CSRF攻击. 域名URL的构成——http://主机名 . 域名（端口号、参数、查询等可选） 此外,我们还要知道域是分层管理的,像中国的行政级别:最高层的域是根域(root)”.”,就是一个点,像国家主席一样.全球只有13个根域服务器,基本数都在美国,中国一台根域服务器都没有. 根域的下一层就是第二层次的顶级域(TLD),像各省的省长.它也就是俗称的”域名后缀”,顶级域划分方法: 按国家划分: .cn(中国)、.tw(台湾)、.hk(香港)等 按组织性质划分: .org、.net、.com、.gov、.cc等 反向域: arpa(这是反向解析的特殊顶级域) 顶级域的下一层就是普通的域,公司或个人在互联网上注册的域名一般都是这些普通的域,如baidu.com. 注意点: 顶级域名就是一级域名 N级域名就是在N-1级域名前追加一级 同源策略这里的”同源”指的是: 协议相同 域名相同 端口相同 带来的限制: Cookie、LocalStorage 和 IndexDB 无法读取 DOM无法获得 AJAX请求不能发送 但是有三个标签是允许跨域加载资源的: &lt;img src=””&gt; &lt;link href=””&gt; &lt;script src=””&gt; 常见的跨域场景当协议、子域名、主域名、端口号任意一个不相同时,都是不同的域.不同域之间相互请求资源,就称为”跨域“,常见跨域场景如下所示: 注意点: 如果是协议和端口造成的跨域问题,”前台”是无能为力的 在跨域问题上,仅仅是通过”URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断. 这里你或许有两个疑问: 在跨域的情况下,请求被怎么处理了?跨域并不是请求发不出去,请求能发出去,服务端能收到请求并正常响应,只是响应结果被浏览器拦截了. 为什么提交表单可以避免跨域问题,Ajax就不行?跨域的目的是为了组织用户读到另一个域名下的内容,Ajax可以获取响应,这里存在有安全隐患,故而浏览器拦截了响应;表单则只是提交数据,不会获取新的内容,所以可以发去跨域请求. 跨域解决方案CORS跨域资源共享(Cross-Origin Resource Sharing)CORS 需要浏览器和后端同时支持,实现 CORS 通信的关键是后端.目前几乎所有浏览器都支持 CORS, IE则不能低于IE10.服务端设置 Access-Control-Allow-Origin 就可以开启 CORS. 该属性可以表示哪些域名可以访问资源,如果设置通配符则表示所有网站都可以访问资源.虽然设置 CORS 和前端没什么关系,但是通过这种方式解决跨域问题的话,会在发送请求时出现两种情况,分别为简单请求和非简单请求(需预检请求). 简单请求: 使用下面任意HTTP方法的: GET HEAD POST Content-Type 的值仅限于下列三者之一: text/plain multipart/form-data application/x-www-form-urlencoded 对于简单请求,浏览器会直接发送 CORS 请求,具体说来就是在 header 中加入 Origin 请求头字段.同样,在响应头中,返回服务器设置的相关 CORS 头部字段, Access-Control-Allow-Origin 字段为允许跨域请求的源.请求时浏览器在请求头的 Origin 中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回,具体如下:非简单请求: 使用下面任意HTTP方法的: PUT DELETE CONNECT OPTIONS TRACE PATCH Content-Type 的值不属于下列三者之一: text/plain multipart/form-data application/x-www-form-urlencoded 当符合非简单请求(预检请求)的条件时,浏览器会自动先发送一个options请求,如果服务端支持该请求,则会将真正的请求发送到后端;反之,控制台将会抛出错误. 如果非简单请求(预检请求)发送成功，则会在头部多返回以下字段: 123Access-Control-Allow-Origin: http://localhost:8000 //该字段表明可供那个源跨域Access-Control-Allow-Methods: GET, POST, PUT // 该字段表明服务端支持的请求方法Access-Control-Allow-Headers: X-Custom-Header // 实际请求将携带的自定义请求首部字段 JSONP 原理:利用**&lt;script&gt;**标签没有跨域限制的漏洞,网页可以得到从其它来源动态产生 JSON 数据.JSONP 请求必须要对方的服务器做支持才可以. JSONP和AJAX对比:二者都是客户端遵循向服务器发送请求,从服务器获取数据的方式.但AJAX属于同源策略,JSONP不是. 看个例子: 12345678910&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;title&gt;JSONP&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://a2.att.hudong.com/36/48/19300001357258133412489354717.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"JavaScript中Promise","slug":"JavaScript中Promise","date":"2020-02-11T09:16:41.000Z","updated":"2022-01-11T07:44:11.616Z","comments":true,"path":"2020/02/11/JavaScript中Promise/","link":"","permalink":"http://example.com/2020/02/11/JavaScript%E4%B8%ADPromise/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 Promise 出现的原因在 Promise 出现以前,处理一个Ajax请求,大概是这样的: 123$.get(&#x27;url&#x27;, &#123;data: data&#125;, function(result)&#123; console.log(&#x27;成功&#x27;, result)// 成功的回调，result为异步拿到的数据&#125;); 看起来还不错,但需求变化了,现在需要根据第前面的结果继续请求,代码大概如下： 123456789101112$.get(&#x27;url&#x27;, &#123;data: data&#125;, function(result1)&#123; $.get(&#x27;url&#x27;, &#123;data: result1&#125;, function(result2)&#123; $.get(&#x27;url&#x27;, &#123;data: result2&#125;, function(result3)&#123; $.get(&#x27;url&#x27;, &#123;data: result3&#125;, function(result4)&#123; ...... $.get(&#x27;url&#x27;, &#123;data: resultn&#125;, function(resultn+1)&#123; console.log(&#x27;成功&#x27;) &#125; &#125; &#125; &#125;&#125;); 以上就是回调地狱,更糟糕的是,我们可能还要对每次请求的结果进行一些处理,代码会更加臃肿,后期维护也非常痛苦! 那么总结一下回调地狱的特点: 代码臃肿 可读性差 耦合度过高,可维护性差 代码复用性差 容易出现Bug 只能在回调里处理异常 后来出现了Promise,它以一种更加友好的代码组织方式,解决了异步嵌套的问题: 12345let 请求结果1 = 请求1();let 请求结果2 = 请求2(请求结果1); let 请求结果3 = 请求3(请求结果2); let 请求结果4 = 请求2(请求结果3); let 请求结果5 = 请求3(请求结果4); 类似与上面同步的写法.于是Promise规范诞生了! 什么是PromisePromise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值. 优点: 异步操作将以同步的流程表达出来,避免了层层嵌套的回调函数. Promise 对象提供了统一的接口,使得控制异步操作更容易. 缺点: 无法取消,一旦新建就会立即执行,无法中途取消. 若不设置回调函数,promise 内部会抛出错误,不会反映到外部 Promise/A+ 规范Promise 规范有很多,如 Promise/A , Promise/B , Promise/D 以及 Promise/A 的升级版 Promise/A+ ,最终ES6采用了 Promise/A+ 规范. Promise 规范: 英文版: https://promisesaplus.com/ 中文版: http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/ 总结如下: 一个 Promise 对象有种个状态,并且状态一旦改变,便不能再被更改为其他状态. pending: 异步任务正在执行. fulfilled: 异步任务执行成功. rejected: 异步任务执行失败. then方法可以被同一个 Promise 调用多次,且必须返回一个 Promise Promise 语法1new Promise( function(resolve, reject) &#123;/* executor */&#125; ); Promise构造函数接受一个函数作为参数,该函数的两个参数分别是resolve和reject.它们是两个函数,由 JavaScript 引擎提供,不用自己部署. resolve 函数的作用:将Promise实例的状态从”pending”到”fulfilled”,在异步操作成功时调用,并将异步操作的结果,作为参数传递出去. reject 函数的作用:将Promise实例的状态从”pending”到”rejected”,在异步操作失败时调用,并将异步操作报出的错误，作为参数传递出去. 例子: 123456789101112let promise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&#x27;Cola&#x27;); console.log(promise);//Promise &#123; &#x27;Cola&#x27; &#125; &#125;, 300);&#125;);promise.then(function (value) &#123; console.log(value);//Cola&#125;);console.log(promise);//Promise &#123; &lt;pending&gt; &#125; 输出顺序: 123Promise &#123; &lt;pending&gt; &#125;Promise &#123; &#x27;Cola&#x27; &#125;Cola Promise 常用API Promise.resolve() Promise.reject() Promise.then(成功回调函数，失败回调函数) Promise.then(成功回调函数).catch(失败回调函数) Promise.then(成功回调函数).catch(失败回调函数).finally(成功失败都执行的函数) 1234567891011let promise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&#x27;Cola&#x27;); &#125;, 300);&#125;).then(data =&gt; &#123; console.log(&#x27;I like &#x27; + data)&#125;).catch(function (error) &#123; console.log(error);&#125;).finally(function () &#123; console.log(&#x27;这是finally&#x27;)&#125;); Promise.all(iterable):方法返回一个 Promise 实例,此实例在 iterable 参数内所有的 promise 都”完成（resolved）”或参数中不包含 promise 时回调完成（resolve）;如果参数中 promise 有一个失败（rejected）,此实例回调失败（reject）,失败原因的是第一个失败 promise 的结果. 12345678910let p1 = Promise.resolve(&#x27;I&#x27;);let p2 = &#x27;like&#x27;let p3 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(&#x27;Cola&#x27;); &#125;, 300);&#125;)Promise.all([p1, p2, p3]).then(function (value) &#123; console.log(value);//[ &#x27;I&#x27;, &#x27;like&#x27;, &#x27;Cola&#x27; ]&#125;); Promise.race(iterable):返回一个 promise,一旦迭代器中的某个promise解决或拒绝,返回的 promise就会解决或拒绝. 1234567891011const promise1 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 500, &#x27;one&#x27;);&#125;);const promise2 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 100, &#x27;two&#x27;);&#125;);Promise.race([promise1, promise2]).then(function(value) &#123; console.log(value);//two&#125;);","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"}]},{"title":"JavaScript的同步异步和执行机制","slug":"JavaScript的同步异步和执行机制","date":"2020-02-10T07:23:13.000Z","updated":"2022-01-11T07:46:32.117Z","comments":true,"path":"2020/02/10/JavaScript的同步异步和执行机制/","link":"","permalink":"http://example.com/2020/02/10/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 JavaScript中的单线程技术的出现总是和应用场景密切相关.JavaScript诞生于1995年,主要用于处理表单验证操作,也就是实现用户和浏览器的交互. 由此带来一个思考:这门语言为什么是单线程?作为浏览器脚本语言,JavaScript 的主要用途是与用户互动,以及操作 DOM.这决定了它只能是单线程,否则会带来很复杂的同步问题.比如,假定JavaScript同时有两个线程,一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以,为了避免复杂性，从一诞生,JavaScript 就是单线程,这已经成了这门语言的核心特征,将来也不会改变. 为了利用多核 CPU 的计算能力,HTML5 提出 Web Worker 标准,允许 JavaScript 脚本创建多个线程,但是子线程完全受主线程控制,且不得操作 DOM.所以,这个新标准并没有改变 JavaScript 单线程的本质. 那么单线程的特点就很明显了: 实现起来比较简单,执行环境相对单纯； 只要有一个任务耗时很长,后面的任务都必须排队等着,会拖延整个程序的执行.(常见的浏览器无响应(假死),往往就是因为某一段Javascript代码长时间运行(比如死循),导致整个页面卡在这个地方,其他任务无法执行.) 同步和异步在JS中,同步意味着在很多情况下CPU在等待:后一个任务等待前一个任务结束,然后再执行,程序的执行顺序与任务的排列顺序是一致的、同步的;也就是说当一件事情没有处理完成,JS会一直处理它,直至完成,才会开始下一件事情,这样可能会堵塞代码执行; 异步则是指每一个任务有一个或多个回调函数(callback),前一个任务结束后,不是执行后一个任务,而是执行回调函数,后一个任务则是不等前一个任务结束就执行,所以程序的执行顺序与任务的排列顺序是不一致的、异步的. 一句话概括就是:同步等结果,异步不等结果. JavaScript的执行机制流程图如下:注意点: JS代码分为同步任务和异步任务. 同步任务进入主线程执行,异步任务进入Event Table(事件表),当事件表中的异步任务完成后会在**Event Queue(事件队列)**中注册回调函数. 主线程中的任务全部完成后,才会执行Event Queue中的任务. JS解析器会不断重复检查主线程执行栈是否为空,然后重复第3步,这称为Event Loop(事件循环). 宏任务和微任务JS代码的类型如下图所示: 宏任务主要有: script代码段 setTimeout setInterval I/O 微任务主要有: process.nextTick Promise 注意点: 任务有**宏任务(Macro Task)和微任务(Micro Task)**之分,这对JS代码的执行有更细致的影响. 异步任务中的宏任务和微任务会进入不同的Event Queue(事件队列),即Event Queue又可以分为宏任务队列和微任务队列. setInterval会按照设定的时间间隔重复地在Event Queue中注册回调函数,如果某一段时间主线程代码执行太久,那么setInterval的回调函数可能阻塞到一起执行,无法保持设定的时间间隔,如果此时setInterval用于动画,则体现为卡顿. 详细过程 通常来说,页面中JS的执行顺序是这样的: 第一轮事件循环: 1.主线程执行JS整段(宏代码),将ajax、setTimeOut、promise等回调函数注册到Event Queue中,并区分宏任务和微任务. 2.主线程提取并执行Evene Queue中的ajax、promise等所有微任务,并注册微任务中的异步任务到Event Queue(如果有). 第二轮事件循环: 1.主线程提取并执行Evene Queue中的第一个宏任务,注册该任务中的异步任务到Evene Queue(如果有). 2.执行Evene Queue中所有的微任务,并注册微任务中的异步任务到Evene Queue(如果有). 类似的循环:宏任务没执行完一个,就清空一次时间队列中的微任务.注意点:事件队列中分”宏任务队列”和”微任务队列”，每执行一次任务都可能注册新的宏任务或微任务到相应的任务队列中. 例子12345678910111213141516171819202122232425262728293031323334353637383940414243console.log(&#x27;1&#x27;);// 记作 set1setTimeout(function () &#123; console.log(&#x27;2&#x27;); // set4 setTimeout(function() &#123; console.log(&#x27;3&#x27;); &#125;); // pro2 new Promise(function (resolve) &#123; console.log(&#x27;4&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;5&#x27;) &#125;)&#125;)// 记作 pro1new Promise(function (resolve) &#123; console.log(&#x27;6&#x27;); resolve();&#125;).then(function () &#123; console.log(&#x27;7&#x27;); // set3 setTimeout(function() &#123; console.log(&#x27;8&#x27;); &#125;);&#125;)// 记作 set2setTimeout(function () &#123; console.log(&#x27;9&#x27;); // 记作 pro3 new Promise(function (resolve) &#123; console.log(&#x27;10&#x27;); resolve(); &#125;).then(function () &#123; console.log(&#x27;11&#x27;); &#125;)&#125;)// 最终输出 : 1 6 7 2 4 5 9 10 11 8 3 第一轮事件循环: 1.将整段script作为第一个宏任务进入主线程,遇到console.log,输出1. 2.遇到set1,其回调函数被分发到宏任务Event Queue中. 3.遇到pro1,new Promise直接执行,输出6.then被分发到微任务Event Queue中. 4.遇到set2,其回调函数被分发到宏任务Event Queue中. 5.主线程的整段JS代码(宏任务)执行完成,开始清空所有微任务;主线程执行微任务pro1,输出7;遇到set3，注册回调函数。 第二轮事件循环 1.主线程执行队列中第一个宏任务set1,输出2;遇到set4,注册回调;再遇到pro2,new Promise直接执行,输出4,并注册回调. 2.set1(宏任务)执行完,开始清空微任务,主线程执行微任务pro2,输出5; 第三轮事件循环 1.主线程执行队列中第一个宏任务set2，输出9；代码中遇到了pro3，new promise()直接输出10，并注册回调； 2.set2宏任务执行完毕，开始情况微任务，主线程执行微任务pro3，输出11。 类似循环…","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"围城——读书笔记","slug":"读书笔记--围城","date":"2020-02-09T15:27:15.000Z","updated":"2022-01-11T07:51:44.822Z","comments":true,"path":"2020/02/09/读书笔记--围城/","link":"","permalink":"http://example.com/2020/02/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%9B%B4%E5%9F%8E/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 惊叹钱老的经典！借着小说揭露那个时代的病态，文笔犀利，辛辣讽刺。方鸿渐自己留洋归来，在有着前清举人称号的父亲，迂腐的母亲，惺惺作态的弟妹的大家庭中，代表着西式文化，与传统的中国文化进行了一场激烈的碰撞。还有和肝胆相照的赵辛楣，极具才气的苏小姐，道貌岸然的李梅亭等一系列个性鲜明人物的故事，道出世事无常，人性虚伪，也暗讽陈腐的旧中国包括代表西方文化的部分知识分子。“城中的人想出去，城外的人想冲进来”，我想这话不仅仅只是说婚姻，生活也是如此。方鸿渐的一生都在城内外兜兜转转，恋爱跟着失恋，教书跟着被辞退，结婚跟着不快乐。之后方鸿渐和孙柔嘉的结合，到底不是有情人终成眷属，步入婚姻，逐渐暴露出双方的真实，原生家庭带来的矛盾，经济上的窘迫，让两个人并不快乐。可以说这样婚姻是围城，不过也不能忽视现实。在现实中我们也会深陷”围城”，大多时候都是我们自己造成的困扰和奇怪的想法，消极的想法总是让人感到悲观，要经常审视自己的内心。有些人快乐的时候很少，和生活一直在做抗争，有些人一直保持积极乐观的心态，带着极大的热情生活，这些人并非一直如此，状态相互转化间可见”围城”并非牢不可破，该破的是我们自己的想法。 围城—读书笔记2.3-2.10小范宝贝《围城》这本书，刚看时没有什么深刻的体会，但它可能经典就经典在随着故事情节的发展，人性的弱点与人生的荒凉慢慢的展现在了你的面前，甚至会使读者在方鸿渐的身上找到一丝情感的共鸣，像是人性的缩影，在他的身上体现的淋漓尽致。故事以夕阳下海面上缓缓行驶的船只开头，在这艘船上方鸿渐与“半裸的”“局部真理的”鲍小姐有了一夜的情缘。而同时，同样留学归来的苏小姐也对他芳心暗许。苏文纨家室不错又是留样归来，长得也眉清目秀，可是方鸿渐到最后也没有喜欢上苏小姐，反而是对她的表妹唐晓芙可以说是一见钟情。钱钟书先生是这样描述唐晓芙的：唐小姐妩媚端正的圆脸，有两个浅酒涡。天生着一般女人要花钱费时、调脂和粉来仿造的好脸色，新鲜得使人见了忘掉口渴而又觉嘴馋，仿佛是好水果。她眼睛并不顶大，可是灵活温柔，反衬得许多女人的大眼睛只像政治家讲的大话，大而无当。古典学者看她说笑时露出的好牙齿，会诧异为什么古今中外诗人，都甘心变成女人头插的钗，腰束的带，身体睡的席，甚至脚下践踏的鞋，可是从没想到化作她的牙刷。她头发没烫，眉毛不镊，口红也没有擦，似乎安心遵守天生的限止，不要弥补造化的缺陷。总而言之，唐小姐是摩登文明社会里那桩罕物——一个真正的女孩子。这段话，真的是我在整本书中，见过的对女孩子最美好的描述了，唐小姐就像一朵红玫瑰，深深地插进了方鸿渐的心中。而这段感情最终也因为他自己的懦弱与退缩夭折在了那个下着大雨的午后。如果说鲍小姐代表肉欲，苏小姐代表才情和家室，唐小姐代表初恋，那接下来出现的这位孙柔嘉则代表了婚姻。孙小姐出现时，一张寡淡的脸上有着些小的雀斑，这与唐小姐的外貌描述简直天差地别。而她一个女孩独自和4个男人一起出远门去大学教书，这种行为刚开始让我不太理解，可看到后面她父母的重男轻女，迫使她一个女孩子要不断的努力才能创造出属于自己的好生活。原以为她是一个乖巧甚至有些单纯的女生，可在她一步一步设下圈套，让方鸿渐慢慢走进自己婚姻的围城中时，让我觉得她实在心思深重，却也觉得她有些可怜。家庭和生活的压力逼迫她成长为了一个敏感、富有心计的女子。她与方鸿渐婚后也渐渐暴露出自己善妒、专横的一面。她过于聪明，每每吵架嘴上说着不想方鸿渐的朋友觉得她限制了他的生活，可他们有哪一次吵架不是孙柔嘉在限制他呢？在生活上、工作上，甚至是朋友的交往上。她很勇敢，她大胆的追求自己的幸福，选择了方鸿渐这在她看来是最好的选择，她拥有抗争人生，迎来幸福生活的勇气，可她选择的却未必是幸福的生活。他们的婚后生活打破了方鸿渐对婚姻的幻想，这是一段被掌控的婚姻，而方鸿渐在被生活不断打磨棱角的同时，也在不断的向他的婚姻做出妥协。可是这些妥协并不能改变他们不断的争吵、不断的发生矛盾的现状。是啊，方鸿渐从来就不是一个会主动争取的人，他好像经不得一点挫折与麻烦。他总是在有了一点点退路后拔腿就跑，不愿意面对一点点的困难或者说努力一点点。考取文凭时是这样，与岳父岳母闹翻时是这样，大学教书时没有聘书也是这样。他也曾在年轻的时候意气风发，被大家吹捧、有女孩喜爱。那时他的身边围绕着的是苏小姐、赵先生、唐小姐、曹先生，这些人无一例外都是家世好，文化高，他也曾是这些人中的一员。但是在时间的细细打磨下，他慢慢露出了原本的样子。文凭是假的，家室也一般，性格又软弱，只有那一身的傲气还算真实。最后只能娶一个像孙柔嘉这样平凡的女生作为妻子，还说“也许这正是我所需要的”。他总是被迫的接受着，还反过来安慰自己也许一切都是最好的安排，真是一个可悲又可恨的人物。方鸿渐有些小聪明，也比一般人有学识，可他的一生，在我看来的的确确是一场悲剧。他一生都无法走出自己的围城里。这个围城，不是别人给他造的，而是他的懦弱退缩加上他莫名的不肯低头的傲气，自己给自己设下的围城。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"JavaScript中Set和Map","slug":"JavaScript中Set和Map","date":"2020-02-07T07:32:12.000Z","updated":"2022-01-11T07:44:01.621Z","comments":true,"path":"2020/02/07/JavaScript中Set和Map/","link":"","permalink":"http://example.com/2020/02/07/JavaScript%E4%B8%ADSet%E5%92%8CMap/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 SetES6 提供了新的数据结构 Set.它类似于数组,但是成员的值都是唯一的,没有重复的值. Set 本身是一个构造函数,用来生成 Set 数据结构.基本用法: 123let set = new Set([1,1,2,3,4,4]);console.log(set);//Set &#123; 1, 2, 3, 4 &#125;console.log(set.size);//4 接下来详细了解一下Set实例的属性和方法: 属性 size:返回集合所包含元素的数量 方法 操作方法(见例子1) add(value):向集合中添加一个新的项 delete(value):从集合中移除一个值 has(value): 判断一个值在集合中是否存在,存在返回true,否则false clear(): 移除集合里所有的项 遍历方法(见例子2) keys():返回键名的遍历器 values():返回键值的遍历器 entries():返回键值对的遍历器 forEach():使用回调函数遍历每个成员 例子1: 123456789101112131415let set = new Set();set.add(&#x27;Cola&#x27;);set.add(3.5);set.add(&#x27;red&#x27;);console.log(set);//Set &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;set.delete(3.5);console.log(set);//Set &#123; &#x27;Cola&#x27;, &#x27;red&#x27; &#125;console.log(set.has(&#x27;red&#x27;));//trueconsole.log(set.has(&#x27;blue&#x27;));//falseset.clear();console.log(set);//Set &#123;&#125; 例子2: 1234567891011let set = new Set([&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;]);console.log(set.keys());//SetIterator &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;console.log(set.values());//SetIterator &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;console.log(set.entries());//SetIterator &#123; [ &#x27;Cola&#x27;, &#x27;Cola&#x27; ], [ 3.5, 3.5 ], [ &#x27;red&#x27;, &#x27;red&#x27; ] &#125;set.forEach((value, key, array) =&gt; &#123; console.log(key + &#x27; : &#x27; + value + &#x27; : &#x27; + array);&#125;)//Cola : Cola : [object Set]//3.5 : 3.5 : [object Set]//red : red : [object Set] 注意:Set的遍历顺序就是插入顺序,由于 Set 结构没有键名,只有键值(或者说键名和键值是同一个值),所以keys方法和values方法的行为完全一致 for of遍历方式: 1234567891011121314let set = new Set([&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;]);for(let value of set)&#123; console.log(value);&#125;//Cola//3.5//redfor(let [value,key] of set.entries())&#123; console.log(value+&#x27;:&#x27;+key);&#125;//Cola:Cola//3.5:3.5//red:red Set和Array转换 数组 =&gt; Set: 123let arr = [&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;];let set = new Set(arr);console.log(set);//Set &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125; Set =&gt; 数组: 123let set = new Set([&#x27;Cola&#x27;, 3.5, &#x27;red&#x27;]);let arr = Array.from(set)console.log(arr);//[ &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; ] WeakSet我们再看看Set,当有对象存储在Set实例中时,这相当于把对象存储在变量中,只要Set实例的引用仍然存在,所存储的对象就无法被垃圾回收机制回收,从而无法释放内存: 123456789101112let set = new Set();let obj = &#123;name:&#x27;Cola&#x27;&#125;;let color = &#x27;red&#x27;;set.add(obj);set.add(color);console.log(set.size); // 2obj = null;color = &#x27;blue&#x27;;console.log(set.size); // 2console.log(obj); // nullconsole.log(set); // Set &#123; &#123; name: &#x27;Cola&#x27; &#125;, &#x27;red&#x27; &#125; WeakSet 结构与 Set 类似,也是不重复的值的集合.但它与 Set 有两个区别: WeakSet 的成员只能是对象，而不能是其他类型的值. 12let ws = new WeakSet();ws.add(&#x27;Cala&#x27;);//TypeError: Invalid value used in weak set WeakSet 中的对象都是弱引用,即垃圾回收机制不考虑 WeakSet 对该对象的引用,也就是说,如果其他对象都不再引用该对象,那么垃圾回收机制会自动回收该对象所占用的内存,不考虑该对象还存在于 WeakSet 之中.因为这个特点,WeakSet 不可遍历. 12345678let ws = new WeakSet();let obj =&#123;name:&#x27;Cola&#x27;&#125;ws.add(obj);ws.add(&#123;&#125;);console.log(ws.has(obj))//truews.delete(obj)console.log(ws.has(obj))//false Weak Set 不提供任何迭代器(例如 keys() 与 values() 方法),没有size属性. MapMap类型是一组键值对的结构,具有极快的查找速度.它是键值对的有序列表，而键和值都可以是任意类型.基本用法: 123456let map = new Map([[&#x27;type&#x27;,&#x27;food&#x27;],[&#x27;name&#x27;, &#x27;Cola&#x27;]]);map.set(&#x27;color&#x27;, &#x27;red&#x27;).set(&#x27;price&#x27;, 3.5);console.log(map.size)//4console.log(map.get(&#x27;name&#x27;))//Colaconsole.log(map.get(&#x27;size&#x27;))//undefinedconsole.log(map);//Map &#123; &#x27;type&#x27; =&gt; &#x27;food&#x27;, &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, &#x27;color&#x27; =&gt; &#x27;red&#x27;, &#x27;price&#x27; =&gt; 3.5 &#125; 接下来详细了解一下Set实例的属性和方法: 属性 size:返回集合所包含元素的数量 方法 操作方法(见例子3) set(key, value):设置键名key对应的键值为value,然后返回整个 Map 结构.如果key已经有值,则键值会被更新,否则就新生成该键.set方法返回的是当前的Map对象，因此可以采用链式写法 get(key):读取key对应的键值，如果找不到key，返回undefined has(key):判断指定键在Map中是否存在,存在返回true,否则false delete(ley):移除Map中的建以及对应的值 clear():移除Map中所有的键与值 遍历方法(见例子4) keys():返回键名的遍历器 values():返回键值的遍历器 entries():返回所有成员的遍历器 forEach():遍历 Map 的所有成员 例子3: 123456789101112let map = new Map()map.set(&#x27;name&#x27;, &#x27;Cola&#x27;);map.set(&#x27;price&#x27;, 3.5);console.log(map.has(&#x27;name&#x27;))//trueconsole.log(map.has(&#x27;color&#x27;))//falsemap.delete(&#x27;name&#x27;);console.log(map.has(&#x27;name&#x27;))//falsemap.clear();console.log(map.size)//0 例子4: 1234567891011121314151617let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]);console.log(map.keys());//MapIterator &#123; &#x27;type&#x27;, &#x27;name&#x27;, &#x27;color&#x27;, &#x27;price&#x27; &#125;console.log(map.values());//MapIterator &#123; &#x27;food&#x27;, &#x27;Cola&#x27;, &#x27;red&#x27;, 3.5 &#125;console.log(map.entries());//MapIterator &#123;// [ &#x27;type&#x27;, &#x27;food&#x27; ],// [ &#x27;name&#x27;, &#x27;Cola&#x27; ],// [ &#x27;color&#x27;, &#x27;red&#x27; ],// [ &#x27;price&#x27;, 3.5 ] &#125;map.forEach((value, key, map) =&gt; &#123; console.log(key + &#x27;:&#x27; + value)&#125;)//type:food//name:Cola//color:red//price:3.5 for of遍历方式: 12345678let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]);for (let item of map.entries()) &#123; console.log(item[0] + &#x27;:&#x27; + item[1])&#125;//type:food//name:Cola//color:red//price:3.5 Map与其他数据结构的相互转换 Map =&gt; 数组 123let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]);let arr = [...map];//或者 let arr = Array.from(map);console.log(arr);//[ [ &#x27;type&#x27;, &#x27;food&#x27; ],[ &#x27;name&#x27;, &#x27;Cola&#x27; ],[ &#x27;color&#x27;, &#x27;red&#x27; ],[ &#x27;price&#x27;, 3.5 ] ] 数组 =&gt; Map 1let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [&#x27;color&#x27;, &#x27;red&#x27;], [&#x27;price&#x27;, 3.5]]); Map =&gt; 对象 1234567891011let map = new Map([[&#x27;type&#x27;, &#x27;food&#x27;], [&#x27;name&#x27;, &#x27;Cola&#x27;], [2, &#x27;red&#x27;]]);function mapToObj(strMap) &#123; let obj = Object.create(null); for (let [k, v] of strMap) &#123; obj[k] = v; &#125; return strMap;&#125;console.log(mapToObj(map))//Map &#123; &#x27;type&#x27; =&gt; &#x27;food&#x27;, &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, 2 =&gt; &#x27;red&#x27; &#125; 对象 =&gt; Map 1234567891011obj = &#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27; &#125;;function objToMap(obj) &#123; let map = new Map(); for (let item of Object.keys(obj)) &#123; map.set(item, obj[item]); &#125; return map;&#125;console.log(objToMap(obj));//Map &#123; &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, &#x27;color&#x27; =&gt; &#x27;red&#x27; &#125; WeakSet如果希望不再引用Map的时候自动触发垃圾回收机制.那么也需要WeakMap。 123456789let map = new WeakMap();const key = document.getElementById(&#x27;div&#x27;);map.set(key, &#x27;这是一个div&#x27;);map.get(key) // &quot;这是一个div&quot;//移除该元素key.parentNode.removeChild(key);key = null;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中IIFE","slug":"JavaScript中IIFE","date":"2020-02-06T10:10:25.000Z","updated":"2023-07-19T01:27:25.491Z","comments":true,"path":"2020/02/06/JavaScript中IIFE/","link":"","permalink":"http://example.com/2020/02/06/JavaScript%E4%B8%ADIIFE/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 概念IIFE(Immediately-Invoked Function Expression) 立即执行函数表达式,也就是说在声明函数的同时立即调用该函数.先看看IIFE的语法: 1234(function()&#123; let color = &#x27;red&#x27;; console.log(color);&#125;)()//red 常规函数的定义和调用: 123456function cola()&#123; let color = &#x27;red&#x27;; console.log(color);&#125;cola();//red 为什么有IIFE如果只是为了执行一个函数,从上面的例子可以看出好处有限.实际上IIFE的出现是为了弥补JS在在scope方面的缺陷：JS只有全局作用域(global scope)、函数作用域(function scope),从ES6开始才有块级作用域(block scope).在JS中，只有function才能实现作用域隔离，因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。 1234567let color = &#x27;blue&#x27;;function cola() &#123; let color = &#x27;red&#x27;; return color;&#125;console.log(cola());//redconsole.log(color); 在我们通常的理解中，将代码封装到函数中的目的是为了复用。在JS中，声明函数的目的在大多数情况下也是为了复用，但是JS迫于作用域控制手段的贫乏，我们也经常看到只使用一次的函数：目的就是为了隔离作用域.既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也省掉了！这就是IIFE的由来。 IIFE一些要注意的地方123(function () &#123; //statements&#125;)(); 表达式中的变量不能从外部访问 123456(function () &#123;let color = &#x27;red&#x27;;return color;&#125;)()//redconsole.log(color);//抛出错误 : ReferenceError: color is not defined 将IIFE分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果 123456let res = (function () &#123; let color = &#x27;red&#x27;; return color;&#125;)();console.log(res);//red IIFE的多参数 123(function (window, document) &#123; // 这里可以调用到window和document &#125;)(window, document); 总结IIFE的目的是为了隔离作用域,防止污染全局命名空间.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript中深拷贝和浅拷贝","slug":"JavaScript中深拷贝和浅拷贝","date":"2020-02-05T11:07:22.000Z","updated":"2022-01-11T07:44:53.342Z","comments":true,"path":"2020/02/05/JavaScript中深拷贝和浅拷贝/","link":"","permalink":"http://example.com/2020/02/05/JavaScript%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 在JavaScript中,对于引用类型数据的值,当从一个变量向另一个变量复制引用类型值时，这个值的副本其实是一个指针，两个变量指向同一个堆对象，改变其中一个变量，另一个也会受到影响.这种拷贝分为两种情况:拷贝引用和拷贝实例,也就是我们说的浅拷贝和深拷贝. 浅拷贝 浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用:第一个例子是直接拷贝原对象的引用 12345678let obj = &#123; name: &quot;Cola&quot;, detail: &#123; price: 3.5 &#125;, color: [&#x27;red&#x27;] &#125;;let obj2 = obj;obj2.name = &quot;Coca Cola&quot;;obj2.detail.price = 5;obj2.color[0] = &#x27;blue&#x27;;console.log(obj)//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; price: 5 &#125;, color: [ &#x27;blue&#x27; ] &#125;console.log(obj2)//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; price: 5 &#125;, color: [ &#x27;blue&#x27; ] &#125; 再看第二个例子,理解拷贝一层的含义(Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。注意：Object.assign()拷贝的是属性值，假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值) 1234567let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = Object.assign(&#123;&#125;, obj);obj2.name=&#x27;Coca Cola&#x27;;obj2.detail.color=&#x27;blue&#x27;;console.log(obj);//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;console.log(obj2);//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125; 其他实现方法 扩展运算符 1234567let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = &#123;...obj&#125;;obj2.name=&#x27;Coca Cola&#x27;;obj2.detail.color=&#x27;blue&#x27;;console.log(obj);//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;console.log(obj2);//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125; Array.prototype.slice(),该方法提取并返回一个新的数组,如果源数组中的元素是个对象的引用,slice会拷贝这个对象的引用到新的数组 1234567let arr = [&#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125;];let arr2 = arr.slice();arr2[0] = &#x27;Coca Cola&#x27;;arr2[1].color = &#x27;blue&#x27;;console.log(arr);//[ &#x27;Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]console.log(arr2);//[ &#x27;Coca Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ] Array.prototype.concat(),该方法用于合并多个数组,并返回一个新的数组,和slice方法类似,当源数组中的元素是个对象的引用，concat在合并时拷贝的就是这个对象的引用 12345678let arr = [&#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125;];let arr2 = [&#123; price: 3.5 &#125;];let arr3 = arr.concat(arr2);arr3[0] = &#x27;Coca Cola&#x27;;arr3[2].price = 5;console.log(arr);//[ &#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125; ]console.log(arr2);//[ &#123; price: 5 &#125; ] 手动实现浅拷贝: 123456789101112131415161718192021function shallowClone(source) &#123; if (!source || typeof source !== &#x27;object&#x27;) &#123; throw new Error(&#x27;error arguments&#x27;); &#125; var target = source.constructor === Array ? [] : &#123;&#125;; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; target[key] = source[key]; &#125; &#125; return target;&#125;let obj = [&#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125;];let obj2 = shallowClone(obj);obj[0] = &#x27;Coca Cola&#x27;obj[1].color = &#x27;blue&#x27;console.log(obj)//[ &#x27;Coca Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]console.log(obj2)//[ &#x27;Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ] 深拷贝 深拷贝是拷贝多层，每一级别的数据都会拷贝出来:也就是说深拷贝会另外拷贝一份一个一模一样的对象,从堆内存中开辟一个新的区域存放新对象,新对象跟原对象不共享内存，修改新对象不会改到原对象. 常用方法:JSON.parse(JSON.stringify()) 123456let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = JSON.parse(JSON.stringify(obj));obj2.name = &#x27;Coca Cola&#x27;;obj2.detail.color = &#x27;blue&#x27;console.log(obj);//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;console.log(obj2);//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125; 这是前端开发过程中比较常用的深拷贝方式。原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象.它有一些值得注意的地方 拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失 对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null 还可以借助jQuery，lodash等第三方库完成一个深拷贝实例. 手动实现深拷贝 123456789101112131415161718192021222324function deepClone(source) &#123; if (!source || typeof source !== &#x27;object&#x27;) &#123; throw new Error(&#x27;error arguments&#x27;); &#125; var target = source.constructor === Array ? [] : &#123;&#125;; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; if (typeof source[key] === &#x27;object&#x27; &amp;&amp; source[key]) &#123; target[key] = deepClone(source[key]); &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;let obj = &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;;let obj2 = deepClone(obj);obj2.name=&#x27;Coca Cola&#x27;;obj2.detail.color = &#x27;blue&#x27;;console.log(obj) // &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;console.log(obj2) // &#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript对象和JSON","slug":"JavaScript对象和JSON","date":"2020-02-05T03:45:23.000Z","updated":"2022-01-11T07:46:22.306Z","comments":true,"path":"2020/02/05/JavaScript对象和JSON/","link":"","permalink":"http://example.com/2020/02/05/JavaScript%E5%AF%B9%E8%B1%A1%E5%92%8CJSON/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 二者概念JSON(JavaScript Object Notation)是一种轻量级的数据交换格式,它主要用于跨平台交流数据.这种数据格式是从JavaScript对象中演变出来的，它是JavaScript的一个子集。JSON本身的意思就是JavaScript对象表示法（JavaScript Object Notation），它用严格的JavaScript对象表示法来表示结构化的数据，因此 JSON 的属性名必须有双引号。 JSON 数据结构有两种，这两种结构就是对象和数组，通过这两种结构可以表示各种复杂的结构。 123456789&#123; &quot;college&quot;: &quot;TKK&quot;, &quot;age&quot;: 16, &quot;students&quot;:[ &#123;&quot;firstName&quot;:&quot;ITT&quot;,&quot;lastName&quot;:&quot;16001&quot;&#125;, &#123;&quot;firstName&quot;:&quot;ITT&quot;,&quot;lastName&quot;:&quot;16002&quot;&#125;, &#123;&quot;firstName&quot;:&quot;ITT&quot;,&quot;lastName&quot;:&quot;16003&quot;&#125; ]&#125; 二者转换 JSON 数据转换为 JS 对象:eval()函数: 1234let txt = &#x27;&#123;&quot;college&quot;: &quot;TKK&quot;,&quot;age&quot;: 16,&quot;students&quot;: [&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16001&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16002&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16003&quot; &#125;]&#125;&#x27;let obj = eval(&quot;(&quot; + txt + &quot;)&quot;);console.log(obj);console.log(typeof obj);//object 使用eval()函数时,必须为传入的JSON数据添加括号”()”,否则会报语法错误.该函数除了可以解析JSON数据,也可以用于执行JavaScript 脚本片段，这就会带来潜在的安全问题。 JSON 数据转换为 JS 对象:parse()函数: 1234let txt = &#x27;&#123;&quot;college&quot;: &quot;TKK&quot;,&quot;age&quot;: 16,&quot;students&quot;: [&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16001&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16002&quot; &#125;,&#123; &quot;firstName&quot;: &quot;ITT&quot;, &quot;lastName&quot;: &quot;16003&quot; &#125;]&#125;&#x27;let obj = JSON.parse(txt);console.log(obj);console.log(typeof obj);//object 这是专门的 JSON Parser 来实现只用于解析 JSON 数据，不会执行 JavaScript 脚本，而且速度更快。 JS 对象转换为 JSON 数据:JSON.strigify() 函数 123let obj = &#123; college: &quot;TKK&quot;, age: 16 &#125;;let txt = JSON.stringify(obj);console.log(txt);//&quot;&#123;&quot;college&quot;:&quot;TKK&quot;,&quot;age&quot;:16&#125;&quot; 一张表格来区别二者 区别 Json Javascript对象 含义 仅仅是一种数据格式 对象的实例 传输 可以跨平台数据传输，速度快 不能传输 表现 1. 键值对 2. 键必须加双引号 3. 值不能为方法函数/undefined/NaN 1.键值对 2.值可以是函数、对象、字符串、数字、boolean 等 相互转换 Json → JS 对象：1. var obj = JSON.parse(jsonstring); 2. var obj = eval(“(“+jsonstring+”)”); JS 对象 → Json：JSON.stringify(obj);","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript数据类型详解","slug":"JavaScript数据类型详解","date":"2020-02-04T11:18:53.000Z","updated":"2022-01-11T07:45:54.910Z","comments":true,"path":"2020/02/04/JavaScript数据类型详解/","link":"","permalink":"http://example.com/2020/02/04/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 一.JavaScript数据类型ECMAScript标准规定了7种数据类型，其把这7种数据类型又分为两种：原始类型和对象类型。原始类型也叫基本数据类型，对象类型也叫引用数据类型。 基本数据类型 Null: 只包含一个值: null Undefined: 只包含一个值: undefined Boolean: 包含两个值: true 和 false Number: 整数或浮点数,还有一些特殊值: -Infinity、**+Infinity、NaN** String: 一串表示文本值的字符序列 Symbol: 一种实例,是唯一且不可改变的数据类型 (在ES10中加入了第七种基本数据类型BigInt) 引用数据类型 Object: 除了常用的Object,还有Array,Function,Date,RegExp等也是特殊的对象 二.基本数据类型和引用数据类型的区别基本数据类型具有不可变性在ECMAScript标准中，它们被定义为primitive values，即原始值，代表值本身是不可被改变的。 以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的： 1234567let name = &quot;Cola&quot;;name.slice(1);//olaname.substr(2);//laname.trim(1);//Colaname.toLowerCase(1);//colaname[1];//oconsole.log(name);//Cola 可以看到对name字符串调用方法后再次打印它的值,name没有发生改变,由此可以得知字符串的不可变性.而这些方法都是在原字符串的基础上产生新字符串. 接下来我们对字符串进行赋值操作: 123let name = &quot;Cola&quot;;name = &quot;Coca &quot; + name;console.log(name);//Coca Cola 发现name的值”改变”了.这是为什么?其实,name只是指向**”Cola”的一个指针,指针的指向可以改变,所以name = “Coca “ + name;执行后改变了name的指向,而“Coca Cola”**这个原始值仍然不可改变. 引用数据类型易变引用类型的值实际存储在堆内存中,在栈中存储的是一个固定长度的地址,该地址指向堆内存中的值. 1234let name = &quot;Cola&quot;;let obj1 = &#123; name: &quot;Cola&quot; &#125;;let obj2 = function () &#123; &#125;;let obj3 = [1, 2]; 基本数据类型的比较是值的比较,引用数据类型的比较是引用(地址)的比较123456let a = 1;let a1 = 1;let b = &#123;&#125;;let b1 = &#123;&#125;;console.log(a === a1);//trueconsole.log(b === b1);//false 两种数据类型的复制区别基本数据类型的复制: 12345let name = &quot;Cola&quot;;let name2 = name;//此时内存开辟了一块新的空间用于存储Colaname2=&quot;Coca Cola&quot;;console.log(name);//Colaconsole.log(name2);//Coca Cola 引用数据类型的复制: 1234let obj=&#123;name:&quot;Cola&quot;&#125;;let obj2 = obj;obj2.name=&quot;Coca Cola&quot;;//实际上复制的是栈中存储的地址,因此obj和obj2指向的是同一个对象console.log(obj.name);//Coca Cola 特别注意:ECMAScript中所有的函数的参数都是按值传递的值传递: 123456let name = &#x27;Cola&#x27;;function changeValue(name)&#123; name = &#x27;Coca Cola&#x27;;&#125;changeValue(name);console.log(name);//Cola 上面执行的结果是Cola,可见函数参数是按值传递的. “引用传递”: 123456let obj = &#123; name: &quot;Cola&quot; &#125;;function changeValue(obj) &#123; obj.name = &#x27;Coca Cola&#x27;;&#125;changeValue(obj);console.log(obj.name);//Coca Cola 这里彷佛违背了上面说的,其实没有.当函数参数是引用类型时,Js同样将参数复制了一个副本到局部变量,只不过这个副本是指向堆内存中的地址,也就是在函数内部会对该对象的属性进行操作. 三.null和undefined的区别先看看他们之间的关系: 1234console.log(typeof null);//objectconsole.log(typeof undefined);//undefinedconsole.log(null == undefined);//true 二者都默认转换成falseconsole.log(null === undefined);//false null表示没有对象,即此处不应该有值 作为函数的参数时,表示该函数的参数不是对象 作为对象原型链的终点 undefined表示缺少值,即此处应该有值,但没有定义 定义了形参,没有传实参,显示undefined 访问对象的属性名不存在时,显示undefined 函数没有返回值时,拿到的是undefined 函数有返回值却没有赋值时,拿到的是undefined null 和 undefined 转换成number数据类型时: null 默认转成 0 undefined 默认转成 NaN 四.知识点很多的Number类型 JavaScript 只有一种数字类型,即为Number，如 5 和 5.12 是相同的类型,也就是说,所有数字都是浮点数。 JavaScript 使用“双精度64位格式IEEE 754”标准 NaN: Not a Number,不是一个数,但它属于数值类型 NaN和任何值进行操作都会返回NaN NaN与任何值都不相等,包括NaN本身 isNaN(): 这是用于检测一个变量是不是Number类型的函数,它接收一个参数,参数可以是任何类型,该函数会尝试把传入的参数转换为数值,不能转换为数值的值返回true，能转换的返回false。 数值转换 Number() parseInt() 取整 parseFloat() 浮点数 Number()转换规则 如果是布尔值，true和false会被转换为1和0。 12Number(true) // 1Number(false) // 0 如果是数字，没有特殊变换。 12Number(1) // 1Number(100) // 100 null 和 undefined 在上文提及 如果是字符串 字符串中只包含数字（包括前面带正/负号的情况），则将其转换为十进制数值,数字前面有0的会被忽略(不管前面有几个0，全部忽略)，例如”010”会转换成10。 1234Number(&quot;1&quot;) // 1Number(&quot;123&quot;) // 123Number(&quot;010&quot;) // 10 (前导的0会被忽略)Number(&quot;-10&quot;) // -10 字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值。 123Number(&quot;1.1&quot;) // 1.1Number(&quot;0.1&quot;) // 0.1Number(&quot;0000.1&quot;) // 0.1 (前导的0会被忽略) 字符串中包含有效的十六进制格式（一般用数字0到9和字母A到F（或af）表示，其中:AF表示10~15，这些称作十六进制数字），如”0xf”,将其转换成相同大小的十进制整数值。 1Number(0xf) // 15 字符串为空，转换成0。 1Number(&quot;&quot;) // 0 字符串中包含除了以上格式之外的字符，则转换为NaN，如字符串中既有数字又有字母的情况。 123456Number(&quot;Hello Wolrd&quot;) // NaNNumber(&quot;0ff6600&quot;) // NaNNumber(&quot;ff6600&quot;) // NaNNumber(&quot;0.1a&quot;) // NaNNumber(&quot;10a&quot;) // NaNNumber(&quot;a10.1&quot;) // NaN parseInt(string,radix) 这是一个将一个字符串转换成x进制整数的函数。 传入的第一个参数为字符串，如果参数不是字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。第二个参数为整数，表示按照xx进制转换，如传入参数10表示按十进制规则转换， 从左到右依次查找有效数字字符，直到遇到非有效数字字符，停止查找（不管后面是否好友数字），把找到的当做数字返回。如果字符串中以0x开头且后跟数字字符，就会将其当做一个十六进制整数。 1234567parseInt(&quot;123abc&quot;) // 123parseInt(&quot;&quot;) // NaNparseInt(&quot;12.5px&quot;) // 12parseInt(&quot;0xA&quot;) // 10 (16进制)parseInt(&quot;0xf&quot;) // 15 (16进制)parseInt(&quot;070&quot;) // 70parseInt(&quot;70&quot;) // 70 parseInt(string,radix) 解析一个参数（必要时先转换为字符串）并返回一个浮点数。默认解析十进制值。 12345function circumference(r) &#123; return parseFloat(r) * 2.0 * Math.PI;&#125;console.log(circumference(4.567));// expected output: 28.695307297889173console.log(circumference(&#x27;4.567abcdefgh&#x27;));// expected output: 28.695307297889173 从左到右依次解析字符，一直解析到字符串末尾，遇到非数字字符会或遇到第二个浮点数（在这之前的字符串都会被解析）会使解析停止,如”3.14”解析成3.14，”3.14.1234”解析成3.14 忽略参数首尾空白符 十六进制格式的字符串始终会被转换成0 1234567891011parseFloat(&quot;3.14&quot;) // 3.14parseFloat(&quot;-3.14&quot;) //-3.14parseFloat(&quot;+3.14&quot;) //3.14parseFloat(&quot;0003.14&quot;) // 3.14parseFloat(&quot; 3.14 &quot;) // 3.14parseFloat(&quot;3.14abc&quot;) // 3.14parseFloat(&quot;3.14.5678&quot;) // 3.14parseFloat(&quot;abc3.14&quot;) // NaNparseFloat(&quot;abc123&quot;) // NaNparseFloat(&quot;123abc&quot;) // 123parseFloat(&quot;0xA&quot;) //0 #####parseInt() 和parseFloat() 的区别在于： parseFloat() 所解析的字符串中第一个小数点是有效的，而parseInt() 遇到小数点会停止解析。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript原型和原型链","slug":"JavaScript原型和原型链","date":"2020-02-03T10:34:20.000Z","updated":"2022-01-20T07:26:18.540Z","comments":true,"path":"2020/02/03/JavaScript原型和原型链/","link":"","permalink":"http://example.com/2020/02/03/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 Constructor 构造函数先写一个构造函数Person(构造函数一般为了区别普通函数，要求首字母大写): 1234function Person(name, age)&#123; this.name = name; this.age = age;&#125; prototype 原型原型是一个对象，实例”继承”对象的属性.也就是说在原型上定义的属性，通过”继承”这个行为，实例也拥有这个属性.该行为是在new关键字内部实现的. 我们把构造函数打印出来看看，发现其内部有一个名为prototype属性，通过它就能访问到原型: Person 就是构造函数，Person.prototype 就是原型 instance 实例现在有构造函数了,我们可以在原型上创建可以被”继承”的属性,并通过new关键词创建实例 可以使用 instanceof 就是判断一个实例是否属于某种类型,现在创建一个实例: 12let person = new Person(&quot;小黄&quot;,22);console.log(person instanceof Person);//true 如果我们在原型上定义一个属性后再实例化对象: 12345678function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.eyeColor = &quot;black&quot;let person = new Person(&quot;小黄&quot;,22);console.log(person.eyeColor);//black proto 隐式原型实例通过 proto 访问到原型： 所以以下二者等价 12345678function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.eyeColor = &quot;black&quot;let person = new Person(&quot;小黄&quot;,22);console.log(person.__proto__ === Person.prototype);//true constructor 构造函数(属性)原型可以通过constructor访问到构造函数: 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;console.log(Person.prototype.constructor === Person);//true 继续完善关系图:注意这里的 constructor 是原型的一个属性，Constructor 指的才是真正的构造函数。两者名字不要弄混了 原型链原型同样也可以通过 proto 访问到原型的原型,直到搜索到null: 123456789101112131415161718function Person(name, age)&#123; this.name = name; this.age = age;&#125;Person.prototype.eyeColor = &quot;black&quot;;function People()&#123;&#125;People.prototype = new Person();let people = new People()console.log(people instanceof Object)//trueconsole.log(people instanceof People)//trueconsole.log(people instanceof Person)//trueconsole.log(people.eyeColor)//blackconsole.log(people.__proto__)//Person &#123;&#125;console.log(people.__proto__.__proto__)//Person &#123;eyeColor: &quot;black&quot;&#125;console.log(people.__proto__.__proto__.__proto__)// &#123;&#125;console.log(people.__proto__.__proto__.__proto__.__proto__)//null 由此可以得出原型、原型链、构造函数、实例、null之间的关系:","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript创建对象的几种方式","slug":"JavaScript创建对象的几种方式","date":"2020-02-03T07:34:24.000Z","updated":"2022-01-11T07:48:00.995Z","comments":true,"path":"2020/02/03/JavaScript创建对象的几种方式/","link":"","permalink":"http://example.com/2020/02/03/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 使用对象字面量 这是创建对象最简单的方法。 使用对象文字，可以在一条语句中定义和创建对象。 对象文字指的是花括号 {} 中的名称:键值对（比如 age:62）。 例子： 12345678910let person = &#123; name:&quot;小黄&quot;, age:22, eyeColor:&quot;black&quot;, say:function()&#123; alert(this.name+&quot;今年&quot;+this.age+&quot;岁!&quot;); &#125;&#125;;person.say()//调用 通过关键词 new 例子: 123456789let person = new Object();person.name = &quot;小黄&quot;;person.age = 22;person.eyeColor = &quot;black&quot;; person.say = function()&#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;);&#125;;person.say()//调用 通过构造函数 无参构造函数,例子: 12345678910function Person()&#123;&#125;let person = new Person(); person.name = &quot;小黄&quot;;person.age = 22;person.eyeColor = &quot;black&quot;; person.say = function() &#123; alert(person.name+&quot;今年&quot;+person.age+&quot;岁!&quot;);&#125;;person.say()//调用 带参构造函数,例子: 1234567891011function Person(name, age, eyeColor) &#123; this.name = name; this.age = age; this.eyeColor = eyeColor; this.say = function() &#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;); &#125;;&#125;let person = new Person(&quot;小黄&quot;, 22, &quot;black&quot;); //实例化、创建对象person.say()//调用 工厂模式,例子: 12345678910111213function createPerson(name, age, eyeColor) &#123; let person = new Object(); person.name = name; person.age = age; person.eyeColor = eyeColor; person.say = function() &#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;); &#125;; return person;&#125;let my = createPerson(&quot;小黄&quot;, 22, &quot;black&quot;);//实例化my.say();//调用 原型模式,例子: 12345678910function Person(name, age, eyeColor)&#123;&#125;Person.prototype.name = &quot;小黄&quot;;Person.prototype.age = 22;Person.prototype.eyeColor = &quot;black&quot;; Person.prototype.say = function() &#123; alert(this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;); &#125;let person = new Person();person.say(); 构造函数和原型组合模式,例子: 123456789101112function Person(name, age, eyeColor)&#123; this.name = name; this.age = age; this.eyeColor = eyeColor; &#125;;Person.prototype.say = function()&#123; return this.name + &quot;今年&quot; + this.age + &quot;岁!&quot;&#125;;let person = new Person(&quot;小黄&quot;, 22, &quot;black&quot;);console.log(person.say());","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"为什么编程语言的都要定义数据类型","slug":"为什么编程语言的都要定义数据类型","date":"2020-02-03T06:27:56.000Z","updated":"2022-01-11T07:50:10.562Z","comments":true,"path":"2020/02/03/为什么编程语言的都要定义数据类型/","link":"","permalink":"http://example.com/2020/02/03/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E9%83%BD%E8%A6%81%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"我们都知道声明变量时，需要在内存中为该变量开辟空间。不同的数据类型占用的内存空间是不同的，如int占用4字节，char占用2字节(java中)，指定数据类型是为了给不同的数据类型分配不同的内存空间，既能适当地存储该变量的值，又不会浪费内存空间。 实际上还有其他原因，可以一句话概括为:数据类型是面向编译器的，决定编译器对相应类型的处理方式。以如下C++代码进行说明: 12345678int a=100;int b=200;double a1=10.1;double b1=10.2;a=a+b;a1=a1+b1; 这段代码非常简单，定义了四个数据，两种类型。a=a+b; 和 a1=a1+b1; 这两条语句几乎一样，但在计算机中使用了不同的处理器:整数使用普通的CPU，而浮点数必须使用浮点运算器。所以，这两句话，产生的机器代码完全不同！ 那么编译器碰到如上代码时如何知道使用哪一种机器指令呢，此时定义数据类型的意义就凸显出来了:编译器就会检查进行加法操作的两个加数的数据类型，根据他们的数据类型，来确定到底使用哪一个运算器的机器代码。 再次总结:数据类型的背后，隐藏的是编译器或者解释器对数据处理方式的定义。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程原理相关","slug":"编程原理相关","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"}]},{"title":"git账号密码输入错误后如何重新输入密码","slug":"git账号密码输入错误后如何重新输入密码","date":"2020-02-03T01:18:16.000Z","updated":"2021-08-07T05:59:13.690Z","comments":true,"path":"2020/02/03/git账号密码输入错误后如何重新输入密码/","link":"","permalink":"http://example.com/2020/02/03/git%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E9%94%99%E8%AF%AF%E5%90%8E%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 搜索–&gt;凭据管理器 –&gt; windows凭据 –&gt;找到对应git凭据删除 –&gt; 重新拉取","categories":[{"name":"解决方案","slug":"解决方案","permalink":"http://example.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"MongoDB常用命令","slug":"MongoDB常用命令","date":"2020-01-31T09:22:58.000Z","updated":"2022-01-11T07:43:25.245Z","comments":true,"path":"2020/01/31/MongoDB常用命令/","link":"","permalink":"http://example.com/2020/01/31/MongoDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 为了从命令提示符下运行 MongoDB 服务器，必须从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件。 1E:\\MongoDB\\bin&gt;mongod --dbpath E:\\MongoDB\\data\\db 数据库查看当前版本1db.version() 数据库查看所有数据库1show dbs 查看当前数据库1db 创建数据库1use DATABASE_NAME 删除当前数据库1db.dropDatabase() 集合在当前数据库创建集合1db.createCollection(name, options) 参数说明： name: 要创建的集合名称 options: 可选参数, 指定有关内存大小及索引的选项 字段 类型 描述 capped 布尔 （可选） 如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 （可选） 如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 （可选） 为固定集合指定一个最大值，以千字节计（KB）。如果 capped 为 true，也需要指定该字段。 max 数值 （可选） 指定固定集合中包含文档的最大数量。 在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。 例子:创建固定集合 hjy_friends，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。 1db.createCollection(&quot;hjy_friends&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; ) 在 MongoDB 中，可以不需要创建集合。当插入一些文档时，MongoDB 会自动创建集合。 1db.hjy_classmates.insert(&#123;&quot;name&quot;:&quot;小黄&quot;&#125;) 查看当前数据库下所有集合123show tablesshow collections 删除集合1db.COLLECTION_NAME.drop() 文档向集合中插入文档1db.COLLECTION_NAME.insert(document) 例子:在hjy_friends集合中创建一条文档: 1db.hjy_friends.insert(&#123;name:&quot;小黄朋友&quot;,age:22&#125;) 更新文档1db.COLLECTION_NAME.update() 例子: 1db.hjy_friends.update(&#123;age:22&#125;,&#123;$set:&#123;name:&quot;小黄的朋友&quot;&#125;&#125;) 删除文档(2.6版本后)1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 例子: 1db.hjy_friends.update(&#123;age:22&#125;,&#123;$set:&#123;name:&quot;小黄的朋友&quot;&#125;&#125;) 查询的文档1db.COLLECTION_NAME.find() pretty()方法以格式化的方式来显示所有文档 1db.COLLECTION_NAME.find().pretty()","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"}]},{"title":"关系型数据库遵循的ACID规则","slug":"ACID规则","date":"2020-01-24T01:35:24.000Z","updated":"2022-01-11T07:49:33.363Z","comments":true,"path":"2020/01/24/ACID规则/","link":"","permalink":"http://example.com/2020/01/24/ACID%E8%A7%84%E5%88%99/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 定义事务的英文中是transaction ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）的缩写 事务事务是访问数据库的一个操作序列，数据库应用系统通过事务集来完成对数据库的存取。事务的正确执行使得数据库从一种状态转换为另一种状态。 原子性（atomicity）原子性很容易理解，即不可分割，事务里的所有操作要么全部被执行，要么全部不执行。也就是说事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要**回滚[1]**。 一致性（consistency）事务的执行使得数据库从一种正确状态转换成另外一种正确状态。 例子:假设用户A和用户B两者账户的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个账户户的钱相加起来应该还得是5000，这就是事务的一致性。 隔离性（isolation）所谓的隔离性(在有些教程中也称独立性)是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。 例子:A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 持久性（durability）事务正确提交之后，其结果将永远保存在数据库之中，即使在事务提交之后有了其他故障，事务的处理结果也会得到保存。 释义回滚:删除由一个或多个部分完成的事务执行的更新。为保证应用程序、数据库或系统错误后还原数据库的完整性，需要使用回滚。回滚泛指程序更新失败, 返回上一次正确状态的行为。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"关系型数据库","slug":"关系型数据库","permalink":"http://example.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"人生海海——读书笔记","slug":"读书笔记--人生海海","date":"2020-01-11T02:27:15.000Z","updated":"2022-01-11T07:51:49.937Z","comments":true,"path":"2020/01/11/读书笔记--人生海海/","link":"","permalink":"http://example.com/2020/01/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F%E6%B5%B7%E6%B5%B7/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 通过”我”这第一人称陆陆续续从其他地方探听到上校曲折的一生，虽并非亲眼见证，但从别人口中娓娓道来也能感知那些跌宕起伏。上校在抗日，内战，文革那几十年来经历的一系列令人愤怒的背叛，战争年代的硝烟，自我宽容的救赎，一步步成全他有遗憾却完满的人生，有时候我不忍继续阅读下去，上校这一生令人心疼，年少的轻狂，救人救命的积极，前线的勇敢，化作他不再年轻时的豁达，唯独肚皮上的字，是他英勇无畏的体现，却让他一辈子被钉在民族大义的耻辱柱上，不敢展于人前，最终誓死捍卫秘密让他崩溃，不免令人唏嘘。人心是个复杂的多面体，在书中也体现得淋漓尽致，恨意和宽容在我们每个人身上都在相爱相杀，也正因为这样，这本书触动了心里某些东西，才影响到了我，为此感慨，为故事情节喜怒哀乐。在历史的滚滚洪流中，去看与上校相关的人和事，爷爷，父亲，老保长，小瞎子，林阿姨的恩怨情仇，或悔恨或遗憾，包括”我”的一生，波涛汹涌，前途茫茫，果真人生海海，潮起潮落。我认为他是民族英雄，虽然很难评判在那个时代的一个人，但上校始终没有背叛过国家，救人救命，除恶务尽。“记住，人生海海，敢死不叫勇气，活着才需要勇气，世上只有一种英雄主义，就是在认清了生活真相后依然热爱生活。”这段话深得我心，这本书完完全全注解了它意思，内在深刻，值得把这段故事记住。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"如何上传文件至远程服务器","slug":"如何上传文件至远程服务器","date":"2019-11-22T14:04:20.000Z","updated":"2022-01-11T07:50:31.055Z","comments":true,"path":"2019/11/22/如何上传文件至远程服务器/","link":"","permalink":"http://example.com/2019/11/22/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%87%B3%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 当我们在自己的电脑上完成开发工作后,常常需要把项目打包上传到远程服务器上部署,那如何进行操作呢?本文提供一种相对简便的方法用以解决该问题. 本文实践具体场景:本地上传文件至华为云服务器,用Xshell这个强大的安全终端模拟软件来验证是否成功 通过FTP工具FTP（File Transfer Protocol）是Internet上用来传送文件的协议（文件传输协议）. 现在有很多FTP工具 : FlashFXP、FileZilla、xFTP等等,操作都不复杂,这里用FlashFXP做演示 打开FlashFXP进行操作 打开Xshell验证是否上传成功 可以看到终端输出的”哈哈哈”,说明文件上传成功.","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"SpringBoot+MySQL+MyBatis的入门教程","slug":"SpringBoot+MySQL+MyBatis的入门教程","date":"2019-10-21T11:57:30.000Z","updated":"2022-01-11T07:42:02.319Z","comments":true,"path":"2019/10/21/SpringBoot+MySQL+MyBatis的入门教程/","link":"","permalink":"http://example.com/2019/10/21/SpringBoot+MySQL+MyBatis%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 本教程的开发环境以工具： JDK1.8 Navicat for MySQL（简单来说是一种数据库图形化工具，方便直接操作数据库） IntelliJ IDEA 开始之前,先对我们要用到的东西有个大概的了解: Spring Boot 中分为为 controller层、service层、dao层、entity层。 entity层存放实体类,与数据库中的属性值基本保持一致,定义为私有,实现set和get方法。 service层存放业务逻辑处理,不直接和数据库打交道,该层有接口还有接口的实现方法，在接口的实现方法中需要导入mapper层,service是供我们使用的方法(提供controller层调用的方法)。 dao层即mapper层，对数据库进行持久化操作，该层的方法是针对数据库操作的，基本用到的就是增删改查。它只是个接口，只有方法名字，具体实现在mapper.xml中。 controller层即控制器，导入service层，因为service中的方法是我们使用到的，controller通过接收前端传过来的参数进行业务操作，再返回一个指定的路径或者数据表。 MySQL就不用说了,最流行的关系型数据库管理系统。 MyBatis首先Mybatis是一个优秀的持久化框架,它支持自定义SQL查询、存储过程,和很好的一个映射。第二,Mybatis减少了大部分JDBC的代码,避免了手动设置参数和结果集的映射。第三,Mybatis用简单的XML配置文件或注解来配置映射关系,将接口和POJO对象映射到数据库记录中。(看不懂也没关系,我也不太清楚,慢慢学!) 一.项目构建1.通过IDEA创建工程:打开IDEA-&gt;file-&gt;New-&gt;Project-&gt;Spring Initializr2.next之后添加如图依赖(红框部分) 3.MySQL部分:打开Navicat,选择数据库,新建查询,DDL如下CREATE TABLE `user` ( `id` int(11) NOT NULL, `name` varchar(255), `age` int(11), PRIMARY KEY (`id`) ) 刷新表之后可以看到刚刚新建的表,继续新建查询,DDL如下INSERT INTO t_msg (id, NAME, age) VALUES (1, &#39;小黄&#39;, 9); 刷新表之后可以看到刚刚插入的数据,如下图所示 4.构建项目目录,如图所示 构建数据库对应的实体类TMsg，这个类放在entity,代码如下1234567891011121314151617181920212223package com.example.demo.entity;import lombok.Data;import java.io.Serializable;/** * Created by HJY on 2019/10/21. */@Datapublic class TMsg implements Serializable &#123; private Integer id; private String name; private Integer age; public String getMessage()&#123; return &quot;id:&quot;+id+&quot;,name:&quot;+name+&quot;,age:&quot;+age; &#125;&#125; 构建构建对应的Mapper接口,代码如下1234567891011121314package com.example.demo.mapper;import com.example.demo.entity.TMsg;import org.apache.ibatis.annotations.Mapper;/** * Created by HJY on 2019/10/21. */@Mapperpublic interface TMsgMapper &#123; public TMsg findById(Integer id);&#125; Mapper接口与TMsgMapper.xml文件对应关系,代码如下1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demo.mapper.TMsgMapper&quot;&gt; &lt;select id=&quot;findById&quot; resultType=&quot;com.example.demo.entity.TMsg&quot;&gt; SELECT id,name,age from user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; service层接口与其实现,代码如下123456789101112package com.example.demo.service;import com.example.demo.entity.TMsg;/** * Created by HJY on 2019/10/21. */public interface TMsgService &#123; public TMsg findById(Integer id);&#125; 1234567891011121314151617181920212223package com.example.demo.service.impl;import com.example.demo.entity.TMsg;import com.example.demo.mapper.TMsgMapper;import com.example.demo.service.TMsgService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * Created by HJY on 2019/10/21. */@Servicepublic class TMsgServiceImpl implements TMsgService &#123; @Autowired private TMsgMapper tMsgMapper; @Override public TMsg findById(Integer id) &#123; return tMsgMapper.findById(id); &#125;&#125; 在controller层构建一个get方法，通过id获取信息,代码如下123456789101112131415161718192021222324252627package com.example.demo.controller;import com.example.demo.entity.TMsg;import com.example.demo.service.TMsgService;import org.apache.ibatis.annotations.Param;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * Created by HJY on 2019/10/21. */@RestController@RequestMapping(&quot;/msg&quot;)public class TMsgController &#123; @Autowired private TMsgService tMsgService; @GetMapping(&quot;/getMsg&quot;) public String getMsg(@Param(&quot;id&quot;) Integer id)&#123; TMsg tMsg = tMsgService.findById(id); return tMsg.getMessage(); &#125;&#125; 修改application.properties文件后缀为application.yml,复制如下代码到该文件中,此处填写数据库信息,还有mybatis的数据库映射地址,实体类地址.(password如果是数字需要用单引号引起来)123456789spring: datasource: url: jdbc:mysql://localhost:3306/test?useSSL=true&amp;serverTimezone=Asia/Shanghai username: root password: &#x27;1234567&#x27; driver-class-name: com.mysql.cj.jdbc.Drivermybatis: mapper-locations: classpath*:mapper/*Mapper.xml type-aliases-package: com.example.demo.entity 二.项目运行启动项目,打开浏览器,输入http://localhost:8080/msg/getMsg?id=1 此时可以看到我们在数据库中插入的数据,至此完成","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"黄金时代——读书笔记","slug":"读书笔记--黄金时代","date":"2019-09-25T14:36:08.000Z","updated":"2022-01-11T07:52:01.724Z","comments":true,"path":"2019/09/25/读书笔记--黄金时代/","link":"","permalink":"http://example.com/2019/09/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 说句实话，初看这本书时，我直接被王小波大胆的描写给震住了，文字露骨却也坦率，话语幽默却也深刻。 每个人都有自己的黄金时代，王二在他的似水流年里或许真的可以说是放荡不羁，做了很多人想做却不敢做的事，我觉得他并非消遣，是在享受人生。他身上有着一些超凡的东西，或许可以说是勇气，当然也不仅仅勇气。他不在意大环境如何，在他二十岁出头的年纪，惦记上了有夫之妇的陈清扬，并以友谊之名付诸行动，之后就有了这看似色情却拥有了更多内在情感和讽刺意味的写作素材，虽然在现在看来有些荒唐，但我也并不怀疑它的真实性。 我相信王小波先生的风流，也喜欢他妙趣横生里的”真知灼见”。字里行间里能看出他的文学才华，他的文字总是能够让我在不经意间惊喜万分，”那一天我21岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失。”我也曾有这样光怪陆离的想法，那时不懂，直到后来才明白这也是我自己时代里美好的事物，说幻想倒也可以，我宁愿叫的好听些，哈哈。 岁月如流这词一点也不错，年岁渐长，王二也正经许多，但仍然有着他那些天马行空的想法，像年轻的时候。真好。 [========] 2020-02-23补充: 每每看到”不怕贼偷就怕贼惦记”这句话，我总会想起王二，王二是贼吗，他偷了什么吗，也惦记着陈清扬，陈清扬对他大抵也是心动过的。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"我们仨——读书笔记","slug":"读书笔记--我们仨","date":"2019-08-20T12:16:08.000Z","updated":"2021-08-07T05:59:13.609Z","comments":true,"path":"2019/08/20/读书笔记--我们仨/","link":"","permalink":"http://example.com/2019/08/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E6%88%91%E4%BB%AC%E4%BB%A8/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 通读全书后，我为杨绛先生真挚深厚的情感深深感动。字里行间没有情话，却处处透露一家三口的亲密无间，守望相助。一家三口皆为学者，偏爱读书，有时候我看着书，会联想到他们仨围坐着一张不高不低的桌子，低头认真读书，一间屋子里只有呼吸声和翻阅书籍的声音，真好。 在现实生活里，我很少见识到这般感情，也许是我还年轻，也许是我接触的人还少，像他们仨这样的相处模式我很羡慕，和最亲近的人一起做着自己最热爱的东西，不被生活琐事所破坏，当然，这也是在一定程度上的完全可接受琐事，哈哈！ “世间好物不坚牢，彩云易散琉璃脆”说的就是杨先生对这份家庭感情的万分留恋，文章结尾处杨先生写到”家在哪里，我不知道，我还在寻觅归途”，心里一酸，她在家人生病这段时期的心里得有多难受啊，几十年的陪伴，如今家人不在，我不敢去想那是怎样的心情。如果有来生，如果有机会，我想杨老先生一定还会来寻觅她的这个家。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]},{"title":"风起陇西 —— 读书笔记","slug":"读书笔记--风起陇西","date":"2019-08-10T10:09:00.000Z","updated":"2021-08-07T05:59:13.543Z","comments":true,"path":"2019/08/10/读书笔记--风起陇西/","link":"","permalink":"http://example.com/2019/08/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%A3%8E%E8%B5%B7%E9%99%87%E8%A5%BF/","excerpt":"","text":"本博客 hjy-xh，转载请申明出处 这是我第一次看谍战小说，感觉这本书当真是有意思，作者创造性地把三国志和西方悬疑小说相结合，以三国时代为背景，架空历史人物，融悬疑于史实，以个人独特的想法来进行写作。 从头到尾读下来，令我吃惊并加以欣赏，强行安利给朋友的原因是作者对于细节的把握，把人物的心理抽丝剥茧，完完全全分析透彻，虽情节有些漏洞，但也不妨碍我佩服作者的丝丝入扣。 对于书中描述的众多官僚机构，倒是让我有点烦恼，一方面是记不住，一方面却是作者功力的展现，他让我反感浓厚的官僚气氛，这一点既无奈又让我自己暗自发笑。 间谍，情报，家国情怀……是这本小说的关键词，小说的最后是各奔天涯，都有了自己的归宿，却没有人知道这片土地上发生过那些令人惊心动魄却意义非凡的事情。世事变迁，沧海桑田，时间抹掉了所有痕迹，我相信真实的历史不乏有小说中千回百转的事件，小说也未必没有写到一些在历史长河中我们应该思考的东西。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"协议","slug":"协议","permalink":"http://example.com/categories/%E5%8D%8F%E8%AE%AE/"},{"name":"解决方案","slug":"解决方案","permalink":"http://example.com/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"http://example.com/tags/Vue/"},{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"Chrome","slug":"Chrome","permalink":"http://example.com/tags/Chrome/"},{"name":"浏览器","slug":"浏览器","permalink":"http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"DNS","slug":"DNS","permalink":"http://example.com/tags/DNS/"},{"name":"CDN","slug":"CDN","permalink":"http://example.com/tags/CDN/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://example.com/tags/TypeScript/"},{"name":"TCP","slug":"TCP","permalink":"http://example.com/tags/TCP/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"思维导图","slug":"思维导图","permalink":"http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"},{"name":"网络","slug":"网络","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"性能优化","slug":"性能优化","permalink":"http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"网络攻击","slug":"网络攻击","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"},{"name":"MobX","slug":"MobX","permalink":"http://example.com/tags/MobX/"},{"name":"webpack","slug":"webpack","permalink":"http://example.com/tags/webpack/"},{"name":"Redux","slug":"Redux","permalink":"http://example.com/tags/Redux/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"文学","slug":"文学","permalink":"http://example.com/tags/%E6%96%87%E5%AD%A6/"},{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"ES6","slug":"ES6","permalink":"http://example.com/tags/ES6/"},{"name":"编程原理相关","slug":"编程原理相关","permalink":"http://example.com/tags/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86%E7%9B%B8%E5%85%B3/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://example.com/tags/NoSQL/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://example.com/tags/MongoDB/"},{"name":"关系型数据库","slug":"关系型数据库","permalink":"http://example.com/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"服务器","slug":"服务器","permalink":"http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}