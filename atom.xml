<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可乐加冰</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-31T09:17:36.455Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HJY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript中extends用法小结</title>
    <link href="http://example.com/2022/08/22/TypeScript%E4%B8%ADextends%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://example.com/2022/08/22/TypeScript%E4%B8%ADextends%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2022-08-22T14:12:31.000Z</published>
    <updated>2022-08-31T09:17:36.455Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><code>extends</code>关键字在TS中有多种用法，单独使用时，常见有以下几种情况</p><ul><li>继承/拓展</li><li>约束</li><li>条件判断</li></ul><h2 id="继承-扩展"><a href="#继承-扩展" class="headerlink" title="继承/扩展"></a>继承/扩展</h2><h4 id="单个-多个接口"><a href="#单个-多个接口" class="headerlink" title="单个/多个接口"></a>单个/多个接口</h4><p>这种用法和类的继承相似，看个🌰</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog继承Animal并扩展一个run方法</span></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="attr">run</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog: Dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;狗子&#x27;</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也支持多重继承</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Blackdog <span class="keyword">extends</span> Animal, Dog &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展类的接口"><a href="#扩展类的接口" class="headerlink" title="扩展类的接口"></a>扩展类的接口</h4><p>除了上面的常见用法，接口还可以继承类的私有成员和受保护成员，而不仅仅是公共成员</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Runnable <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: 缺少属性 state</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>一个接口可以继承/扩展一个或多个现有接口</li><li>一个接口也可以继承/扩展一个类。如果该类包含私有或受保护成员，则该接口只能由该类或其子类实现</li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>此处说的约束，一般指泛型约束，即对泛型的类型进行约束控制</p><p>在编写方法的时候，可能会需要对参数的类型做一些限制，比方说入参有一个<code>length</code>属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Error: 类型“T”上不存在属性“length”</span></span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;length: <span class="built_in">number</span>&#125;&gt;(arg: T): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>和三目表达式类似，看看官网的示例和说明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeType <span class="keyword">extends</span> OtherType ? TrueType : FalseType;</span><br></pre></td></tr></table></figure><blockquote><p>When the type on the left of the <code>extends</code> is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).</p></blockquote><p><strong>如果extends前面的类型能够赋值给extends后面的类型，那么表达式判断为真，否则为假</strong></p><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A1 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A2 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A的类型为string</span></span><br><span class="line"><span class="keyword">type</span> A = A2 <span class="keyword">extends</span> A1 ? <span class="built_in">string</span> : <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str: A = <span class="string">&#x27;this is string&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A1，A2两个接口，满足A2的接口一定可以满足A1，所以条件为真，A的类型取string</p><h4 id="结合泛型使用"><a href="#结合泛型使用" class="headerlink" title="结合泛型使用"></a>结合泛型使用</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A1 = <span class="string">&#x27;x&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> A2 = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> A3 = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>A1、A2的结果也就是常规的用法，很容易得出结果，但是A3结合了泛型，这里有一个<code>Distributive Conditional Types</code>的概念</p><blockquote><p>When conditional types act on a generic type, they become <em>distributive</em> when given a union type</p></blockquote><p><em>如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</em></p><p>以上面的A3为例，进行推导</p><p>P<T>中T是一个泛型参数。在A3的定义中，给T传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入P<T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; =&gt; P&lt;<span class="string">&#x27;x&#x27;</span>&gt; | P&lt;<span class="string">&#x27;y&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// &#x27;x&#x27;代入得到</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="comment">// &#x27;y&#x27;代入得到</span></span><br><span class="line"><span class="string">&#x27;y&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure><p>然后将每一项代入得到的结果联合起来，得到string | number</p><p>满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型</p><h4 id="特殊的never"><a href="#特殊的never" class="headerlink" title="特殊的never"></a>特殊的never</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never是所有类型的子类型</span></span><br><span class="line"><span class="keyword">type</span> A1 = <span class="built_in">never</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> A2 = P&lt;<span class="built_in">never</span>&gt; <span class="comment">// never</span></span><br></pre></td></tr></table></figure><p><strong>never被认为是空的联合类型</strong>，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以<code>P&lt;T&gt;</code>的表达式其实根本就没有执行，所以A2的定义也就类似于永远没有返回的函数一样，是never类型的</p><h4 id="防止条件判断中的分配"><a href="#防止条件判断中的分配" class="headerlink" title="防止条件判断中的分配"></a>防止条件判断中的分配</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="string">&#x27;x&#x27;</span>] ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> A1 = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> A2 = P&lt;<span class="built_in">never</span>&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>在条件判断类型的定义中，将泛型参数使用<code>[]</code>括起来，即可阻断条件判断类型的分配，此时，传入参数T的类型将被当做一个整体，不再分配</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.typescripttutorial.net/typescript-tutorial/typescript-extend-interface/">How to Extend Interfaces in TypeScript</a></li><li><a href="https://www.typescripttutorial.net/typescript-tutorial/typescript-generic-constraints/">TypeScript Generic Constraints</a></li><li><a href="https://juejin.cn/post/6998736350841143326">TS关键字extends用法总结</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">Conditional Types</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;关键字在TS中有多种用法，单独使用时，常见有以下</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的any、unknown、never如何理解</title>
    <link href="http://example.com/2022/08/15/TypeScript%E4%B8%AD%E7%9A%84any%E3%80%81unknown%E3%80%81never%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2022/08/15/TypeScript%E4%B8%AD%E7%9A%84any%E3%80%81unknown%E3%80%81never%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3/</id>
    <published>2022-08-15T13:06:41.000Z</published>
    <updated>2022-08-31T02:51:25.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>在TS中使用<code>any</code>类型，可以用来表示允许赋值给变量任意类型，这种方式与直接使用JS没有太大差别，无法享受到TS的类型检查，在可能出错的地方也不会发现错误。</p><p><code>any</code>类型本质上是类型系统的一个逃逸舱，那我们在什么情况下会使用该类型呢？</p><ul><li>无法确定当前类型时</li><li>逐步向TS迁移时</li></ul><p><strong>而在编写代码的过程中，明确知道类型的时候，有时为了偷懒，使用了<code>any</code>，这是一种不好的行为。</strong></p><p>而以下种种原因，可能都会对我们是否使用<code>any</code>有影响：</p><ul><li>添加类型时，需要编写大量代码，而<code>any</code>工作量很少</li><li>已经通过必要的运行时检查以防御性的方式编写了代码，以确保没有错误</li><li>有些参数很难正确输入，但是<code>any</code>更容易</li><li>不知道参数是什么</li><li>类型增加了很多复杂性，有时<code>any</code>更简单</li></ul><p>使用<code>any</code>还会造成类型污染的问题：即<code>any</code>类型的对象会导致后续的属性类型都会变成<code>any</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: any = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.name = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>在TS的3.0版本中，引入了<code>unknown</code>类型，它可以这样理解成：**<code>unknown</code>类型是<code>any</code>的类型安全版本。**</p><p>这意味着如果要在TS中使用<code>unknown</code>类型时，需要知道它所指的类型，也就自然地推导出使用该类型的变量前，需要对该变量的类型进行断言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">value: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// @ts-ignore: Object is of type &#x27;unknown&#x27;.</span></span><br><span class="line">  value.toFixed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type assertion:</span></span><br><span class="line">  (value <span class="keyword">as</span> number).toFixed(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缩小为更具体的类型范围，包括 typeof 运算符，instanceof 运算符和自定义类型保护函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">       value.toFixed(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unknown</code>类型只能被赋值给<code>any</code>类型和<code>unknown</code>类型本身。</p><p>因为只有能够保存任意类型值的容器才能保存<code>unknown</code> 类型的值，所以这个限制很合理。毕竟我们不知道变量中存储了什么类型的值。</p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code>类型表示的是那些永不存在的值的类型，<code>never</code>类型是任何类型的子类型，也可以赋值给任何类型。</p><p>然而，没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）,<code>never</code>用于那些永不可发生的情况:</p><ul><li>一个从来不会有返回值的函数（如：如果函数内含有 <code>while(true) &#123;&#125;</code>）；</li><li>一个总是会抛出错误的函数（如：<code>function foo() &#123; throw new Error(&#39;Not Implemented&#39;) &#125;</code>，foo 的返回类型是 never）；</li></ul><h3 id="与-void-的差异"><a href="#与-void-的差异" class="headerlink" title="与 void 的差异"></a>与 void 的差异</h3><p><code>void</code>表示没有任何类型，<code>never</code>表示永远不存在的值的类型</p><h2 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h2><ul><li><code>any</code>和<code>unknown</code>是TS中所谓的顶级类型：当把类型看作是值的集合时，any 和 unknown 是包含所有值的集合</li><li><code>never</code>类型是TS中的底层类型：空集</li></ul><h2 id="以下或许是最佳实践"><a href="#以下或许是最佳实践" class="headerlink" title="以下或许是最佳实践"></a>以下或许是最佳实践</h2><ul><li>如果不是有意忽略类型检查，不使用<code>any</code></li><li>如果要用<code>any</code>，可以考虑用<code>unknown</code>代替（进行断言后使用）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://wanago.io/2020/01/27/understanding-any-and-unknown-in-typescript-difference-between-never-and-void/">understanding-any-and-unknown-in-typescript-difference-between-never-and-void</a></p></li><li><p><a href="https://mariusschulz.com/blog/the-unknown-type-in-typescript">The unknown Type in TypeScript</a></p></li><li><p><a href="https://www.51cto.com/article/676734.html">使用 TypeScript 中的 Any 类型前，你需要了解的一切</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;any&quot;&gt;&lt;a href=&quot;#any&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>网络相关常见知识点汇总</title>
    <link href="http://example.com/2022/02/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2022/02/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</id>
    <published>2022-02-19T08:11:41.000Z</published>
    <updated>2022-02-25T06:55:39.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://www.png8.com/imgs/2022/02/7f0a206c63646d10.png" alt="网络相关常见知识点汇总.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6908327746473033741">「2021」高频前端面试题汇总之计算机网络篇</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="思维导图" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 如何实现单例模式</title>
    <link href="http://example.com/2022/01/05/JavaScript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/05/JavaScript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-05T14:56:59.000Z</published>
    <updated>2022-01-06T01:29:52.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式，也叫单子模式，是一种常用的软件设计模式，属于<code>创建型模式</code>的一种。</p><p>保证一个类<code>仅有一个实例</code>，并提供一个访问它的<code>全局访问点</code>。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>全局变量符合单例模式吗？</strong></p><p>不是。但我们经常会把变量当成单例来使用，看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>通过字面量创建对象时，对象<code>person</code>确实是独一无二的，如果该变量在全局作用域下声明，就可以在代码中的任何地方使用它。</p><p>但是全局变量存在一些问题：</p><ul><li>污染命名空间（变量名冲突）</li><li>不易维护 (被覆盖)</li></ul><p>并且随着项目的体积和功能增大，出现问题的概率也会增大。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先我们要清楚 JS 是一门<code>没有类</code>的语言，ES6 出现类也是原型的语法糖。也正因为没有类，在 JS 中实现单例模式也只需要一个<code>唯一</code>的对象，这是很自然的做法。</p><p>这里以一个登录弹窗为例，实践一下单例模式。</p><p>假设现在有一个登录按钮，点击后能够出现登录弹窗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;loginBtn&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先来写创建登录弹窗的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doCreateLoginModal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> modal = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  modal.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  modal.textContent = <span class="string">&quot;登录弹窗&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(modal);</span><br><span class="line">  <span class="keyword">return</span> modal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来就是单例模式的重点了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getInstance = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createLoginModal = getInstance(doCreateLoginModal);</span><br></pre></td></tr></table></figure><p>这里可以发现返回的结果被封装在闭包（内部的函数被保存到了外部）产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命名污染。</p><p>先看这段代码中产生的闭包：</p><p>最后一行外部的<code>createLoginModal</code>变量保存了<code>getInstance</code>中的匿名函数，该拥有<code>getInstance</code>作用域的访问权限。</p><p>再仔细看<code>return result || (result = fn.apply(this, arguments));</code>这条语句：</p><p>第一次调用方法时，<code>result</code>为<code>undefined</code>,会执行<code>result = fn.apply(this, arguments)</code>,这里利用传入的<code>fn</code>调用生成登录弹窗的方法生成登录弹窗，并被赋值给<code>result</code>，使得之后<code>createLoginModal</code>再被调用时，返回第一次创建的登录弹窗。</p><p>最后给按钮绑定点击事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loginBtn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;loginBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line">loginBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loginModal = createLoginModal();</span><br><span class="line">  loginModal.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/HJY-xh/plantTrees/blob/master/Demos/%5BJavaScript%5D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%BC%B9%E7%AA%97/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">完整代码</a></p><h2 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h2><p>惰性单例指的是在需要的时候菜创建对象实例。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式-维基百科</a></p><p>书目</p><ul><li><p>JavaScript 设计模式与开发实践</p></li><li><p>JavaScript 设计模式</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React Hook解析</title>
    <link href="http://example.com/2021/12/28/React%20Hook%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/12/28/React%20Hook%E8%A7%A3%E6%9E%90/</id>
    <published>2021-12-28T12:23:54.000Z</published>
    <updated>2022-01-25T08:34:05.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><p>带着以下问题学习：</p><ul><li>Hook解决了什么问题？</li><li>Hook有哪些优势？</li><li>为什么有Hook？</li><li>useState方括号有什么用？</li><li>为什么每次更新的时候都要运行 Effect?</li><li>useMemo 和 shouldComponentUpdate 有什么区别？</li></ul><h2 id="Hook概述"><a href="#Hook概述" class="headerlink" title="Hook概述"></a>Hook概述</h2><ul><li><p>React 16.8的新增特性</p></li><li><p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性（是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数）</p></li></ul><h2 id="Hook的动机"><a href="#Hook的动机" class="headerlink" title="Hook的动机"></a>Hook的动机</h2><ul><li>在无需修改组件结构的情况下复用状态逻辑</li></ul><p>在组件之间复用状态逻辑很难</p><p>Hook出现之前，将可复用性行为”附加“到组件的解决方案有<code>render props</code>和<code>高阶组件</code>，但是这类方案需要重新组织组件结构，可能会很麻烦，进而让代码难以理解。</p><ul><li>Hook将组件中相互关联的部分拆分成更小的函数（比如监听事件、请求数据），而并非强制按照生命周期划分</li></ul><p>组件期初很简单，但是逐渐会被状态逻辑和副作用充斥，相关关联且需要对照修改的代码被拆分（监听事件），不相关的代码在同一个方法中（<code>componentDidMount</code>、<code>componentWillUnmount</code>)组合在一起，容易产生bug。</p><ul><li>降低学习门槛</li></ul><p>对class的学习（需要理解JS中的this工作方式）</p><h2 id="Hook使用规则"><a href="#Hook使用规则" class="headerlink" title="Hook使用规则"></a>Hook使用规则</h2><ul><li><p>只能在函数最外层调用Hook。不要在循环、条件判断或者子函数中调用</p><p>  这样能够确保Hook在每一次渲染中都按照同样的顺序被调用</p></li><li><p>只能在React的函数组件中调用Hook（包括自定义的Hook）</p></li></ul><h2 id="常见的Hook"><a href="#常见的Hook" class="headerlink" title="常见的Hook"></a>常见的Hook</h2><ul><li><p>基础 Hook</p><ul><li>useState</li><li>useEffect<ul><li>说明<pre><code>  - 可以把该Hook看做是`componentDidMount`、`componentDidUpdate`、`componentWillUnmout`三个函数的组合  - React保证了每次运行effect的同时，DOM都已经更新完毕  - 与`componentDidMount`或`componentDidUpdate`不同，使用useEffect调度的effect不会阻塞浏览器更新屏幕，这让应用看起来响应更快  - effect中可选的清除机制在组件卸载的时候触发</code></pre></li><li>使用技巧<pre><code>  - 使用多个 Effect 实现关注点分离（按照代码的用途分离它们），React将按照effect声明的顺序一次调用组建的每一个effect  - 跳过 Effect 进行性能优化（第二个参数）</code></pre></li></ul></li><li>useContext<pre><code>接收一个 context 对象（`React.createContext` 的返回值）并返回该 context 的当前值</code></pre></li></ul></li><li><p>额外的 Hook</p><ul><li>useReducer<br>useState 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</li><li>useCallback<br>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</li><li>useMemo<br>可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证<br>可以使用它缓存一些相对耗时的计算，也非常适合用于存储引用类型的数据，可以传入对象字面量，匿名函数等，甚至是 React Element</li><li>useRef<br>useRef 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）</li><li>useImperativeHandle<ul><li>useImperativeHandle 可以在使用 ref 时自定义暴露给父组件的实例值</li><li>在大多数情况下，应当避免使用 ref 这样的命令式代码</li><li>useImperativeHandle 应当与 <code>forwardRef</code> 一起使用</li></ul></li><li>useLayoutEffect<br>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染</li><li>useDebugValue<br>useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签,它接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值</li></ul></li></ul><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中</p><p>字应该始终以 use 开头，这样可以一眼看出其符合 Hook 的规则</p><p>自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p>函数组件执行函数<code>renderWithHooks</code></p><ul><li>作用<br>它是调用<code>function组件</code>函数的主要函数，从源码中看，它首先会置空即将调和渲染的<code>workInProgress树</code>的<code>memoizedState</code>和<code>updateQueue</code>，把新的hooks信息挂载到这两个属性上，然后在组件<code>commit阶段</code>，将<code>workInProgress树</code>替换成<code>current树</code>，替换真实的DOM元素节点。并在current树保存hooks信息。</li><li>步骤<ul><li>执行函数组件</li><li>改变<code>ReactCurrentDispatcher</code>对象</li></ul></li></ul></li><li><p>初始化hooks</p><p>  相关hook实际执行的函数:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useState: mountState, <span class="comment">// 初始化useState</span></span><br><span class="line"><span class="attr">useEffect</span>: mountEffect, <span class="comment">// 初始化useEffect</span></span><br><span class="line"><span class="attr">useLayoutEffect</span>: mountLayoutEffect, <span class="comment">// 初始化useLayoutEffect</span></span><br><span class="line"><span class="attr">useMemo</span>: mountMemo, <span class="comment">// 初始化useMemo</span></span><br><span class="line"><span class="attr">useReducer</span>: mountReducer, <span class="comment">// 初始化useReducer</span></span><br><span class="line"><span class="attr">useRef</span>: mountRef, <span class="comment">// 初始化useRef</span></span><br><span class="line"><span class="attr">useCallback</span>: mountCallback, <span class="comment">// 初始化useCallback</span></span><br></pre></td></tr></table></figure><p>  <code>mountWorkInProgressHook</code>生成hook链表</p><ul><li>在一个函数组件第一次渲染时，每个hook执行，都会产生一个hook对象，并形成链表结构，绑定在<code>workInProgress</code>的<code>memoizedState</code>属性上</li><li>hook上的状态，绑定在当前hook对象的<code>memoizedState</code>属性上</li><li>对于effect副作用钩子，会绑定在<code>workInProgress.updateQueue</code>上，等到<code>commit阶段</code>，dom树构建完成，再执行每个 effect 副作用钩子。</li></ul></li><li><p>更新hooks</p><p>  相关hook实际执行的函数:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useState: updateState, <span class="comment">// 得到最新的state</span></span><br><span class="line"><span class="attr">useEffect</span>: updateEffect, <span class="comment">// 更新updateQueue</span></span><br><span class="line"><span class="attr">useLayoutEffect</span>: updateLayoutEffect,</span><br><span class="line"><span class="attr">useMemo</span>: updateMemo,</span><br><span class="line"><span class="attr">useReducer</span>: updateReducer,</span><br><span class="line"><span class="attr">useRef</span>: updateRef, <span class="comment">// 获取ref对象</span></span><br><span class="line"><span class="attr">useCallback</span>: updateCallback</span><br></pre></td></tr></table></figure><p>  <code>updateWorkInProgressHook</code>更新hook链表，找到对应的hooks</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">官方文档</a></p><p><a href="https://juejin.cn/post/6844904165500518414">React Hooks 最佳实践</a></p><p><a href="https://juejin.cn/post/6864438643727433741">react-hooks如何使用？</a></p><p><a href="https://juejin.cn/post/6944863057000529933#heading-0">一文吃透react-hooks原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题列表&quot;&gt;&lt;a href=&quot;#问题列表&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法</title>
    <link href="http://example.com/2021/12/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/12/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-19T02:41:09.000Z</published>
    <updated>2021-12-23T07:18:00.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="常见的排序"><a href="#常见的排序" class="headerlink" title="常见的排序"></a>常见的排序</h2><p><img src="https://s2.loli.net/2021/12/13/JeNhZmiWYlv85Ot.png"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>说明：重复遍历要排序的数列，一次比较两个元素，按排序顺序交换元素值，不断遍历直到没有再需要交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [...input];</span><br><span class="line">    <span class="keyword">const</span> length = output.length;</span><br><span class="line">    <span class="keyword">let</span> hasSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output[j] &gt; output[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = output[j];</span><br><span class="line">                output[j] = output[j + <span class="number">1</span>];</span><br><span class="line">                output[j + <span class="number">1</span>] = temp;</span><br><span class="line">                hasSwap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasSwap) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>说明：遍历数组，找到数据应该插入的位置将其插入即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [...input];</span><br><span class="line">    <span class="keyword">const</span> length = output.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = output[i];</span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; output[j] &gt; temp) &#123;</span><br><span class="line">            output[j + <span class="number">1</span>] = output[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        output[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>说明: 每一次从待排序的数据元素中选出最小（或最大）的一个元素，放到已排序数组的末尾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [...input];</span><br><span class="line">    <span class="keyword">const</span> length = output.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output[j] &lt; output[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = output[i];</span><br><span class="line">        output[i] = input[minIndex];</span><br><span class="line">        output[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>说明：归并的的核心思想是分治。它把数组从中间划分成两个数组，一直递归把子数组划分成更小的数组，知道数组中元素个数为1时进行排序。按大小顺序合并两个数组，接着按照递归的顺序返回，不断合并排好序的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> length = input.length;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> left = input.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">const</span> right = input.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>说明：它是冒泡排序的一种改进，通过元素之间的比较和交换位置来达到排序的目的。快排在每一轮挑选一个基准元素，把剩下的元素同它进行比较，大于它的放到数列的一边，小于它的放到数列的另一边，一轮比较完成后，整个序列以选取的基准元素位为界，左侧均小于基准元素，右侧均大于基准元素。但左右两侧内部并不是有序的(左右两侧关键字个数也不一定相同)。进而继续将左右两侧分别再以这种方式进行排序，直到将序列拆分的剩余一个关键字为止，整个序列即变成有序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">    <span class="keyword">const</span> left = [];</span><br><span class="line">    <span class="keyword">const</span> right = [];</span><br><span class="line">    <span class="keyword">const</span> middle = input.splice(<span class="built_in">Math</span>.round(input.length / <span class="number">2</span>), <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">        (middle &gt; input[i] ? left : right).push(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [...quickSort(left), middle, ...quickSort(right)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常见的排序&quot;&gt;&lt;a href=&quot;#常见的排序&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript思维导图</title>
    <link href="http://example.com/2021/12/09/TypeScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://example.com/2021/12/09/TypeScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2021-12-09T13:34:11.000Z</published>
    <updated>2022-01-06T01:31:21.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://s2.loli.net/2021/12/10/GpcItLvliHzMWRA.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>深入理解 TypeScript</p><p><a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a></p><p><a href="https://www.tslang.cn/index.html">https://www.tslang.cn/index.html</a></p><p><a href="https://stackoverflow.com/questions/28818849/how-do-the-different-enum-variants-work-in-typescript">https://stackoverflow.com/questions/28818849/how-do-the-different-enum-variants-work-in-typescript</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="思维导图" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>DOM基本操作思维导图</title>
    <link href="http://example.com/2021/11/16/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/11/16/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-16T13:01:11.000Z</published>
    <updated>2022-01-06T01:33:50.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><img src="https://i.loli.net/2021/11/25/pkRSm7J3saNxV2z.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/11/25/pkRS</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="思维导图" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入了解eval</title>
    <link href="http://example.com/2021/10/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3eval/"/>
    <id>http://example.com/2021/10/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3eval/</id>
    <published>2021-10-26T11:29:04.000Z</published>
    <updated>2022-01-11T07:50:24.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="相关定义和描述"><a href="#相关定义和描述" class="headerlink" title="相关定义和描述"></a>相关定义和描述</h2><p>eval 是全局对象上的一个函数，会把传入的字符串当做 JavaScript 代码执行，它通常被用来执行动态创建的代码。</p><p>语法很简单：</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">eval</span>(string) <span class="comment">// 一个表示 JavaScript 表达式、语句或一系列语句的字符串。表达式可以包含变量与已存在对象的属性。</span></span><br></pre></td></tr></table></figure></blockquote><p>举个🌰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&quot;console.log(&#x27;hello, eval&#x27;)&quot;</span>;</span><br><span class="line"><span class="built_in">window</span>.eval(string);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/25/3jKtcFlqQmuZE2G.png"></p><p>先提出问题：eval这个方法很强大，且兼容性很好，但是为什么很少使用？</p><p><img src="https://i.loli.net/2021/10/25/vr74wlehWzH6k8u.png"></p><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><h3 id="返回最后一个表达式的值"><a href="#返回最后一个表达式的值" class="headerlink" title="返回最后一个表达式的值"></a>返回最后一个表达式的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;1+1+1&#x27;</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 = <span class="string">&#x27;let x; x = 1;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">&#x27;let x, y; x = 1; y = 2;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">eval</span>(str);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(string1); <span class="comment">// 1</span></span><br><span class="line">test(string2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="函数作为字符串被定义时需要”-“和”-“作为前缀和后缀"><a href="#函数作为字符串被定义时需要”-“和”-“作为前缀和后缀" class="headerlink" title="函数作为字符串被定义时需要”(“和”)“作为前缀和后缀"></a>函数作为字符串被定义时需要”(“和”)“作为前缀和后缀</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcStr1 = <span class="string">&#x27;function test() &#123;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcStr2 = <span class="string">&#x27;(function test() &#123;&#125;)&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(funcStr1)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(funcStr2)); <span class="comment">// [Function: test]</span></span><br></pre></td></tr></table></figure><h3 id="直接调用和间接调用"><a href="#直接调用和间接调用" class="headerlink" title="直接调用和间接调用"></a>直接调用和间接调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>, y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;x + y&#x27;</span>));  <span class="comment">// 直接调用，使用本地作用域，结果是 4</span></span><br><span class="line">    <span class="keyword">const</span> geval = <span class="built_in">eval</span>; <span class="comment">// 等价于在全局作用域调用</span></span><br><span class="line">    <span class="built_in">console</span>.log(geval(<span class="string">&#x27;x + y&#x27;</span>)); <span class="comment">// 间接调用，使用全局作用域，结果是 2</span></span><br><span class="line">    <span class="built_in">console</span>.log((<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;this&#x27;</span>)); <span class="comment">// 另一个间接调用的例子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;this&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>逗号操作符：对它的每个操作数求值（从左到右），并返回最后一个操作数的值</p></blockquote><p>这里使用逗号操作符，于是返回表达式中的最后一项，然后为eval传入’this’字符串，来立即执行这个表达式，这里其实就是把全局对象给打印出来</p><h2 id="黑魔法"><a href="#黑魔法" class="headerlink" title="黑魔法"></a>黑魔法</h2><h3 id="欺骗词法作用域"><a href="#欺骗词法作用域" class="headerlink" title="欺骗词法作用域"></a>欺骗词法作用域</h3><p><strong>原理：JavaScript中的eval(str)函数可以接受一个字符串为参数，并将字符串内容视为好像在书写时就存在于eval()函数所在位置的代码。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(str); <span class="comment">// 欺骗</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&quot;var b = 3;&quot;</span>, <span class="number">1</span>); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure><p>这个例子中<code>var b = 3;</code>这条语句会被当做本来就在那里，因此foo函数内部的变量b遮蔽了外部的变量b</p><h4 id="严格模式下的表现"><a href="#严格模式下的表现" class="headerlink" title="严格模式下的表现"></a>严格模式下的表现</h4><p>在严格模式下，eval在运行时会有自己的词法作用域，意味着其中的声明无法修改所在的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span></span><br><span class="line">    <span class="built_in">eval</span>(str);</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&quot;var a = 2;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="使用时有哪些坑"><a href="#使用时有哪些坑" class="headerlink" title="使用时有哪些坑"></a>使用时有哪些坑</h2><h3 id="eval不容易调试"><a href="#eval不容易调试" class="headerlink" title="eval不容易调试"></a>eval不容易调试</h3><p>调试困难，且可读性非常差（没有行号）</p><p>用chromeDev、VSCode等工具无法打断点调试</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>JavaScript 通常被认为是一门解释型的语言，但是现代的 JavaScript 引擎不再只是解释 JavaScript，也会对其进行编译。</p><p>V8 为了提高 JS的运行性能，在运行之前会先将JS编译为本地的机器码，然后再去执行机器码（JIT）。</p><blockquote><p>现代JavaScript解释器将javascript转换为机器代码。 这意味着任何变量命名的概念都会被删除。 因此，任意一个eval的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。 另外，新内容将会通过 eval() 引进给变量， 比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。</p></blockquote><p><strong>eval破坏了JS引擎优化</strong></p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>当使用来源不可靠的第三方代码时，无法保证不碰到恶意代码</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">MDN</a></p><p><a href="https://github.com/mqyqingfeng/blog/issues/3">JavaScript深入之词法作用域和动态作用域</a></p><p><a href="http://nodejs.cn/learn/the-v8-javascript-engine">V8 JavaScript 引擎</a></p><p>《你不知道的JavaScript》 上卷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;相关定义和描述&quot;&gt;&lt;a href=&quot;#相关定义和描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="网络攻击" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redux和Mobx的异同</title>
    <link href="http://example.com/2021/10/10/Redux%E5%92%8CMobx%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>http://example.com/2021/10/10/Redux%E5%92%8CMobx%E7%9A%84%E5%BC%82%E5%90%8C/</id>
    <published>2021-10-10T11:53:01.000Z</published>
    <updated>2022-02-16T10:07:31.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="二者主要概念"><a href="#二者主要概念" class="headerlink" title="二者主要概念"></a>二者主要概念</h2><p><a href="https://hjy-xh.github.io/2021/09/13/MobX%E8%AE%B0%E5%BD%95/">MobX</a></p><p><a href="https://hjy-xh.github.io/2020/12/03/Redux%E8%AE%B0%E5%BD%95/">Redux</a></p><h2 id="函数式编程相关知识"><a href="#函数式编程相关知识" class="headerlink" title="函数式编程相关知识"></a>函数式编程相关知识</h2><p><a href="https://hjy-xh.github.io/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/">读书笔记:Javascript函数式编程指南（一）</a></p><p><a href="https://hjy-xh.github.io/2021/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/">读书笔记:Javascript函数式编程指南（二）</a></p><p><a href="https://hjy-xh.github.io/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/">读书笔记:Javascript函数式编程指南（三）</a></p><p><a href="https://hjy-xh.github.io/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/">读书笔记:Javascript函数式编程指南（四）</a></p><h2 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h2><ul><li><p>设计思想：函数式 VS 面向对象</p><p><code>Redux</code>遵循函数式编程思想，<code>MobX</code>则更多从面向对象和响应式编程的角度来考虑问题</p><p>可以从<code>Redux</code>的<code>reducer</code>中看出来，它就是一个纯函数，只依赖入参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MobX</code>将状态包装成可观察对象，一但状态对象变更，就重新渲染视图</p></li><li><p>对store管理：单一store VS 多个store</p><p><code>store</code>是应用管理数据的地方，在<code>Redux</code>中，应用的所有数据都集中在一个大的<code>store</code>中；<code>MobX</code>则通常是按照模块来将应用状态划分，在多个独立的<code>store</code>中管理</p></li><li><p>数据可变性：不可变 VS 可变</p><p><code>Redux</code>状态对象通常是不可变的，一般是在原来的状态对象基础上返回一个新的状态对象；<code>MobX</code>则可以直接使用新的值更新状态对象</p></li><li><p>整体差异</p><p><code>Redux</code>提供可以进行时间回溯的开发工具，同时因为它使用纯函数以及更少的抽象，让调试变得更加容易；<code>MobX</code>使用起来相对简单，但是其中有更多的抽象和封装，所以调试起来会更加复杂，同时结果也更难以预测</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://cn.redux.js.org/">Redux 中文官网</a></p><p><a href="https://www.redux.org.cn/">Redux 中文文档</a></p><p><a href="https://juejin.cn/post/6844903562095362056">你需要Mobx还是Redux？</a></p><p><a href="https://tech.youzan.com/mobx_vs_redux/">我为什么从Redux迁移到了Mobx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二者主要概念&quot;&gt;&lt;a href=&quot;#二者主要概念&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>MobX记录</title>
    <link href="http://example.com/2021/09/23/MobX%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/09/23/MobX%E8%AE%B0%E5%BD%95/</id>
    <published>2021-09-23T14:56:31.000Z</published>
    <updated>2022-02-16T10:07:20.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>简单、可扩展的状态管理</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>简单直接</p><ul><li>编写无模板的极简代码来精准描述意图</li></ul></li><li><p>轻松实现最优渲染</p><ul><li>所有对数据的变更和使用都会在运行时被追踪到，并构成一个截取所有状态和输出之间关系的依赖树。这样保证了那些依赖于状态的计算只有在真正需要的时候才会运行，就像React组件一样。无需使用记忆化或选择器之类容易出错的次优技巧来对组件进行手动优化。</li></ul></li><li><p>架构自由</p><ul><li>它可以让你在任意UI框架之外管理你的应用状态。这样会使你的代码低耦合、可移植和更加容易测试</li></ul></li></ul><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><ul><li>Mobx &gt;= 5 版本运行在任何<code>支持 ES6 proxy</code>的浏览器。</li><li>Mobx 4 可以运行在任何支持ES5的浏览器上，而且也讲进行持续地维护。MobX 4 和 5 的API是相同的，并且语义上也能达到相同的效果，只是Mobx 4 存在一些局限性<ul><li>Observable 数组不是真正的数组，所以它们无法通过<code>Array.isArray()</code> 的检查。最常见的处理方法是在传递给第三方库之前，你经常需要先对其进行<code>.slice()</code>操作，从而得到一个浅拷贝的真正数组</li><li>向一个已存在的 observable 对象中添加属性不会被自动捕获。要么使用 observable 映射来替代，要么使用工具函数中方法来对想要动态添加属性的对象进行读/写/迭代</li></ul></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>State(状态)</li></ul><p>状态是驱动应用的数据。</p><p>可以用任何数据结构来存储状态，如JS基本数据类型、引用类型、普通对象、类实例、数组和映射</p><p>通常有像待办事项列表数据这样的<code>领域特定状态</code>，还有像当前已选元素的<code>视图状态</code>（状态就像是有数据的excel表格）</p><ul><li>Action(动作)</li></ul><p>Action(动作)是任意可以改变State(状态)的代码,比如用户事件处理、后端推送数据处理、调度器事件处理等</p><p>使用Action可以更好地组织代码，并防止在无意中修改State</p><p>如果是在严格模式下使用 MobX的话，MobX 会强制只有在动作之中才可以修改状态</p><ul><li>Derivations(派生)</li></ul><p>任何来源是State并且不需要进一步交互的东西都是Derivation<br> 多种形式：</p><ul><li>用户界面</li><li>派生数据，比如剩下的待办事项的数量</li><li>后端集成，比如把变化发送到服务器端<br>两种类型：</li><li>Computed values（计算值） 它们是永远可以使用纯函数从当前可观察状态中衍生出的值</li><li>Reactions（反应）他们是当状态改变时需要自动发生的副作用 (命令式编程和响应式编程之间的桥梁，或者说得更明确一些，它们最终都需要实现I / O 操作)</li></ul><p>黄金法则：如果想创建一个基于当前状态的值时，使用<code>computed</code></p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>MobX使用单向数据流，利用Action改变State，进而更新所有受影响的View</p><p><img src="https://zh.mobx.js.org/assets/action-state-view.png"></p><ul><li>所有的Derivations将在State改变时自动且原子化的更新，引测不可能观察中间值</li><li>所有的Derivations默认将会同步更新，这意味着Action可以在State改变之后安全的直接获取computed值</li><li>Computed value的更新是惰性的，任何Computed value在需要它们的副作用发生之前都是不激活的</li><li>所有的Computed value都应该是纯函数，它们不应该修改State</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>MobX使用<code>Object.defineProperty</code>来拦截对数据的访问，一旦值发生变化，就会调用<code>React</code>的<code>render</code>方法重新渲染视图或者触发<code>autorun</code></p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><p>Autorun</p><ul><li>用法：autorun(effect: (reaction) =&gt; void)</li><li>说明：autorun 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。 当你自己创建 autorun 时，它也会运行一次</li></ul></li><li><p>Reaction</p><ul><li>用法：<ul><li>5：reaction(() =&gt; data, (data, reaction) =&gt; { sideEffect }, options?)</li><li>6：reaction(() =&gt; value, (value, previousValue, reaction) =&gt; { sideEffect }, options?)</li></ul></li><li>说明：<ul><li>reaction 类似于 autorun，但可以让你更加精细地控制要跟踪的可观察对象。 它接受两个函数作为参数：第一个，data 函数，其是被跟踪的函数并且其返回值将会作为第二个函数，effect 函数，的输入。 重要的是要注意，副作用只会对 data 函数中被访问过的数据做出反应，这些数据可能少于 effect 函数中实际使用的数据</li><li>一般的模式是在 data 函数中返回你在副作用中需要的所有数据， 并以这种方式更精确地控制副作用触发的时机。 与 autorun 不同，副作用在初始化时不会自动运行，而只会在 data 表达式首次返回新值之后运行</li></ul></li></ul></li><li><p>When</p><ul><li>用法：<ul><li>when(predicate: () =&gt; boolean, effect?: () =&gt; void, options?)</li><li>when(predicate: () =&gt; boolean, options?): Promise</li></ul></li><li>说明：when 会观察并运行给定的 predicate 函数，直到其返回 true。 一旦 predicate 返回了 true，给定的 effect 函数就会执行并且自动执行器函数将会被清理掉。</li></ul></li></ul><h2 id="集成React"><a href="#集成React" class="headerlink" title="集成React"></a>集成React</h2><p>MobX 可以独立于 React 运行, 但是他们通常是结合在一起使用</p><p>常用的两个包：</p><ul><li>mobx-react</li><li>mobx-react-lite</li></ul><p><code>mobx-react</code>中引用了<code>mobx-react-lite</code>包，它提供了很多在新项目中不再需要的特性，其中有：</p><ul><li>对于React class components的支持</li><li>Provider 和 inject ，MobX的这些东西在有React.createContext替代后变得不必要了</li><li>特殊的观察对象 propTypes</li></ul><p>要注意 mobx-react 是全量包，也会暴露 mobx-react-lite包中的任何方法,其中包含对函数组件的支持。 如果你使用 mobx-react，那就不要添加 mobx-react-lite 的依赖和引用了</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>区分<code>computed</code>和<code>auturun</code><br>如果想响应式的产生一个可以被其它observer使用的值，使用<code>@compouted</code>;如果想要达到一个效果，使用<code>autorun</code>（打印日志，发起网络请求等这样命令式的副作用）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.mobx.js.org/">MobX 中文文档</a></p><p><a href="https://mobx.js.org/README.html">MobX</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="MobX" scheme="http://example.com/tags/MobX/"/>
    
  </entry>
  
  <entry>
    <title>React中Fiber的简单实现</title>
    <link href="http://example.com/2021/09/11/React%E4%B8%ADFiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/09/11/React%E4%B8%ADFiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-11T15:14:54.000Z</published>
    <updated>2022-02-21T07:04:30.815Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><a href="https://github.com/HJY-xh/frame-course/blob/master/React/Fiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/Fiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.md">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HJY-xh/frame-cou</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>类数组转换成数组的几种方式</title>
    <link href="http://example.com/2021/08/25/%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2021/08/25/%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2021-08-25T13:44:29.000Z</published>
    <updated>2022-02-21T07:00:45.191Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><ul><li>Array.prototype.slice.call()</li><li>Array.from()</li><li>拓展运算符</li></ul><h2 id="Array-prototype-slice-call"><a href="#Array-prototype-slice-call" class="headerlink" title="Array.prototype.slice.call()"></a>Array.prototype.slice.call()</h2><p>这种方法是借用了数组原型中的<code>slice</code>方法，返回一个数组</p><p><code>slice()</code>返回一个新的数组对象，这一对象是一个由<code>begin</code>和<code>end</code>决定的原数组的浅拷贝（包括 begin，不包括end），且原始数组不会被改变，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.slice([begin[, end]])</span><br></pre></td></tr></table></figure><p>这里看看<code>slice()</code>方法的内部实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice = <span class="function"><span class="keyword">function</span> (<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    start = start || <span class="number">0</span>;</span><br><span class="line">    end = end || <span class="built_in">this</span>.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        result.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p><code>Array.from()</code>方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure><ul><li>arrayLike<br>  想要转换成数组的伪数组对象或可迭代对象</li><li>mapFn 可选<br>  如果指定了该参数，新数组中的每个元素会执行该回调函数。</li><li>thisArg 可选<br>  可选参数，执行回调函数 mapFn 时 this 对象。</li></ul><h2 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h2><p>ES6中的扩展运算符…也能将某些数据结构转换成数组，这种数据结构必须有遍历器接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = [...arguments];</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>MDN</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化的前世今生</title>
    <link href="http://example.com/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://example.com/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2021-08-19T12:23:54.000Z</published>
    <updated>2022-01-06T01:28:03.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>近年来 Web 应用变得更加复杂与庞大，Web 前端技术的应用范围也更加广泛。通过直接编写 JavaScript、CSS、HTML 开发 Web 应用的方式已经无法应对当前 Web 应用的发展。</p><p>站在巨人的肩膀往回看，好在 JavaScript 模块化出现，解决了前端痛点，并且推动前端工程化。</p><h2 id="那什么是模块化呢？-为什么需要它呢？"><a href="#那什么是模块化呢？-为什么需要它呢？" class="headerlink" title="那什么是模块化呢？ 为什么需要它呢？"></a>那什么是模块化呢？ 为什么需要它呢？</h2><p>模块化可以理解成是将一个复杂的系统分解为多个模块以方便组织和编码。</p><p>很久以前，网页开发要通过命名空间的方式来组织代码。像 jQuery 就是将他的 API 都放在 <code>window.$</code> 下，在加载完 jQuery 后，其它模块再通过 <code>window.$</code> 去使用。</p><p>那这么做会有一些问题，其中包括：</p><ul><li>命名空间冲突</li><li>无法合理地管理项目地依赖和版本</li><li>无法方便地控制依赖的加载顺序</li></ul><p>可以预见，当项目越大，维护成本也越高，因此用模块化的思想来组织代码。</p><p>回顾前端模块化的前世今生，按时间先后可以总结为以下几个过程</p><ul><li>刀耕火种时代</li><li>CommonJS 模块规范及在 Node.js 里的实现</li><li>AMD 异步模块定义</li><li>ESM ECMAScript 模块系统</li></ul><h2 id="刀耕火种时代"><a href="#刀耕火种时代" class="headerlink" title="刀耕火种时代"></a>刀耕火种时代</h2><p>我们都知道 HTML 的 <code>&lt;script&gt;</code> 元素用于嵌入或引用可执行脚本。</p><p>在互联网早期，Web1.0 时代，页面比较简单，大多时候只是展示内容，使用内嵌的方式或者引用单个 JavaScript 文件就可以满足业务需求。</p><p>当功能变得复杂时，单个 JavaScript 文件代码量也变多，此时可以将 JavaScript 分为多个文件，但需要处理好各个 <code>&lt;script&gt;</code> 标签的书写顺序。</p><p>这个时期针对 JavaScript 源码的组织，谈不上模块化。即便采用了文件拼接（concat）这样的处理技术，其先后顺序也需要人工维护。</p><h2 id="CommonJS-模块规范及在-Node-js-里的实现"><a href="#CommonJS-模块规范及在-Node-js-里的实现" class="headerlink" title="CommonJS 模块规范及在 Node.js 里的实现"></a>CommonJS 模块规范及在 Node.js 里的实现</h2><p>这是一种被广泛使用的 JavaScript 模块化规范，其核心思想是通过<code>require</code>方法来<strong>同步加载</strong>依赖的其他模块，通过<code>module.export</code>导出需要暴露的接口。</p><p>它的流行得益于 Node.js 采用了这种方法。</p><p>它的优点在于：</p><ul><li>代码可复用于 Node.js 环境下并运行</li><li>有很多遵循此规范的 Npm 包</li></ul><p>它的缺点在于：</p><ul><li>代码无法直接运行在浏览器环境下，需要通过工具转换成标准的 ES5</li></ul><p>CommonJS 还可以细分为 CommonJS1 和 CommonJS2，区别在于 CommonJS1 只能通过<code>export.xx = xx</code>的方式导出，而 CommonJS2 在 CommonJS1 的基础上加入了<code>module.export = xx</code>的导出方式。CommonJS 通常指 CommonJS2。</p><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><p>Node.js 在解析与执行每个模块之前，会先加上一层包装，类似于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模块代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以，模块作用域实际上是一个函数作用域；而 <code>__dirname</code>、<code>__filename</code>、<code>require</code>、<code>module</code> 等模块常量/变量都是外部传入的参数。</p><h2 id="AMD-异步模块定义"><a href="#AMD-异步模块定义" class="headerlink" title="AMD 异步模块定义"></a>AMD 异步模块定义</h2><p>AMD（Asynchronous Module Definition）即异步模块定义。AMD 规范中，各个依赖可以异步加载而不影响正常逻辑，非常适用于浏览器环境。AMD 规范的核心 API 只有一个简单的 <code>define()</code>函数。</p><p>AMD 模块系统的经典实现库是 require.js。</p><p>例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(id?: <span class="built_in">String</span>, dependencies?: <span class="built_in">String</span>[], <span class="attr">factory</span>: <span class="built_in">Function</span>|<span class="built_in">Object</span>);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><code>id</code> 是模块的名字，它是可选的参数。</p><p><code>dependencies</code> 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 <code>factory</code> 中。如果没有指定 <code>dependencies</code>，那么它的默认值是 <code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code>。</p><p><code>factory</code> 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p><p>AMD 规范平时用得很少，这里举一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;myModule&quot;</span>, [<span class="string">&quot;jquery&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $ 是 jquery 模块的输出</span></span><br><span class="line">  $(<span class="string">&quot;body&quot;</span>).text(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;myModule&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>这里我们再来看看它的优点：</p><ul><li>可在不转换代码的情况下直接在浏览器中运行</li><li>可异步加载依赖</li><li>可并行加载多个依赖</li><li>代码可运行在浏览器环境和 Node.js 环境下</li></ul><p>AMD 的缺点在于 JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。</p><h2 id="ESM-ECMAScript-模块系统"><a href="#ESM-ECMAScript-模块系统" class="headerlink" title="ESM ECMAScript 模块系统"></a>ESM ECMAScript 模块系统</h2><p>前面所提到的所有模块化解决方案，都是利用 JavaScript 语言本身的特性，实现的封装。而鉴于模块系统的重要性、必要性，TC39 委员会也对其标准化极为上心。2015 年推出的 ECMAScript 6 标准正式定义了 JavaScript 的模块系统。</p><p>需要记住的是：</p><ul><li>它在语言层面上实现了模块化。</li><li>浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS、AMD 规范，成为浏览器和服务器通用的模块解决方法</li></ul><p>它的工作原理是模块文件只加载、执行一次。</p><p>虽然 ES6 模块是终极模块化方案，但它目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;近年来 Web 应用变得更加复杂与庞大，Web 前端技术的应用范围也更加广泛。通过直接编</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack笔记</title>
    <link href="http://example.com/2021/08/05/webpack%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/05/webpack%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-05T13:09:33.000Z</published>
    <updated>2022-01-10T07:59:19.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><ul><li>webpack是用来解决什么问题的 ？</li><li>它有什么亮点 ？</li><li>loader 和 plugin 有什么区别 ？</li><li>运行原理 ？</li><li>如何编写 Loader?</li><li>Webpack 和 Rollup 有什么相同点与不同点？</li></ul><h2 id="webpack-作用"><a href="#webpack-作用" class="headerlink" title="webpack 作用"></a>webpack 作用</h2><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><p>根据官网的高度概述，我们可以简单理解<code>webpack</code>是一个针对<code>JavaScript</code>项目的打包工具。</p><p><img src="https://s2.loli.net/2022/01/06/M17foghaR2QwBbv.png"></p><p>简单浏览一遍官方文档，再看看上面这张图，就会发现<code>webpack</code>的关键点在于<code>模块处理</code>和<code>打包</code>,在webpack构建的流程中，通过<code>loader</code>处理非 JS 文件，将其转换为 webpack 能够处理的有效模块，使用各式各样的<code>plugin</code>在构建时的关键步骤进行一些操作（比如按需加载，代码压缩等），最终输出浏览器能使用的静态资源。</p><h3 id="这里思考一下为什么需要模块化呢？"><a href="#这里思考一下为什么需要模块化呢？" class="headerlink" title="这里思考一下为什么需要模块化呢？"></a>这里思考一下为什么需要模块化呢？</h3><p><a href="https://hjy-xh.github.io/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">答案</a></p><h3 id="那怎么理解模块化呢？"><a href="#那怎么理解模块化呢？" class="headerlink" title="那怎么理解模块化呢？"></a>那怎么理解模块化呢？</h3><p>在<code>webpack</code>中，核心思想就是一切皆模块，比如说一张图片，一个SCSS文件。</p><p>这样做的好处就是能够清晰地描述出各个模块之间依赖关系，便于<code>webpack</code>对模块进行组合、打包。</p><h2 id="为什么是-webpack"><a href="#为什么是-webpack" class="headerlink" title="为什么是 webpack"></a>为什么是 webpack</h2><p>这些年前框框架、工具非常多，那为什么<code>webpack</code>更受青睐呢？</p><h3 id="这里来分析一下其它的工具"><a href="#这里来分析一下其它的工具" class="headerlink" title="这里来分析一下其它的工具"></a>这里来分析一下其它的工具</h3><ul><li><p>基于任务执行的工具</p><p>  比如说：<a href="https://www.gulpjs.com.cn/">gulp</a>、<a href="https://www.gruntjs.net/">grunt</a></p><p>  <strong>这些工具能够自动执行指定的任务。</strong>它们简单高效，社区活跃，有着丰富的插件，可以方便打造各种工作流。</p></li><li><p>基于模块化打包的工具</p><p>  比如说：<a href="https://browserify.org/">browserify</a>、<a href="https://www.webpackjs.com/">webpack</a>、<a href="https://www.rollupjs.com/">rollup</a></p><p>  在 Node 环境下，如果需要引用组件，使用<code>require</code>关键字即可，这类工具就是这个模式，还可以实现按需加载、异步加载模块</p></li><li><p>整合型工具</p><p>  比如说：<a href="https://fis.baidu.com/">FIS3</a>、<a href="https://elemefe.github.io/cooking/">cooking</a></p><p>  这类工具使用了多种技术栈实现的脚手架工具，好处是即开即用，缺点就是它们约束了技术选型，并且学习成本相对较高。</p></li></ul><h3 id="为什么选用-webpack"><a href="#为什么选用-webpack" class="headerlink" title="为什么选用 webpack"></a>为什么选用 webpack</h3><ul><li>大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，<code>webpack</code>可以为这些新项目提供一站式的解决方案</li><li><code>webpack</code> 有良好的生态链和维护团队，能提供良好的开发体验和保证质量</li><li><code>webpack</code> 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>entry: 入口<br>  <code>webpack</code>执行构建的第一步就从入口开始，可以抽象理解为输入</li><li>module: 模块<br>  在<code>webpack</code>中一切皆模块，一个文件就是一个模块，<code>webpack</code>会从入口开始递归遍历找出所有依赖的模块</li><li>chunk: 代码块<br>  一个<code>Chunk</code>由多个模块组合而成，它是代码合并、分割的产物</li><li>loader: 模块转换器<br>  <code>webpack</code>使用它把原内容转换成浏览器能够使用的文件</li><li>plugin: 插件拓展<br>  <code>webpack</code>在构建流程中的特定时机注入扩展逻辑来改变构建结果</li><li>output: 输出结果<br>  <code>webpack</code>经过一系列处理后，输出的最终结果</li></ul><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p><code>webpack</code> 只能理解<code>JavaScript</code>和<code>JSON</code>文件，这是<code>webpack</code>开箱可用的自带能力。</p><p><code>loader</code>让<code>webpack</code>能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>处理文件时可以使用多个<code>loader</code>,<code>loader</code>的执行顺序和配置中的顺序是相反的。也就是说最后一个<code>loader</code>先执行，它接收源文件作为参数，处理之后把处理结果传给下一个<code>loader</code></p><h3 id="常用的-loader"><a href="#常用的-loader" class="headerlink" title="常用的 loader"></a>常用的 loader</h3><ul><li>css-loader<br>  加载<code>CSS</code>、支持模块化、压缩、文件导入等特性</li><li>style-loader<br>  把<code>CSS</code>代码注入到<code>JavaScript</code>中，通过<code>DOM</code>操作去加载<code>CSS</code></li><li>file-loader<br>  把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件</li><li>url-loader<br>  它和 filr-loader 类似，但是能在文件很小的情况下以<code>base64</code>的方式把文件内容注入到代码中</li><li>babel-loader<br>  让开发者能够在项目中使用新的<code>JavaScript</code>特性</li></ul><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>插件是<code>webpack</code>的<strong>支柱</strong>功能。</p><p>插件目的在于解决<code>loader</code>无法实现的其他事。</p><p><code>webpack</code>自身也是构建于插件系统之上。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在<code>webpack</code>运行的生命周期中会广播出许多事件，插件可以监听这些事件，在合适的时机通过<code>webpack</code>提供的API改变输出结果，在这个过程中插件可以访问到<code>compile</code>和<code>compilation</code>，通过钩子拦截<code>webpack</code>的执行。</p><h3 id="常用的-plugin"><a href="#常用的-plugin" class="headerlink" title="常用的 plugin"></a>常用的 plugin</h3><ul><li>clean-webpack-plugin<br>  每次打包后自动清理<code>output.path</code>内的文件，只保留本次构建的结果</li><li>html-webpack-plugin<br>  创建一个<code>html</code>文件，并把<code>webpack</code>打包后的静态文件自动插入到这个<code>html</code>文件当中</li><li>DefinePlugin<br>  这是一个定义全局变量的插件,定义的变量可以在<code>webpack</code>打包范围内任意<code>JavaScript</code>环境内访问</li><li>MiniCssExtractPlugin<br>  将<code>CSS</code>单独打包成一个文件，它为每个包含<code>CSS</code>和<code>JavaScript</code>文件都创建一个<code>CSS</code>文件，结合<code>html-webpack-plugin</code>插件，以<code>link</code>的形式插入到<code>html</code>文档中</li><li>babel-loader<br>  让开发者能够在项目中使用新的<code>JavaScript</code>特性</li><li>webpack-merge<br>  该插件用于合并配置</li><li>webpack-bundle-analyzer<br>  项目打包后进行性能分析</li></ul><h2 id="构建流程和原理"><a href="#构建流程和原理" class="headerlink" title="构建流程和原理"></a>构建流程和原理</h2><p>构建之前先了解几个名词：</p><ul><li>Compiler：编译管理器，<code>webpack</code>启动后会创建<code>compiler</code>对象，该对象一直存活直到结束退出</li><li>Complilation：单次编译过程的管理器，比如<code>watch=true</code>时，运行过程中只有一个<code>compiler</code>，但每次文件变更触发重新编译时，都会创建一个新的<code>compilation</code>对象</li><li>Dependence：依赖对象，<code>webpack</code>基于该类型记录模块间依赖关系</li><li>Module：<code>webpack</code>内部所有资源都会以<code>module</code>对象形式存在，所有关于资源的操作、转译、合并都是以<code>module</code>为基本单位进行的</li><li>Chunk：编译完成准备输出时，<code>webpack</code>会将<code>module</code>按特定的规则组织成一个一个的<code>chunk</code>，这些<code>chunk</code>某种程度上跟最终输出一一对应</li></ul><p>构建流程：</p><ul><li><p>初始化阶段</p><ul><li>初始化参数：从配置文件、配置对象、Shell参数中读取，进行错误检查，与默认配置结合得出最终的参数</li><li>创建编译器对象：用上一步得到的参数创建<code>Compiler</code>对象</li><li>初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化RuleSet集合、加载配置的插件等</li><li>开始编译：执行<code>compiler</code>对象的<code>run</code>方法</li><li>确定入口：根据配置中的<code>entry</code>找出所有的入口文件，调用<code>compilition.addEntry</code>将入口文件转换为<code>dependence</code>对象</li></ul></li><li><p>构建阶段</p><ul><li>编译模块：根据<code>entry</code>对应的<code>dependence</code>创建<code>module</code>对象，调用<code>loader</code>将模块转移为标准JS内容，调用JS解释器将内容转换为AST对象，从中找出该模块依赖的模块，再递归这个步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的<code>依赖关系图</code></li></ul></li><li><p>生成阶段</p><ul><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的<code>Chunk</code>，再把每个<code>Chunk</code>转换成一个单独的文件加入到输出列表。这个步骤是可以修改输出内容的最后机会</li><li>写入文件系统：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul></li></ul><p>源码中的一些重要方法：</p><ul><li><strong>webpack_require</strong>: 我们在模块化开发的时候，通常会使用ES Module或者CommonJS规范导入导出以来的模块，webpack在打包的时候，会统一替换成自己的__webpack_require__来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性</li><li>__webpack_modules__：存放了编译后的各个文件模块的JS内容</li><li>__webpack_module_cache__：用来做模块缓存</li></ul><h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><p><code>webpack</code>配置虽然简单，但是配置项非常多，每个配置项的取值可能也有很多的选择，故而优化的空间很大。</p><p>讲一些平常用的多的配置优化：</p><ul><li><p>使用<code>webpack-bundle-analyzer</code>插件</p><p>  可以看到项目各模块大小，进行按需优化</p><p>  stat表示文件的输入大小，parsed表示文件的输出大小，gzip表示通过gzip压缩运行解析的包/模块大小</p></li><li><p>使用<code>tree shaking</code>擦除无用代码</p><p>  移除<code>JavaScript</code>上下文中的未引用代码</p></li><li><p>开启<code>scope hosting</code>减少函数申明和内存开销</p><p>  这个名词直译过来就是作用域提升，它把所有的代码按照引用顺序放在一个函数作用域里面，适当的重命名变量防止冲突</p></li><li><p>使用<code>splitChunksPlugin</code>分离页面公共文件，抽取公共代码</p></li><li><p>使用多进程多实例解析资源</p></li><li><p>使用<code>DLLPlugin</code>对基础依赖库进行分包，减少编译次数</p><p>  DllPlugin动态链接库插件，其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。</p></li></ul><p>总结来看，可以使用大量插件对编译过程进行优化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.webpackjs.com/concepts/">官网</a></p><p><a href="https://juejin.cn/post/6943468761575849992">当面试官问Webpack的时候他想知道什么</a></p><p><a href="https://juejin.cn/post/6949040393165996040">一文吃透 Webpack 核心原理</a></p><p><a href="https://tsejx.github.io/webpack-guidebook/basic/build-tool/">构建工具</a></p><p>书目：</p><ul><li>深入浅出 Webpack</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题列表&quot;&gt;&lt;a href=&quot;#问题列表&quot; class=&quot;headerlink&quot; title=&quot;问题列表&quot;&gt;&lt;/a&gt;问题列表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;webpack是用来解决什么问题的 ？&lt;/li&gt;
&lt;li&gt;它有什么亮点 ？&lt;/li&gt;
&lt;li&gt;loader 和 </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="webpack" scheme="http://example.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>React中render的实现</title>
    <link href="http://example.com/2021/07/19/React%E4%B8%ADrender%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/07/19/React%E4%B8%ADrender%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-19T14:03:04.000Z</published>
    <updated>2022-02-21T07:06:17.619Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><a href="https://github.com/HJY-xh/frame-course/blob/master/React/render%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/render%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.md">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HJY-xh/frame-cou</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的作用域</title>
    <link href="http://example.com/2021/06/11/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/06/11/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-06-11T11:16:33.000Z</published>
    <updated>2022-01-06T01:30:53.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="作用域的定义"><a href="#作用域的定义" class="headerlink" title="作用域的定义"></a>作用域的定义</h2><blockquote><p>当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。如果一个变量或者其他表达式不 “在当前的作用域中”，那么它就是不可用的。作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。</p></blockquote><p>从上面的定义出发，可以简单概括为：作用域决定了变量与函数的可访问范围，即<code>作用域控制着变量与函数的可见性和生命周期</code>。</p><h2 id="作用域分类"><a href="#作用域分类" class="headerlink" title="作用域分类"></a>作用域分类</h2><p>作用域分为两种</p><ul><li>全局作用域</li><li>函数作用域</li></ul><h3 id="全局作用域特性"><a href="#全局作用域特性" class="headerlink" title="全局作用域特性"></a>全局作用域特性</h3><ul><li>全局作用域在当 JavaScript 开始要解释执行代码的时候被创建，整个程序结束的时候被销毁</li><li>全局对象在不同的宿主环境下是不同的，在浏览器环境下，全局对象即为<code>window</code>，代表一个浏览器窗口，由浏览器创建，可以直接调用</li><li>全局作用域中声明的变量和函数会作为<code>window</code>对象的属性和方法保存，作用域为全局，在任何地方都能访问到</li></ul><h3 id="局部作用域特性"><a href="#局部作用域特性" class="headerlink" title="局部作用域特性"></a>局部作用域特性</h3><ul><li>调用函数时，函数作用域被创建，函数执行完毕，其作用域被销毁</li><li>每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的</li><li>在函数作用域中可以访问到全局作用域的变量，在函数外无法直接访问到函数作用域内的变量</li><li>在函数作用域中访问变量，会现在自身作用域中查找，如果没有找到，则回到函数的上一级作用域中查找，一直到全局作用域</li></ul><h2 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>总结：Javascript 引擎会沿着作用域链(Scope Chain) 寻找需要的变量。</p><h2 id="作用域的深层次理解"><a href="#作用域的深层次理解" class="headerlink" title="作用域的深层次理解"></a>作用域的深层次理解</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p><ul><li>在执行函数前，会创建一个执行上下文的内部对象 AO（作用域）</li><li>这个内部对象时预编译时被创建出来的，在函数被调用时，会先进行预编译</li><li>在全局代码执行前会创建一个执行上下文的对象 GO</li></ul><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><h3 id="函数作用域预编译"><a href="#函数作用域预编译" class="headerlink" title="函数作用域预编译"></a>函数作用域预编译</h3><ul><li>创建 AO 对象</li><li>找形参和变量声明，将函数内的变量和形参名作为 AO 对象的属性名，值为 undefined</li><li>将实参和形参相统一</li><li>在函数体中找函数声明，值赋予函数体</li></ul><h3 id="全局作用域预编译"><a href="#全局作用域预编译" class="headerlink" title="全局作用域预编译"></a>全局作用域预编译</h3><ul><li>创建 GO 对象</li><li>找变量声明，将变量名作为 GO 对象的属性名，值为 undefined</li><li>找函数声明，值值赋予函数体</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Scope">Scope（作用域）</a></p><p><a href="https://medium.com/itsems-frontend/javascript-scope-and-scope-chain-ca17a1068c96">Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/3">JavaScript 深入之词法作用域和动态作用域</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;作用域的定义&quot;&gt;&lt;a href=&quot;#作用域的定义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>reduce实现map、forEach、filter方法</title>
    <link href="http://example.com/2021/05/25/reduce%E5%AE%9E%E7%8E%B0map%E3%80%81forEach%E3%80%81filter%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/05/25/reduce%E5%AE%9E%E7%8E%B0map%E3%80%81forEach%E3%80%81filter%E6%96%B9%E6%B3%95/</id>
    <published>2021-05-25T11:56:01.000Z</published>
    <updated>2022-02-21T07:02:11.044Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="reduce如何工作"><a href="#reduce如何工作" class="headerlink" title="reduce如何工作"></a>reduce如何工作</h2><p><code>reduce()</code>方法对于数组中的每个元素执行一个用户提供的reducer函数（升序执行），将其结果汇总为单个返回值，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure><p>reducer 函数接收4个参数:</p><ul><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ul><p>看个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 + 1 + 2 + 3</span></span><br><span class="line"><span class="keyword">const</span> initialValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> sum = source.reduce(</span><br><span class="line">  <span class="function">(<span class="params">previousValue, currentValue</span>) =&gt;</span> previousValue + currentValue,</span><br><span class="line">  initialValue</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>reduce()</code>方法就是对传入的数组累计执行回调函数，并返回最终计算结果</p><h2 id="实现map"><a href="#实现map" class="headerlink" title="实现map"></a>实现map</h2><p><code>map()</code>的定义：创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._map = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callbackThis</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 最终返回的新数组</span></span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="comment">// 重新定义this</span></span><br><span class="line">    <span class="keyword">let</span> cbThis = callbackThis || <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">before, after, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">        result.push(fn.call(cbThis, array[index], index, array))</span><br><span class="line">    &#125;, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> res = arr._map(<span class="function">(<span class="params">current</span>) =&gt;</span> current * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h2 id="实现forEach"><a href="#实现forEach" class="headerlink" title="实现forEach"></a>实现forEach</h2><p><code>forEach()</code>的定义：对数组的每个元素执行一次给定的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._forEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callbackThis</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 重新定义this</span></span><br><span class="line">    <span class="keyword">let</span> cbThis = callbackThis || <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">before, after, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">        fn.call(cbThis, array[index], index, array);</span><br><span class="line">    &#125;, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> res = arr._forEach(<span class="function">(<span class="params">current</span>) =&gt;</span> <span class="built_in">console</span>.log(current * <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="实现filter"><a href="#实现filter" class="headerlink" title="实现filter"></a>实现filter</h2><p><code>filter()</code>的定义：创建一个新数组, 其包含通过所提供函数实现的测试的所有元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype._filter = <span class="function"><span class="keyword">function</span> (<span class="params">fn, callbackThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="comment">// 重新定义this</span></span><br><span class="line">    <span class="keyword">let</span> cbThis = callbackThis || <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">before, after, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">        fn.call(cbThis, array[index], index, array) ? result.push(array[index]) : <span class="literal">null</span>;</span><br><span class="line">    &#125;, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> res = arr._filter(<span class="function">(<span class="params">current</span>) =&gt;</span> current === <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// [ 2 ]</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>MDN</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;reduce如何工作&quot;&gt;&lt;a href=&quot;#reduce如何工作&quot; class</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（四）</title>
    <link href="http://example.com/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-04-16T02:13:29.000Z</published>
    <updated>2022-01-11T07:51:22.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h1 id="四-函数式编程——针对复杂应用的设计模式"><a href="#四-函数式编程——针对复杂应用的设计模式" class="headerlink" title="四.函数式编程——针对复杂应用的设计模式"></a>四.函数式编程——针对复杂应用的设计模式</h1><p>（读书笔记：JavaScript函数式编程指南）</p><p>今日分享</p><ul><li>命令式错误处理异常方式的问题</li><li>使用容器，以防访问无效数据</li><li>用 Functor 的实现来做数据转换</li></ul><blockquote><p>空引用是一个价值数十亿美元的错误。<br>——Tony Hoare，InfoQ</p></blockquote><h2 id="命令式错误处理的不足"><a href="#命令式错误处理的不足" class="headerlink" title="命令式错误处理的不足"></a>命令式错误处理的不足</h2><p>在许多情况下都会发生 JavaScript 错误，特别是在与服务器通信时，或是在试图访问一个为 null 对象的属性时。</p><p>因此，开发者在编程时总是需要做好最坏的打算。在命令式编程世界中，异常是通过 try-catch 处理的。</p><h3 id="用-try-catch-处理错误"><a href="#用-try-catch-处理错误" class="headerlink" title="用 try-catch 处理错误"></a>用 try-catch 处理错误</h3><p>JavaScript 的异常处理机制通常会以大多数现代语言都有的 try-catch 语句来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ERROR&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以该语句包裹住你认为不太安全的代码，一旦有异常发生，JavaScript 会立即终止程序，并创建导致该问题的指令的函数调用堆栈跟踪。有关错误的具体细节，如消息、行号和文件名，被填充到 Error 类型的对象中，并传递到 catch 块中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> student = findStudentById(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ERROR&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 try-catch 后的代码将不能组合或连在一起，对于函数式编程来说，这将会严重影响代码设计。</p><h3 id="函数式程序不应抛出异常"><a href="#函数式程序不应抛出异常" class="headerlink" title="函数式程序不应抛出异常"></a>函数式程序不应抛出异常</h3><p>命令式的 JavaScript 代码结构有很多缺陷，而且也会与函数式的设计有兼容性问题。会抛出异常的函数存在以下问题：</p><ul><li>难以与其他函数组合或链接</li><li>违反了引用透明性，因为抛出异常会导致函数调用出现另一出口，所以不能确保单一的可预测的返回值</li><li>会引起副作用，因为异常会在函数调用之外对堆栈引发不可预料的影响</li><li>违反非局域性的原则，因为用于恢复异常的代码与原始的函数调用渐行渐远。当发生错误时，函数离开局部栈与环境</li><li>不能只关注函数的返回值，调用者需要负责声明 catch 块中的异常匹配类型来管理特定的异常</li><li>当有多个异常条件时会出现嵌套的异常处理块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;inner&quot;</span>, ex.message);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;outer&quot;</span>, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;inner&quot; &quot;oops&quot;</span></span><br><span class="line"><span class="comment">// &quot;finally&quot;</span></span><br><span class="line"><span class="comment">// &quot;outer&quot; &quot;oops&quot;</span></span><br></pre></td></tr></table></figure><p>那函数式编程真的不需要抛出异常吗？</p><p>该作者不这么认为。在实践中，很多因素是在控制范围之外的，而且依赖库也有抛出异常的可能。对于某些边缘情况，使用异常可能颇有效率。异常应该由一个地方抛出，而不应该随处可见。</p><h3 id="空值（null）检查问题"><a href="#空值（null）检查问题" class="headerlink" title="空值（null）检查问题"></a>空值（null）检查问题</h3><p>另一种跟抛出异常一样烦人的错误是 null 返回值。虽然 null 返回值保证了函数的出口只有一个，但是也并没有好到哪去——给使用函数的用户带来需要 null 检查的负担。比如获取学生地址与国家的 getCountry 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserCountry</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> school = student.getSchool();</span><br><span class="line">  <span class="keyword">if</span> (school !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> addr = school.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (addr !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> country = addr.getCountry();</span><br><span class="line">      <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Error extracting country info&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很容易实现，但是需要大量的判空检查。不管是使用 try-catch 还是 null 检查，都是被动的解决方式。</p><h2 id="一种更好的解决方案——Functor"><a href="#一种更好的解决方案——Functor" class="headerlink" title="一种更好的解决方案——Functor"></a>一种更好的解决方案——Functor</h2><p>函数式以一种完全不同的方法应对软件系统的错误处理。其思想说起来也非常简单，就是创建一个安全的容器，来存放危险代码,比方说 try-catch 就可以看作存放着会抛出异常的函数的保险箱。而保险箱可以看作一种容器。</p><p>在函数式编程中，仍然会包裹这些危险代码，但可以不用 try-catch 块。使用函数式数据类型是解决不纯性的主要手段。不过，首先从最简单的类型开始。</p><h3 id="包裹不安全的值"><a href="#包裹不安全的值" class="headerlink" title="包裹不安全的值"></a>包裹不安全的值</h3><p>将值包裹起来是函数式编程的一个基本设计模式，因为它直接地保证了值不会被任意篡改。这有点像把值保护起来，只能通过 map 操作来访问该容器中的值。实际上数组的 map，而数组也是值的容器。我们将继续扩展更广义的 map 的概念。</p><p>其实，可以映射函数到更多类型，而不仅仅是数组。在函数式 JavaScript 中，map 只不过是一个函数，由于引用透明性，只要输入相同，map 永远会返回相同的结果。当然，还可以认为 map 是可以使用 lambda 表达式变换容器内的值的途径。比如，对于数组，就可以通过 map 转换值，返回包含新值的新数组。</p><p>下面用 Wrapper 解释一下这个概念</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123; <span class="comment">// 存储任意类型值的简单类型</span></span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map ::  A -&gt; B</span></span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123; <span class="comment">// 用一个函数来 map 该类型（就像数组一样）</span></span><br><span class="line">    <span class="keyword">return</span> f(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Wrapper (&#x27;</span> + <span class="built_in">this</span>.value + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wrap :: A -&gt; Wrapper(A)</span></span><br><span class="line"><span class="keyword">const</span> wrap = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="keyword">new</span> Wrapper(val); <span class="comment">// 能够根据值快速创建 Wrapper 的帮助函数</span></span><br></pre></td></tr></table></figure><p>要访问包裹内的对象，唯一办法是 map 一个 Ramda 的 identity 函数（注意，Wrapper 类型并没有 get 方法）。虽然 JavaScript 允许用户方便地访问这个值，但重要的是，一旦该值进入容器，就不应该能被直接获取或转化（就像一个虚拟的屏障），如图1 所示：</p><p><img src="https://i.loli.net/2021/08/08/1FiDH4MEVbfOJS9.png"></p><p>Wrapper 类型使用 map 安全地访问和操作值。在这种情况下，通过映射 identity 函数就能在容器中提取值。</p><p>下面是获取值的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedValue = wrap(<span class="string">&#x27;Get Functional&#x27;</span>);</span><br><span class="line">wrappedValue.map(R.identity); <span class="comment">// &#x27;Get Functional&#x27; &lt;--- 值的提取</span></span><br></pre></td></tr></table></figure><p>其实还可以映射任何函数到该容器，比如变换该值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrappedValue.map(R.toUpper); <span class="comment">// &#x27;GET FUNCTIONAL&#x27; &lt;--- 对内部值应用函数</span></span><br></pre></td></tr></table></figure><p>如此一来，所有对值的操作都必须借助 Wrapper.map “伸入”容器，从而使值得到一定的保护。但是 null 或者 undefined 的情况仍然存在，还是需要在映射的函数中去处理。接下来看看解决的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedNull = wrap(<span class="literal">null</span>);</span><br><span class="line">wrappedNull.map(doWork); <span class="comment">// doWork 被赋予了空值检查的责任</span></span><br></pre></td></tr></table></figure><p>就像这个例子，由于直接调用函数，完全可以交给 Wrapper 类型来做错误处理。换句话说，可以在调用函数之前，检查 null、空字符串或者负数，等等。因此，Wrapper.map 的语义就由具体的 Wrapper 类型来确定。</p><p>继续来看看 map 的变种——fmap：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmap :: (A -&gt; B) -&gt; Wrapper[A] -&gt; Wrapper[B]</span></span><br><span class="line">Wrapper.prototype.fmap = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(f(<span class="built_in">this</span>.valve)); <span class="comment">// &lt;--- 先将返回值包裹到容器中，再返回给调用者</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>fmap 知道如何在上下文中应用函数值。它会先打开该容器，应用函数到值，最后把返回的值包裹到一个新的同类型容器中。拥有这种函数的类型称为 Functor。</strong></p><h3 id="Functor-定义"><a href="#Functor-定义" class="headerlink" title="Functor 定义"></a>Functor 定义</h3><p>从本质上讲，Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。<br>下面是 fmap 的一般定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmap :: (A -&gt; B) -&gt; Wrapper(A) -&gt; Wrapper(B) <span class="comment">// &lt;--- Wrapper 可以是任何容器类型</span></span><br></pre></td></tr></table></figure><p>fmap 函数接受一个从 A-&gt;B 的函数，以及一个 Wrapper(A) Functor，然后返回包裹着结果的新 Functor —— Wrapper(B)。图 2 显示了用 increment 函数作为 A-&gt;B 的映射函数，只是这里的 A 和 B 为同一类型。</p><p><img src="https://i.loli.net/2021/08/08/WLrdu1SBHiDy735.png"></p><p>图 2 Wrapper 内的值 1，在应用函数 increment 后再次包裹成新的容器。</p><p>要注意的是，<strong>fmap 在每次调用都会返回一个新的副本，是不可变的。</strong></p><p>在开始解决更实际的问题之前，再来看一个简单的例子。试用 Functor 来完成简单的 2 + 3 = 5。首先柯里化 add 函数，这样就得到了 plus3 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = R.curry(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="keyword">const</span> plus3 = plus(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>现在可以把数字 2 放到 Wrapper 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>再调用 fmap 把 plus3 映射到容器上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> five = two.fmap(plus3); <span class="comment">//-&gt; Wrapper(5) &lt;--- 返回一个具有上下文包裹的值</span></span><br><span class="line">five.map(R.identity); <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure><p>fmap 返回同样类型的结果，可以通过映射 R.identity 来提取它的值。不过需要注意的是，值会一直在容器中，因此可以 fmap 任意次函数来转换值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(plus3).fmap(plus10); <span class="comment">//-&gt; Wrapper(15)</span></span><br></pre></td></tr></table></figure><p>光看代码可能不够直观，图 3 更清楚地解释了如何 fmapplus3。</p><p><img src="https://i.loli.net/2021/08/08/XUa6k7sG4vZ81rS.png"></p><p>图 3 Wrapper 容器中的值是 2。Functor 会将其打开，应用 fmap 的函数，再包裹函数的返回值到新的容器中。<br>fmap 函数会返回同样的类型，这样就可以链式地继续使用 fmap。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> isFive = two.fmap(plus3).fmap(R.equals(<span class="number">5</span>)); <span class="comment">//-&gt; Wrapper(true) &lt;--- 返回一个具有上下文包裹的值</span></span><br></pre></td></tr></table></figure><p>这种链式的函数调用是不是非常眼熟？其实很多人一直在使用 Functor 却没有意识到而已。比如 Array的 map 和 filter 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map :: (A -&gt; B) -&gt; <span class="built_in">Array</span>(A) -&gt; <span class="built_in">Array</span>(B)</span><br><span class="line"><span class="attr">filter</span> :: (A -&gt; <span class="built_in">Boolean</span>) -&gt; <span class="built_in">Array</span>(A) -&gt; <span class="built_in">Array</span>(A)</span><br></pre></td></tr></table></figure><p>map 和 filter 都返回同样类型的 Functor，因此可以不断地链接。来看看另一个 Functor：compose。<br>正如之前分享提到的，这是从一个函数到另一个函数的映射（也保持类型不变）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose :: (B -&gt; C) -&gt; (A -&gt; B) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure><p>Functor 有如下一些重要的<strong>属性约束</strong>:</p><ul><li><strong>必须是无副作用的。</strong> 若映射 R.identity 函数可以获得上下文中相同的值，即可证明 Functor 是无副作用的：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap(<span class="string">&#x27;Get Functional&#x27;</span>).fmap(R.identity); <span class="comment">//-&gt; Wrapper(&#x27;Get Functional&#x27;)</span></span><br></pre></td></tr></table></figure><ul><li><strong>必须是可组合的。</strong> 这个属性的意思是 fmap 函数的组合，与分别 fmap 函数是一样的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(R.compose(plus3, R.add(<span class="number">5</span>))).map(R.identity); <span class="comment">//-&gt; 10</span></span><br></pre></td></tr></table></figure><p>Functor 的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。其实际目的只是创建一个上下文或一个抽象，以便可以安全地应用操作到值，而又不改变原始值。这也是 map 可以将一个数组转换到另一个数组，而不改变原数组的原因。而 Functor 就是这个概念的推广。</p><p>Functor 本身并不需要知道如何处理 null。例如 Ramda 中的 R.compose，在收到为 null 的函数引用时就会抛出异常。这完全是预期的行为，并不是设计上的缺陷。因为 Functor 映射从一个类型到另一类型的函数。还有一个更为具体化的函数式数据类型——Monad。Monad 可以简化代码中的错误处理，进而更流畅地进行函数组合。但是它跟 Functor 有什么关系呢？其实，Monad 就是 Functor“伸入”的容器。</p><p>如果写过 jQuery 代码，那么应该觉得 Monad 很面熟。</p><p>Monad 只是给一些资源提供了抽象，例如一个简单的价值，一个 DOM 元素、事件或 AJAX 调用，这样就可以安全地处理其中包含的数据。比如，jQuery 就可以看作 DOM 的 Monad：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#student-info&#x27;</span>).fadeIn(<span class="number">3000</span>).text(student.fullname());</span><br></pre></td></tr></table></figure><p>这段代码的行为之所以像 Monad，是因为 jQuery 可以将 fadeIn 和 text 行为安全地应用到 DOM 上。如果 student-info 面板不存在，将方法应用到空的 jQuery 对象上只会什么也不发生，而不会抛出任何异常。Monad 旨在安全地传送错误，这样应用才具有较好的容错性。</p><h2 id="使用-Monad-函数式地处理错误"><a href="#使用-Monad-函数式地处理错误" class="headerlink" title="使用 Monad 函数式地处理错误"></a>使用 Monad 函数式地处理错误</h2><p>Monad 用于函数式地解决传统错误处理的问题。但在深入这个话题之前，先来了解使用 Functor 的局限性。使用 Functor 可以安全地应用函数到其内部的值，并且返回一个不可变的新 Functor。但如果它遍布在代码中，就会有一些让人不那么顺心的地方。下面来看一个通过 id 获取学生地址的例子。对于这个例子，大概需要两个函数——findStudent 和 getAddress，这两个函数都给值包裹上一个安全的上下文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findStudent = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(find(db, id)); <span class="comment">// &lt;--- 包裹对象获取逻辑，以避免找不到对象所造成的问题</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(student.fmap(R.prop(<span class="string">&quot;address&quot;</span>))); <span class="comment">// 用 Ramda 的 R.prop()函数来 map 对象以获取其地址， 再将结果包裹起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这两个函数组合在一起：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> studentAddress = R.compose(</span><br><span class="line">  getAddress,</span><br><span class="line">  findStudent(DB(<span class="string">&#x27;student&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>虽然成功地避免了所有的错误处理代码，但是结果却出乎意料。返回的值是被包裹了两层的 address对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentAddress(<span class="string">&#x27;666&#x27;</span>); <span class="comment">//-&gt; Wrapper(Wrapper(address))</span></span><br></pre></td></tr></table></figure><p>为了提取这个值，需要两次应用 R.identity 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentAddress(<span class="string">&#x27;666&#x27;</span>).map(R.identity).map(R.identity);</span><br></pre></td></tr></table></figure><p>在自己的代码中见到两层这样的代码还可以勉强接受，如果出现三四层呢？这个时候，Monad 可以成为更好的解决方案。</p><h3 id="Monad：从控制流到数据流"><a href="#Monad：从控制流到数据流" class="headerlink" title="Monad：从控制流到数据流"></a>Monad：从控制流到数据流</h3><p>Monad 和 Functor 类似，但在处理某些情况时可以带来一些特殊的逻辑。下面就用简单的例子来看看Monad 到底有什么特殊的功能。假如有一个函数 half::Number -&gt;Number（见图 4）：</p><p><img src="https://i.loli.net/2021/08/08/bPwu5ENr4mpAQoU.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper(<span class="number">2</span>).fmap(half); <span class="comment">//-&gt; Wrapper(1)</span></span><br><span class="line">Wrapper(<span class="number">3</span>).fmap(half); <span class="comment">//-&gt; Wrapper(1.5)</span></span><br></pre></td></tr></table></figure><p>图 4 Functor 可以将函数应用到包裹的值上。例子中包裹的值会被 2 除。<br>不过，Functor 只管应用函数到值并将结果包裹起来，并不能加额外的逻辑。如果想要限制 half 只应用到偶数，而输入是一个奇数，该怎么办？或许可以返回 null 或抛出异常，但更好的策略是让该函数能给合法的数字返回正确的结果，并忽略不合法的数字。<br>现在假设有一个名为 Empty 的类似 Wrapper 的容器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Empty = <span class="function"><span class="keyword">function</span> (<span class="params">_</span>) </span>&#123;</span><br><span class="line">  ; <span class="comment">// 无操作。 Empty 不会存储任何值，其代表着“空”或“无”的概念</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// map :: (A -&gt; B) -&gt; A -&gt; B</span></span><br><span class="line">Empty.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;; <span class="comment">// &lt;--- 类似，将函数 map 到 Empty 上会跳过该操作</span></span><br><span class="line"><span class="comment">// empty :: _ -&gt; Empty</span></span><br><span class="line"><span class="keyword">const</span> empty = <span class="function">() =&gt;</span> <span class="keyword">new</span> Empty();</span><br></pre></td></tr></table></figure><p>为了实现 half 以满足新的需求，可以通过以下方式完成（见图 5）：</p><p><img src="https://i.loli.net/2021/08/08/YvoIHae8QUJfq6x.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Number</span>.isFinite(n) &amp;amp;&amp;amp; (n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// &lt;--- 区分奇偶数的工具函数</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">val</span>) =&gt;</span> isEven(val) ? wrap(val / <span class="number">2</span>) : empty(); <span class="comment">// &lt;--- half 函数只会操作偶数，否则会返回一个空的容器</span></span><br><span class="line">half(<span class="number">4</span>); <span class="comment">//-&gt; Wrapper(2)</span></span><br><span class="line">half(<span class="number">3</span>); <span class="comment">//-&gt; Empty</span></span><br></pre></td></tr></table></figure><p>图 5 函数 half 可以根据输入返回一个包裹好的值或空容器。<br>Monad 用于创建一个带有一定规则的容器，而 Functor 并不需要了解其容器内的值。Functor 可以有效地保护数据，然而当需要组合函数时，即可以用Monad 来安全并且无副作用地管理数据流。在前面的例子中，对于奇数会返回 Empty 而不是 null。所以此后如果想应用函数，就不必在意可能会出现的异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half(<span class="number">4</span>).fmap(plus3); <span class="comment">//-&gt; Wrapper(5)</span></span><br><span class="line">half(<span class="number">3</span>).fmap(plus3); <span class="comment">//-&gt; Empty &lt;--- 容器知道该如何应用函数，即便其值是非法的</span></span><br></pre></td></tr></table></figure><p>除此之外，Monad 还适用于解决其他问题。这里只讨论如何使用 Monad 来解决命令式错误处理的问题，从而使代码更可读、更易于推理。</p><p>以下两个概念非常重要。</p><ul><li>Monad:为 Monadic 操作提供抽象接口。</li><li>Monadic 类型: 该接口的具体实现。</li></ul><p>Monadic 类型类似于上面提到的的 Wrapper 对象。不过每个 Monad 都有不同的用途，可以定义不同的语义便于确定其行为（例如 map 或 fmap）。使用这些类型可以进行链式或嵌套操作，但都应遵循下列接口定义。</p><ul><li>类型构造函数: 创建 Monadic 类型（类似于 Wrapper 的构造函数）。</li><li>unit 函数: 可将特定类型的值放入 Monadic 结构中（类似于 wrap 和前面看到的 empty 函数）。对于 Monad 的实现来说，该函数也被称为 of 函数。</li><li>bind 函数: 可以链式操作，后文将使用更简短的 map。</li><li>join 函数: 将两层 Monadic 结构合并成一层。这会对嵌套返回 Monad 的函数特别有用。<br>将这一个接口应用到 Wrapper 类型，就可以重构成以下这种形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// unit 函数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">a</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wrapper(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bind 函数（ Functor）</span></span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> Wrapper.of(f(<span class="built_in">this</span>.value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 压平嵌套的 Wrapper</span></span><br><span class="line">  <span class="function"><span class="title">join</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(!(<span class="built_in">this</span>.value <span class="keyword">instanceof</span> Wrapper)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.value.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个当前结构的文本描述</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Wrapper (<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 使用 Functor 的 map 将数据提升到容器中，这样就可以无任何副作用。通常还可以用_.identity 函数来检查其内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wrapper.of(<span class="string">&#x27;Hello Monads!&#x27;</span>)</span><br><span class="line">.map(R.toUpper)</span><br><span class="line">.map(R.identity); <span class="comment">//-&gt; Wrapper(&#x27;HELLO MONADS!&#x27;)</span></span><br></pre></td></tr></table></figure><p>map 操作被视为一种中立的 functor，因为它无非只是映射函数到对象，然后关闭它。之后，Monad 给map 加入特殊的功能。join 函数用于逐层扁平化嵌套结构，就像剥洋葱一样。这可以用来消除之前用functor 时发现的问题，如下 所示。<br>扁平化 Monadic 结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findObject :: DB -&gt; String -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> findObject = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(find(db, id));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// getAddress :: Student -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(student.map(R.prop(<span class="string">&#x27;address&#x27;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> studentAddress = R.compose(getAddress, findObject(DB(<span class="string">&#x27;student&#x27;</span>)));</span><br><span class="line">studentAddress(<span class="string">&#x27;444-44-4444&#x27;</span>).join().get(); <span class="comment">// Address</span></span><br></pre></td></tr></table></figure><p>该代码返回一组嵌套的 wrapper，其中 join 操作用于将这种嵌套结构压平成单一的层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper.of(Wrapper.of(Wrapper.of(<span class="string">&#x27;Get Functional&#x27;</span>))).join();</span><br><span class="line"><span class="comment">//-&gt; Wrapper(&#x27;Get Functional&#x27;)</span></span><br></pre></td></tr></table></figure><p>图 6 为 join 操作的示意图，递归扁平化嵌套结构的 Monad，像剥洋葱一样：</p><p><img src="https://i.loli.net/2021/08/08/dAocQ8O6PJMTUVk.png"></p><p>Monad 通常有更多的操作，这里提及的最小接口只是其整个 API 的子集。一个 Monad 本身只是抽象，没有任何实际意义。只有实际的实现类型才有丰富的功能。大多数函数式编程的代码只用一些常用的类型就可以消除大量的样板代码，同时还能完成同样的工作。</p><p>Monad 实例丰富，例如：Maybe、Either 和 IO，大家有兴趣可以自行查看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>面向对象抛异常的机制让函数变得不纯，把大部分的责任都推到了调用者的尝试——try-catch逻辑上</li><li>把值包裹到容器中的模式是为了构建无副作用的代码，把可能不纯的变化包裹成引用透明的过程</li><li>使用Functor将函数应用到容器中的值，这是无副作用地、不可变地访问和修改操作</li><li>Monad是函数式中用来降低应用复杂度的设计模式，通过这种模式可以将函数编排成安全的数据流程</li><li>交错的组合函数和Monadic类型是非常有弹性而且强大的，如Maybe、Either和IO</li></ul><p><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html">阮一峰：图解 Monad</a><br><a href="https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">阮一峰：函数式编程入门教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;四-函数式编程——针对复杂应用的设计模式&quot;&gt;&lt;a href=&quot;#四-函数式编程</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为什么打开一个页面，会有4个进程？</title>
    <link href="http://example.com/2021/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BC%9A%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F/"/>
    <id>http://example.com/2021/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BC%9A%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F/</id>
    <published>2021-03-22T05:07:12.000Z</published>
    <updated>2022-01-20T03:06:49.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="简单回答"><a href="#简单回答" class="headerlink" title="简单回答"></a>简单回答</h2><p>因为打开1个页面，至少需要1个浏览器进程、1个网络进程、1个GPU进程以及1个渲染进程</p><h2 id="相关思维导图"><a href="#相关思维导图" class="headerlink" title="相关思维导图"></a>相关思维导图</h2><p><img src="https://s2.loli.net/2022/01/09/P5xs9HKBg1WpLiD.png"></p><h2 id="前置知识：线程和进程"><a href="#前置知识：线程和进程" class="headerlink" title="前置知识：线程和进程"></a>前置知识：线程和进程</h2><p>进程资源分配的最小单元，线程是CPU调度的最小单元。</p><p>二者都是一个时间段的描述，是CPU工作时间段的描述，是运行中的程序指令的一种描述，这需要与程序中的代码区别开来。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这个问题与浏览器的发展相关，浏览器是从单进程时代发展到多进程时代。</p><h3 id="单进程时代"><a href="#单进程时代" class="headerlink" title="单进程时代"></a>单进程时代</h3><p>顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，其中包含JS引擎、渲染引擎、网络进程、插件进程、GPU进程等等。</p><p>如此之多的功能模块在一个进程中，使得浏览器面临以下的窘境：</p><ul><li>不稳定<br>  插件容易崩溃</li><li>不流畅<br>  所有功能模块都在一个进程中，从线程和进程的关系得知，这意味着同一时刻只有一个模块可以运行，效率不高</li><li>不安全<br>  恶意插件、恶意脚本</li></ul><h3 id="多进程时代"><a href="#多进程时代" class="headerlink" title="多进程时代"></a>多进程时代</h3><p>这里以Chrome浏览器为例，它也是第一个采用多进程架构的浏览器，这个架构<strong>能容许许多个程序同事运行而互不影响</strong></p><p><img src="https://s2.loli.net/2022/01/09/Vmk68QIpOBgZGoU.png"></p><p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ul><li>更高的资源占用</li><li>更复杂的体系结构</li></ul><h3 id="关于安全沙箱"><a href="#关于安全沙箱" class="headerlink" title="关于安全沙箱"></a>关于安全沙箱</h3><p>采用多进程架构的好处之一是可以使用安全沙箱，沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源，</p><h2 id="各个进程的作用"><a href="#各个进程的作用" class="headerlink" title="各个进程的作用"></a>各个进程的作用</h2><p>这里仍以Chrome浏览器为例</p><ul><li>浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储功能</li><li>渲染进程：核心任务就是将HTML、CSS和JavaScript转换为用户可以与之交互的网页(排版引擎Blink、JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程，出于安全考虑，渲染进程都是运行在沙箱模式下)</li><li>GPU进程：该进程的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器的普遍需求。最后，Chrome在其多进程架构上也引入了GPU进程。</li><li>网络进程：主要负责页面的网络资源加载</li><li>插件进程：主要负责插件的运行，因为插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程不会对浏览器和页面造成影响</li></ul><h2 id="标题的答案"><a href="#标题的答案" class="headerlink" title="标题的答案"></a>标题的答案</h2><p>打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1688297">进程和线程的概念、区别及进程线程间通信</a></p><p><a href="https://codeantenna.com/a/Xr9k4lpBJn">Chrome为什么打开一个页面，会有4个进程?</a></p><p><a href="https://cloud.tencent.com/developer/news/414508">Chrome架构：仅仅打开了1个页面，为什么有4个进程？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单回答&quot;&gt;&lt;a href=&quot;#简单回答&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
