<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可乐加冰</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-08T03:25:21.967Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HJY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（四）</title>
    <link href="http://example.com/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-04-16T02:13:29.000Z</published>
    <updated>2021-08-08T03:25:21.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h1 id="四-函数式编程——针对复杂应用的设计模式"><a href="#四-函数式编程——针对复杂应用的设计模式" class="headerlink" title="四.函数式编程——针对复杂应用的设计模式"></a>四.函数式编程——针对复杂应用的设计模式</h1><p>（读书笔记：JavaScript函数式编程指南）</p><p>今日分享</p><ul><li>命令式错误处理异常方式的问题</li><li>使用容器，以防访问无效数据</li><li>用 Functor 的实现来做数据转换</li></ul><blockquote><p>空引用是一个价值数十亿美元的错误。<br>——Tony Hoare，InfoQ</p></blockquote><h2 id="命令式错误处理的不足"><a href="#命令式错误处理的不足" class="headerlink" title="命令式错误处理的不足"></a>命令式错误处理的不足</h2><p>在许多情况下都会发生 JavaScript 错误，特别是在与服务器通信时，或是在试图访问一个为 null 对象的属性时。</p><p>因此，开发者在编程时总是需要做好最坏的打算。在命令式编程世界中，异常是通过 try-catch 处理的。</p><h3 id="用-try-catch-处理错误"><a href="#用-try-catch-处理错误" class="headerlink" title="用 try-catch 处理错误"></a>用 try-catch 处理错误</h3><p>JavaScript 的异常处理机制通常会以大多数现代语言都有的 try-catch 语句来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ERROR&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以该语句包裹住你认为不太安全的代码，一旦有异常发生，JavaScript 会立即终止程序，并创建导致该问题的指令的函数调用堆栈跟踪。有关错误的具体细节，如消息、行号和文件名，被填充到 Error 类型的对象中，并传递到 catch 块中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> student = findStudentById(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ERROR&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 try-catch 后的代码将不能组合或连在一起，对于函数式编程来说，这将会严重影响代码设计。</p><h3 id="函数式程序不应抛出异常"><a href="#函数式程序不应抛出异常" class="headerlink" title="函数式程序不应抛出异常"></a>函数式程序不应抛出异常</h3><p>命令式的 JavaScript 代码结构有很多缺陷，而且也会与函数式的设计有兼容性问题。会抛出异常的函数存在以下问题：</p><ul><li>难以与其他函数组合或链接</li><li>违反了引用透明性，因为抛出异常会导致函数调用出现另一出口，所以不能确保单一的可预测的返回值</li><li>会引起副作用，因为异常会在函数调用之外对堆栈引发不可预料的影响</li><li>违反非局域性的原则，因为用于恢复异常的代码与原始的函数调用渐行渐远。当发生错误时，函数离开局部栈与环境</li><li>不能只关注函数的返回值，调用者需要负责声明 catch 块中的异常匹配类型来管理特定的异常</li><li>当有多个异常条件时会出现嵌套的异常处理块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;inner&quot;</span>, ex.message);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;outer&quot;</span>, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;inner&quot; &quot;oops&quot;</span></span><br><span class="line"><span class="comment">// &quot;finally&quot;</span></span><br><span class="line"><span class="comment">// &quot;outer&quot; &quot;oops&quot;</span></span><br></pre></td></tr></table></figure><p>那函数式编程真的不需要抛出异常吗？</p><p>该作者不这么认为。在实践中，很多因素是在控制范围之外的，而且依赖库也有抛出异常的可能。对于某些边缘情况，使用异常可能颇有效率。异常应该由一个地方抛出，而不应该随处可见。</p><h3 id="空值（null）检查问题"><a href="#空值（null）检查问题" class="headerlink" title="空值（null）检查问题"></a>空值（null）检查问题</h3><p>另一种跟抛出异常一样烦人的错误是 null 返回值。虽然 null 返回值保证了函数的出口只有一个，但是也并没有好到哪去——给使用函数的用户带来需要 null 检查的负担。比如获取学生地址与国家的 getCountry 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserCountry</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> school = student.getSchool();</span><br><span class="line">  <span class="keyword">if</span> (school !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> addr = school.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (addr !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> country = addr.getCountry();</span><br><span class="line">      <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Error extracting country info&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很容易实现，但是需要大量的判空检查。不管是使用 try-catch 还是 null 检查，都是被动的解决方式。</p><h2 id="一种更好的解决方案——Functor"><a href="#一种更好的解决方案——Functor" class="headerlink" title="一种更好的解决方案——Functor"></a>一种更好的解决方案——Functor</h2><p>函数式以一种完全不同的方法应对软件系统的错误处理。其思想说起来也非常简单，就是创建一个安全的容器，来存放危险代码,比方说 try-catch 就可以看作存放着会抛出异常的函数的保险箱。而保险箱可以看作一种容器。</p><p>在函数式编程中，仍然会包裹这些危险代码，但可以不用 try-catch 块。使用函数式数据类型是解决不纯性的主要手段。不过，首先从最简单的类型开始。</p><h3 id="包裹不安全的值"><a href="#包裹不安全的值" class="headerlink" title="包裹不安全的值"></a>包裹不安全的值</h3><p>将值包裹起来是函数式编程的一个基本设计模式，因为它直接地保证了值不会被任意篡改。这有点像把值保护起来，只能通过 map 操作来访问该容器中的值。实际上数组的 map，而数组也是值的容器。我们将继续扩展更广义的 map 的概念。</p><p>其实，可以映射函数到更多类型，而不仅仅是数组。在函数式 JavaScript 中，map 只不过是一个函数，由于引用透明性，只要输入相同，map 永远会返回相同的结果。当然，还可以认为 map 是可以使用 lambda 表达式变换容器内的值的途径。比如，对于数组，就可以通过 map 转换值，返回包含新值的新数组。</p><p>下面用 Wrapper 解释一下这个概念</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123; <span class="comment">// 存储任意类型值的简单类型</span></span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map ::  A -&gt; B</span></span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123; <span class="comment">// 用一个函数来 map 该类型（就像数组一样）</span></span><br><span class="line">    <span class="keyword">return</span> f(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Wrapper (&#x27;</span> + <span class="built_in">this</span>.value + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wrap :: A -&gt; Wrapper(A)</span></span><br><span class="line"><span class="keyword">const</span> wrap = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="keyword">new</span> Wrapper(val); <span class="comment">// 能够根据值快速创建 Wrapper 的帮助函数</span></span><br></pre></td></tr></table></figure><p>要访问包裹内的对象，唯一办法是 map 一个 Ramda 的 identity 函数（注意，Wrapper 类型并没有 get 方法）。虽然 JavaScript 允许用户方便地访问这个值，但重要的是，一旦该值进入容器，就不应该能被直接获取或转化（就像一个虚拟的屏障），如图1 所示：</p><p><img src="https://i.loli.net/2021/08/08/1FiDH4MEVbfOJS9.png"></p><p>Wrapper 类型使用 map 安全地访问和操作值。在这种情况下，通过映射 identity 函数就能在容器中提取值。</p><p>下面是获取值的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedValue = wrap(<span class="string">&#x27;Get Functional&#x27;</span>);</span><br><span class="line">wrappedValue.map(R.identity); <span class="comment">// &#x27;Get Functional&#x27; &lt;--- 值的提取</span></span><br></pre></td></tr></table></figure><p>其实还可以映射任何函数到该容器，比如变换该值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrappedValue.map(R.toUpper); <span class="comment">// &#x27;GET FUNCTIONAL&#x27; &lt;--- 对内部值应用函数</span></span><br></pre></td></tr></table></figure><p>如此一来，所有对值的操作都必须借助 Wrapper.map “伸入”容器，从而使值得到一定的保护。但是 null 或者 undefined 的情况仍然存在，还是需要在映射的函数中去处理。接下来看看解决的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedNull = wrap(<span class="literal">null</span>);</span><br><span class="line">wrappedNull.map(doWork); <span class="comment">// doWork 被赋予了空值检查的责任</span></span><br></pre></td></tr></table></figure><p>就像这个例子，由于直接调用函数，完全可以交给 Wrapper 类型来做错误处理。换句话说，可以在调用函数之前，检查 null、空字符串或者负数，等等。因此，Wrapper.map 的语义就由具体的 Wrapper 类型来确定。</p><p>继续来看看 map 的变种——fmap：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmap :: (A -&gt; B) -&gt; Wrapper[A] -&gt; Wrapper[B]</span></span><br><span class="line">Wrapper.prototype.fmap = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(f(<span class="built_in">this</span>.valve)); <span class="comment">// &lt;--- 先将返回值包裹到容器中，再返回给调用者</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>fmap 知道如何在上下文中应用函数值。它会先打开该容器，应用函数到值，最后把返回的值包裹到一个新的同类型容器中。拥有这种函数的类型称为 Functor。</strong></p><h3 id="Functor-定义"><a href="#Functor-定义" class="headerlink" title="Functor 定义"></a>Functor 定义</h3><p>从本质上讲，Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。<br>下面是 fmap 的一般定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmap :: (A -&gt; B) -&gt; Wrapper(A) -&gt; Wrapper(B) <span class="comment">// &lt;--- Wrapper 可以是任何容器类型</span></span><br></pre></td></tr></table></figure><p>fmap 函数接受一个从 A-&gt;B 的函数，以及一个 Wrapper(A) Functor，然后返回包裹着结果的新 Functor —— Wrapper(B)。图 2 显示了用 increment 函数作为 A-&gt;B 的映射函数，只是这里的 A 和 B 为同一类型。</p><p><img src="https://i.loli.net/2021/08/08/WLrdu1SBHiDy735.png"></p><p>图 2 Wrapper 内的值 1，在应用函数 increment 后再次包裹成新的容器。</p><p>要注意的是，<strong>fmap 在每次调用都会返回一个新的副本，是不可变的。</strong></p><p>在开始解决更实际的问题之前，再来看一个简单的例子。试用 Functor 来完成简单的 2 + 3 = 5。首先柯里化 add 函数，这样就得到了 plus3 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = R.curry(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="keyword">const</span> plus3 = plus(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>现在可以把数字 2 放到 Wrapper 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>再调用 fmap 把 plus3 映射到容器上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> five = two.fmap(plus3); <span class="comment">//-&gt; Wrapper(5) &lt;--- 返回一个具有上下文包裹的值</span></span><br><span class="line">five.map(R.identity); <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure><p>fmap 返回同样类型的结果，可以通过映射 R.identity 来提取它的值。不过需要注意的是，值会一直在容器中，因此可以 fmap 任意次函数来转换值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(plus3).fmap(plus10); <span class="comment">//-&gt; Wrapper(15)</span></span><br></pre></td></tr></table></figure><p>光看代码可能不够直观，图 3 更清楚地解释了如何 fmapplus3。</p><p><img src="https://i.loli.net/2021/08/08/XUa6k7sG4vZ81rS.png"></p><p>图 3 Wrapper 容器中的值是 2。Functor 会将其打开，应用 fmap 的函数，再包裹函数的返回值到新的容器中。<br>fmap 函数会返回同样的类型，这样就可以链式地继续使用 fmap。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> isFive = two.fmap(plus3).fmap(R.equals(<span class="number">5</span>)); <span class="comment">//-&gt; Wrapper(true) &lt;--- 返回一个具有上下文包裹的值</span></span><br></pre></td></tr></table></figure><p>这种链式的函数调用是不是非常眼熟？其实很多人一直在使用 Functor 却没有意识到而已。比如 Array的 map 和 filter 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map :: (A -&gt; B) -&gt; <span class="built_in">Array</span>(A) -&gt; <span class="built_in">Array</span>(B)</span><br><span class="line"><span class="attr">filter</span> :: (A -&gt; <span class="built_in">Boolean</span>) -&gt; <span class="built_in">Array</span>(A) -&gt; <span class="built_in">Array</span>(A)</span><br></pre></td></tr></table></figure><p>map 和 filter 都返回同样类型的 Functor，因此可以不断地链接。来看看另一个 Functor：compose。<br>正如之前分享提到的，这是从一个函数到另一个函数的映射（也保持类型不变）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose :: (B -&gt; C) -&gt; (A -&gt; B) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure><p>Functor 有如下一些重要的<strong>属性约束</strong>:</p><ul><li><strong>必须是无副作用的。</strong> 若映射 R.identity 函数可以获得上下文中相同的值，即可证明 Functor 是无副作用的：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap(<span class="string">&#x27;Get Functional&#x27;</span>).fmap(R.identity); <span class="comment">//-&gt; Wrapper(&#x27;Get Functional&#x27;)</span></span><br></pre></td></tr></table></figure><ul><li><strong>必须是可组合的。</strong> 这个属性的意思是 fmap 函数的组合，与分别 fmap 函数是一样的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(R.compose(plus3, R.add(<span class="number">5</span>))).map(R.identity); <span class="comment">//-&gt; 10</span></span><br></pre></td></tr></table></figure><p>Functor 的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。其实际目的只是创建一个上下文或一个抽象，以便可以安全地应用操作到值，而又不改变原始值。这也是 map 可以将一个数组转换到另一个数组，而不改变原数组的原因。而 Functor 就是这个概念的推广。</p><p>Functor 本身并不需要知道如何处理 null。例如 Ramda 中的 R.compose，在收到为 null 的函数引用时就会抛出异常。这完全是预期的行为，并不是设计上的缺陷。因为 Functor 映射从一个类型到另一类型的函数。还有一个更为具体化的函数式数据类型——Monad。Monad 可以简化代码中的错误处理，进而更流畅地进行函数组合。但是它跟 Functor 有什么关系呢？其实，Monad 就是 Functor“伸入”的容器。</p><p>如果写过 jQuery 代码，那么应该觉得 Monad 很面熟。</p><p>Monad 只是给一些资源提供了抽象，例如一个简单的价值，一个 DOM 元素、事件或 AJAX 调用，这样就可以安全地处理其中包含的数据。比如，jQuery 就可以看作 DOM 的 Monad：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#student-info&#x27;</span>).fadeIn(<span class="number">3000</span>).text(student.fullname());</span><br></pre></td></tr></table></figure><p>这段代码的行为之所以像 Monad，是因为 jQuery 可以将 fadeIn 和 text 行为安全地应用到 DOM 上。如果 student-info 面板不存在，将方法应用到空的 jQuery 对象上只会什么也不发生，而不会抛出任何异常。Monad 旨在安全地传送错误，这样应用才具有较好的容错性。</p><h2 id="使用-Monad-函数式地处理错误"><a href="#使用-Monad-函数式地处理错误" class="headerlink" title="使用 Monad 函数式地处理错误"></a>使用 Monad 函数式地处理错误</h2><p>Monad 用于函数式地解决传统错误处理的问题。但在深入这个话题之前，先来了解使用 Functor 的局限性。使用 Functor 可以安全地应用函数到其内部的值，并且返回一个不可变的新 Functor。但如果它遍布在代码中，就会有一些让人不那么顺心的地方。下面来看一个通过 id 获取学生地址的例子。对于这个例子，大概需要两个函数——findStudent 和 getAddress，这两个函数都给值包裹上一个安全的上下文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findStudent = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(find(db, id)); <span class="comment">// &lt;--- 包裹对象获取逻辑，以避免找不到对象所造成的问题</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(student.fmap(R.prop(<span class="string">&quot;address&quot;</span>))); <span class="comment">// 用 Ramda 的 R.prop()函数来 map 对象以获取其地址， 再将结果包裹起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这两个函数组合在一起：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> studentAddress = R.compose(</span><br><span class="line">  getAddress,</span><br><span class="line">  findStudent(DB(<span class="string">&#x27;student&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>虽然成功地避免了所有的错误处理代码，但是结果却出乎意料。返回的值是被包裹了两层的 address对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentAddress(<span class="string">&#x27;666&#x27;</span>); <span class="comment">//-&gt; Wrapper(Wrapper(address))</span></span><br></pre></td></tr></table></figure><p>为了提取这个值，需要两次应用 R.identity 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentAddress(<span class="string">&#x27;666&#x27;</span>).map(R.identity).map(R.identity);</span><br></pre></td></tr></table></figure><p>在自己的代码中见到两层这样的代码还可以勉强接受，如果出现三四层呢？这个时候，Monad 可以成为更好的解决方案。</p><h3 id="Monad：从控制流到数据流"><a href="#Monad：从控制流到数据流" class="headerlink" title="Monad：从控制流到数据流"></a>Monad：从控制流到数据流</h3><p>Monad 和 Functor 类似，但在处理某些情况时可以带来一些特殊的逻辑。下面就用简单的例子来看看Monad 到底有什么特殊的功能。假如有一个函数 half::Number -&gt;Number（见图 4）：</p><p><img src="https://i.loli.net/2021/08/08/bPwu5ENr4mpAQoU.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper(<span class="number">2</span>).fmap(half); <span class="comment">//-&gt; Wrapper(1)</span></span><br><span class="line">Wrapper(<span class="number">3</span>).fmap(half); <span class="comment">//-&gt; Wrapper(1.5)</span></span><br></pre></td></tr></table></figure><p>图 4 Functor 可以将函数应用到包裹的值上。例子中包裹的值会被 2 除。<br>不过，Functor 只管应用函数到值并将结果包裹起来，并不能加额外的逻辑。如果想要限制 half 只应用到偶数，而输入是一个奇数，该怎么办？或许可以返回 null 或抛出异常，但更好的策略是让该函数能给合法的数字返回正确的结果，并忽略不合法的数字。<br>现在假设有一个名为 Empty 的类似 Wrapper 的容器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Empty = <span class="function"><span class="keyword">function</span> (<span class="params">_</span>) </span>&#123;</span><br><span class="line">  ; <span class="comment">// 无操作。 Empty 不会存储任何值，其代表着“空”或“无”的概念</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// map :: (A -&gt; B) -&gt; A -&gt; B</span></span><br><span class="line">Empty.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;; <span class="comment">// &lt;--- 类似，将函数 map 到 Empty 上会跳过该操作</span></span><br><span class="line"><span class="comment">// empty :: _ -&gt; Empty</span></span><br><span class="line"><span class="keyword">const</span> empty = <span class="function">() =&gt;</span> <span class="keyword">new</span> Empty();</span><br></pre></td></tr></table></figure><p>为了实现 half 以满足新的需求，可以通过以下方式完成（见图 5）：</p><p><img src="https://i.loli.net/2021/08/08/YvoIHae8QUJfq6x.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Number</span>.isFinite(n) &amp;amp;&amp;amp; (n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// &lt;--- 区分奇偶数的工具函数</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">val</span>) =&gt;</span> isEven(val) ? wrap(val / <span class="number">2</span>) : empty(); <span class="comment">// &lt;--- half 函数只会操作偶数，否则会返回一个空的容器</span></span><br><span class="line">half(<span class="number">4</span>); <span class="comment">//-&gt; Wrapper(2)</span></span><br><span class="line">half(<span class="number">3</span>); <span class="comment">//-&gt; Empty</span></span><br></pre></td></tr></table></figure><p>图 5 函数 half 可以根据输入返回一个包裹好的值或空容器。<br>Monad 用于创建一个带有一定规则的容器，而 Functor 并不需要了解其容器内的值。Functor 可以有效地保护数据，然而当需要组合函数时，即可以用Monad 来安全并且无副作用地管理数据流。在前面的例子中，对于奇数会返回 Empty 而不是 null。所以此后如果想应用函数，就不必在意可能会出现的异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half(<span class="number">4</span>).fmap(plus3); <span class="comment">//-&gt; Wrapper(5)</span></span><br><span class="line">half(<span class="number">3</span>).fmap(plus3); <span class="comment">//-&gt; Empty &lt;--- 容器知道该如何应用函数，即便其值是非法的</span></span><br></pre></td></tr></table></figure><p>除此之外，Monad 还适用于解决其他问题。这里只讨论如何使用 Monad 来解决命令式错误处理的问题，从而使代码更可读、更易于推理。</p><p>以下两个概念非常重要。</p><ul><li>Monad:为 Monadic 操作提供抽象接口。</li><li>Monadic 类型: 该接口的具体实现。</li></ul><p>Monadic 类型类似于上面提到的的 Wrapper 对象。不过每个 Monad 都有不同的用途，可以定义不同的语义便于确定其行为（例如 map 或 fmap）。使用这些类型可以进行链式或嵌套操作，但都应遵循下列接口定义。</p><ul><li>类型构造函数: 创建 Monadic 类型（类似于 Wrapper 的构造函数）。</li><li>unit 函数: 可将特定类型的值放入 Monadic 结构中（类似于 wrap 和前面看到的 empty 函数）。对于 Monad 的实现来说，该函数也被称为 of 函数。</li><li>bind 函数: 可以链式操作，后文将使用更简短的 map。</li><li>join 函数: 将两层 Monadic 结构合并成一层。这会对嵌套返回 Monad 的函数特别有用。<br>将这一个接口应用到 Wrapper 类型，就可以重构成以下这种形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// unit 函数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">a</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wrapper(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bind 函数（ Functor）</span></span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> Wrapper.of(f(<span class="built_in">this</span>.value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 压平嵌套的 Wrapper</span></span><br><span class="line">  <span class="function"><span class="title">join</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(!(<span class="built_in">this</span>.value <span class="keyword">instanceof</span> Wrapper)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.value.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个当前结构的文本描述</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Wrapper (<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 使用 Functor 的 map 将数据提升到容器中，这样就可以无任何副作用。通常还可以用_.identity 函数来检查其内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wrapper.of(<span class="string">&#x27;Hello Monads!&#x27;</span>)</span><br><span class="line">.map(R.toUpper)</span><br><span class="line">.map(R.identity); <span class="comment">//-&gt; Wrapper(&#x27;HELLO MONADS!&#x27;)</span></span><br></pre></td></tr></table></figure><p>map 操作被视为一种中立的 functor，因为它无非只是映射函数到对象，然后关闭它。之后，Monad 给map 加入特殊的功能。join 函数用于逐层扁平化嵌套结构，就像剥洋葱一样。这可以用来消除之前用functor 时发现的问题，如下 所示。<br>扁平化 Monadic 结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findObject :: DB -&gt; String -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> findObject = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(find(db, id));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// getAddress :: Student -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(student.map(R.prop(<span class="string">&#x27;address&#x27;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> studentAddress = R.compose(getAddress, findObject(DB(<span class="string">&#x27;student&#x27;</span>)));</span><br><span class="line">studentAddress(<span class="string">&#x27;444-44-4444&#x27;</span>).join().get(); <span class="comment">// Address</span></span><br></pre></td></tr></table></figure><p>该代码返回一组嵌套的 wrapper，其中 join 操作用于将这种嵌套结构压平成单一的层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper.of(Wrapper.of(Wrapper.of(<span class="string">&#x27;Get Functional&#x27;</span>))).join();</span><br><span class="line"><span class="comment">//-&gt; Wrapper(&#x27;Get Functional&#x27;)</span></span><br></pre></td></tr></table></figure><p>图 6 为 join 操作的示意图，递归扁平化嵌套结构的 Monad，像剥洋葱一样：</p><p><img src="https://i.loli.net/2021/08/08/dAocQ8O6PJMTUVk.png"></p><p>Monad 通常有更多的操作，这里提及的最小接口只是其整个 API 的子集。一个 Monad 本身只是抽象，没有任何实际意义。只有实际的实现类型才有丰富的功能。大多数函数式编程的代码只用一些常用的类型就可以消除大量的样板代码，同时还能完成同样的工作。</p><p>Monad 实例丰富，例如：Maybe、Either 和 IO，大家有兴趣可以自行查看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>面向对象抛异常的机制让函数变得不纯，把大部分的责任都推到了调用者的尝试——try-catch逻辑上</li><li>把值包裹到容器中的模式是为了构建无副作用的代码，把可能不纯的变化包裹成引用透明的过程</li><li>使用Functor将函数应用到容器中的值，这是无副作用地、不可变地访问和修改操作</li><li>Monad是函数式中用来降低应用复杂度的设计模式，通过这种模式可以将函数编排成安全的数据流程</li><li>交错的组合函数和Monadic类型是非常有弹性而且强大的，如Maybe、Either和IO</li></ul><p><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html">阮一峰：图解 Monad</a><br><a href="https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">阮一峰：函数式编程入门教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;四-函数式编程——针对复杂应用的设计模式&quot;&gt;&lt;a href=&quot;#四-函数式编程</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（三）</title>
    <link href="http://example.com/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-03-05T06:33:22.000Z</published>
    <updated>2021-08-08T03:26:48.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h1 id="三-函数式编程——模块化且可重用的代码"><a href="#三-函数式编程——模块化且可重用的代码" class="headerlink" title="三.函数式编程——模块化且可重用的代码"></a>三.函数式编程——模块化且可重用的代码</h1><p>（读书笔记：JavaScript函数式编程指南）</p><p>今日分享</p><ul><li>方法链与函数管道的比较</li><li>管道函数的兼容条件</li><li>柯里化的函数求值</li><li>部分应用和函数绑定（略）</li></ul><h2 id="1-方法链与函数管道的比较"><a href="#1-方法链与函数管道的比较" class="headerlink" title="1 方法链与函数管道的比较"></a>1 方法链与函数管道的比较</h2><p>之前提到了连接一系列函数的方法链，从而揭示了一种与众不同的函数式编程风格。还有一种称为管道的方法也可以用来连接函数。</p><p>函数的输入和输出对于了解函数本身是十分重要的。<code>Haskell</code>（发音为/ˈhæskəl/）中使用一种符号来描述函数。<br>如图一：</p><p><img src="https://i.loli.net/2021/08/08/tnKNhbJXykumAFe.png"></p><p>在函数式编程中，函数是输入和输出类型之间的数学映射。举例来说，一个简单的函数 isEmpty，它接收一个字符串并返回一个布尔值，就像这样表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isEmpty :: <span class="built_in">String</span> -&gt; <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><p>如图二：</p><p><img src="https://i.loli.net/2021/08/08/zD8JNZ3AucwUmQ1.png"></p><p>该函数是所有 String 类型输入值到所有 Boolean 值之间的引用透明映射。该函数<code>JavaScript</code>的<code>lambda</code>描述形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isEmpty :: String -&gt; Boolean</span></span><br><span class="line"><span class="keyword">const</span> isEmpty = <span class="function">(<span class="params">s</span>) =&gt;</span> !s || !s.trim();</span><br></pre></td></tr></table></figure><p>了解函数作为类型映射的性质是理解如何将函数链接和管道化的关键:</p><ul><li>方法链接（紧耦合，有限的表现力）</li><li>函数的管道化（松耦合，灵活）</li></ul><h3 id="1-1-方法链接"><a href="#1-1-方法链接" class="headerlink" title="1.1 方法链接"></a>1.1 方法链接</h3><p><code>map</code>和<code>filter</code>函数都以一个数组作为输入并返回一个新的数组。这些函数都可以通过<code>Lodash</code>封装的隐式对象紧密地连接在一起，从而在后台实现对新数据结构的创建。<br>这是上一次分享中一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names) <span class="comment">//&lt;--- 初始化函数链（创建惰性计算函数链来处理给定的数组）</span></span><br><span class="line">  .filter(isValid) <span class="comment">//&lt;--- 去除非法值</span></span><br><span class="line">  .map(<span class="function">(<span class="params">s</span>) =&gt;</span> s.replace(<span class="regexp">/_/</span>, <span class="string">&quot; &quot;</span>)) <span class="comment">//&lt;--- 规范化值</span></span><br><span class="line">  .uniq() <span class="comment">// &lt;---去掉重复元素</span></span><br><span class="line">  .map(_.startCase) <span class="comment">//&lt;--- 大写首字母</span></span><br><span class="line">  .sort()</span><br><span class="line">  .value(); <span class="comment">//&lt;--- 执行函数链中的所有函数</span></span><br><span class="line"><span class="comment">//-&gt; [&#x27;Alonzo Church&#x27;, &#x27;Haskell Curry&#x27;, &#x27;Jon Von Neumann&#x27;, &#x27;Stephen Kleene&#x27;]</span></span><br></pre></td></tr></table></figure><p>比较命令式代码，这的确是一个能够极大提高代码可读性的语法改进。然而，它与方法所属的对象紧紧地耦合在一起，限制链中可以使用的方法数量，也就限制了代码的表现力。这样就只能够使用由<code>Lodash</code>提供的操作，而无法轻松地将不同函数库的（或自定义的）函数连接在一起。(尽管使用 mixin 的方法可以扩展一个对象的功能，但这就需要自己去管理 mixin 对象本身。这里不做讨论)</p><p>从高阶函数角度来看，可以一组对数组操作的简单方法序列表示为图三所示的形式。打破函数链的约束就能够自由地排列所有独立的函数操作，而可以使用函数管道来实现这一目的。</p><p><img src="https://i.loli.net/2021/08/08/FMG4nCA3bhuK81v.png"></p><h3 id="1-2-函数的管道化"><a href="#1-2-函数的管道化" class="headerlink" title="1.2 函数的管道化"></a>1.2 函数的管道化</h3><p>函数式编程能够消除方法链中存在的限制，使得任何函数的组合都更加灵活。管道是松散结合的有向函数序列，一个函数的输出会作为下一个函数的输入。图四抽象地说明了以不同类型对象作为输入的函数的连接方式。</p><p><img src="https://i.loli.net/2021/08/08/1zSkQ9sacgx3ODE.png"></p><p>这也是面向对象设计模式中的管道与过滤器模式，它是从函数式编程衍变而来的（其中的过滤器就是各个函数）。</p><p>比较图三和图四就会发现一个关键的区别：方法链接通过对象的方法紧密连接；而管道以函数作为组件，将函数的输入和输出松散地连接在一起。但是，为了实现管道，被连接的函数必须在元数（arity）和类型上相互兼容。</p><h2 id="2-管道函数的兼容条件"><a href="#2-管道函数的兼容条件" class="headerlink" title="2 管道函数的兼容条件"></a>2 管道函数的兼容条件</h2><p>面向对象的编程在一些特定情况下（其中之一是认证与授权）偶尔会使用管道。而函数式编程将管道视为构建程序的唯一方法。</p><p>通常来说，对于不同的任务，问题的定义与解决方案间总是存在很大的差异。因此，特定的计算必须在特定的阶段进行。这些阶段由不同的函数表征，而所选函数的输入和输出需要满足以下两个兼容条件。</p><ul><li>类型——函数的返回类型必须与接收函数的参数类型相匹配。</li><li>元数——接收函数必须声明至少一个参数才能处理上一个函数的返回值。</li></ul><h3 id="2-1-函数的类型兼容条件"><a href="#2-1-函数的类型兼容条件" class="headerlink" title="2.1 函数的类型兼容条件"></a>2.1 函数的类型兼容条件</h3><p>在设计函数管道时，函数的返回类型与函数的接收参数之间具有一定程度的兼容性是极其重要的。</p><p>由于<code>JavaScirpt</code>是弱类型语言，因此从类型角度来看，无须像使用一些静态类型语言一样太过关注类型。因此，如果一个对象在应用中表现得像某个特定类型，那么它就是该类型。这也被称为鸭子类型：“如果走起来像鸭子，并且像鸭子一样叫，那这就是一只鸭子。”</p><p><code>JavaScript</code>的动态调度机制会尝试在对象中查找属性与方法，而不关注类型信息。虽然这非常灵活，但开发者仍然需要了解一个函数所期望的参数类型。使用清晰的定义（例如在代码中使用 <code>Haskell</code> 符号标记）可以使程序更易理解。</p><p>正式地讲，仅当 f 的输出类型等同于函数 g 的输入时，两个函数 f 和 g 是类型兼容的。举例来说，一个处理用户输入的简单程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trim :: <span class="built_in">String</span> -&gt; <span class="built_in">String</span> &lt;--- 截掉首末空白符</span><br><span class="line"><span class="attr">normalize</span> :: <span class="built_in">String</span> -&gt; <span class="built_in">String</span> &lt;--- 去除横线</span><br></pre></td></tr></table></figure><p>此时，<code>normalize</code>的输入与<code>trim</code>的输出服从兼容性的对应关系，因此可以在一个简单的管道序列中调用它们:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trim :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> trim = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// normalize :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> normalize = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/\-/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">normalize(trim(<span class="string">&quot; 444-44-4444 &quot;</span>));</span><br><span class="line"><span class="comment">//-&gt; &#x27;444444444&#x27; &lt;--- 手动构建系列管道调用两个函数（之后会涉及如何自动化这一过程）。使用带有首末空白符的输入测试</span></span><br></pre></td></tr></table></figure><p>类型固然重要，但在<code>JavaScript</code>中，更关键的是函数元数的兼容性。</p><h2 id="2-2-函数与元数：元组的应用"><a href="#2-2-函数与元数：元组的应用" class="headerlink" title="2.2 函数与元数：元组的应用"></a>2.2 函数与元数：元组的应用</h2><p>元数定义为函数所接收的参数数量，也被称为函数的长度（length）。尽管在其他编程范式中，元数是最基本的，但在函数式编程中，引用透明的必然结果就是，声明的函数参数数量往往与其复杂性成正比。例如，操作一个字符串的函数很可能比具有 3 个或 4 个参数的函数简单得多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isValid :: String -&gt; Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValid</span>(<span class="params">str</span>) </span>&#123; &lt;--- 使用简单</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// makeAsyncHttp:: String, String, Array -&gt; Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAsyncHttp</span> (<span class="params">method, url, data</span>) </span>&#123; <span class="comment">//&lt;--- 难以使用，因为必须先计算出所有参数</span></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只具有单一参数的纯函数是最简单的，因为其实现目的非常单纯，也就意味着职责单一。因此，应该尽可能地使用具有少量参数的函数，这样的函数更加灵活和通用。然而，总是使用一元函数并非那么容易。例如，在真实世界中，isValid 函数可能会额外返回一个描述错误信息的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isValid :: <span class="built_in">String</span> -&gt; (<span class="built_in">Boolean</span>, <span class="built_in">String</span>) <span class="comment">// &lt;--- 返回含有验证状态或错误信息的结构体</span></span><br><span class="line">isValid(<span class="string">&#x27; 444-444-44444&#x27;</span>); <span class="comment">//-&gt; (false, &#x27;Input is too long!&#x27;)</span></span><br></pre></td></tr></table></figure><p>但如何返回两个不同的值呢？函数式语言通过一个称为元组的结构来做到这一点。元组是有限的、有序的元素列表，通常由两个或三个值成组出现，记为<code>(a, b,c)</code>。由此，可以使用一个元组作为<code>isValid</code>函数的返回值——它将状态与可能的错误消息捆绑，作为单个实体返回，并随后传递到另一个函数中（如果需要的话）。</p><p>下面详细探讨一下元组。元组是不可变的结构，它将不同类型的元素打包在一起，以便将它们传递到其他函数中。将数据打包返回的方式还包括字面对象或数组等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">status</span> : <span class="literal">false</span>, or <span class="keyword">return</span> [<span class="literal">false</span>, <span class="string">&#x27;Input is too long!&#x27;</span>];</span><br><span class="line">message: <span class="string">&#x27;Input is too long!&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但当涉及函数间的数据传输时，元组能够具有更多的优点。</p><ul><li>不可变的——一旦创建，就无法改变一个元组的内部内容。</li><li>避免创建临时类型——元组可以将可能毫不相关的数据相关联。而定义和实例化一些仅用于数据分组的新类型使得模型复杂并令人费解。</li><li>避免创建异构数组——包含不同类型元素的数组使用起来颇为困难，因为会导致代码中充满大量的防御性类型检查。传统上，数组意在存储相同类型的对象。</li></ul><p><code>JavaScript</code>并不原生地支持<code>Tuple</code>数据类型。例如，给定一个<code>Scala</code>中的元组定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = (<span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>);</span><br></pre></td></tr></table></figure><p>可以像这样访问各个元素：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumAnglesTriangle = (t._1 + t._2 + t._3 = <span class="number">180</span>);</span><br></pre></td></tr></table></figure><p>但是<code>JavaScript</code>已经提供了实现元组所需的所有工具,实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Tuple = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="comment">/* types */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> typeInfo = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>); <span class="comment">// &lt;--- 读取参数作为元组的元素类型</span></span><br><span class="line">  <span class="keyword">const</span> _T = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="comment">/* values */</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;--- 声明内部类型_T，以保障类型与值匹配</span></span><br><span class="line">    <span class="keyword">const</span> values = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>); <span class="comment">// &lt;--- 提取参数作为元组内的值</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      values.some(</span><br><span class="line">        <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">          val <span class="comment">// &lt;--- 检查非空值。函数式数据类型不允许空值</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>) =&gt;</span> val === <span class="literal">null</span> || val === <span class="literal">undefined</span></span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;Tuples may not have any null values&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (values.length !== typeInfo.length) &#123;</span><br><span class="line">      <span class="comment">// &lt;--- 按照定义类型的个数检查元组的元数</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Tuple arity does not match its prototype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    values.map(<span class="function"><span class="keyword">function</span> (<span class="params">val, index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// &lt;--- 使用 checkType 检查每一个值都能匹配其类型定义。其中的元素都可以通过_n 获取， n 为元素的索引（注意是从 1 开始）</span></span><br><span class="line">      <span class="built_in">this</span>[<span class="string">&quot;_&quot;</span> + (index + <span class="number">1</span>)] = checkType(typeInfo[index])(val);</span><br><span class="line">    &#125;, <span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">Object</span>.freeze(<span class="built_in">this</span>); <span class="comment">// &lt;--- 让元组实例不可变</span></span><br><span class="line">  &#125;;</span><br><span class="line">  _T.prototype.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;--- 提取元组中的元素，也可以使用 ES6 的解构赋值把元素赋值到变量上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[k];</span><br><span class="line">    &#125;, <span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> _T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkType :: Type -&gt; Type -&gt; Type | TypeError</span></span><br><span class="line"><span class="keyword">const</span> checkType = curry2(<span class="function"><span class="keyword">function</span> (<span class="params">typeDef, actualType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (R.is(typeDef, actualType)) &#123;</span><br><span class="line">    <span class="comment">// &lt;--- 使用 R.is()检查类型信息</span></span><br><span class="line">    <span class="keyword">return</span> actualType;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">&quot;Type mismatch. Expected [&quot;</span> +</span><br><span class="line">        typeDef +</span><br><span class="line">        <span class="string">&quot;] but found [&quot;</span> +</span><br><span class="line">        <span class="keyword">typeof</span> actualType +</span><br><span class="line">        <span class="string">&quot;]&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="string">&quot;Curry&quot;</span>); <span class="comment">//-&gt; String</span></span><br><span class="line">checkType(<span class="built_in">Number</span>)(<span class="number">3</span>); <span class="comment">//-&gt; Number</span></span><br><span class="line">checkType(<span class="built_in">Date</span>)(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">//-&gt; Date</span></span><br><span class="line">checkType(<span class="built_in">Object</span>)(&#123;&#125;); <span class="comment">//-&gt; Object</span></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="number">42</span>); <span class="comment">//-&gt; Throws TypeError</span></span><br></pre></td></tr></table></figure><p>上面定义的元组对象是不可变且长度固定的数据结构，是可用于在函数间通讯的存储了 n 个不同类型值的异构集合。举例来说，可以用元组来快速构建如<code>Status</code>这样的值对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Status = Tuple(<span class="built_in">Boolean</span>, <span class="built_in">String</span>);</span><br></pre></td></tr></table></figure><p>下面利用元组来完成用户输入验证：使用了元组的 isValid 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trim :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> trim = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// normalize :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> normalize = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/\-/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// isValid :: String -&gt; Status</span></span><br><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Status(<span class="literal">false</span>, <span class="string">&quot;Invald input. Expected non-empty value!&quot;</span>); <span class="comment">// &lt;--- 声明包含状态（ Boolean）和消息（ String）的类型Status</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Status(<span class="literal">true</span>, <span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">isValid(normalize(strim(<span class="string">&quot;444-44-4444&quot;</span>))); <span class="comment">//-&gt; (true, &#x27;Success!&#x27;)</span></span><br></pre></td></tr></table></figure><p>在软件开发过程中，二元组出现得非常频繁，将其设定为一等的对象非常具有实际意义。在<code>ES6</code>解构赋值特性的支持下，可以简明地将元组值映射到变量中。如下代码使用元组创建了一个名为<code>StringPair</code>的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StringPair = Tuple(<span class="built_in">String</span>, <span class="built_in">String</span>);</span><br><span class="line"><span class="keyword">const</span> name = <span class="keyword">new</span> StringPair(<span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>);</span><br><span class="line">[first, last] = name.values();</span><br><span class="line">first; <span class="comment">//-&gt; &#x27;Barkley&#x27;</span></span><br><span class="line">last; <span class="comment">//-&gt; &#x27;Rosser&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fullname = <span class="keyword">new</span> StringPair(<span class="string">&quot;J&quot;</span>, <span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>); <span class="comment">// &lt;--- 抛出元素不匹配的错误</span></span><br></pre></td></tr></table></figure><p>元组是减少函数元数的方式之一，但还可以使用更好的方式去应对那些不适于元组的情况。通过引入函数柯里化不仅可以降低元数，还可以增强代码的模块化和可重用性。</p><h2 id="3-柯里化的函数求值"><a href="#3-柯里化的函数求值" class="headerlink" title="3 柯里化的函数求值"></a>3 柯里化的函数求值</h2><p>将函数的返回值作为参数传递给一元函数是十分容易的，但如果目标函数需要更多参数呢？</p><p>为了理解<code>JavaScript</code>的柯里化，首先必须了解柯里化的求值和常规（非柯里化的）求值之间的区别。</p><p><code>JavaScript</code>是允许在缺少参数的情况下对常规或非柯里化函数进行调用的。换句话说，如果定义一个函数<code>f(a, b, c)</code>，并只在调用时传递<code>a</code>，<code>JavaScript</code>运行时的调用机制会将<code>b</code>和<code>c</code>设为<code>undefined</code>。如图五：</p><p><img src="https://i.loli.net/2021/08/08/nlyjCQxwFL8kYpS.png"></p><p>再看柯里化函数，它要求所有参数都被明确地定义，因此当使用部分参数调用时，它会返回一个新的函数，在真正运行之前等待外部提供其余的参数。图六能够直观地表现这一点：</p><p><img src="https://i.loli.net/2021/08/08/a4dMPNFtcZzWObu.png"></p><p>柯里化是一种在所有参数被提供之前，挂起或“延迟”函数执行，将多参函数转换为一元函数序列的技术。具有三个参数的柯里化函数的定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curry(f) :: (a,b,c) -&gt; f(a) -&gt; f(b)-&gt; f(c)</span><br></pre></td></tr></table></figure><p>以上符号描述表明，<code>curry</code>是一种从函数到函数的映射，将输入<code>(a, b, c)</code>分解为多个分离的单参数调用。在纯函数式编程语言中（如<code>Haskell</code>），柯里化是原生特性，是任何函数定义中的组成部分。由于<code>JavaScript</code>原生不支持柯里化函数，因此需要编写一些代码来实现它。</p><p>我们先从二元参数的手动柯里化例子开始，代码如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">firstArg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;--- 第一次调用 curry2，获得第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">secondArg</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// &lt;--- 第二次调用获得第二个参数</span></span><br><span class="line">      <span class="keyword">return</span> fn(firstArg, secondArg); <span class="comment">// &lt;--- 将两个参数应用到函数 fn 上</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化是一种词法作用域（闭包），其返回的函数只不过是一个接收后续参数的简单嵌套函数包装器。以下是一个简单应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = curry2(<span class="function"><span class="keyword">function</span> (<span class="params">last, first</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StringPair(<span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">[first, last] = name(<span class="string">&quot;Curry&quot;</span>)(<span class="string">&quot;Haskell&quot;</span>).values(); <span class="comment">// &lt;--- 当给定两个参数时，函数会完全求值</span></span><br><span class="line">first; <span class="comment">//-&gt; &#x27;Curry&#x27;</span></span><br><span class="line">last; <span class="comment">//-&gt; &#x27;Haskell&#x27;</span></span><br><span class="line">name(<span class="string">&quot;Curry&quot;</span>); <span class="comment">//-&gt; Function &lt;--- 当只提供一个参数时，返回一个函数，而不是将第二个参数当作 undefined</span></span><br></pre></td></tr></table></figure><p>curry2 能够胜任简单的任务，但是当构建更复杂的功能时，就需要能够自动处理任意数量参数的柯里化函数。</p><p><code>curry</code>是一个很长且复杂的函数，因此与其去解释它令人头疼的实现，不如讨论更为有用的东西（者可以在<code>Lodash</code>和<code>Ramda</code>中找到<code>curry</code>及其另两个版本<code>curryRight</code>和<code>curryN</code>的实现）。可以使用<code>R.curry</code>对任意数量参数的函数进行自动的柯里化。</p><p>可以将自动柯里化想象为基于声明参数的数量人工创建对应嵌套函数作用域的过程。柯里化<code>fullname</code>函数如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fullname :: (String, String) -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> fullname = <span class="function"><span class="keyword">function</span> (<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个参数会被通过如下形式转换成多个一元函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fullname :: String -&gt; String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> fullname =<span class="function"><span class="keyword">function</span> (<span class="params">first</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">last</span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看一些柯里化的实际应用。尤其是，它可以用于实现以下两种流行的设计模式。</p><ul><li>仿真函数接口</li><li>实现可重用模块化函数模板</li></ul><h3 id="3-1-仿真函数工厂"><a href="#3-1-仿真函数工厂" class="headerlink" title="3.1 仿真函数工厂"></a>3.1 仿真函数工厂</h3><p>在面向对象世界中，接口是用于定义子类必须实现的契约抽象类型。如果创建的接口包含函数<code>findStudent(id)</code>，那么实体类必须实现此函数。下面这段<code>Java</code>示例代码说明了这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentStore</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">findStudent</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbStudentStore</span> <span class="keyword">implements</span> <span class="title">StudentStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudent</span><span class="params">(String ssn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ResultSet rs = jdbcStmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            String id = rs.getString(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">&quot;firstname&quot;</span>) +</span><br><span class="line">            rs.getString(<span class="string">&quot;lastanme&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(id, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStudentStore</span> <span class="keyword">implements</span> <span class="title">StudentStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudent</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码显示了同一个接口的两个实现：一个从数据库读取；另一个从缓存读取。</p><p>但是从调用代码的角度来看，它只关心方法的调用而并不关心来自哪个对象。这就是面向对象设计模式中工厂方法模式的美妙之处。只要使用一个函数工厂就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentStore store = getStudentStore();</span><br><span class="line">store.findStudent(<span class="string">&quot;444-44-4444&quot;</span>);</span><br></pre></td></tr></table></figure><p>当然，函数式编程的实现是不容错过的，其解决方案就是柯里化。通过分别创建在存储数据和数组中查找学生对象的函数，就能够将这段<code>Java</code>代码翻译为<code>JavaScript</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchStudentFromDb :: DB -&gt; (String -&gt; Student)</span></span><br><span class="line"><span class="keyword">const</span> fetchStudentFromDb = R.curry(<span class="function"><span class="keyword">function</span> (<span class="params">db, ssn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;--- 在 DB对象中查找</span></span><br><span class="line">  <span class="keyword">return</span> find(db, ssn);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// fetchStudentFromArray :: Array -&gt; (String -&gt; Student)</span></span><br><span class="line"><span class="keyword">const</span> fetchStudentFromArray = R.curry(<span class="function"><span class="keyword">function</span> (<span class="params">arr, ssn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;--- 在数组中查找</span></span><br><span class="line">  <span class="keyword">return</span> arr[ssn];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于这两个函数都是柯里化的，因此可以使用一个通用工厂方法<code>findStudent</code>将函数的定义与求值分离，而其具体的实现细节可能是任意一个查找函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findStudent = useDb ? fetchStudentFromDb(db) : fetchStudentFromArray(arr);</span><br><span class="line">findStudent(<span class="string">&quot;444-44-4444&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在<code>findStudent</code>可以传递给其他模块，而其调用者无须了解其具体实现。从可重用的角度来看，柯里化也能够帮助开发者创建函数模板。</p><h3 id="3-2-创建可重用的函数模板"><a href="#3-2-创建可重用的函数模板" class="headerlink" title="3.2 创建可重用的函数模板"></a>3.2 创建可重用的函数模板</h3><p>假设开发者需要配置不同的日志函数来处理应用程序中的不同状态，比如错误、警告以及调试信息等。函数模板会根据创建时的参数数量来定义一系列的相关函数。这里用一个日志相关的库<code>Log4js</code>举例子。以下是一些基本设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Log4js.getLogger(<span class="string">&quot;StudentEvents&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;Student added successfully!&quot;</span>);</span><br></pre></td></tr></table></figure><p>在<code>Log4js</code>的辅助下，还可以做到更多。假设需要在弹出的窗口中显示消息，可以通过配置一个<code>appender</code>来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.addAppender(<span class="keyword">new</span> Log4js.JSAlertAppender());</span><br></pre></td></tr></table></figure><p>也可以通过配置一个布局，使其输出 JSON 而不是纯文本格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appender.setLayout(<span class="keyword">new</span> Log4js.JSONLayout());</span><br></pre></td></tr></table></figure><p>开发者可能设置很多的配置，而将这些代码复制并粘贴到每个文件中会导致大量重复。使用柯里化来定义一个可重用的函数模板（如下所示的日志函数模板），将带来最大的灵活性和重用性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="keyword">function</span> (<span class="params">appender, layout, name, level, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> appenders = &#123;</span><br><span class="line">    <span class="comment">// &lt;--- 预设 appenders</span></span><br><span class="line">    <span class="attr">alert</span>: <span class="keyword">new</span> Log4js.JSAlertAppender(),</span><br><span class="line">    <span class="attr">console</span>: <span class="keyword">new</span> Log4js.BrowserConsoleAppender(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> layouts = &#123;</span><br><span class="line">    <span class="comment">// &lt;--- 预设布局layouts</span></span><br><span class="line">    <span class="attr">basic</span>: <span class="keyword">new</span> Log4js.BasicLayout(),</span><br><span class="line">    <span class="attr">json</span>: <span class="keyword">new</span> Log4js.JSONLayout(),</span><br><span class="line">    <span class="attr">xml</span>: <span class="keyword">new</span> Log4js.XMLLayout(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> appender = appenders[appender];</span><br><span class="line">  appender.setLayout(layouts[layout]);</span><br><span class="line">  <span class="keyword">const</span> logger = <span class="keyword">new</span> Log4js.getLogger(name);</span><br><span class="line">  logger.addAppender(appender);</span><br><span class="line">  logger.log(level, message, <span class="literal">null</span>); <span class="comment">// &lt;--- 使用配置好的logger 打印消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过柯里化 logger，可以集中管理和重用适用于任何场合的日志配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = R.curry(logger)(<span class="string">&quot;alert&quot;</span>, <span class="string">&quot;json&quot;</span>, <span class="string">&quot;FJS&quot;</span>);</span><br><span class="line">log(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;Error condition detected!!&quot;</span>);</span><br><span class="line"><span class="comment">// -&gt; this will popup an alert dialog with the requested message</span></span><br></pre></td></tr></table></figure><p>如果要在一个函数或文件中记录多条错误日志，可以灵活地设置除最后一个参数之外的其他参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logError = R.curry(logger)(<span class="string">&quot;console&quot;</span>, <span class="string">&quot;basic&quot;</span>, <span class="string">&quot;FJS&quot;</span>, <span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">logError(<span class="string">&quot;Error code 404 detected!!&quot;</span>);</span><br><span class="line">logError(<span class="string">&quot;Error code 402 detected!!&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>curry</code>函数的后续调用在后台被执行，最终生产一个一元函数。事实上，可以通过现有的函数创建新函数，并将任意数量的参数传递给它们，从而逐步实现函数构建。除了能够有效提升代码的可重用性之外，将多元函数转换为一元函数才是柯里化的主要动机。</p><p>柯里化的可替代方案是部分应用和函数绑定，它们受到<code>JavaScript</code>语言的适度支持，以产生更小的功能，在插入功能管道时也能很好地工作。</p><h2 id="4-部分应用和函数绑定"><a href="#4-部分应用和函数绑定" class="headerlink" title="4 部分应用和函数绑定"></a>4 部分应用和函数绑定</h2><p>部分应用是一种通过将函数的不可变参数子集初始化为固定值来创建更小元数函数的操作。简单来说，如果存在一个具有五个参数的函数，给出三个参数后，就会得到一个、两个参数的函数。和柯里化一样，部分应用也可以用来缩短函数的长度，但又稍有不同。因为柯里化的函数本质上是部分应用的函数，所以这两种技术往往会被互相混淆。它们的主要区别在于参数传递的内部机制与控制。</p><p>柯里化在每次分步调用时都会生成嵌套的一元函数。在底层，函数的最终结果是由这些一元函数的逐步组合产生的。同时，curry 的变体允许同时传递一部分参数。因此，可以完全控制函数求值的时间与方式。</p><p>部分应用将函数的参数与一些预设值绑定（赋值），从而产生一个拥有更少参数的新函数。该函数的闭包中包含了这些已赋值的参数，在之后的调用中被完全求值。</p><p>现在，既然已经明确两者的不同，下面继续研究<code>partial</code>函数可能的实现方式，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">this</span>, boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">let</span> placeholder = &lt;&lt;partialPlaceholderObj&gt;&gt;; <span class="comment">// &lt;--- 库中的具体占位符实现，像 Lodash 会使用下画线对象作为占位符。其他的实现使用 undefined 来表示应该略过该参数</span></span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;--- 使用部分应用的参数创建新的函数</span></span><br><span class="line">        <span class="keyword">let</span> position = <span class="number">0</span>, length = args.length;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            args[i] = boundArgs[i] === placeholder <span class="comment">// &lt;--- 其中 placeholder 对象略过了定义函数的参数</span></span><br><span class="line">            ? <span class="built_in">arguments</span>[position++] : boundArgs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (position &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            args.push(<span class="built_in">arguments</span>[position++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args); <span class="comment">// &lt;--- 使用 fn.apply()给定函数合适的上下文，并将参数列表应用到函数的参数上</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于部分应用和函数绑定的讨论，再次使用<code>Lodash</code>，因为它对函数绑定提供了比<code>Ramda</code>更好的支持。然而从表面来看，<code>_.partial</code>与<code>R.curry</code>的使用方式非常相似，并且都支持使用各自的占位符对象对参数进行占位。应用于之前看到的 logger 函数，就通过部分应用部分参数来创建更具体的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> consoleLog = _.partial(logger, <span class="string">&quot;console&quot;</span>, <span class="string">&quot;json&quot;</span>, <span class="string">&quot;FJS Partial&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面用该函数加强对<code>curry</code>与<code>partial</code>之间差异的认识。在应用了三个参数之后，生成的<code>consoleLog</code>函数会在调用时接收另外的两个参数（一次性的，而不是一步一步地传入）。与柯里化不同，只使用一个参数调用<code>consoleLog</code>并不会返回一个新的函数，而是会以<code>undefined</code>作为最后一个参数<br>来执行。但是，可以像下面这样继续使用_.partial 将部分参数应用于<code>consoleLog</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> consoleInfoLog = _.partial(consoleLog, <span class="string">&quot;INFO&quot;</span>);</span><br><span class="line">consoleInfoLog(<span class="string">&quot;INFO logger configured with partial&quot;</span>);</span><br></pre></td></tr></table></figure><p>柯里化是一种部分应用的自动化使用方式，这是它与<code>partial</code>本身的主要区别。另一种类似的<code>JavaScript</code>原生技术称为函数绑定，即<code>Function.prototype.bind()</code>。但其作用与<code>partial</code>有所不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = _.bind(logger, <span class="literal">undefined</span>, <span class="string">&quot;console&quot;</span>, <span class="string">&quot;json&quot;</span>, <span class="string">&quot;FJS Binding&quot;</span>);</span><br><span class="line">log(<span class="string">&quot;WARN&quot;</span>, <span class="string">&quot;FP is too awesome!&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>_.bind</code>的第二个参数<code>undefined</code>是什么呢？使用绑定能够创建绑定函数，该函数可在一个所属对象的上下文中执行（传递<code>undefined</code>表示该函数将在全局作用域中运行）。来看看<code>_.partial</code>和<code>_.bind</code>的一些实际用途：</p><ul><li>核心语言扩展</li><li>惰性函数绑定</li></ul><h3 id="4-1-核心语言扩展"><a href="#4-1-核心语言扩展" class="headerlink" title="4.1 核心语言扩展"></a>4.1 核心语言扩展</h3><p>在增强语言的表现力方面，部分应用可用于扩展如 String 或 Number 这样的核心数据类型的实用功能。注意，如果语言中加入了可造成冲突的新方法，以这种方式扩展语言可能会使代码很难在平台升级的过程中移植。考虑下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Take the first N characters</span></span><br><span class="line"><span class="built_in">String</span>.prototype.first = _.partial(<span class="built_in">String</span>.prototype.substring, <span class="number">0</span>, _); <span class="comment">// &lt;--- 使用占位符，可以部分应用 substring 一个参数 0，从而创建期待一个偏移量参数的函数</span></span><br><span class="line"><span class="string">&quot;Functional Programming&quot;</span>.first(<span class="number">3</span>); <span class="comment">// -&gt; &#x27;Fun&#x27;</span></span><br><span class="line"><span class="comment">// Convert any name into a Last, First format</span></span><br><span class="line"><span class="built_in">String</span>.prototype.asName = _.partial(</span><br><span class="line">  <span class="built_in">String</span>.prototype.replace,</span><br><span class="line">  <span class="regexp">/(\w+)\s(\w+)/</span>,</span><br><span class="line">  <span class="string">&quot;$2, $1&quot;</span></span><br><span class="line">); <span class="comment">// &lt;--- 部分应用参数来创建具体的行为</span></span><br><span class="line"><span class="string">&quot;Alonzo Church&quot;</span>.asName(); <span class="comment">//-&gt; &#x27;Church, Alonzo&#x27;</span></span><br><span class="line"><span class="comment">// Converts a string into an array</span></span><br><span class="line"><span class="built_in">String</span>.prototype.explode = _.partial(<span class="built_in">String</span>.prototype.match, <span class="regexp">/[\w]/gi</span>); <span class="comment">// &lt;--- 部分应用 match 方法，给定具体的正则表达式，得到能将字符串转换成数组的函数</span></span><br><span class="line"><span class="string">&quot;ABC&quot;</span>.explode(); <span class="comment">//-&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line"><span class="comment">// Parses a simple URL</span></span><br><span class="line"><span class="built_in">String</span>.prototype.parseUrl = _.partial(</span><br><span class="line">  <span class="built_in">String</span>.prototype.match, <span class="comment">//&lt;--- 部分应用 match 方法，给定具体的正则表达式，得到能将字符串转换成数组的函数</span></span><br><span class="line">  <span class="regexp">/(http[s]?|ftp):\/\/([^:\/\s]+)\.([^:\/\s]&#123;2,5&#125;)/</span></span><br><span class="line">);</span><br><span class="line"><span class="string">&quot;http://example.com&quot;</span>.parseUrl(); <span class="comment">// -&gt; [&#x27;http&#x27;, &#x27;example&#x27;, &#x27;com&#x27;]</span></span><br></pre></td></tr></table></figure><p>在实现自己的函数之前，首先要进行存在性检查，以便适用于新的语言版本升级：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">String</span>.prototype.explode) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.explode = _.partial(<span class="built_in">String</span>.prototype.match, <span class="regexp">/[\w]/gi</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些特定情况下，部分应用会失效，例如当用于（如<code>setTimeout</code>）延迟函数时。这时就需要使用函数绑定来实现。</p><h3 id="4-2-延迟函数绑定"><a href="#4-2-延迟函数绑定" class="headerlink" title="4.2 延迟函数绑定"></a>4.2 延迟函数绑定</h3><p>当期望目标函数使用某个所属对象来执行时，使用函数绑定来设置上下文对象就变得尤为重要。</p><p>例如，浏览器中的<code>setTimeout</code>和<code>setInterval</code>等函数，如果不将 this 的引用设为全局上下文，即<code>window</code>对象，是不能正常工作的。传递 undefined 在运行时正确设置它们的上下文。例如，<code>setTimeout</code>可用于创建一个简单的调度对象来执行延迟的任务。以下是使用<code>_.bind</code> 和<code>_.partial</code>的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scheduler = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> delayedFn = _.bind(<span class="built_in">setTimeout</span>, <span class="literal">undefined</span>, _, _);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">delay5</span>: _.partial(delayedFn, _, <span class="number">5000</span>),</span><br><span class="line">    <span class="attr">delay10</span>: _.partial(delayedFn, _, <span class="number">10000</span>),</span><br><span class="line">    <span class="attr">delay</span>: _.partial(delayedFn, _, _),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Scheduler.delay5(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  consoleLog(<span class="string">&quot;Executing After 5 seconds!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>Scheduler</code>，可以将任何一段代码包含在函数体中延迟的执行（运行时是无法确保计时器的精准的，但这是另一个问题）。由于 <code>bind</code> 和 <code>partial</code> 都是返回另一个函数的函数，因此可以很容易地嵌套使用。如前面的代码所示，每一个延迟操作都基于函数绑定和部分应用函数的合。在函数式编程中，函数绑定并不像部分应用那么有用，而且使用起来也比较投机，因为它会重新设置函数的上下文。</p><p>部分应用和柯里化都是十分有用的技术。柯里化技术使用得非常广泛，通常用于创建可抽象函数行为的函数包装器，可预设其参数或对其部分求值。其优势源于具有较少参数的纯函数比较多参数的函数更易使用。两种方法都有助于向函数提供正确的参数，这样函数就不必在减少为一元函数时公然地访问其作用域之外的对象。这种分离参数获取逻辑的方式使得函数具有更好的可重用性。更重要的是，它简化了函数的组合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;三-函数式编程——模块化且可重用的代码&quot;&gt;&lt;a href=&quot;#三-函数式编程—</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（二）</title>
    <link href="http://example.com/2021/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2021/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-01-15T03:33:09.000Z</published>
    <updated>2021-08-08T03:05:36.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>今日分享: 如何创建易于推断的代码</p><h2 id="轻数据结构，重操作"><a href="#轻数据结构，重操作" class="headerlink" title="轻数据结构，重操作"></a>轻数据结构，重操作</h2><h3 id="理解程序中控制流"><a href="#理解程序中控制流" class="headerlink" title="理解程序中控制流"></a>理解程序中控制流</h3><p>程序为实现业务目标所要进行的路径被成为控制流。 命令式程序需要通过暴露所有的必要步骤才能极其详细地描述其控制流。这些步骤通常涉及大量的循环和分支，以及随语句执行变化的各种变量。</p><p>简单的命令式程序大致可以这样描述:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loop = optC();</span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">  <span class="keyword">var</span> condition = optA();</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    optB1();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    optB2();</span><br><span class="line">  &#125;</span><br><span class="line">  loop = optC();</span><br><span class="line">&#125;</span><br><span class="line">optD();</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://i.loli.net/2021/08/08/Oyv9LmXzZtJo4MS.png"></p><p>然而，声明式程序，特别是函数式程序，则多使用以简单拓扑连接的独立黑盒操作组合而成的较小结构化控制流，从而提升程序的抽象层次。</p><p>这些连接在一起的操作只是一些能够将状态传递至下一个操作的高阶函数，如下图所示。使用函数式开发风格操作数据结构，其实就是将数据与控制流视为一些高级组件的简单连接。</p><p>使用这种方式可以形成类似这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optA().optB().optC().optD();</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/08/qiv7BhkpG5K3ry2.png"></p><p>采用这种链式操作能够使程序简洁、流畅并富有表现力，能够从计算逻辑中很好地分离控制流，因此可以使得代码和数据更易推理。</p><h3 id="链接方法"><a href="#链接方法" class="headerlink" title="链接方法"></a>链接方法</h3><p>方法链是一种能够在一个语句中调用多个方法的面向对象编程模式。当这些方法属于同一个对象时，方法链又称为方法级联。</p><p>尽管该模式大多出现在面向对象的应用程序中，但在一些特定条件下，如操作不可变对象时，也能很好地用于函数式编程中。</p><p>既然在函数式代码中是禁止修改对象的，又如何能使用这种方法链模式呢？让我们来看一个字符串处理的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Functional Programming&quot;</span>.substring(<span class="number">0</span>, <span class="number">10</span>).toLowerCase() + <span class="string">&quot; is fun&quot;</span>;</span><br></pre></td></tr></table></figure><p>在这个中，<code>substring</code> 和 <code>toLowerCase</code> 都是（通过 this）在隶属的字符串对象上操作并返回一个新字符串的方法。JavaScript 中字符串的加号（+）运算符被重载为连接字符串操作的语法糖，它也会返回一个新的字符串。通过一系列变换后的结果与原先字符串毫无引用关系，而原先的字符串也不会有任何变化。</p><p>这种行为是理所当然的，因为按照设计，字符串是不可变的。从面向对象的角度来看，这没有什么特别的。但从函数式编程的角度来看，这是一种理想行为。</p><p>如果用更加函数式的风格重构上面的代码，它会像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(toLowerCase(substring(<span class="string">&#x27;Functional Programming&#x27;</span>, <span class="number">1</span>, <span class="number">10</span>))),<span class="string">&#x27; is fun&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这段代码符合函数式风格，所有参数都应在函数声明中明确定义，而且它没有副作用，也不会修改的原有对象。</p><p>但可以说，这样的代码写起来并没有方法链流畅。而且它也更难阅读，因为需要一层层地剥离外部函数，才能知晓内部真正发生的事情。</p><p>只要遵守不可变的编程原则，函数式中也会应用这种隶属于单个对象实例的方法链。能用该模式来处理数组变换吗？</p><h3 id="函数链"><a href="#函数链" class="headerlink" title="函数链"></a>函数链</h3><p>面向对象程序将继承作为代码重用的主要机制。子类继承了父类的所有状态和方法，例如在 Java 中，有一大堆继承于基础接口 List 的各种实体 List 类，如 ArrayList、LinkedList、DoublyLinkedList、CopyOnWrite ArrayList 等，它们都源自共同的父类，并各自添加了一些特定的功能。</p><p>函数式编程则采用了不同的方式。它不是通过创建一个全新的数据结构类型来满足特定的需求，而是使用如数组这样的普通类型，并施加在一套粗粒度的高阶操作之上，这些操作是底层数据形态所不可见的。</p><p>这些操作会作如下设计:</p><ul><li><p>接收函数作为参数，以便能够注入解决特定任务的特定行为。</p></li><li><p>代替充斥着临时变量与副作用的传统循环结构，从而减少所要维护以及可能出错的代码。</p></li></ul><p>继续之前，我们先看一些东西并暂时记住它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">firstname, lastname, ssn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._firstname = firstname;</span><br><span class="line">    <span class="built_in">this</span>._lastname = lastname;</span><br><span class="line">    <span class="built_in">this</span>._ssn = ssn;</span><br><span class="line">    <span class="built_in">this</span>._address = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>._birthYear = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">ssn</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._ssn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">firstname</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._firstname;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">lastname</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._lastname;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">address</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">birthYear</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._birthYear;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">birthYear</span>(<span class="params">year</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._birthYear = year;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">address</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._address = addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Person(<span class="subst">$&#123;<span class="built_in">this</span>._firstname&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>._lastname&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Haskell&quot;</span>, <span class="string">&quot;Curry&quot;</span>, <span class="string">&quot;111-11-1111&quot;</span>);</span><br><span class="line">p1.address = <span class="keyword">new</span> Address(<span class="string">&quot;US&quot;</span>);</span><br><span class="line">p1.birthYear = <span class="number">1900</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>, <span class="string">&quot;222-22-2222&quot;</span>);</span><br><span class="line">p2.address = <span class="keyword">new</span> Address(<span class="string">&quot;Greece&quot;</span>);</span><br><span class="line">p2.birthYear = <span class="number">1907</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;von Neumann&quot;</span>, <span class="string">&quot;333-33-3333&quot;</span>);</span><br><span class="line">p3.address = <span class="keyword">new</span> Address(<span class="string">&quot;Hungary&quot;</span>);</span><br><span class="line">p3.birthYear = <span class="number">1903</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> Person(<span class="string">&quot;Alonzo&quot;</span>, <span class="string">&quot;Church&quot;</span>, <span class="string">&quot;444-44-4444&quot;</span>);</span><br><span class="line">p4.address = <span class="keyword">new</span> Address(<span class="string">&quot;US&quot;</span>);</span><br><span class="line">p4.birthYear = <span class="number">1903</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/08/Guis8KPxqvYewbA.png"></p><h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>lambda 表达式（在 JavaScript 中也被称为箭头函数）源自函数式编程，比起传统的函数声明，它可以采用相对简洁的语法形式来声明一个匿名函数。</p><p>尽管 lambda 函数也可以写成多行形式，但单行是最普遍的形式。使用 lambda 表达式或普通函数声明语法一般只会影响到代码的可读性，其本质是一样的。</p><p>下面是一个可用于提取个人姓名的示例函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="function">(<span class="params">p</span>) =&gt;</span> p.fullname;</span><br><span class="line"><span class="built_in">console</span>.log(name(p1)); <span class="comment">//-&gt; &#x27;Haskell Curry&#x27;</span></span><br></pre></td></tr></table></figure><p><code>(P) =&gt; p.fullname</code> 这种简洁的语法糖表明它只接收一个参数 p 并隐式地返回 p.fullname。</p><p>lambda 表达式适用于函数式的函数定义，因为它总是需要返回一个值。对于单行表达式，其返回值就是函数体的值。</p><p>另一个值得注意的是一等函数与 lambda 表达式之间的关系。函数名代表的不是一个具体的值，而是一种（惰性计算的）可获取其值的描述。换句话说，函数名指向的是代表着如何计算该数据的箭头函数。这就是在函数式编程中可以将函数作为数值使用的原因。<br>之后会深入讨论惰性计算函数。</p><p>很多函数式的 JavaScript 代码都需要处理数据列表，这也就是衍生 JavaScript 的函数式语言鼻祖起名为 <code>LISP</code>（列表处理）的原因。JavaScript 5.1 本身就提供特定版本的该类操作——称为函数式<code>array extras</code>,也就是<code>forEach</code>、<code>map``reduce</code> 以及 <code>filter</code> 这些函数，它们都能够与 <code>lambda</code> 表达式良好地配合使用。</p><h3 id="代码推理"><a href="#代码推理" class="headerlink" title="代码推理"></a>代码推理</h3><p>“代码推理”到底是什么意思呢？</p><p>之前的章节用“松散”这个词来表征分析一个程序任何一个部分，并建立相应心智模型的难易程度。</p><p>该模型分为两部分：动态部分包括所有变量的状态和函数的输出，而静态部分包含可读性以及设计的表达水平。</p><p>两个部分都很重要。不可变性和纯函数会使得该模型的构建更加容易。之前的内容强调将高阶操作链接起来构成程序的价值。</p><p>命令式的程序流与函数式的程序流有着本质的不同。函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的。</p><h4 id="声明式惰性计算函数链"><a href="#声明式惰性计算函数链" class="headerlink" title="声明式惰性计算函数链"></a>声明式惰性计算函数链</h4><p>之前提到，函数式程序是由一些简单函数组成的，尽管每个函数只完成一小部分功能，但组合在一起就能够解决很多复杂的任务。</p><p>函数式编程的声明式模型将程序视为对一些独立的纯函数的求值，从而在必要的抽象层次之上构建出流畅且表达清晰的代码。这样就可以构成一个能够清晰表达应用程序意图的本体或词汇表。使用如<code>map</code>、<code>reduce</code> 和 <code>filter</code> 这样的基石来搭建纯函数，可使代码易于推理并一目了然。</p><p>这个层次的抽象的强大之处在于，它会使开发者开始认识到各种操作应该对所采用的底层数据结构不可见。从理论上说，无论是使用数组、链表、二叉树还是其他数据结构，它都不应该改变程序原本的语义。正是出于这个原因，函数式编程选择更关注于操作而不是数据结构。</p><p>例如，假设需要对一组姓名进行读取、规范化、去重，最终进行排序。首先写一个命令式的版本，然后再重构成函数式的风格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [</span><br><span class="line">  <span class="string">&quot;alonzo church&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Haskell curry&quot;</span>,</span><br><span class="line">  <span class="string">&quot;stephen_kleene&quot;</span>,</span><br><span class="line">  <span class="string">&quot;John Von Neumann&quot;</span>,</span><br><span class="line">  <span class="string">&quot;stephen_kleene&quot;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">  <span class="comment">//&lt;--- 遍历数组中的所有名字</span></span><br><span class="line">  <span class="keyword">let</span> n = names[i];</span><br><span class="line">  <span class="keyword">if</span> (n !== <span class="literal">undefined</span> &amp;amp;&amp;amp; n !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//&lt;--- 检查所有词是否都合法</span></span><br><span class="line">    <span class="keyword">let</span> ns = n.replace(<span class="regexp">/_/</span>, <span class="string">&quot; &quot;</span>).split(<span class="string">&quot; &quot;</span>); <span class="comment">//&lt;--- 数组包含格式不一致的数据。这是规范化（修复）元素的步骤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; ns.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = ns[j];</span><br><span class="line">      p = p.charAt(<span class="number">0</span>).toUpperCase() + p.slice(<span class="number">1</span>);</span><br><span class="line">      ns[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(ns.join(<span class="string">&quot; &quot;</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//&lt;--- 检查是否已存在于结果中，以去除重复的元素</span></span><br><span class="line">      result.push(ns.join(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">result.sort(); <span class="comment">// &lt;--- 数组排序</span></span><br></pre></td></tr></table></figure><p>命令式代码的缺点是限定于高效地解决某个特定的问题。例如，这段代码用于解决上述的问题。比起函数式代码，其抽象水平要低得多。抽象层次越低，代码重用的概率就会越低，出现错误的复杂性和可能性就会越大。此外，函数式的实现不过是将各种黑盒组件连接在一起，将重任赋予如<code>map</code>、<code>reduce</code> 和 <code>filter</code>这些成熟且经过测试的 API。请注意，级联排列的函数调用可以使该代码更易阅读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names) <span class="comment">//&lt;--- 初始化函数链（创建惰性计算函数链来处理给定的数组）</span></span><br><span class="line">  .filter(isValid) <span class="comment">//&lt;--- 去除非法值</span></span><br><span class="line">  .map(<span class="function">(<span class="params">s</span>) =&gt;</span> s.replace(<span class="regexp">/_/</span>, <span class="string">&quot; &quot;</span>)) <span class="comment">//&lt;--- 规范化值</span></span><br><span class="line">  .uniq() &lt;</span><br><span class="line">  ---去掉重复元素</span><br><span class="line">    .map(_.startCase) <span class="comment">//&lt;--- 大写首字母</span></span><br><span class="line">    .sort()</span><br><span class="line">    .value(); <span class="comment">//&lt;--- 执行函数链中的所有函数</span></span><br><span class="line"><span class="comment">//-&gt; [&#x27;Alonzo Church&#x27;, &#x27;Haskell Curry&#x27;, &#x27;Jon Von Neumann&#x27;, &#x27;Stephen Kleene&#x27;]</span></span><br></pre></td></tr></table></figure><p>这样的代码看起来舒服很多，不仅是因为代码量的减少，还因为其结构简单明了。</p><p>现在我们可以更深刻明白为什么函数式的程序是如此优越。能够写得如此流畅与函数式编程中的纯性以及无副作用的基本原则息息相关。链中的每个函数都以一种不可变的方式来处理由上一个函数构建的新数组。Lodash 利用函数链这种模式，通过调用_.chain()提供了一种基础功能，以满足各种需求。这有助于过渡到对 point-free 编程风格的理解。pointfree 是函数式编程的特色，会在之后分享。</p><p>能够惰性地定义程序的管道不止有可读性这一个好处。由于以惰性计算方式编写的程序会在运行前定义好，因此可以使用数据结构重用或者方法融合等技术对其进行优化。这些优化不会减少执行函数本身所需的时间，但有助于消除不必要的调用。之后会更详细解释。</p><h4 id="类-SQL-的数据：函数即数据"><a href="#类-SQL-的数据：函数即数据" class="headerlink" title="类 SQL 的数据：函数即数据"></a>类 SQL 的数据：函数即数据</h4><p>比如<code>map</code>、<code>reduce</code>、<code>filter</code>等。将这些函数组成一个列表，可用来梳理数据相关的信息。如果在更高层面细细思考，就会发现这些函数与<code>SQL</code>相似，这不是偶然的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.firstname, p.birthYear <span class="keyword">FROM</span> Person p</span><br><span class="line"><span class="keyword">WHERE</span> p.birthYear <span class="operator">&gt;</span> <span class="number">1903</span> <span class="keyword">and</span> p.country <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="string">&#x27;US&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.firstname, p.birthYear</span><br></pre></td></tr></table></figure><p>事实证明，在构建程序时，使用查询语言来思考与函数式编程中操作数组类似——使用通用关键字表或代数方法来增强对数据及其结构的深层次思考。</p><p>Lodash 支持一种称为 mixins 的功能，可以用来为核心库扩展新的函数，并使得它们可以以相同的方式连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.mixin(&#123;</span><br><span class="line">  <span class="attr">select</span>: _.pluck,</span><br><span class="line">  <span class="attr">from</span>: _.chain,</span><br><span class="line">  <span class="attr">where</span>: _.filter,</span><br><span class="line">  <span class="attr">groupBy</span>: _.sortByOrder,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>编写类似 SQL 的 JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.from(persons)</span><br><span class="line">  .where(<span class="function">(<span class="params">p</span>) =&gt;</span> p.birthYear &gt; <span class="number">1900</span> &amp;amp;&amp;amp; p.address.country !== <span class="string">&quot;US&quot;</span>)</span><br><span class="line">  .groupBy([<span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;birthYear&quot;</span>])</span><br><span class="line">  .select(<span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;birthYear&quot;</span>)</span><br><span class="line">  .value();</span><br><span class="line"><span class="comment">//-&gt; [&#x27;Alan&#x27;, &#x27;Barkley&#x27;, &#x27;John&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面的代码创建了一个 SQL 关键字到对应别名函数的映射，从而可以更深刻地理解一个查询语言的函数式特性。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>另一种用于替换循环的常见技术是递归，尤其当处理一些“自相似”的问题时，可以用其来抽象迭代。对于这些类型的问题，序列函数链会显得效率低下或不适用。而递归实现了自己的处理数据的方式，从而大大缩短了标准循环的执行时间。</p><p>在 JavaScript 中，递归具有许多应用场景，例如解析 XML、HTML 文档或图形等。</p><h4 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h4><p>递归是一种旨在通过将问题分解成较小的自相似问题来解决问题本身的技术，将这些小的自相似问题结合在一起，就可以得到最终的解决方案。递归函数包含以下两个主要部分。</p><ul><li>基例（终止条件）</li><li>递归条件</li></ul><p>基例是能够令递归函数计算出具体结果的一组输入，而不必再重复下去。递归条件则处理函数调用自身的一组输入（必须小于原始值）。如果输入不变小，那么递归就会无限期地运行，直至程序崩溃。</p><p>随着函数的递归，输入会无条件地变小，最终到达触发基例的条件，以一个值作为递归过程的终止。</p><p>栗子：递归求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_.isEmpty(arr)) &#123; <span class="xml">&lt;---//  基例（终止条件）</span></span><br><span class="line"><span class="xml">        return 0;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return _.first(arr) + sum(_.rest(arr)); //&lt;--- 递归条件：使用更小一些的输入集调用自身。这里通过_.first和_.rest缩减输入集</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">sum([]); //-&gt; 0</span></span><br><span class="line"><span class="xml">sum([1,2,3,4,5,6,7,8,9]); //-&gt;</span><span class="number">45</span></span><br></pre></td></tr></table></figure><h4 id="递归定义的数据结构"><a href="#递归定义的数据结构" class="headerlink" title="递归定义的数据结构"></a>递归定义的数据结构</h4><p>person 对象示例数据中的那些名字。20 世纪 20 年代，函数式编程（lambda 演算、范畴论等）背后的数学社区非常活跃。大部分发表的研究成果都是融合一些由 Alonzo Church 这样的知名大学教授提出的思想和定理。事实上，许多数学家，如 Barkley Rosser、Alan Turing 和 Stephen Kleene 等，都是 Church 的博士生。后来他们也有了自己的博士生。下图为这种师徒关系（的一部分）的示意图。</p><p><img src="https://i.loli.net/2021/08/08/2z79CousSLvyHqc.png"></p><p>这种结构在软件中是很寻常的，它可用于建模 XML 文档、文件系统、分类法、种别、菜单部件、逐级导航、社交图谱等，所以学习如何处理它们至关重要。图 3.8 显示了一组节点，其连线表示了导师-学生这一关系。到目前为止，我们已经利用函数式技术解析过一些扁平化的数据结构，如数组。但这些操作对树形数据是无效的。因为 JavaScript 没有内置的树型对象，所以需要基于节点创建一种简单的数据结构。节点是一种包含了当前值、父节点引用以及子节点数组的对象。</p><p>节点对象的定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._val = val;</span><br><span class="line">        <span class="built_in">this</span>._parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>._children = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">isRoot</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValid(<span class="built_in">this</span>._parent); &lt;--- 之前创建的函数</span><br><span class="line">    &#125;</span><br><span class="line">    get children() &#123;</span><br><span class="line">        return this._children;</span><br><span class="line">    &#125;</span><br><span class="line">    hasChildren() &#123;</span><br><span class="line">        return this._children.length &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    get value() &#123;</span><br><span class="line">        return this._val;</span><br><span class="line">    &#125;</span><br><span class="line">    set value(val) &#123;</span><br><span class="line">        this._val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    append(child) &#123;</span><br><span class="line">        child._parent = this; //&lt;--- 设置父节点</span><br><span class="line">        this._children.push(child); //&lt;--- 将孩子节点加入孩子列表中</span><br><span class="line">        return this; //&lt;--- 返回该节点（便于方法级联）</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        return `Node (val: $&#123;this._val&#125;, children: $&#123;this._children.length&#125;)`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样创建一个新节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> church = <span class="keyword">new</span> Node(<span class="keyword">new</span> Person(<span class="string">&quot;Alonzo&quot;</span>, <span class="string">&quot;Church&quot;</span>, <span class="string">&quot;111-11-1111&quot;</span>)); <span class="comment">// &lt;--- 重复树中的所有节点</span></span><br></pre></td></tr></table></figure><p>树是包含了一个根节点的递归定义的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._root = root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">map</span>(<span class="params">node, fn, tree = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//&lt;--- 使用静态方法以免与Array.prototype.map 混淆。静态方法也能像单例函数一样高效</span></span><br><span class="line">    node.value = fn(node.value); <span class="comment">//&lt;--- 调用遍历器函数，并更新树中的节点值</span></span><br><span class="line">    <span class="keyword">if</span> (tree === <span class="literal">null</span>) &#123;</span><br><span class="line">      tree = <span class="keyword">new</span> Tree(node); <span class="comment">//&lt;--- 与 Array.prototype.map 类似。结果是一个新的结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.hasChildren()) &#123;</span><br><span class="line">      <span class="comment">//&lt;--- 如果节点没有孩子，则返回（基例）</span></span><br><span class="line">      _.map(node.children, <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;--- 将函数应用到每一个孩子节点</span></span><br><span class="line">        Tree.map(child, fn, tree); <span class="comment">//&lt;--- 递归地调用每一个孩子节点</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">root</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点的主要逻辑在于 <code>append</code> 方法。要给一个节点追加一个子节点，需要将该节点设置为子节点的 parent 引用，并把子节点添加至该节点的子节点列表中。通过从根部不断地将节点链接到其他子节点来填充一棵树，由 church 开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">church.append(rosser).append(turing).append(kleene);</span><br><span class="line">kleene.append(nelson).append(constable);</span><br><span class="line">rosser.append(mendelson).append(sacks);</span><br><span class="line">turing.append(gandy);</span><br></pre></td></tr></table></figure><p>每个节点都包裹着一个 person 对象。递归算法执行整个树的先序遍历，从根开始并且下降到所有子节点。由于其自相似性，从根节点遍历树和从任何节点遍历子树是完全一样的，这就是递归定义。为此，可以使用与 Array.prototype.map 语义类似的高阶函数 Tree.map——它接收一个对每个节点求值的函数。可以看出，无论用什么数据结构来建模（这里是树形数据结构），该函数的语义应该保持不变。从本质上讲，任何数据类型都可以使用 map 并保持其结构不变。</p><p>树的先序遍历按照以下步骤执行，从根节点开始。</p><ul><li>显示根元素的数据部分。</li><li>通过递归地调用先序函数来遍历左子树。</li><li>以相同的方式遍历右子树。</li></ul><p>下图显示了算法采用的路径：<br><img src="/tdl/tfl/pictures/202101/tapd_20278041_1610076259_80.png" alt="5.png"></p><p>函数 Tree.map 有两个必需的输入：根节点（即树的开始）以及转换每个节点数值的迭代函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree.map(church, <span class="function">(<span class="params">p</span>) =&gt;</span> p.fullname);</span><br></pre></td></tr></table></figure><p>它以先序方式遍历树，并将给定的函数应用于每个节点，输出以下结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Alonzo Church&#x27;</span>, <span class="string">&#x27;Barkley Rosser&#x27;</span>, <span class="string">&#x27;Elliot Mendelson&#x27;</span>, <span class="string">&#x27;Gerald Sacks&#x27;</span>, <span class="string">&#x27;Alan</span></span><br><span class="line"><span class="string">Turing&#x27;</span>, <span class="string">&#x27;Robin Gandy&#x27;</span>, <span class="string">&#x27;Stephen Kleene&#x27;</span>, <span class="string">&#x27;Nels Nelson&#x27;</span>, <span class="string">&#x27;Robert Constable&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用<code>map</code>、<code>reduce</code>和<code>filter</code>等高阶函数来编写高可扩展的代码。</li><li>使用 Lodash 进行数据处理，通过控制链创建控制流与数据变换明确分离的程序。</li><li>使用声明式的函数式编程能够构建出更易理解的程序。</li><li>将高阶抽象映射到 SQL 语句，从而深刻地认识数据。</li><li>递归能够解决自相似问题，并解析递归定义的数据结构。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今日分享: 如何创建易于推断的代码&lt;/p&gt;
&lt;h2 id=&quot;轻数据结构，重操作&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（一）</title>
    <link href="http://example.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-11-20T09:49:02.000Z</published>
    <updated>2021-08-08T03:12:08.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>&gt; 面向对象编程（OO）通过封装变化是的代码更易理解。<br>&gt; 函数式编程（FP）通过最小化变化使得代码更易理解。</p><p>Michael Feathers 是世界级面向对象技术专家，以丰富的软件项目开发经验著称。</p><p>简明扼要，可见函数式编程的优点。</p><h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><p>简单来说：函数式是一种强调以函数使用为主的软件开发风格。</p><p>这听起来很平常，好像我们平常也都是这么做的。</p><p>先讲概念：函数式编程的目标是使用函数来<strong>抽象作用在数据之上的控制流与操作</strong>，从而在系统中<strong>消除副作用</strong>并<strong>减少对状态的改变</strong>。</p><p>没有栗子就是在耍流氓:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;#msg&quot;</span>).innerHTML = <span class="string">&quot;&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>代码很简单，但是写死了，也就不能动态显示消息。</p><p>如果想改变消息的格式，内容或者目标 DOM 元素，需要重写整个表达式。</p><p>我们给它改进一下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printMessage = (elementId, NodeType, message) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(elementId).innerHTML = <span class="string">`&amp;lt;<span class="subst">$&#123;NodeType&#125;</span>&amp;gt;<span class="subst">$&#123;message&#125;</span>&amp;lt;/<span class="subst">$&#123;NodeType&#125;</span>&amp;gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line">printMessage(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;h1&quot;</span>, <span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样好一点，但是重用性仍然不高，接下来改成函数式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="keyword">const</span> printMessage = run(addToDOM(<span class="string">&quot;msg&quot;</span>), h1, echo);</span><br><span class="line"></span><br><span class="line">printMessage(<span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure><p>这段代码与之前的完全不同: <code>h1</code>不再是一个量值，它与<code>addToDOM</code>,<code>echo</code>都是函数，这样看上去像是用一些较小的函数构建成一个新的函数。</p><p>代码写成这样的原因是什么？</p><p>将代码分解成一些更可重用，更可靠且易于理解的部分，再将其组合起来，形成一个更易推理的程序整体。</p><p>上面的代码有一个神奇的函数<code>run</code>，它序列地调用一系列函数。</p><p>在后台，<code>run</code>函数基本上是通过将一个函数的返回值作为下一个函数的输入，以这张方式将各个函数连接起来。这样，由<code>echo</code>返回字符串，被传递到<code>h1</code>中，其结果最终又被传递到<code>addToDOM</code>。<code>run</code>函数的细节之后会解释。</p><p>上面比较了函数式和非函数式的编程方案，尽管他们结果相同，但是实现过程截然不同。这是源于函数式编程开发中固有的声明模式，为了充分理解函数式编程，我们先来了解一些基本概念:</p><ul><li>声明式编程</li><li>纯函数</li><li>引用透明</li><li>不可变性</li></ul><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>函数式编程属于<strong>声明式</strong>编程范式:这种范式会描述一系列的操作，但并不会暴露它们是如何实现的或是数据流如何穿过它们。</p><p>目前更加主流的是<strong>命令式</strong>或者<strong>过程式</strong>的编程范式，如 Java、C#、C++和其他大多数结构化语言和面向对象语言都对其提供支持。</p><p>命令式编程将计算机视为一系列自上而下的断言，通过修改系统的的各个状态来计算最终的结果。</p><p>看个栗子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &amp;lt; array.length; i++) &#123;</span><br><span class="line">  array[i] = <span class="built_in">Math</span>.pow(array[i], <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ 0,  1,  4, 9, 16, 25, 36]</span></span><br></pre></td></tr></table></figure><p>命令式编程很具体地告诉计算机如何执行某个任务。</p><p>而声明式编程将程序的描述与求值分离开来。它关注于如何用各种表达式来描述程序逻辑，而不一定要指明其控制流或者状态的变化。</p><p>函数式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">array.map((num) =&amp;gt; <span class="built_in">Math</span>.pow(num, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>函数式编程只需要对应用在每个数组元素上的行为予以关注，将循环交给系统的其他其他部分去控制。</p><h3 id="副作用带来问题和纯函数"><a href="#副作用带来问题和纯函数" class="headerlink" title="副作用带来问题和纯函数"></a>副作用带来问题和纯函数</h3><p>函数式编程基于一个前提:即使用纯函数构建具有不变性的程序。</p><p>它具有以下性质:</p><ul><li>仅取决于提供的输入，而不依赖于任何在函数求值期间或调用间隔时可能变化的隐藏状态或外部状态</li><li>不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数</li></ul><p>栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> add = () =&amp;gt; ++counter;</span><br><span class="line"></span><br><span class="line">add(); <span class="comment">// 1</span></span><br><span class="line">counter++; <span class="comment">// 2</span></span><br><span class="line">add(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这个函数是不纯的，因为它读取并修改了一个外部变量，即函数作用域外的 counter。</p><p>一般来说，函数在读取或写入外部资源时都会产生副作用，例如上面的代码中，<code>counter</code>可以在调用间隔的任何时间发生改变。</p><p>另一个常见的函数是<code>Date.now()</code>,它的输出是不可预见的，并且不一致，因为它依赖于一个不断变化的因素–时间。</p><p>常见的副作用:</p><ul><li>改变一个全局的变量、属性或数据结构</li><li>改变一个参数的原始值</li><li>处理用户输入</li><li>屏幕打印</li><li>查询 cookie</li></ul><p>如果没有这些操作，那程序会有什么实用价值？</p><p>事实上，在一个充满了动态行为与变化的世界里，纯函数确实很难使用。</p><p>但是，函数式编程在实践上并不限制一切状态的改变，它只是提供了一个框架来帮助管理和减少可变状态，同时让你能够将纯函数从不纯的部分中分离出来。</p><p>栗子:<br>假设有一段程序，它能够通过身份证(ID)来找到一个人的记录并渲染在浏览器中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> showPerson = (ID) =&amp;gt; &#123;</span><br><span class="line">  <span class="comment">// 查询数据库</span></span><br><span class="line">  <span class="keyword">const</span> person = db.get(ID);</span><br><span class="line">  <span class="comment">// 判断是否有这个人</span></span><br><span class="line">  <span class="keyword">if</span> (person !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 渲染操作</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;elementId&#125;</span>`</span></span><br><span class="line">    ).innerHTML = <span class="string">`<span class="subst">$&#123;person.ID&#125;</span>:<span class="subst">$&#123;person.name&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;404&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">showPerson(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>分析代码:</p><ul><li>该函数访问数据，与外部变量<code>db</code>进行了交互，因为该函数签名中并没有声明该参数，在任意时间，这个引用可能为<code>null</code>,或在调用间隔内改变，从而导致完全不同的结果并破坏了程序的完整性</li><li>全局变量<code>elementId</code>可能随时改变，难以控制</li><li>HTML 元素被直接修改了，HTML 文档（DOM）本身是一个可变的、共享的全局资源</li><li>如果没有找到记录，该函数可能为抛出异常，导致整个程序的栈回退并突然结束</li></ul><p>用函数式思想改进:</p><ul><li>将这个长函数分离成多个具有单一职责的短函数</li><li>通过显示地将完成功能所需的依赖都定义为函数参数来减少副作用的数量</li></ul><p>首先通过分离显示与获取数据的行为。</p><p>当然，与外部存储系统和 DOM 交互所产生的副作用是不可避免的，但至少可以通过将其从主逻辑中分离出来的方式使它们更易于管理。</p><p>这里需要引入一种常见的函数式编程技巧–<strong>柯里化</strong>，使用它，可以允许部分地传递函数参数，以便将函数的参数减少为一个，之后会再介绍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分离函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> find = () =&amp;gt; &#123;</span><br><span class="line">  curry((db, id) =&amp;gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = db.get(id);</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;404&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = (person) =&amp;gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;person.ID&#125;</span>:<span class="subst">$&#123;person.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> append = () =&amp;gt; &#123;</span><br><span class="line">  curry((elementId, info) =&amp;gt; &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(elementId).innerHTML = info;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> showPerson = run(append(<span class="string">&quot;msg&quot;</span>), message, find(db));</span><br><span class="line"></span><br><span class="line">showPerson(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>尽管这个程序只有些许改进，但是它开始展现出许多优势:</p><ul><li>灵活很多，因为有了三个可以被复用的组件</li><li>这种细粒度函数的重用是提高工作效率的一种手段，因为可以大大减少需要主动维护的代码量</li><li>声明式代码风格提供了程序需要执行的那些高阶步骤的一个清晰试图，增强了代码的可读性</li><li>将纯函数从不纯的行为中分离出来</li></ul><p>由于一些我们会在后续了解到的原因，能够确保一个函数有相同的返回值是一个优点，它使得函数的结果是一致的和可预测的。这是纯函数的一个特质，称为引用透明</p><h3 id="引用透明和可置换性"><a href="#引用透明和可置换性" class="headerlink" title="引用透明和可置换性"></a>引用透明和可置换性</h3><p>引用透明是定义一个纯函数正确的方式。纯度在这个意义上表明了一个函数的参数和返回值之前映射的纯的关系。</p><p>因此，如果一个函数对于相同输入始终产生相同的结果，那么就说它是<strong>引用透明</strong>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> add = () =&amp;gt; ++counter;</span><br></pre></td></tr></table></figure><p>这个函数不是引用透明的，因为其返回值严重依赖外部变量 counter。改造:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (counter) =&amp;gt; ++counter;</span><br></pre></td></tr></table></figure><p>为了引用透明，需要删除其依赖的外部变量这一状态，使其成为函数签名中显示定义的参数。</p><p>现在这个函数是稳定的，对于相同输入每次都返回相同的输出结果。</p><p>之所以追求这种函数的特质，是因为它不仅能让代码更易于测试，还可以让开发人员更容易<strong>推理整个程序</strong>。</p><p>假设现在要求一个数组中的平均值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = [<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = (total, current) =&amp;gt; total + current;</span><br><span class="line"><span class="keyword">const</span> total = (arr) =&amp;gt; arr.reduce(sum);</span><br><span class="line"><span class="keyword">const</span> size = (arr) =&amp;gt; arr.length;</span><br><span class="line"><span class="keyword">const</span> divide = (a, b) =&amp;gt; a / b;</span><br><span class="line"><span class="keyword">const</span> average = (arr) =&amp;gt; divide(sum(arr), size(arr));</span><br><span class="line"></span><br><span class="line">average(input);</span><br></pre></td></tr></table></figure><p>由于函数<code>sum</code>和<code>size</code>都是引用透明的，对于如下给定输入，可以很容易重写这个表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">divide(<span class="number">90</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">90</span> / <span class="number">3</span> = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h3 id="存储不可变数据"><a href="#存储不可变数据" class="headerlink" title="存储不可变数据"></a>存储不可变数据</h3><p><strong>不可变数据</strong>是指那些被创建后不能更改的数据。</p><p>与许多其他语言一样，JavaScript 中的所有基本类型（String、Number 等）从本质上是不可变的。但是其他对象，例如数组，都是可变的——即使他们作为输入传递给另一个函数，仍然可以通过改变原有内容的方式产生副作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortDesc = (arr) =&amp;gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.sort((a, b) =&amp;gt; b - a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> output = sortDesc(input);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(input); <span class="comment">// [7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(output); <span class="comment">// [7, 6, 5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>排序的目的达到了，但是产生了副作用，即改变了输入。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在我们已经了解了函数式编程的一些基本原则（如声明式的、纯的和不可变的），那可以这么描述它:</p><p>函数式编程是指为创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程。</p><h2 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a>函数式编程的优点</h2><ul><li>促使开发人员将任务分解成更小的任务(函数)</li><li>使用流式的调用链来处理数据</li><li>通过响应式范式降低是将驱动代码的复杂性</li></ul><h3 id="复杂任务的分解"><a href="#复杂任务的分解" class="headerlink" title="复杂任务的分解"></a>复杂任务的分解</h3><p>从宏观上讲，函数式编程实际上是分解（将程序拆分成小片段）和组合（将小片段连接到一起）之间的相互作用。正是这种二元性，使得函数式如此模块化和高效。</p><p>这里的模块化就是函数本身，函数式思维的学习通常始于将特定任务分解为逻辑子任务（函数）的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> find = () =&amp;gt; &#123;</span><br><span class="line">  curry((db, id) =&amp;gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = db.get(id);</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;404&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = (person) =&amp;gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;person.ID&#125;</span>:<span class="subst">$&#123;person.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> append = () =&amp;gt; &#123;</span><br><span class="line">  curry((elementId, info) =&amp;gt; &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(elementId).innerHTML = info;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> showPerson = run(append(<span class="string">&quot;msg&quot;</span>), message, find(db));</span><br><span class="line"></span><br><span class="line">showPerson(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                find</span><br><span class="line">showPerson  →   message</span><br><span class="line">                append</span><br></pre></td></tr></table></figure><p>如果需要，这些子任务可以进一步分解，直到成为一个个简单的，相互独立的纯函数功能单元。</p><p>可以看出，函数式编程的模块化概念与<strong>单一职责</strong>原则息息相关，也就是说，函数都应该拥有单一的目的。纯度和引用透明会促使我们这样思考问题。</p><p>还记得上面说的那个<code>run</code>函数吗？</p><p>现在揭秘这个黑魔法:实际上<code>run</code>函数是一个极为重要的技术的别名 —— <strong>组合</strong> 。</p><p>两个函数的组合是一个新的函数，它拿到一个函数的输出，并传递到另一个函数中。讲述有两个函数<code>f</code>和<code>g</code>，形式上，组合可以如下描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f · g = f(g(x))</span><br></pre></td></tr></table></figure><p>这个公式读作“f 组合上 g”,它在 g 的返回值与 f 的参数之间构建了一个松耦合的且类型安全的联系。</p><p>两个函数能够组合的条件是，它们必须在参数数目及参数类型上形成一致。</p><p>现在用<code>compose</code>构建组合函数<code>showPerson</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> showPerson = compose(append(<span class="string">&quot;#msg&quot;</span>), message, find(db));</span><br><span class="line">showPerson(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>关于组合，先了解这么多。</p><p>到此为此，我们可以看到:函数式的组合提高了抽象的层次，可以清晰地够勾勒代码的所有步骤，但又不暴露任何底层细节在此代码执行的所有步骤。</p><p>由于<code>compose</code>接受其他函数为参数，这被称为<code>高阶函数</code>，但组合并不是构建流式的、模块化的代码的唯一方式。</p><h3 id="使用流式链来处理函数"><a href="#使用流式链来处理函数" class="headerlink" title="使用流式链来处理函数"></a>使用流式链来处理函数</h3><p>除了<code>map</code>，我们还可以通过导入一些函数式类库来获得更多高阶函数，比方说<code>lodash</code>。</p><p>假设一个场景:需要计算那些选择多门课程的学生的平均分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">number</span>: <span class="number">2</span>, <span class="attr">grade</span>: <span class="number">100</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">number</span>: <span class="number">3</span>, <span class="attr">grade</span>: <span class="number">80</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">number</span>: <span class="number">1</span>, <span class="attr">grade</span>: <span class="number">89</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>命令式代码可能是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> totalGrade = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> totalStudentsFound = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &amp;lt; data.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> student = data[i];</span><br><span class="line">  <span class="keyword">if</span> (student !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (student.number &amp;gt; <span class="number">1</span>) &#123;</span><br><span class="line">      totalGrade += student.grade;</span><br><span class="line">      totalStudentsFound++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> average = totalGrade / totalStudentsFound;</span><br></pre></td></tr></table></figure><p>用函数式思维来分解这个问题:</p><ul><li>选择合适的学生（选课数量大于 1 的）</li><li>获取他们的成绩</li><li>计算平均值</li></ul><p>通过<code>lodash</code>把这些操作连接起来:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.chain(data)</span><br><span class="line">  .filter((student) =&amp;gt; student.number &amp;gt; <span class="number">1</span>)</span><br><span class="line">  .pluck(<span class="string">&quot;grade&quot;</span>)</span><br><span class="line">  .average()</span><br><span class="line">  .value(); <span class="comment">// 执行链式队列并提取解链后的值。</span></span><br></pre></td></tr></table></figure><p>我们先不用太在意发生了什么，与命令式版本比较，并注意如何消除变量的声明和变化，以及循环和判断语句。</p><p>诸如循环和逻辑分支这样的很多命令式控制流机制，会提高函数的复杂程度，因为它们会根据某些条件不同而执行不同的行为，难以测试。</p><p>上面代码略过了一些错误处理代码，我们可以利用一些纯函数式的设计模式来处理它，这个以后再说。</p><h3 id="复杂异步应用中的响应"><a href="#复杂异步应用中的响应" class="headerlink" title="复杂异步应用中的响应"></a>复杂异步应用中的响应</h3><p>大家经历过回调地狱吗？</p><p>它打破了线性的代码结构，使代码变得难以阅读，因为它的成功处理和失败处理的逻辑混杂在一起。</p><p>我们经常要处理在服务端或者客户端的异步和事件驱动代码，可以用响应式编程来大幅降低这些代码的复杂性</p><p>响应式是一种范式，是函数式编程应用之一，采用它的好处在于能够提高代码的抽象级别，从而更专注业务逻辑。这种范式能够充分利用函数式编程中函数链和组合的样式。</p><p>事件有很多种:鼠标点击、文本变化、焦点变化、HTTP 请求处理或者文件写入等等。假设现在根据输入的 ID 号码查询用户是否存在，命令式代码可能是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> valid = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;#input&quot;</span>);</span><br><span class="line">element.onkeyup = (event) =&amp;gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> val = element.value;</span><br><span class="line">  <span class="keyword">if</span> (val !== <span class="literal">null</span> &amp;amp;&amp;amp; val.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 可能进行的裁剪或者清理输入，直接改变数据</span></span><br><span class="line">    val = val.replace(<span class="regexp">/^[a-zA-Z0-9_-]&#123;4,16&#125;$/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 可能存在的嵌套逻辑分支</span></span><br><span class="line">    <span class="keyword">if</span> (val.length === <span class="number">9</span>) &#123;</span><br><span class="line">      valid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;404&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我刚学编程那会写过类似结构的代码，一大段逻辑塞在一起。但是对于这样一个简单的任务，编码从一开始就变得复杂，这样除了增加心智负担，代码也无法重用。</p><p>来康康响应式，这种白痴南横范式使用了一个叫做<code>observable</code>的概念，它能够订阅一个数据流，让开发者通过使用组合和链式操作来优雅地处理数据。</p><p>代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="built_in">document</span>.getElementById(<span class="string">&quot;#input&quot;</span>), <span class="string">&quot;keyup&quot;</span>)</span><br><span class="line">  .map((input) =&amp;gt; input.srcElement.value)</span><br><span class="line">  .filter((val) =&amp;gt; val !== <span class="literal">null</span> &amp;amp;&amp;amp; val.length !== <span class="number">0</span>)</span><br><span class="line">  .skipWhile((val) =&amp;gt; length === <span class="number">9</span>)</span><br><span class="line">  .subscribe(() =&amp;gt; <span class="built_in">console</span>.log(<span class="string">&quot;404&quot;</span>));</span><br></pre></td></tr></table></figure><p>它和前面的例子相像，这说明，无论是处理集合元素序列或者用户输入序列，一切都被抽象出来，这使得可以用相同的方式去处理数据。</p><p>上面的代码的操作是不可变的，并且所有业务逻辑被分割成单独的函数。并不是必须要响应式地使用函数，但函数式的思维会迫使开发者这么做。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用纯函数的代码绝不会更改或破坏全局状态，有助于提高代码的可测试性和可维护性</li><li>函数式编程采用声明式的风格，易于推理。这提高了应用程序的整体可读性，通过使用组合和 lambda 表达式使函数更加精简</li><li>集合中数据元素可以通过链接如 map 和 reduce 这样的函数来实现</li><li>函数式编程将函数视为积木，通过一等高阶函数来提高代码的模块化和可重用性</li><li>可以利用响应式编程组合各个函数来降低驱动程序的复杂性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;gt; 面向对象编程（OO）通过封装变化是的代码更易理解。&lt;br&gt;&amp;gt; 函数式编程</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise规范翻译</title>
    <link href="http://example.com/2020/11/09/PromisesA+%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/"/>
    <id>http://example.com/2020/11/09/PromisesA+%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/</id>
    <published>2020-11-09T13:30:40.000Z</published>
    <updated>2021-08-07T05:59:13.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><a href="https://promisesaplus.com/">原文</a></p><p>一个开放标准,通用的 JavaScript promise ,由开发者制定，供开发者使用。</p><p>Promise 用于表示一个异步操作的最终结果。与 Promise 交互的主要方式为<code>then</code>方法,该方法注册回调函数以接收 promise 的成功的结果或者失败的原因。</p><p>该规范详细说明了<code>then</code>方法的行为,所有基于 Promise/A+规范实现的 Promise 都必须以此为基础实现。因此规范应该非常稳定。尽管 Promises/A+组织可能会偶尔修改此规范以向后兼容,只有经过仔细考虑，讨论和测试后，我们才会集成大型或不向后兼容的更改。</p><p>从其发展过程来看，Promises/A+其实是把之前的<code>Promises/A提案</code>归纳总结为标准。扩展了一些现有的行为规范，并删除了一些有问题的、未明确的部分。</p><p>最终，Promises/A+规范核心内容不包括怎样处理 promises 的创建（create）,完成（fulfill）和拒绝（reject），而是选择专注于提供一个通用的，具备可互操作的<code>then</code>方法。上述的操作方法可能会在未来修改该规范时提及。</p><h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h3><p>1.1 “promise” 是一个拥有<code>then</code>方法的对象或函数，其行为符合本规范<br>1.2 “thenable” 是一个定义了<code>then</code>方法的对象或函数<br>1.3 “value” 可以是任何 JavaScript 的合法值（包括 undefined, thenable 和 promise）<br>1.4 “exception” 是一个使用<code>throw</code>语句抛出的值。<br>1.5 “reason”是一个表示 promise 失败的原因</p><h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h3><h4 id="2-1-Promise-要求"><a href="#2-1-Promise-要求" class="headerlink" title="2.1 Promise 要求"></a>2.1 Promise 要求</h4><p>一个 Promise 必须处于以下三种状态中的其中一种: pending（等待）, fulfilled（完成）, 或 rejected（拒绝）。</p><p>2.1.1 当 promise 处于 pending 状态</p><ul><li><p>2.1.1.1. 可以转换到 fulfilled 或 rejected 的状态。</p><p>2.1.2 当 promise 处于 fulfilled 状态</p></li><li><p>2.1.2.1 不能再转换状态。</p></li><li><p>2.1.2.2 必须有一个值(value),且不可改变。</p><p>2.1.3 当 promise 处于 rejected 状态</p></li><li><p>2.1.3.1 不能再转换状态。</p></li><li><p>2.1.3.2 必须有一个原因(reason),且不可改变。</p></li></ul><p>这里的不可改变指的是恒等（即 <code>===</code> ），而不是意味着其内部的不可变（即仅仅是其引用地址不变，但属性值可被更改）。</p><h4 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2 then 方法"></a>2.2 then 方法</h4><p>一个 promise 必须提供一个<code>then</code>方法以读取其当前值、终值和失败原因。<br>一个 promise 的<code>then</code>方法接收两个参数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFullfilled, onRejected);</span><br></pre></td></tr></table></figure><p>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选的参数:</p><ul><li><p>2.2.1.1 如果<code>onFullfilled</code>不是一个函数，则它会被忽略</p></li><li><p>2.2.1.2 如果<code>onRejected</code>不是一个函数，则它会被忽略</p><p>2.2.2 如果<code>onFulfilled</code>是一个函数</p></li><li><p>2.2.2.1 必须在 <code>promise</code> 执行结束后执行，<code>promise</code>的 value 作为第一个参数</p></li><li><p>2.2.2.2 在 <code>promise</code> 执行结束前不可被调用</p></li><li><p>2.2.2.3 不能被多次调用</p><p>2.2.3 如果<code>onRejected</code>是一个函数</p></li><li><p>2.2.3.1 必须在 <code>promise</code> 被拒绝后执行,<code>promise</code>的 reason 作为第一个参数</p></li><li><p>2.2.3.2 在 <code>promise</code> 执行结束前不可被调用</p></li><li><p>2.2.3.3 不能被多次调用</p><p>2.2.4 <code>onFulfilled</code>和<code>onRejected</code>只有在执行环境堆栈仅包含平台代码时才可被调用 <a href="####3.1">3.1</a></p><p>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须被作为函数调用（即没有 this 值） <a href="####3.2">3.2</a></p><p>2.2.6 <code>then</code>方法可以被同一个 promise 调用多次</p></li><li><p>2.2.6.1 如果/当 <code>promise</code>是 fulfilled 状态，则所有相应的<code>onFulfilled</code>回调必须按注册顺序执行<code>then</code>方法</p></li><li><p>2.2.6.2 如果/当 <code>promise</code>是 rejected 状态，则所有相应的<code>onRejected</code>回调必须按注册顺序执行<code>then</code>方法</p><p>2.2.7 <code>then</code>方法必须返回一个 promise 对象<a href="####3.3">3.3</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure><ul><li>2.2.7.1 如果<code>onFulfilled</code>或者<code>onRejected</code>返回一个值<code>x</code> ，则运行下面的 Promise 解决过程：<code>[[Resolve]](promise2, x)</code></li><li>2.2.7.2 如果<code>onFulfilled</code>或者<code>onRejected</code>抛出一个异常<code>e</code> ，则<code>promise2</code>必须拒绝执行，并将<code>e</code>作为拒绝原因</li><li>2.2.7.3 如果<code>onFulfilled</code>不是一个函数并且<code>promise1</code>已经完成，则<code>promise2</code>必须使用与<code>promise1</code>相同的 value 来 fulfilled</li><li>2.2.7.4 如果<code>onRejected</code>不是一个函数并且<code>promise1</code>已经完成，则<code>promise2</code>必须使用与<code>promise1</code>相同的 reason 来 rejected</li></ul><h4 id="2-3-Promise-解决过程"><a href="#2-3-Promise-解决过程" class="headerlink" title="2.3 Promise 解决过程"></a>2.3 Promise 解决过程</h4><p>Promise 解决过程是一个抽象的操作,其需输入一个 promise 和一个值,我们表示为<code>[[Resolve]](promise, x)</code>,如果 x 是一个 thenable(promise),它会尝试采用 x 的状态,前提是<code>x</code>行为至少有点像 promise。否则，它作为<code>promise</code>的 fulfilled 的 value 返回。<br>对 thenables 的这种处理允许 promise 实现进行更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与不冲突的实现能良好共存。</p><p>要运行<code>[[Resolve]](promise, x)</code>, 需遵循以下步骤：</p><ul><li>2.3.1 如果<code>promise</code>和<code>x</code>指向同一对象，以<code>TypeError</code>为拒绝原因拒绝执行<code>promise</code></li><li>2.3.2 如果<code>x</code>为 Promise,则使 promise 接受 x 的状态<a href="####3.4">3.4</a><ul><li>2.3.2.1 如果<code>x</code>处于 pending,promise 需保持 pending,直至<code>x</code>被执行或拒绝</li><li>2.3.2.2 如果<code>x</code>执行完毕,用相同的值执行<code>promise</code></li><li>2.3.2.3 如果<code>x</code>被拒绝,用相同的原因拒绝<code>promise</code></li></ul></li><li>2.3.3 如果<code>x</code>为对象或者函数<ul><li>2.3.3.1 把<code>x.then</code>赋值给<code>then</code><a href="####3.5">3.5</a></li><li>2.3.3.2 如果取<code>x.then</code>的值时抛出错误<code>e</code>,则用<code>e</code>作为 promise 的拒绝原因</li><li>2.3.3.3 如果<code>then</code>是函数,将<code>x</code>作为函数的作用域<code>this</code>调用之。传递两个回调函数作为参数,第一个参数叫做<code>resolvePromise</code>,第二个参数叫做<code>rejectPromise</code>:<ul><li>2.3.3.3.1 如果<code>resolvePromise</code>以值<code>y</code>为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></li><li>2.3.3.3.2 如果<code>rejectPromise</code>以拒绝原因<code>r</code>为参数被调用,则以<code>r</code>拒绝<code>promise</code></li><li>2.3.3.3.3 如果<code>resolvePromise</code>和<code>rejectPromise</code>均被调用,或者被同一参数调用了多次,则优先采用首次调用并忽略其余调用</li><li>2.3.3.3.4 如果调用<code>then</code>方法时抛出异常<code>e</code>,<ul><li>2.3.3.3.4.1 如果<code>resolvePromise</code>或<code>rejectPromise</code>已经被调用,就忽略它</li><li>2.3.3.3.4.2 否则以<code>e</code>为原因拒绝<code>promise</code></li></ul></li></ul></li><li>2.3.3.4 如果<code>then</code>不是函数,以<code>x</code>为参数执行<code>promise</code></li></ul></li><li>2.3.4 如果<code>x</code>不为对象或者函数,以<code>x</code>为参数执行<code>promise</code></li></ul><p>如果一个 promise 被一个循环的 thenable 链中的对象解决，而<code>[[Resolve]](promise, thenable)</code>的递归性质导致其被再次调用,根据上述的算法将会陷入无限递归。规范鼓励施者检测这样的递归是否存在,但不强制,如果检测到存在则以一个可识别的<code>TypeError</code>为原因来拒绝 <code>promise</code>。<a href="####3.6">3.6</a></p><h3 id="3-备注"><a href="#3-备注" class="headerlink" title="3. 备注"></a>3. 备注</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>这里的“平台代码”指的是引擎,环境和 promise 实现代码。实践中要确保<code>onFulfilled</code>和<code>onRejected</code>方法异步执行,且应该在<code>then</code>方法被调用的那一轮事件循环之后的新执行栈中执行。这可以用“宏任务”机制实现,例如<code>setTimeout</code>或者<code>setImmediate</code>,或者用“微任务”机制,例如<code>MutationObserver</code>或<code>process.nextTick</code>。由于 promise 实现被认为是平台代码,因此它本身可能包含一个任务调度队列或“trampoline”的处理程序。</p><h4 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h4><p>也就是说在严格模式（strict）中，<code>this</code>的值为<code>undefined</code>;在非严格模式中其为全局对象。</p><h4 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h4><p>代码实现在满足所有要求的情况下可以允许<code>promise2 === promise1</code>。每个实现都要文档说明其是否允许以及在何种条件下允许 p<code>romise2 === promise1</code>。</p><h4 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h4><p>一般来说,<code>x</code>如果它来自当前的实现,那么它是一个真正的 promise。该子句允许使用特定于实现的方法来采用已知符合的 promise 的状态。</p><h4 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h4><p>此过程首先存储引用<code>x.then</code>,然后测试,调用该引用,避免多次访问该<code>x.then</code>属性。这么做的原因是防止每次获取该值时,返回不同的情况（ES5 的 getter 特性可能会产生副作用）</p><h4 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h4><p>实现不应该对 thenable 链的深度设限,并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致<code>TypeError</code>异常；如果一条无限长的链上 thenable 均不相同,那么递归下去永远是正确的行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;原文&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>margin 合并</title>
    <link href="http://example.com/2020/10/26/margin%E5%90%88%E5%B9%B6/"/>
    <id>http://example.com/2020/10/26/margin%E5%90%88%E5%B9%B6/</id>
    <published>2020-10-26T10:42:31.000Z</published>
    <updated>2021-08-07T05:59:13.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="什么是-margin-合并"><a href="#什么是-margin-合并" class="headerlink" title="什么是 margin 合并"></a>什么是 margin 合并</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">MDN 定义</a></p><p>块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距,其大小为单个边距的最大值(或如果它们相等,则仅为其中一个),这种行为称为边距折叠.</p><p>举个 🌰</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">        writing-mode: vertical-lr;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>块级元素</strong>,但不包括浮动和绝对定位元素(他们可以让元素块状化)</li><li>只发生在垂直方向(不考虑<strong>writing-mode</strong>的情况,严格来说应该是只发生在和当前文档流方向的相垂直方向上,默认的文档流是水平流)</li></ul><h2 id="margin-合并三种场景"><a href="#margin-合并三种场景" class="headerlink" title="margin 合并三种场景"></a>margin 合并三种场景</h2><ul><li>相邻兄弟元素 margin 合并</li><li>父级和第一个/最后一个子元素</li><li>空的块级元素的 margin 合并</li></ul><h4 id="相邻兄弟元素-margin-合并"><a href="#相邻兄弟元素-margin-合并" class="headerlink" title="相邻兄弟元素 margin 合并"></a>相邻兄弟元素 margin 合并</h4><p>例子如上</p><h4 id="父级和第一个-最后一个子元素"><a href="#父级和第一个-最后一个子元素" class="headerlink" title="父级和第一个/最后一个子元素"></a>父级和第一个/最后一个子元素</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="如何阻止这里margin合并的发生"><a href="#如何阻止这里margin合并的发生" class="headerlink" title="如何阻止这里margin合并的发生?"></a>如何阻止这里margin合并的发生?</h5><p>可以进行的操作(满足一个条件即可):</p><ul><li>父元素设置块状格式化上下文元素</li><li>父级和第一个/最后一个子元素之间添加内联元素进行分隔</li><li>父元素设置<code>border</code></li><li>父元素设置<code>padding</code></li></ul><h4 id="空的块级元素的-margin-合并"><a href="#空的块级元素的-margin-合并" class="headerlink" title="空的块级元素的 margin 合并"></a>空的块级元素的 margin 合并</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="如何阻止这里margin合并的发生-1"><a href="#如何阻止这里margin合并的发生-1" class="headerlink" title="如何阻止这里margin合并的发生?"></a>如何阻止这里margin合并的发生?</h5><p>可以进行的操作(满足一个条件即可):</p><ul><li>设置<code>height</code>或者<code>min-height</code></li><li>添加内联元素进行分隔</li><li>父元素设置<code>border</code></li><li>父元素设置<code>padding</code></li></ul><h2 id="margin-合并的计算规则"><a href="#margin-合并的计算规则" class="headerlink" title="margin 合并的计算规则"></a>margin 合并的计算规则</h2><ul><li>同向取极值<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 50px;&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 20px;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>此时两个<code>div</code>的间距为50px</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px; background-color: antiquewhite;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: -50px;&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: -20px;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时两个<code>div</code>的间距为-50px,视觉上非50px</p><ul><li>反向取差值<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 50px;&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: -20px;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>此时两个<code>div</code>的间距为30px,即 50px+(-20px)</li></ul><h2 id="margin-合并的意义"><a href="#margin-合并的意义" class="headerlink" title="margin 合并的意义"></a>margin 合并的意义</h2><h4 id="为什么会有margin"><a href="#为什么会有margin" class="headerlink" title="为什么会有margin"></a>为什么会有margin</h4><p>最初CSS的设计本意就是为了图文信息的展示,有了默认的<code>margin</code>,图文就不会挤在一起,垂直方向上就可以层次分明.<br>比如说<code>&lt;p&gt;&lt;/p&gt;</code>,其<code>margin</code>默认单位为em,为什么使用相对单位?<br>浏览器的字号大小可以自定义,当我们自定义为较大值时,margin跟随变化,能够保持合适的排版.</p><h4 id="margin-合并的意义-1"><a href="#margin-合并的意义-1" class="headerlink" title="margin 合并的意义"></a>margin 合并的意义</h4><p>对于兄弟元素的<code>margin</code>合并其作用和em类似,都是为了让图文信息打得排版更舒服自然.</p><p>对于父子元素的<code>margin</code>合并的意义在于:在页面中任何地方插入和嵌套<code>&lt;div&gt;&lt;/div&gt;</code>都不会影响原来的块状布局.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 20px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在在该元素外嵌套一层<code>&lt;div&gt;&lt;/div&gt;</code>标签,如果没有合并规则,该元素和兄弟节点的间距可能就会变大,也就影响了原来的布局.</p><p>对于自身的<code>margin</code>合并的意义在于可以避免空标签的影响</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为规则的存在,它和底下的代码是一样的效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是-margin-合并&quot;&gt;&lt;a href=&quot;#什么是-margin-合并&quot;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Babel转译下的装饰器</title>
    <link href="http://example.com/2020/08/16/Babel%E8%BD%AC%E8%AF%91%E4%B8%8B%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://example.com/2020/08/16/Babel%E8%BD%AC%E8%AF%91%E4%B8%8B%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2020-08-16T11:40:50.000Z</published>
    <updated>2021-08-07T05:59:13.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h4 id="装饰器概念"><a href="#装饰器概念" class="headerlink" title="装饰器概念"></a>装饰器概念</h4><p>它是一个函数，它会通过返回一个新函数来修改传入的函数或方法的行为</p><h4 id="装饰器用法"><a href="#装饰器用法" class="headerlink" title="装饰器用法"></a>装饰器用法</h4><ul><li>装饰类方法或属性(类成员)</li><li>装饰类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = descriptor.value;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> descriptor.value === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(oldValue.apply(<span class="built_in">this</span>, args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foodCategory = <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  target.category = <span class="string">&quot;food&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@foodCategory</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @log</span><br><span class="line">  <span class="function"><span class="title">color</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`red`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cola = <span class="keyword">new</span> Cola(<span class="string">&quot;Coca Cola&quot;</span>);</span><br><span class="line">cola.color(); <span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(Cola.category); <span class="comment">// food</span></span><br></pre></td></tr></table></figure><p><strong>装饰方法本质上是通过 <code>Object.defineProperty()</code> 来实现的</strong></p><p>经过babel转换之后(底下有babel详细操作):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function </span></span></span><br><span class="line"><span class="comment"> * 该函数的作用就是将数组中的方法添加到构造函数或者构造函数的原型中</span></span><br><span class="line"><span class="comment"> * 最后返回这个构造函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将props数组上的每一个对象都通过Object.defineProperty()方法</span></span><br><span class="line"><span class="comment">     * 定义到目标对象target上去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;</span><br><span class="line">            props.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">            <span class="comment">// 类的内部所有定义的方法,都是不可枚举的</span></span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">            descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;protoProps&#125;</span> </span>原型属性数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;protoProps&#125;</span> </span>静态属性数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 为构造函数prototype添加属性</span></span><br><span class="line">        <span class="comment">// (即为用构造函数生成的实例原型添加属性,可以被实例通过原型链访问到)</span></span><br><span class="line">        <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        <span class="comment">// 为构造函数添加属性</span></span><br><span class="line">        <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _class, _desc, _value, _class2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function </span></span></span><br><span class="line"><span class="comment"> * 作用是检查 Person 是否是通过 new 的方式调用</span></span><br><span class="line"><span class="comment"> * 防止构造函数被当做普通函数执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_applyDecoratedDescriptor</span>(<span class="params">target, property, decorators, descriptor, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> desc = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 这里对 descriptor 属性做了一层拷贝</span></span><br><span class="line">    <span class="built_in">Object</span>[<span class="string">&#x27;keys&#x27;</span>](descriptor).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        desc[key] = descriptor[key];</span><br><span class="line">    &#125;);</span><br><span class="line">    desc.enumerable = !!desc.enumerable;</span><br><span class="line">    desc.configurable = !!desc.configurable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有 value 或者 initializer 属性的,表明是 get 和 set 方法</span></span><br><span class="line">    <span class="comment">// initializer是 Babel 的 Class 为了与 decorator 配合而产生的一个属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> desc || desc.initializer) &#123;</span><br><span class="line">        desc.writable = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理多个 decorator 的情况,由类内向类外执行</span></span><br><span class="line">    desc = decorators.slice().reverse().reduce(<span class="function"><span class="keyword">function</span> (<span class="params">desc, decorator</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decorator(target, property, desc) || desc;</span><br><span class="line">    &#125;, desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void其实是javascript中的一个函数,接受一个参数,返回值永远是undefined</span></span><br><span class="line">    <span class="keyword">if</span> (context &amp;&amp; desc.initializer !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        desc.value = desc.initializer ? desc.initializer.call(context) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        desc.initializer = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.initializer === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>[<span class="string">&#x27;defineProperty&#x27;</span>](target, property, desc);</span><br><span class="line">        desc = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> descriptor.value === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, args = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">                args[_key] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(oldValue.apply(<span class="built_in">this</span>, args));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(descriptor.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foodCategory = <span class="function"><span class="keyword">function</span> <span class="title">foodCategory</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    target.category = <span class="string">&quot;food&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cola = foodCategory(_class = (_class2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Cola</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="built_in">this</span>, Cola);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Cola, [&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;color&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Cola;</span><br><span class="line">&#125;(), (_applyDecoratedDescriptor(_class2.prototype, <span class="string">&quot;color&quot;</span>, [log], <span class="built_in">Object</span>.getOwnPropertyDescriptor(_class2.prototype, <span class="string">&quot;color&quot;</span>), _class2.prototype)), _class2)) || _class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cola = <span class="keyword">new</span> Cola(<span class="string">&quot;Coca Cola&quot;</span>);</span><br><span class="line">cola.color();</span><br><span class="line"><span class="built_in">console</span>.log(Cola.category);</span><br></pre></td></tr></table></figure><h4 id="babel详细操作"><a href="#babel详细操作" class="headerlink" title="babel详细操作"></a>babel详细操作</h4><p>使用<code>npm init</code>初始化项目:<br>生成文件<code>pakeage.json</code>,它会将记录项目开发中所要用到的包,以及项目的详细信息</p><p>babel-cli是一种在命令行下使用Babel编译文件的简单方法,主要用于文件的输入输出<br>安装babel命令行工具:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">global</span> babel-cli</span><br></pre></td></tr></table></figure><p>安装装饰器依赖:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev babel-plugin-transform-decorators-legacy</span><br></pre></td></tr></table></figure><p>项目中创建**.babelrc**文件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;es2015&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;transform-decorators-legacy&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>文件说明:</p><ul><li><p>.babelrc<br>babel所有的操作基本都会来读取这个配置文件,除了一些在回调函数中设置options参数的,如果没有这个配置文件,会从package.json文件的babel属性中读取配置</p></li><li><p>presets<br>可以简单的把它视为 Babel Plugin 的集合</p></li><li><p>plugins<br>babel中的插件,通过配置不同的插件告诉babel,代码中有哪些是需要转译的</p></li></ul><p>使用babel命令转码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel [fileName].js</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;装饰器概念&quot;&gt;&lt;a href=&quot;#装饰器概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中offset、client、scroll</title>
    <link href="http://example.com/2020/06/10/JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/"/>
    <id>http://example.com/2020/06/10/JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/</id>
    <published>2020-06-10T13:49:20.000Z</published>
    <updated>2021-08-07T05:59:13.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在web前端开发中经常会碰到offset、client、scroll,容易混乱,这里记录一番.<br>先放两张图,未来好查阅 :smile:<br><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/1.png" alt="JavaScript中offset、client、scroll.md"><br><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/2.png" alt="JavaScript中offset、client、scroll.md"></p><h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>offset: 偏移量<br>它包括元素在屏幕上占用的所有可见的空间.元素的可见大小由其高度、宽度决定,包括所有的内边距<code>padding</code>,滚动条和边框<code>border</code>大小(注意:不包括外边距).</p><p>通过以下4个属性可以取得元素的偏移量:</p><ul><li>offsetHeight: offsetHeight = border-width * 2 + padding-top + padding-bottom + height</li><li>offsetWidth: offsetWidth = border-width * 2 + padding-left + padding-right + width</li><li>offsetLeft: offsetLeft = offsetParent 的padding-left + 中间元素的offsetWidth + 当前元素的margin-left</li><li>offsetTop: offsetParent 的padding-top + 中间元素的offsetHeight + 当前元素的margin-top</li></ul><p><strong>它们都是只读属性,每次访问都要重新计算,如果经常访问,可以用变量存起来,以提高性能</strong></p><p><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/3.png" alt="JavaScript中offset、client、scroll.md"></p><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>client: 客户区大小<br>它包括元素内容及其内边距所占据的空间大小.</p><p>通过以下2个属性可以取得元素的客户区:</p><ul><li>clientHeight: padding-top + padding-bottom + height</li><li>clientWidth: padding-left + padding-right + width</li></ul><p><strong>它们也是只读属性,每次访问都要重新计算</strong></p><p><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/4.png" alt="JavaScript中offset、client、scroll.md"></p><h2 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h2><p>scroll: 滚动大小<br>它指的是滚动内容的元素的大小.<br>有些元素(比如<code>&lt;html&gt;</code>),即使没有执行任何代码也能自动地添加滚动条;有些元素需要通过设置CSS的<code>overflow</code>属性才能滚动.</p><p>通过以下4个属性可以取得滚动的相关属性:</p><ul><li>scrollHeight: 在没有滚动条的情况下,元素实际内容的总高度</li><li>scrollWidth: 在没有滚动条的情况下,元素实际内容的总宽度</li><li>scrollLeft: 被隐藏在内容区域左侧的像素数,设置该属性可以改变元素的滚动位置</li><li>scrollTop: 被隐藏在内容区域上方的像素数,设置该属性可以改变元素的滚动位置</li></ul><p><strong>通常认为<code>&lt;html&gt;</code>元素是在web浏览器的视口中滚动的元素,所以带有垂直滚动条的页面总高度就是<code>document.documentElement.scrollHeight</code>.</strong></p><p><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/5.png" alt="JavaScript中offset、client、scroll.md"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>直击本质——读书笔记</title>
    <link href="http://example.com/2020/05/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/"/>
    <id>http://example.com/2020/05/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-05-03T07:19:12.000Z</published>
    <updated>2021-08-07T05:59:13.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><img src="%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.JPG" alt="读书笔记--直击本质.md"></p><p>这本书让我受益很多，思维导图分享给大家。<br>以下再完善一些概念：</p><ul><li>迁移思考：迁移思考是先找到经过抽象与当前问题“表面不同、本质相似”的问题，通过借用前面问题的解决方法，解决当下问题的思维方式。它的迁移对象主要是思维模型和底层逻辑。</li><li>升维思考：跳出眼前问题的限制和常规解法，通过层级、时间、视角、边界、位置、结构的变换，重新思考问题及其解决之道的思考方式。升维思考的本质是对价值观、人生观、世界观的重新审视，拓展及重塑。比如，层级思考法和时间轴思考法是对自我价值观的审视，视角思考法是对世界观的拓展和重塑，无边界思考法是对人生观的拓展和重塑。</li><li>逆向思维：它是对司空见惯的、似乎已成定论的事物或观点反过来思考的一种思维方式。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文学" scheme="http://example.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中Object常用方法</title>
    <link href="http://example.com/2020/04/30/JavaScript%E4%B8%ADObject%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/04/30/JavaScript%E4%B8%ADObject%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-30T14:34:24.000Z</published>
    <updated>2021-08-07T05:59:13.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇文章尚未完成!!</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Object</code>是<code>JavaScript</code>中标准内置对象，它非常强大，虽然在日常开发中却用的不多，但十分有必要深入学习。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>该方法创建一个新对象，使用现有的对象提供新创建对象的__proto__.<br><code>Object.create(proto[, propertiesObject])</code><br>参数：</p><ul><li>proto为新创建对象的原型对象</li><li>propertiesObject可选，如果没有指定为undefined，这样会添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及响应的属性名称。<br>返回值：</li><li>一个新对象，带着指定原型对象和属性</li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p>先看看常用的对象定义属性并赋值的写法：密码，，，，，，，，，，，，，，，，，，。xcccccccccccccccccc.mpo[yup]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">&#x27;Cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line">这种方式简单粗暴，但是对象属性的值可以想改就改，想删就删：</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">let obj = &#123;&#125;;</span></span><br><span class="line"><span class="string">obj.name = &#x27;Cola&#x27;;</span></span><br><span class="line"><span class="string">console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">obj.name = &#x27;Coca cola&#x27;;</span></span><br><span class="line"><span class="string">console.log(obj);// &#123; name: &#x27;Coca cola&#x27; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">delete obj.name;</span></span><br><span class="line"><span class="string">console.log(obj);// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>再来看看<code>Object.defineProperty(obj, prop, descriptor)</code><br>参数：</p><ul><li>obj为要定义属性的对象</li><li>prop为要定义或修改的属性的名称或Symbol</li><li>descriptor为要定义或修改的属性描述符<br>返回值：</li><li>被传递给函数的对象</li></ul><p><strong>ES6新增Symbol类型，，由于它独一无二的特性，可以用该类型作为对象的key</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;Coca cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br></pre></td></tr></table></figure><p>通过实践发现以这样的写法定义的属性是无法被修改和删除的，且访问对象为空。<br>要想和我们常规写法达到相同的效果，还需要修改属性描述符。<br>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符</strong>和<strong>存取描述符</strong>，用一张表来区分二者区别：<br>|   |configurable   |enumerable   |value   |writable   |get   |set   |<br>| ———— | ———— | ———— | ———— | ———— | ———— | ———— |<br>| 数据描述符  |√   |√   |√   |√   |×   |×   |<br>| 存取描述符  |√   |√   |×   |×   |√   |√   |<br>如果一个描述符不具备<code>value</code>、<code>enumerable</code>、<code>writable</code>、<code>configurable</code>任意一个键，那么它会被认为是一个数据描述符；<br>如果一个描述符同时拥有<code>value</code>或<code>writable</code>和<code>get</code>、<code>set</code>，则会产生一个异常。</p><p>下面再来看一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;Coca cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Coca cola</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>可以看到obj对象和我们以常用写法达到的效果一样，这是因为<code>enumerable</code>描述符能够控制对象属性是否可枚举;<code>writable</code>描述符能够控制对象属性是否可写，也就是覆盖;<code>configurable</code>描述符能够控制对象属性是否可配置，也就是将属性从对象上删除。<br>这里我们可以得出结论：除了<code>value</code>描述符，其他数据描述符的值默认为<code>false</code>。</p><p>那<code>get</code>和<code>set</code>呢，再看看以下的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute </span></span><br></pre></td></tr></table></figure><p>对照前文的表格，代码抛出异常，证实了<code>value</code>或<code>writable</code>和<code>get</code>、<code>set</code>不能同时出现。<br>那怎么使用呢，按照异常提示信息，删掉<code>value</code>和<code>writable</code>描述符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get!&#x27;</span>);</span><br><span class="line">        <span class="comment">// return obj;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123; name: [Getter/Setter] &#125;</span></span><br><span class="line">obj.name;<span class="comment">// get!</span></span><br><span class="line">obj.name = <span class="string">&#x27;Coca cola&#x27;</span>;<span class="comment">// Coca cola</span></span><br></pre></td></tr></table></figure><p>在上面代码中，每次访问<code>obj.name</code>总是返回同一个值，这是因为我们对这个属性做了特殊处理，也就是get方法做的事情；每次对<code>obj.name</code>进行赋值操作，控制台总是打印此次赋值的内容，也就是set方法做的事情。</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>该方法是ES6新添加的方法，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。<br><code>Object.assign(target, ...sources)</code><br>参数：</p><ul><li>target为目标对象</li><li>sources为源对象<br>返回值：</li><li>目标对象<br>用法示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manA = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;manA&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(manA, &#123;</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;China&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;height&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;1.8m&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manB = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;manB&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manC = <span class="built_in">Object</span>.assign(&#123;&#125;, manA, manB, <span class="literal">null</span>, <span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">console</span>.log(manC);<span class="comment">// &#123; name: &#x27;manB&#x27;, age: 13, address: &#x27;China&#x27; &#125;</span></span><br></pre></td></tr></table></figure>实践后可以得出结论：</li><li>该方法只拷贝源对象自身的并且可枚举的属性到目标对象（其内部使用源对象存取描述符<code>get()</code>和目标对象的<code>set()</code>方法，因此它会调用相关方法）。</li><li>该方法不会因为sources参数为<code>null</code>或<code>undefined</code>而报错。</li></ul><p>深拷贝问题：<br><code>Object.assign()</code>方法只能实现浅拷贝：假如源对象的属性值是一个对象的引用，那么返回值中该属性值也直指向这个引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manA = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;manA&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">region</span>: <span class="string">&#x27;Asia&#x27;</span>,</span><br><span class="line">        <span class="attr">nationality</span>: <span class="string">&#x27;China&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manB = <span class="built_in">Object</span>.assign(&#123;&#125;, manA);</span><br><span class="line"><span class="built_in">console</span>.log(manB);<span class="comment">// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;China&#x27; &#125; &#125;</span></span><br><span class="line">manB.address.nationality = <span class="string">&#x27;Japan&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(manA)；<span class="comment">// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;Japan&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的防抖和节流</title>
    <link href="http://example.com/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2020-04-28T14:18:41.000Z</published>
    <updated>2021-08-07T05:59:13.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>防抖和节流是优化前端性能的一种手段。<br>以下情况可以考虑使用防抖和节流：</p><ul><li>DOM 频繁重绘</li><li>频繁请求后端接口</li><li>浏览器的 resize、scroll（适合用节流）</li><li>鼠标的 mounsemove、mouseover（适合用节流）</li><li>input 输入框的 keypress（适合用防抖）</li></ul><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>核心思想：当事件被触发，延迟 n 秒后执行回调函数，如果在 n 秒内再次被触发，则重新计时延迟时间。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(that, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>核心思想：在规定的一个单位时间内只能触发一次函数，如果在这个单位时间内出发多次函数，只有一次生效。</p><p>代码实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(that, args);</span><br><span class="line">      <span class="comment">// 在执行完fn后清空timer,throttle触发可以进入计时器</span></span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流与防抖的异同"><a href="#节流与防抖的异同" class="headerlink" title="节流与防抖的异同"></a>节流与防抖的异同</h2><p>相同：在一段时间内防止函数被频繁调用，减少资源浪费，提升性能。<br>不同：防抖是固定时间内只执行一次，节流是间隔固定时间后执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MQTT协议详解</title>
    <link href="http://example.com/2020/04/26/MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2020/04/26/MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-26T05:18:56.000Z</published>
    <updated>2021-08-07T05:59:13.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)，是一种基于发布/订阅(public/subscribe)模式的轻量级物联网消息推送协议。<br>该协议构建于TCP/IP协议上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的协议。这让它成为新兴的”机器到机器（M2M)”，”物联网(IoT)”场景下的理想选择。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>MQTT协议是轻量、简单、开放和易于实现的</li><li>提供服务质量管理</li><li>采用发布/订阅模式，方便消息传递</li><li>基于TCP/IP网络连接，提供有序，无损的双向连接</li><li>假如数据不可知，不强求传输数据的类型与格式，保持灵活性</li><li>1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域</p><ul><li>物联网M2M通信，物联网大数据采集</li><li>Android消息推送，Web消息推送</li><li>移动即时消息，例如Facebook Messenger</li><li>智能硬件、智能家居</li><li>车联网通信、电动车站桩采集</li><li>电力、石油与能源等行业市场</li></ul><h2 id="主题和负载"><a href="#主题和负载" class="headerlink" title="主题和负载"></a>主题和负载</h2><p>MQTT传输的消息分为：主题（Topic）和负载（payload）</p><ul><li>Topic：可以理解为消息的类型，订阅者订阅（Subscribe)后，就会收到该主题的消息内容（payload）</li><li>payload：可以理解为消息的内容，失致订阅者具体要使用的内容</li></ul><h2 id="三种消息发布服务质量："><a href="#三种消息发布服务质量：" class="headerlink" title="三种消息发布服务质量："></a>三种消息发布服务质量：</h2><ul><li>至多一次：消息发布完全依赖底层TCP/IP网络，qos=0。会发生消息丢失或重复的情况，这一级别可用于如下情况，环境传感器数据，丢失一次读记录影响不大</li><li>至少一次：确保消息到达，qos=1。但消息重复可能会发生</li><li>只有一次：确保消息到底一次，qos=2。</li></ul><h2 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h2><ul><li><p>实现方式<br><img src="./MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/1.jpg" alt="MQTT协议详解.md"><br>MQTT协议具有三种身份：发布者（Publish)、代理（Broker)（服务器）、订阅者（Subscribe）<br>其中，消息的发布者和订阅者都是客户端，消息代理是服务器。消息的发布者可以同时是订阅者</p></li><li><p>网络传输与应用消息<br>MQTT会构建底层网络传输：它将简历客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。<br>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关联。</p></li><li><p>MQTT客户端<br>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p><ul><li>发布其他客户端可能会订阅的消息</li><li>订阅其他客户端发布的消息</li><li>退订或删除应用程序的消息</li><li>断开与服务器连接</li></ul></li><li><p>MQTT服务端<br>MQTT服务器已称为”消息代理”(Broker)，可以是一个应用程序或一台设备。它位于消息发布者和订阅者中间，它可以：</p><ul><li>接受来自客户的网络连接</li><li>接受客户发布的应用消息</li><li>处理来自客户端的订阅和退订请求</li><li>向订阅的客户转发应用程序消息</li></ul></li><li><p>MQTT协议中的订阅、主题、会话</p><ul><li>订阅（Subscription）<br>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每个会话中的每个订阅都有一个不同的主题筛选器。</li><li>会话（Session）<br>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。绘画存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</li><li>主题名（Topic Name）<br>连接到一个应用程序消息的标签，如果该标签与服务器的订阅相匹配，服务器就会将消息发送给订阅所匹配标签的客户端。</li><li>主题筛选器（Topic Filter）<br>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</li></ul></li><li><p>MQTT协议中的方法<br>MQTT协议中定义了一些方法，也被称之为动作，来表示对于确定资源进行的操作。资源可以是预先存在的数据或者动态生成的数据，这取决于服务器的实现，通常来说，资源指服务器上的文件或输出。主要方法有：</p><ul><li>Connect：等待与服务器建立连接</li><li>Disconnect：等待MQTT客户端完成所作的工作，并与服务器断开TCP/IP会话</li><li>Subscribe:等待完成订阅</li><li>UnSubscribe:等待服务器取消客户端的一个或多个topics订阅</li><li>Publish：MQTT客户端发送消息请求，发送完成后返回应用程序线程</li></ul></li></ul><h2 id="MQTT协议数据包结构"><a href="#MQTT协议数据包结构" class="headerlink" title="MQTT协议数据包结构"></a>MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Varibale header）、消息体（payload）三部分构成。</p><ul><li><p>固定头（Fixed header）：存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/2.jpg" alt="MQTT协议详解.md"><br>数据包类型为byte 1中bits7-4,相当于一个4位的无符号值，类型如下：<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/3.jpg" alt="MQTT协议详解.md"><br>标识位为byte 1中bits3-0,在不使用标识位的消息类型中，标识位被做为保留位。如果收到无效的标志时，接收端必须关闭网络连接：<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/4.jpg" alt="MQTT协议详解.md"></p><ul><li>DUP：发布消息的副本，用来保证消息的可靠传输。如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送</li><li>QoS：发布消息的服务质量，即：保证消息传递的次数<ul><li>00：最多一次，即：&lt;=1</li><li>01：至少一次，即：&gt;=1</li><li>10：一次，即：=1</li><li>11：预留</li></ul></li><li>RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放<br>剩余长度（Remaining Length）<br>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为 1时，表示长度不足，需要使用二个字节继续保存。</li></ul></li><li><p>可变头（Varibale header）：存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容<br>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p></li></ul><p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/5.jpg" alt="MQTT协议详解.md"></p><ul><li>消息体（payload））：存在于部分MQTT数据包中，表示客户端收到的具体内容<br>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：<ul><li>CONNECT:消息体内容主要是客户端的ClientID、订阅的Topic、Message以及用户名和密码</li><li>SUBSCRIBE:消息内内容是一系列要订阅的主题以及QoS</li><li>SUBACK：消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复</li><li>UNSUBSCRIBE:消息体内容是要订阅的主题</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="协议" scheme="http://example.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="协议" scheme="http://example.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>霍乱时期的爱情——读书笔记</title>
    <link href="http://example.com/2020/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/"/>
    <id>http://example.com/2020/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/</id>
    <published>2020-04-20T13:12:03.000Z</published>
    <updated>2021-08-07T05:59:13.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>我相信爱情是有许多模样的，街头巷尾里互相搀扶的老夫老妻，小家里过着平平淡淡日子的夫妇，婚礼上很累却非常甜蜜的新人，还有拉着彼此的手在暴雨天一路奔跑的情侣等。当然，有积极正面的，热情似火的爱，也必然有阴暗扭曲，卑劣粗俗的爱，这本书让我看到关于爱情更多的细枝末节。<br>当年轻的阿里萨第一次见到费尔明娜，一生内心的纠葛就此开始。从最初的懵懂羞涩，在花园装作看书看诗集，实则等待费尔明娜路过时的那一撇，那就是心动的第一个阶段吧。彼时费尔明娜乖巧懂事，对父亲言听计从，但在阿里萨鼓起勇气送出信件的那一天，她的心态悄然变化。虽然二人几乎没有或正式的面对面的对话，但是在信中从无话不谈到私定终身，看到这里我觉得有些荒诞，但也不可否认，在那个年代这是可能发生的事情，或许这不是靠谱的爱情，但它一定是两个少男少女勇敢无畏，憧憬爱情的表现。<br>纸里包不住火，洛伦索发现女儿的地下情，愤怒之余却也拿女儿没什么办法，只能带着女儿出去旅行一场，以期让她忘记阿里萨。在经历时间和空间的考验之后，费尔明娜在代笔门廊处看见阿里萨的第一眼果断决定放弃这一段长达数年的感情，她完全没有想到阿里萨是这般模样。我想这是爱情的一种残酷，发现自己朝思暮想的另一半因为某种不合的观念，失望占据内心，想要迫切希望离开，以逃避给自己带来的情感冲击。而阿里萨也因此陷入漫长的相思之苦，在无数个日日夜夜幻想着未来继续和费尔明娜生活下去的可能。<br>医生的出现，让故事更加戏剧化，他和阿里萨是完完全全两种不同的人。医生光鲜亮丽，才华横溢，医术高超，和阿里萨奇怪装束，一身为爱情诗歌所浸染的气息形成鲜明对比。费尔明娜嫁给了医生，甜蜜旅行之后是多年的不开心，期间偶尔穿插着过往蜜月的回忆。漫长岁月不过弹指间就过去了，阿里萨对她的感情日渐病态，一边心里装着她，一边勾搭成百上千的女人满足生理上需求。漫长岁月里，阿里萨也有那么几个中意的女人，奇怪的是他从来没有放弃一直盘踞在内心的念想，也从未对其他人提起，少年时的爱慕经受了五十多年岁月的考验，尽管这种感情面目全非，阿里萨还是坚持了下去，足够令人惊叹。<br>阿里萨终于等到医生死亡的消息，不像他想象中的体面离世，跌倒死亡让阿里萨没有把竞争对手比下去的快感。即便如此，暮年的他没有浪费太多时间，再次向费尔明娜表明心意，在坚持不懈的努力下，费尔明娜意识到自己是对阿里萨那一份特殊感情。最终在他们剩下的生命里借助霍乱的掩护，阿里萨如愿和费尔明娜一起在海上漂流了下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我相信爱情是有许多模样的，街头巷尾里互相搀扶的老夫老妻，小家里过着平平淡淡日子的夫妇，婚</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文学" scheme="http://example.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>网络攻击-XSS攻击详解</title>
    <link href="http://example.com/2020/03/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB-XSS%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2020/03/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB-XSS%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-03-10T05:39:41.000Z</published>
    <updated>2021-08-07T05:59:13.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="XSS-概念"><a href="#XSS-概念" class="headerlink" title="XSS 概念"></a>XSS 概念</h2><p>跨站脚本攻击(XSS),是最普遍的Web应用安全漏洞.</p><p>这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中,当正常用户访问该页面时,则可导致嵌入的恶意脚本代码的执行,从而达到恶意攻击用户的目的.</p><p>人们经常将跨站脚本攻击(Cross Site Scripting)缩写为 CSS ,但这会与层叠样式表(Cascading Style Sheet,CSS)的缩写混淆,因此将其改为 XSS .</p><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><ul><li>盗用 cookie ,获取敏感信息</li></ul><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>HTML 是一种超文本标记语言,通过特殊对待一些字符来区别文本和标记:小于符号(&lt;)被看作是 HTML 标签的开始,浏览器会将特定的字符误认为HTML 标签.当 HTML标签引入了 JavaScript 脚本时,浏览器就会执行.因此,当这些特殊字符不能被动态页面检查或检查出错的时候,就会产生 XSS 漏洞</p><h2 id="XSS-类型"><a href="#XSS-类型" class="headerlink" title="XSS 类型"></a>XSS 类型</h2><ul><li>反射型(非持久型):指发生请求时,XSS代码出现在请求URL中,作为参数提交到服务器,服务器解析并响应,响应结果中包含XSS代码,最后被浏览器解析并执行.这个过程像一次反射,故叫做反射型XSS.</li><li>存储型(持久型):将XSS代码存储在服务器中.</li><li>DOM跨站:指受害者端的网页脚本在修改本地页面DOM环境时未进行合理的处置,而使得攻击脚本被执行.在整个攻击过程中,服务器响应的页面并没有发生变化,引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用</li></ul><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><ul><li><p>反射型XSS<br>假如一个接口<code>http://www.test.com/xss/reflect.php</code>的代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>这里的x值没有经过处理直接输出,当客户端提交请求<code>http://www.test.com/xss/reflect.php?x=&lt;script&gt;alert(1)&lt;/script&gt;</code>,此时浏览器会触发alert()函数.</p></li><li><p>存储型XSS<br>最典型的例子就是留言板XSS,当用户提交了一条包含XSS代码的留言存储到数据库,目标用户查看留言板时,留言内容会从数据库提取并展示在页面上,浏览器发现有XSS代码,就当成HTML和JavaScript解析执行,从而触发XSS攻击.简单的可以是一个alert()弹窗,复杂一些的可以是盗用用户cookie等操作.</p></li><li><p>DOM XSS<br>DOM XSS攻击并不需要服务器参与,触发攻击靠浏览器的DOM解析,核心是运用DOM函数.<br>我们知道<code>eval()</code>函数有一个作用是将一段字符串转换成<code>JavaScript</code>语句,因此在<code>JavaScript</code>中使用<code>eval()</code>是一件有风险的事情,容易造成XSS攻击.</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;alert(&#x27;Hello world&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure><p>  可能触发DOM XSS攻击的属性有:</p><ul><li>document.referer属性</li><li>window.name属性</li><li>location属性</li><li>innerHTML属性</li><li>documen.write</li></ul></li></ul><h2 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h2><ul><li>入参字符过滤<br>对诸如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code>等标签进行过滤.</li><li>出参进行编码<br>像一些常见的符号,如<code>&lt;&gt;</code>在输入的时候要对其进行转换编码,这样做浏览器是不会对该标签进行解释执行的,同时也不影响显示效果.</li><li>入参长度限制<br>xss攻击要能达成往往需要较长的字符串,因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;XSS-概念&quot;&gt;&lt;a href=&quot;#XSS-概念&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="网络攻击" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
    <category term="Web安全" scheme="http://example.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中对象的拓展、密封及冻结三大特性</title>
    <link href="http://example.com/2020/03/02/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95%E3%80%81%E5%AF%86%E5%B0%81%E5%8F%8A%E5%86%BB%E7%BB%93%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2020/03/02/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95%E3%80%81%E5%AF%86%E5%B0%81%E5%8F%8A%E5%86%BB%E7%BB%93%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2020-03-02T09:24:20.000Z</published>
    <updated>2021-08-07T05:59:13.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>属性描述符是ES5引入的概念,它用于描述对象的特征.</p><p>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符</strong>和<strong>存取描述符</strong>.</p><blockquote><p>MDN中的描述：<br>数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。<br>存取描述符是由getter-setter函数对描述的属性。<br>描述符必须是这两种形式之一；不能同时是两者。</p></blockquote><p>数据描述符和存取描述符均具有以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)</p><ul><li><code>configurable</code>: <strong>可配置性</strong>.当且仅当该属性的 configurable 为 true 时,该属性描述符才能够被改变,同时该属性也能从对应的对象上被删除.默认为 <code>false</code>.</li><li><code>enumerable</code>: <strong>可枚举性</strong>.当且仅当该属性的enumerable为<code>true</code>时,该属性才能够出现在对象的枚举属性中.默认为 <code>false</code>.</li></ul><p>数据描述符同时具有以下可选键值：</p><ul><li><code>writable</code>: <strong>可写性</strong>.当且仅当该属性的writable为true时,value才能被赋值运算符改变.默认为 <code>false</code>.</li><li><code>value</code>: <strong>属性值</strong>.该属性对应的值.可以是任何有效的 JavaScript 值(数值,对象,函数等).默认为 <code>undefined</code>.</li></ul><p>存取描述符同时具有以下可选键值：</p><ul><li><code>get</code>: 一个给属性提供 getter 的方法,如果没有 getter 则为 <code>undefined</code>.当访问该属性时.该方法会被执行,方法执行时没有参数传入,但是会传入this对象（由于继承关系,这里的this并不一定是定义该属性的对象）.</li><li><code>set</code>: 一个给属性提供 setter 的方法,如果没有 setter 则为 <code>undefined</code>.当属性值修改时,触发执行该方法.该方法将接受唯一参数,即该属性新的参数值.</li></ul><p>描述符可同时具有的键值:<br>|            | configurable |  enumerable | value | writable | get | set<br>| ——–   | —–:  | :—-:  | :—-:  | :—-:  | :—-:  | :—-:  |<br>| <strong>数据描述符</strong> | Yes | Yes | Yes | Yes | No | No |<br>| <strong>存取描述符</strong> | Yes | Yes | No | No | Yes | Yes |</p><p>如果一个描述符不具有value,writable,get 和 set 任意一个关键字,那么它将被认为是一个数据描述符.如果一个描述符同时有(value或writable)和(get或set)关键字,将会产生一个异常.</p><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.defineProperty(obj, prop, descriptor)</p></blockquote><p>obj:在其上定义或修改属性的对象.</p><p>prop:要定义或修改的属性的名称.</p><p>descriptor:将被定义或修改的属性描述符.</p><blockquote><p>Object.defineProperties(obj, props)</p></blockquote><p>obj:在其上定义或修改属性的对象.</p><p>props:要定义其可枚举属性或修改的属性描述符的对象.对象中存在的属性描述符主要有两种:数据描述符和访问器描述符</p><blockquote><p>Object.getOwnPropertyDescriptors(obj)</p></blockquote><p>obj:任意对象.</p><blockquote><p>Object.getOwnPropertyDescriptor(obj, prop)</p></blockquote><p>obj:需要查找的目标对象.</p><p>prop:目标对象内属性名称</p><h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">price</span>: &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updatePrice&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.capacity;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 3.5, updatePrice: [Getter/Setter] &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj.updatePrice = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 5, updatePrice: [Getter/Setter] &#125;</span></span><br></pre></td></tr></table></figure><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ul><li><p>如果属性不可配置,则不能修改它的可配置性和可枚举性,否则抛出异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;color&#x27;</span>));<span class="comment">//&#123; value: undefined, writable: false, enumerable: false, configurable: false &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果存取器属性是不可配置的，则不能修改<code>get</code>和<code>set</code>方法，也不能将它转换为数据属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Coca &#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: updateName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = val + <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: updateName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;Coco Cola&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: updateName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果数据属性是不可配置的,则不能将它转换为存取器属性;同时也不能将它的可写性从<code>false</code>修改成<code>true</code>，但可以从<code>true</code>修改为<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;5&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;6&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;color&#x27;</span>)); <span class="comment">//&#123; value: &#x27;red&#x27;, writable: false, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;price&#x27;</span>)); <span class="comment">//&#123; value: &#x27;5&#x27;, writable: false, enumerable: false, configurable: false &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果数据属性是不可配置且不可写的,就不能修改它的值;如果是可配置但不可写，则可以修改值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接修改值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;12&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.price); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;price&#x27;</span>)); <span class="comment">//&#123; value: &#x27;12&#x27;, writable: false, enumerable: false, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以修改writable为true后再修改值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.price = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.price); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></li><li><p>严格模式下,只指定<code>get</code>时,如果对该属性赋值将会抛出类型错误异常,只指定<code>set</code>时,如果读取该属性将返回undefined,非严格模式下都不抛出异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Coca &#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot set property color of #&lt;Object&gt; which has only a getter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.color); <span class="comment">//Coca Cola</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.price);<span class="comment">//undefined</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h2><p>如果一个对象可以添加新的属性,那么这个对象是可扩展的.如何检验对象是否可扩展及如何让它变得不可扩展呢？</p><h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.isExtensible(obj)</p></blockquote><p>obj：需要检测的对象</p><blockquote><p>Object.preventExtensions(obj)</p></blockquote><p>obj：将要变得不可扩展的对象</p><h4 id="用法示例-1"><a href="#用法示例-1" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新创建的对象默认是可扩展的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">//false</span></span><br><span class="line">obj.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;Coca Cola&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//使用`Object.defineProperty`方法为不可扩展对象添加新属性会抛出异常</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;price&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">3.5</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot define property price, object is not extensible</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Coca Cola&#x27; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;name&#x27;</span>));<span class="comment">//&#123; value: &#x27;Coca Cola&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writable属性为false时，属性值不可修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Coca Cola&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line">obj.name = <span class="string">&#x27;Sprite&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h2><p>密封对象是指不可扩展，且自身所有属性都不可配置的对象.</p><p>也就是说密封对象要满足以下条件:</p><ul><li>不能添加新属性</li><li>不能删除已有属性</li><li>不能修改已有属性的可枚举性、可配置性、可写性,但可能可以修改已有属性的值的对象</li></ul><h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.isSealed(obj)</p></blockquote><p>obj：需要检测的对象</p><blockquote><p>Object.seal(obj)</p></blockquote><p>obj：需要被密封的对象</p><h4 id="用法示例-2"><a href="#用法示例-2" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建的对象默认不是密封的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动密封</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空对象的手动密封</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//密封后不再能够添加或删除属性</span></span><br><span class="line">obj.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Coca  Cola&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//密封后如果writable为true</span></span><br><span class="line">obj.name = <span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Pepsi  Cola&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h2><p>冻结对象要满足以下条件:</p><ul><li>不能添加新属性</li><li>不能删除已有属性</li><li>不能修改已有属性的可枚举性、可配置性、可写性</li></ul><p>即这个对象永远是不可变的.</p><h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.isFrozen(obj)</p></blockquote><p>obj：需要检测的对象</p><blockquote><p>Object.freeze(obj)</p></blockquote><p>obj：需要被冻结的对象</p><h4 id="用法示例-3"><a href="#用法示例-3" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建的对象默认不是冻结的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(obj)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当对象变得不可扩展且无属性时，也成为冻结对象</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(obj));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不可扩展的空对象是一个密封对象，同时也是冻结对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(<span class="built_in">Object</span>.preventExtensions(&#123;&#125;))); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(<span class="built_in">Object</span>.preventExtensions(&#123;&#125;))); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &#x27;Cola&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(obj);</span><br><span class="line">console.log(Object.isFrozen(obj)); //true</span><br><span class="line"></span><br><span class="line">//对冻结对象的任何操作都会失败</span><br><span class="line">obj.name = &#x27;Coca Cola&#x27;;</span><br><span class="line">delete obj.name;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><p><strong>注意:再严格模式下,对冻结对象的操作会抛出类型异常</strong></p><h4 id="浅冻结"><a href="#浅冻结" class="headerlink" title="浅冻结"></a>浅冻结</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="attr">CocaCola</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        <span class="attr">PepsiCola</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">obj.name = <span class="string">&#x27;Sprite&#x27;</span></span><br><span class="line">obj.color.CocaCola = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, color: &#123; CocaCola: &#x27;white&#x27;, PepsiCola: &#x27;blue&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="深冻结"><a href="#深冻结" class="headerlink" title="深冻结"></a>深冻结</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completelyFreezeObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) != <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&quot;obj不是对象&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj[key]) == <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">            completelyFreezeObj(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;属性描述符&quot;&gt;&lt;a href=&quot;#属性描述符&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Google JavaScript 编码规范部分整理</title>
    <link href="http://example.com/2020/02/17/Google%20JavaScript%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/02/17/Google%20JavaScript%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/</id>
    <published>2020-02-17T08:54:50.000Z</published>
    <updated>2021-08-07T05:59:13.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文参考:</p><ul><li><a href="https://google.github.io/styleguide/jsguide.html">https://google.github.io/styleguide/jsguide.html</a></li><li><a href="http://alloyteam.github.io/JX/doc/specification/google-javascript.xml">http://alloyteam.github.io/JX/doc/specification/google-javascript.xml</a></li><li><a href="https://max.book118.com/html/2019/0202/7052110006002005.shtm">https://max.book118.com/html/2019/0202/7052110006002005.shtm</a></li><li><a href="https://segmentfault.com/a/1190000012916070#item-5-22">https://segmentfault.com/a/1190000012916070#item-5-22</a></li><li><a href="https://github.com/wayou/wayou.github.io/issues/21">https://github.com/wayou/wayou.github.io/issues/21</a></li></ul><p>因本人水平有限,如有错误,可及时联系作者修改.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JavaScript 是一种客户端脚本语言，Google 的许多开源工程中都有用到它。这份指南列出了编写 JavaScript 时需要遵守的规则，当且仅当 JavaScript 源文件遵守此处规则时，它才被描述为 Google 风格。</p><h2 id="JavaScript-语言规范"><a href="#JavaScript-语言规范" class="headerlink" title="JavaScript 语言规范"></a>JavaScript 语言规范</h2><ul><li><p>局部变量声明</p><ul><li>使用<code>const</code> 和<code>let</code><br>用 <code>const</code>或 <code>let</code> 声明所有局部变量，默认情况下使用<code>const</code>，除非需要重新分配变量。</li><li>一个变量一个声明<br>每个局部变量声明仅声明一个变量。不使用诸如 <code>let a = 1, b = 2;</code> 这样的声明形式。</li><li>在需要时进行声明，并尽快初始化<br>局部变量不是在其包含的块或类似块的结构的开头习惯性地声明的。而是将局部声明在接近首次使用它们的地方(在合理范围内)，以最大程度地减小其范围。</li><li>根据需要声明类型<br>可以在声明的局部变量上方添加JSDoc类型注释，或者如果不存在其他JSDoc，则可以在变量名称之前内联。</li></ul><p>  例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="comment">/**! Array &lt;number&gt; */</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一些描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="type">&#123;! Array &lt;number&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">const</span> data = [];</span><br></pre></td></tr></table></figure><p>  不允许混合使用内联和JSDoc样式：因为编译器将仅处理第一个JSDoc，即内联注释会丢失，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一些描述。*/</span> <span class="keyword">const</span> <span class="comment">/**！Array &lt;number&gt; */</span> 数据= [];</span><br></pre></td></tr></table></figure><p>  <strong>提示：在许多情况下，编译器可以推断出模板化类型，但不能推断其参数。当初始化字面量或构造函数调用不包含模板参数类型的任何值(例如，空数组，对象，Map和Set)或变量在闭包中修改时，在这些情况下，局部变量类型注释特别有用，否则编译器会将模板参数推断成未知。</strong></p></li><li><p>数组字面量</p><ul><li>使用逗号结尾<br>如果最后一个元素和右括号之间有换行符，请在结尾加上逗号，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [</span><br><span class="line"><span class="string">&#x27;first value&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;second value&#x27;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li>不要使用可变参数的 <code>Array构造函数</code><br>构造函数很容易因为传参不恰当而导致错误。请改用字面量形式。<br>不建议的形式，例：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2, x3);</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1);</span><br><span class="line"><span class="keyword">const</span> a4 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure><p>  除了第三种情况外，这可以按照预期工作：如果x1为整数，那么a3则是一个长度为x1的数组，其所有元素均为<code>undefined</code>。如果x1为其他任何数字，则将引发异常。<br>  建议的写法，例：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [x1, x2, x3];</span><br><span class="line"><span class="keyword">const</span> a2 = [x1, x2];</span><br><span class="line"><span class="keyword">const</span> a3 = [x1];</span><br><span class="line"><span class="keyword">const</span> a4 = [];</span><br></pre></td></tr></table></figure><p>  在适当的时候，允许用<code>new Array(length)</code>显示分配一个给定长度的数组。</p><ul><li>非数字属性<br>请勿在数组上定义或使用非数字属性（除了<code>length</code>）。使用<code>Map</code>（或<code>Object</code>）代替。</li><li>解构<br>数组字面量可用于分配的左侧以执行解构（例如，从单个数组中解压缩多个值或可迭代时）。 可以包含最后一个rest元素（在…和变量名之间没有空格）,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, ...rest] = generateResults();</span><br><span class="line"><span class="comment">//解构赋值还可以忽略某些元素</span></span><br><span class="line"><span class="keyword">let</span> [, b,, d] = someArray</span><br></pre></td></tr></table></figure>解构也可以用于函数参数（请注意，参数名称是必需的，但会被忽略）。如果解构数组的参数是可选的，要始终指定<code>[]</code>为默认值，并在左侧提供默认值，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;!Array&lt;number&gt;=&#125;</span> </span>param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optionalDestructuring</span>(<span class="params">[a = <span class="number">4</span>, b = <span class="number">2</span>] = []</span>) </span>&#123; … &#125;;</span><br></pre></td></tr></table></figure>错误的写法，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badDestructuring</span>(<span class="params">[a, b] = [<span class="number">4</span>, <span class="number">2</span>]</span>) </span>&#123; … &#125;;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>提示：对于将多个值（解包）到一个函数的参数或返回中，在可能的情况下，优先选择对象分解而不是数组分解，因为它允许命名单个元素并为每个元素指定不同的类型。</strong></p><ul><li>展开运算符<br>数组字面量可以包含展开运算符（<code>…</code> ），以将元素从一个或多个可迭代对象中展开，而不是用更笨拙的构造<code>Array.prototype</code> 。变量紧跟在展开运算符后，没有空格。</li></ul></li><li><p>对象字面量</p><ul><li>不要使用<code>Object构造函数</code><br>虽然<code>Object 构造器</code>没有上述类似的问题, 但鉴于可读性和一致性考虑, 最好还是在字面上更清晰地指明，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></li><li>请勿混用带引号和不带引号的键<br>对象字面量可以表示结构（具有未加引号的键和/或符号）或字典（具有引号和/或计算的键）。不要将这两种键类型混合在单个对象字面量中，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">42</span>,<span class="comment">// struct风格的未加引号的键</span></span><br><span class="line"><span class="string">&#x27;maxWidth&#x27;</span>: <span class="number">43</span> <span class="comment">// dict风格的加引号的键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这还扩展到将属性名称传递给函数，例如 <code>hasOwnProperty</code>。特别是这样做会破坏编译后的代码，因为编译器无法重命名/混淆字符串文字。<br>不建议的写法，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;&#123;width: number, maxWidth: (number|undefined)&#125;</span></span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">width</span>: <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (o.hasOwnProperty(<span class="string">&#x27;maxWidth&#x27;</span>)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  最好这样实现，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;&#123;width: number, maxWidth: (number|undefined)&#125;</span></span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">width</span>: <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (o.maxWidth != <span class="literal">null</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>计算的属性名称<br>允许使用计算的属性名称（例如<code>&#123;[&#39;key&#39;+ foo（）]：42&#125;</code>），并且将其视为dict样式（带引号的）键（即，不得与非引号的键混合使用），除非计算出的属性 是一个符号（例如[Symbol.iterator]）。 枚举值也可以用于计算键，但不应与同一字面量中的非枚举键混合使用,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;width&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">42</span>,</span><br><span class="line">[<span class="string">&#x27;max&#x27;</span> + foo()] : <span class="number">43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法速记<br>可以使用方法简写（<code>&#123;method（）&#123;…&#125;&#125;</code>）代替冒号后紧跟函数或箭头函数常量，从而在对象上定义方法。<br>例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">42</span>,</span><br><span class="line"><span class="function"><span class="title">getWidth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.width;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>速记属性<br>对象字面量允许使用速记属性,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">foo,</span><br><span class="line">bar,</span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.foo + <span class="built_in">this</span>.bar; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>解构<br>对象解构模式可以在分配的左侧使用，以执行解构并从单个对象解压缩多个值。<br>分解后的对象也可以用作函数参数，但应保持尽可能的简单：单个级别的未引用速记属性。 参数解构中可能不使用更深层的嵌套和计算的属性。 在解构参数的左侧指定任何默认值（<code>&#123;str =&#39;some default&#39;&#125; = &#123;&#125;</code>，而不是<code>&#123;str&#125; = &#123;str：&#39;some default&#39;&#125;</code>），如果解构对象为本身是可选的，它必须默认为<code>&#123;&#125;</code>。 可以为分解结构参数的JSDoc指定任何名称（该名称未使用，但编译器需要）,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">ordinary</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;&#123;num: (number|undefined), str: (string|undefined)&#125;</span></span>=&#125; param1</span></span><br><span class="line"><span class="comment">*     num: The number of times to do something.</span></span><br><span class="line"><span class="comment">*     str: A string to do stuff to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destructured</span>(<span class="params">ordinary, &#123;num, str = <span class="string">&#x27;some default&#x27;</span>&#125; = &#123;&#125;</span>)</span></span><br><span class="line"><span class="function">不被允许的写法，例：</span></span><br><span class="line"><span class="function">/** @<span class="title">param</span> </span>&#123;&#123;<span class="attr">x</span>: &#123;<span class="attr">num</span>: (number|<span class="literal">undefined</span>), <span class="attr">str</span>: (string|<span class="literal">undefined</span>)&#125;&#125;&#125; param1 */</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nestedTooDeeply</span>(<span class="params">&#123;x: &#123;num, str&#125;&#125;</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;&#123;num: (number|undefined), str: (string|undefined)&#125;</span></span>=&#125; param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonShorthandProperty</span>(<span class="params">&#123;num: a, str: b&#125; = &#123;&#125;</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;&#123;a: number, b: number&#125;</span></span>&#125; param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computedKey</span>(<span class="params">&#123;a, b, [a + b]: c&#125;</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;&#123;a: number, b: string&#125;</span></span>=&#125; param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nontrivialDefault</span>(<span class="params">&#123;a, b&#125; = &#123;a: <span class="number">2</span>, b: <span class="number">4</span>&#125;</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li><li>枚举<br>枚举是通过将@enum批注添加到对象字面量中来定义的。 定义枚举后，可能无法将其他属性添加到枚举中。 枚举必须是常量，并且所有枚举值都必须是不可变的,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Supported temperature scales.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@enum <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> TemperatureScale = &#123;</span><br><span class="line"><span class="attr">CELSIUS</span>: <span class="string">&#x27;celsius&#x27;</span>,</span><br><span class="line"><span class="attr">FAHRENHEIT</span>: <span class="string">&#x27;fahrenheit&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An enum with two options.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@enum <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> Option = &#123;</span><br><span class="line"><span class="comment">/** The option used shall have been the first. */</span></span><br><span class="line"><span class="attr">FIRST_OPTION</span>: <span class="number">1</span>,</span><br><span class="line"><span class="comment">/** The second among two options. */</span></span><br><span class="line"><span class="attr">SECOND_OPTION</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类</p><ul><li>构造函数<br>构造函数是可选的,子类构造函数必须在设置任何字段或以其他方式访问<code>this</code>之前调用<code>super（）</code>。<br>正确的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name, age, height</span>)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(name,age);</span><br><span class="line"><span class="built_in">this</span>.height = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>错误的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name, age, height</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.height = height;</span><br><span class="line"><span class="built_in">super</span>(name,age);</span><br><span class="line"><span class="comment">//SyntaxError: &#x27;this&#x27; is not allowed before super()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>字段<br>在构造函数中设置所有具体对象的字段（即方法以外的所有属性）。使用 @const 修饰的字段代表常量，不能被重新赋值。 使用适当的可见性注释（@private，@protected，@package）注释非公共字段，并在所有@private字段的名称后面加上下划线。 字段永远不会设置在具体类的原型上,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@private </span><span class="doctag">@const <span class="type">&#123;!Bar&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.bar_ = computeBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@protected </span><span class="doctag">@const <span class="type">&#123;!Baz&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.baz = computeBaz();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>提示:类在初始化之后，就不能再向其添加或删除属性了，因为这会影响虚拟机对其进行优化。如果必要，可以将之后才进行初始化的字段先赋值为 undefined，这样先占位之后，防止后面再添加新属性。对象身上的@struct 注释可以对不存在的字段的访问进行检查。类自带了这一功能。</strong></p><ul><li>计算属性<br>计算属性只能用于类的属性是 symbol 的情况。 Dict-style 类型的属性（带引号或非 symbol 的计算属性是不被允许的。对于可遍历的类，需要定义其 [Symbol.iterator] 方法。其他情况下少用 Symbol。</li></ul><p>  <strong>注意:使用其他内建的 symbol 时要格外小心（e.g. Symbol.isConcatSpreadable）,因为编译器没有对它进行垫片（向后兼容）处理，所以在旧版浏览器中会有问题</strong></p><ul><li>静态方法<br>在不影响可读性的前提下，推荐使用模块内部的函数而不是静态方法。</li></ul><p>  静态方法应该只用于基类。静态方法不应该从一个保存了实例的变量身上调用，这个实例有可能是构造器或者子类的构造器初始化而来（静态方法应该使用 @nocollapse 来注释），而且如果子类没有定义该方法的话，不应该从子类直接调用。<br>  错误的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="comment">/** <span class="doctag">@nocollapse </span>*/</span> <span class="keyword">static</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">cls</span>) </span>&#123; cls.foo(); &#125;  <span class="comment">// discouraged: don&#x27;t call static methods dynamically</span></span><br><span class="line">Sub.foo();  <span class="comment">// illegal: don&#x27;t call static methods on subclasses that don&#x27;t define it themselves</span></span><br></pre></td></tr></table></figure><ul><li>声明类的旧方式<br>ES6 方式的类声明是首选，但在某些情况下ES6类可能不可行。例如：<ul><li>如果存在或将要存在子类，包括框架创建的子类，还不能立即使用 ES6 风格的类声明。因为如果基类使用 ES6 方式的话，所有子类代码都需要更改。</li><li>有些框架在调用子类构造器时需要显式提供 this，而 ES6 风格的类中在调用 super 前是获取不到 this 的。</li></ul></li></ul><p>  此规则还应用于这些代码：<code>let</code>，<code>const</code>，默认参数，rest 和箭头函数。</p><p>  通过 goog.defineClass 可以进行类 ES6 方式的类声明：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> C = goog.defineClass(S, &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">S.call(<span class="built_in">this</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/** <span class="doctag">@const </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.prop = value;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">param</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params">param</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  另外，尽管<code>goog.defineClass</code>所有新代码都应首选，但也可以使用更传统的语法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@constructor </span><span class="doctag">@extends <span class="type">&#123;S&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">S.call(<span class="built_in">this</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/** <span class="doctag">@const </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.prop = value;</span><br><span class="line">&#125;</span><br><span class="line">goog.inherits(C, S);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">param</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">C.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  如果有基类的话，实例中的属性需要在基类的构造器中定义。而方法则需要在构造器的原型上定义。</p><p>  一开始正确地定义构造器的继承关系并不是件容易的事！所以，最好使用 the Closure Library 提供的 <code>goog.inherits</code> 方法。</p><ul><li><p>不要直接操作<code>prototype</code><br>通过 class 关键字定义类比操作 prototype 更加简洁和直观。一般情况下的代码并没有必要操作原型，尽管它们对于定义旧式类声明中定义的类仍然有用。明确禁止混入和修改内置对象的原型.<br>例外:框架代码(例如Polymer或Angular)可能需要使用<code>prototype</code>s，否则实现起来会更加丑陋。</p></li><li><p>Getters and Setters<br>不要使用 JavaScript <code>getter</code>和 <code>setter</code>属性。其行为不透明出问题难追查，编译器支持上也有局限。提供正常的方法来代替他们。</p></li></ul><p>  例外：在某些情况下不可避免地会定义<code>getter</code>或<code>setter</code>（例如<code>Angular</code>和<code>Polymer</code>等数据绑定框架，或者无法与调整的外部API的兼容时）。仅在这些情况下，使用<code>getter</code>和<code>setter</code>时要格外小心，前提是它们是通过<code>get</code>和<code>set</code>简写方法关键字定义的<code>Object.defineProperties</code>（或（不是 <code>Object.defineProperty</code>，这会干扰属性重命名））。Getters不得更改可观察状态。<br>  不允许的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">get</span> <span class="title">next</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.nextId++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重写 toString<br>可以重写 toString 方法，但始终应该返回成功，并且不产生副作用（side effects）。</li></ul><p>  <strong>提示:需要注意的是，特别是在 toString 中调用其他方法时，特殊情况可能导致死循环。</strong></p><ul><li><p>接口<br>接口可以通过 @interface 或 @record 来声明。通过 @record 声明的接口能够被显式（i.e. 通过 @implements）或者隐式地被类或对象实现。<br>接口上的所有非静态方法主体都必须为空块。 字段必须在类构造函数中声明为未初始化的成员,例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Something that can frobnicate.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@record</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frobnicator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>The number of attempts before giving up. */</span></span><br><span class="line"><span class="built_in">this</span>.attempts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Performs the frobnication according to the given strategy.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!FrobnicationStrategy&#125;</span> <span class="variable">strategy</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">frobnicate</span>(<span class="params">strategy</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类<br>适当时使用抽象类。抽象类和方法必须使用注释@abstract。不要使用<code>goog.abstractMethod</code>。请参阅<a href="https://github.com/google/closure-compiler/wiki/@abstract-classes-and-methods">抽象类和方法</a>。</p></li></ul></li><li><p>函数</p><ul><li>顶级函数<br>顶级函数可以直接在导出对象上定义，也可以在本地声明，也可以选择导出,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>str */</span></span><br><span class="line"><span class="built_in">exports</span>.processString = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Process the string.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>str */</span></span><br><span class="line"><span class="keyword">const</span> processString = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Process the string.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span> = &#123;processString&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>嵌套函数及闭包<br>函数内可包含嵌套函数的定义。如果需要，可以赋值给一个 const 变量。</p></li><li><p>箭头函数<br>箭头函数提供了简洁的函数语法，并简化了嵌套函数的作用域。 优先选择箭头函数而不是function关键字，特别是对于嵌套函数。</p></li></ul><p>  推荐使用箭头函数代替 <code>f.bind(this)</code>，特别是代替 <code>goog.bind(f,this)</code>。 避免<code>const self = this</code>这样的写法。箭头函数特别适合用于可能会传参回调。</p><p>  箭头的左侧包含零个或多个参数。如果只有一个未分解的参数，则参数周围的括号是可选的。使用括号时，可以指定内联参数类型</p><p>  <strong>提示:始终都写括号是种好的做法，因为后面如果一旦新加了参数又忘记写括号则会有语法错误。</strong></p><p>  箭头的右侧包含函数的主体。 默认情况下，主体为block语句（零个或多个用花括号括起来的语句）。 如果发生以下情况之一，则主体也可能是隐式返回的单个表达式：程序逻辑要求返回值，或者void运算符位于单个函数或方法调用之前（使用void确保未定义返回，防止泄漏值并传达意图）。 如果单一表达形式提高了可读性（例如，对于简短表达或简单表达），则它是首选,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Arrow functions can be documented just like normal functions.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>numParam A number to add.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>strParam Another number to add that happens to be a string.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>The sum of the two parameters.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> moduleLocalFunc = <span class="function">(<span class="params">numParam, strParam</span>) =&gt;</span> numParam + <span class="built_in">Number</span>(strParam);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses the single expression syntax with `void` because the program logic does</span></span><br><span class="line"><span class="comment">// not require returning a value.</span></span><br><span class="line">getValue(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="keyword">void</span> alert(<span class="string">`Got <span class="subst">$&#123;result&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallbackExample</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@private <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.cachedValue_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For inline callbacks, you can use inline typing for parameters.</span></span><br><span class="line"><span class="comment">// Uses a block statement because the value of the single expression should</span></span><br><span class="line"><span class="comment">// not be returned and the expression is not a single function call.</span></span><br><span class="line">getNullableValue(<span class="function">(<span class="params"><span class="comment">/** ?number */</span> result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.cachedValue_ = result == <span class="literal">null</span> ? <span class="number">0</span> : result;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  不建议的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A function with no params and no returned value.</span></span><br><span class="line"><span class="comment">* This single expression body usage is illegal because the program logic does</span></span><br><span class="line"><span class="comment">* not require returning a value and we&#x27;re missing the `void` operator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> moduleLocalFunc = <span class="function">() =&gt;</span> anotherFunction();</span><br></pre></td></tr></table></figure><ul><li>生成器(Generators)<br>生成器带来许多有用的抽象概念，必要时可以使用。</li></ul><p>  通过在<code>function</code>关键字后面加<code>*</code>号来定义一个生成器，后面加空格与生成器名称隔开。使用代理的<code>yield</code>时，在<code>yield</code>关键字后加<code>*</code>号,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;!Iterator&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;!Iterator&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">const</span> gen2 = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">yield</span>* gen1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;!Iterator&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class="line">* <span class="function"><span class="title">gen</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数和返回类型<br>函数参数和返回类型通常应使用JSDoc注释记录。</p><ul><li>默认参数<br>参数列表中通过等号来指定可选参数。可选参数必须在<code>=</code>运算符的两侧都包含空格，命名上与正常参数一样（不使用 opt_ 前缀），JSDoc 指定类型时使用<code>=</code>后缀，顺序上置于正常参数之后，不要用初始化以确保代码明确。所有可选参数都需要指定默认值，哪怕它是<code>undefined</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>required This parameter is always needed.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string=&#125;</span> </span>optional This parameter can be omitted.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!Node=&#125;</span> </span>node Another optional parameter.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maybeDoSomething</span>(<span class="params">required, optional = <span class="string">&#x27;&#x27;</span>, node = <span class="literal">undefined</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@interface </span>*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interface and abstract methods must omit default parameter values.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string=&#125;</span> <span class="variable">optional</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">someMethod</span>(<span class="params">optional</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>尽量少地使用可选参数。参数不定的情况下推荐使用解构的方式，这样所定义出来的 API 更加可读。</li></ul><p>  <strong>注意：与 Python 不同，初始化可选参数时返回新的非可变对象（[] 或 {}）是可以的。因为每次可选参数被使用时，都是重新赋值，不会与上一次的复用。包括函数调用的任何表达式都会用到初始化模块，所以初始化模块应该尽量简单。避免初始化模块暴露共享可变域，这容易导致函数调用之间的无意耦合。</strong></p><ul><li>剩余参数<br>使用剩余参数而不是 arguments。JSDoc 中使用<code>...</code>标识剩余参数。剩余参数必需位于参数列表末尾。注意<code>...</code>与参数名间没有空格。也不要给剩余参数命名。千万不要给变量或参数取名<code>arguments</code>，这会覆盖内建的同名参数,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!Array&lt;string&gt;&#125;</span> </span>array This is an ordinary parameter.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;...number&#125;</span> </span>numbers The remainder of arguments are all numbers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">variadic</span>(<span class="params">array, ...numbers</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>泛型<br>定义泛型函数或方法时需在JS注文中加上@template TYPE。</p></li><li><p>扩展运算符<br>可使用展示操作符（<code>...</code>）来调用函数。当使用数组或可遍历对象解析后作为函数入参时，推荐使用展开操作符来替代 <code>Function.prototype.apply</code>。注意<code>...</code>后面没有空格,例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">...elements</span>) </span>&#123;&#125;</span><br><span class="line">myFunction(...array, ...iterable, ...generator());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串字面量</p><ul><li>使用单引号<br>常规字符串使用单引号(<code>&#39;</code>)而非双引号(<code>&quot;</code>)来定义。<br>通常情况下，字符串不能跨行。</li></ul><p>  <strong>提示:如果字符串包含单引号字符，请考虑使用模板字符串，以避免不得不对引号进行转义。</strong></p><ul><li>模板字符串<br>使用模板字符串（<code> </code> `）替代复杂的字符串拼接，特别是参与拼接的变量很多时。模板字符串是可以跨越多行的。<br>模板字符串跨越多行时，可不受代码块缩进规则限制，如果加上缩进好看些的话也可以,例:</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arithmetic</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`Here is a table of arithmetic operations:</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> - <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a - b&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> * <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a * b&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> / <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a / b&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用多行接续<br>无论是常规字符串还是模板字符串中都不要使用多行接续（即在行尾加反斜杠\）。虽然 ES5 允许这么操作，但反斜杠后的空格会导致问题，并且这种形式也不易读。<br>错误的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longString = <span class="string">&#x27;This is a very long string that far exceeds the 80 \</span></span><br><span class="line"><span class="string">column limit. It unfortunately contains long stretches of spaces due \</span></span><br><span class="line"><span class="string">to how the continued lines are indented.&#x27;</span>;</span><br></pre></td></tr></table></figure>正确的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longString = <span class="string">&#x27;This is a very long string that far exceeds the 80 &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;column limit. It does not contain long stretches of spaces since &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;the concatenated strings are cleaner.&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数字字面量<br>数字可有多种呈现形式：十进制，十六进制，八进制或二进制。分别使用小写的 0x，0o，0b 前缀表示十六进制，八进制以及二进制数字。除此之外不应该出现以0开头的数字。</p></li><li><p>控制结构</p><ul><li><p>for循环<br>ES6之后一共有三种for循环,推荐使用<code>for-of</code><br><code>for-in</code>适用于字典类型（dist-style）而不要用于遍历数组。配合<code>Object.prototype.hasOwnProperty</code>来过滤掉非直接的属性。推荐使用<code>for-of </code>和<code> Object.keys</code>，其次才是 <code>for-in</code>。</p></li><li><p>异常<br>异常是语言中重要的一部分，发生异常时应尽可能抛出。始终抛出Error或子类的Error，而不是抛出字符串或其他对象作为异常。使用 <code>Error</code>时始终通过<code>new</code>来创建新实例。</p></li></ul><p>  这种处理扩展到<code>Promise</code>拒绝值，因为在异步函数中<code>Promise.reject（obj）</code>等效于<code>throw obj;</code> 。</p><p>  自定义类型的错误提供了非常好的方式展示函数中的异常。当原生错误类型不能满足需求时，应尽可能创建自定义的异常。</p><p>  遇到错误后立即抛出优于将错误进行传递。</p><p>  空的 catch 块</p><p>  响应捕获到的异常，什么也不做是非常正确的。 当确实在catch块中不执行任何操作时，但记得加注释解释一下原因,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> handleNumericResponse(response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ok) &#123;</span><br><span class="line"><span class="comment">// it&#x27;s not numeric; that&#x27;s fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure><p>  错误的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">shouldFail();</span><br><span class="line">fail(<span class="string">&#x27;expected an error&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>提示:不像其他一些语言，上面示例行不通，因为会通过<code>fail</code>来捕获处理。所以使用<code>assertThrows</code>。</strong></p><ul><li><p>switch 语句<br>术语解释：switch 语句体中其实是很多组的代码块。每一组又包含一个或多个 switch 标签（<code>case Foo:</code> 或 <code>default:</code>）以及标签后跟随的代码语句。</p><ul><li>Fall-through：要加注释<br>每个 switch 标签要么通过<code>break</code>，<code>return</code>，<code>throw</code> 结束，要么通过注释直接跳过到下一标签。在发生跳过的情况时，随便加个注释都行。如果是最后一个标签可以不加,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">prepareOneOrTwo();</span><br><span class="line"><span class="comment">// fall through</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">handleOneTwoOrThree();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>default 是不能省的<br>即使 default 标签中不包含逻辑，也不要省略。</li></ul></li></ul></li><li><p>this<br>  应该只在类的构造器或方法中使用<code>this</code>，或类中的箭头函数。其他情况下使用·this·需要在函数的 JSDoc 结尾处添加 @this 注释。<br>  不要使用<code>this</code>来引用全局对象，<code>eval</code>的执行上下文，事件的触发元素，以及函数这种不必要的用法中 <code>call()</code>，<code>apply()</code> 。</p></li><li><p>相等检查<br>使用恒等运算符（=== /！==），但以下情况除外。</p><ul><li>需要强制转换的异常<br>捕捉<code>null</code>和<code>undefined</code>值：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObjectOrPrimitive == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Checking for null catches both null and undefined for objects and primitives , </span></span><br><span class="line"><span class="comment">// but does not catch other falsy values like 0 or the empty string.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>禁止使用的特性</p><ul><li>with<br>杜绝使用<code>with</code>关键字。这样的代码不易读，而且 ES5 之后就禁止掉了。</li><li>代码的动态求值<br>不要使用<code>eval</code>或<code>Function(...string) 构造器</code>代码加载器（code loader）中除外）。这些关键字很危险并且在 CSP 环境中是不工作的。</li></ul><p>  <strong>CSP 指 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policy (CSP)</a></strong></p><ul><li>自动分号添加<br>始终以分号结束语句（类与函数的声明除外）。</li><li>非标准的特性<br>不要使用还不是标准的特性。包括已经被移除的特性（e.g. WeakMap.clear），还未纳入标准的新特性（e.g. TC39 目前的草稿，提议，通过提议但还未完成标准制定），或一些只被部分浏览器所实现的特性。只使用包含在 ECMA-262 或 WHATWG standards 标签中的特性。但一些有自己规范的项目是可以使用这些特性的，比如 Chrome 插件或 Node.js。三方转译器提供的特性也是被禁止的。</li><li>原始类型的包装对象<br>对于原始值的包装对象（<code>Boolean</code>, <code>Number</code>, <code>String</code>, <code>Symbol</code>）不能用<code>new</code>调用，也不能用来作类型声明。<br>错误的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="comment">/** Boolean */</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) alert(<span class="keyword">typeof</span> x);  <span class="comment">// alerts &#x27;object&#x27; - WAT?</span></span><br></pre></td></tr></table></figure>这些包装器可在需要类型转换时当作函数来调用（而不是使用拼接空字符串的方式来转成字符串），或用于创建 symbol。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="comment">/** boolean */</span> x = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!x) alert(<span class="keyword">typeof</span> x);  <span class="comment">// alerts &#x27;boolean&#x27;, as expected</span></span><br></pre></td></tr></table></figure></li><li>修改原生对象<br>千万不要修改原生对象，向其构造器或原型添加方法都是不行的。进行了这些操作的三方库也要避免使用。编译器在编译时会尽可能提供这些原生对象的原始版本；所以原生对象的任何东西都不要去动。</li></ul><p>  不到万不得已，不要向全局对象添加属性（e.g. 三方库需要这样做）。</p></li></ul><h2 id="JavaScript-编码风格"><a href="#JavaScript-编码风格" class="headerlink" title="JavaScript 编码风格"></a>JavaScript 编码风格</h2><ul><li><p>JSDoc<br>JSDoc 使用在了所有的类，字段以及方法上。</p><ul><li>通用形式<br>JSDoc 基本的形式如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Multiple lines of JSDoc text are written here,</span></span><br><span class="line"><span class="comment">* wrapped normally.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>arg A number to do something to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>或者这种单行的形式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@const </span><span class="doctag">@private <span class="type">&#123;!Foo&#125;</span> </span>A short bit of JSDoc. */</span></span><br><span class="line"><span class="built_in">this</span>.foo_ = foo;</span><br></pre></td></tr></table></figure>如果单行形式长到需要折行，则需要切换到多行模式而不是使用单行形式。<br>有许多工具会对 JSDoc 文档进行解析以提取出有效的信息对代码进行检查和优化。所以这些注释需要好好写。</li><li>Markdown<br>JSDoc 支持 Markdown，所以必要时可包含 HTML。<br>工具会自动提取 JSDoc 的内容，其中自己书写的格式会被忽略。比如如果你写成下面这个样子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Computes weight based on three factors:</span></span><br><span class="line"><span class="comment">*   items sent</span></span><br><span class="line"><span class="comment">*   items received</span></span><br><span class="line"><span class="comment">*   last timestamp</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>最终提取出来是这样的：<br><code>Computes weight based on three factors: items sent items received last timestamp</code><br>取而代之的是，我们应该按 markdown 的语法来格式化,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Computes weight based on three factors:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  - items sent</span></span><br><span class="line"><span class="comment">*  - items received</span></span><br><span class="line"><span class="comment">*  - last timestamp</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>JSDoc标签<br>本规则可使用 JSDoc tags 的一个子集。详细列表见附录。大部分 tags 独占一行。<br>错误的写法,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The &quot;param&quot; tag must occupy its own line and may not be combined.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>left <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">left, right</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><p>  简单的 tag 无需额外数据（比如 @private，@const，@final，@export），可以合并到一行。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Place more complex annotations (like &quot;implements&quot; and &quot;template&quot;)</span></span><br><span class="line"><span class="comment">* on their own lines.  Multiple simple tags (like &quot;export&quot; and &quot;final&quot;)</span></span><br><span class="line"><span class="comment">* may be combined in one line.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@export </span><span class="doctag">@final</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@implements <span class="type">&#123;Iterable&lt;TYPE&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@template <span class="variable">TYPE</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!ObjType&#125;</span> </span>obj Some object.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number=&#125;</span> </span>num An optional number.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">obj, num = <span class="number">42</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@private </span><span class="doctag">@const <span class="type">&#123;!Array&lt;!ObjType|number&gt;&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.data_ = [obj, num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  关于合并及合并后的顺序没有明确的规范，代码中保持一致即可。</p><ul><li>换行<br>换行之后的 tag 块使用四个空格进行缩进。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Illustrates line wrapping for long param/return descriptions.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>foo This is a param with a description too long to fit in</span></span><br><span class="line"><span class="comment">*     one line.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>This returns something that has a description too long to</span></span><br><span class="line"><span class="comment">*     fit in one line.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">exports</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>@fileoverview 换行时不缩进。</li><li>文件头部注释<br>一个文件可以在头部有个总览。包括版权信息，作者以及默认可选的可见信息/visibility level等。文件中包含多个类时，头部这个总览显得很有必要。它可以帮助别人快速了解该文件的内容。如果写了，则应该有一个描述字段简单介绍文件中的内容以及一些依赖，或者其他信息。换行后不缩进,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@fileoverview </span>Description of file, its uses and information</span></span><br><span class="line"><span class="comment">* about its dependencies.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@package</span></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>类的注释<br>类，接口以及 records 需要有描述，参数，实现的接口以及可见性或其他适当的 tags 注释。类的描述需要告诉读者类的作用及何时使用该类，以及其他一些可以帮助别人正确使用该类的有用信息。构造器上的文本描述可省略。@constructor 和 @extends 不与 class 一起使用，除非该类是用来声明接口 @interface 或者扩展一个泛型类。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A fancier event target that does cool things.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@implements <span class="type">&#123;Iterable&lt;string&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFancyTarget</span> <span class="keyword">extends</span> <span class="title">EventTarget</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>arg1 An argument that makes this more interesting.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!Array&lt;number&gt;&#125;</span> </span>arg2 List of numbers to be processed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">arg1, arg2</span>)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Records are also helpful.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@extends <span class="type">&#123;Iterator&lt;TYPE&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@record</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@template <span class="variable">TYPE</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listable</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;TYPE&#125;</span> </span>The next item in line to be returned. */</span></span><br><span class="line"><span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>枚举和 typedef 注释<br>所有枚举和typedef必须在上一行用适当的JSDoc标记（@typedef或@enum）进行记录。 公共枚举和typedef也必须有描述。 单个枚举项可能在上一行带有JSDoc注释的文档中。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A useful type union, which is reused often.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@typedef <span class="type">&#123;!Bandersnatch|!BandersnatchType&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> CoolUnionType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Types of bandersnatches.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@enum <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> BandersnatchType = &#123;</span><br><span class="line"><span class="comment">/** This kind is really frumious. */</span></span><br><span class="line"><span class="attr">FRUMIOUS</span>: <span class="string">&#x27;frumious&#x27;</span>,</span><br><span class="line"><span class="comment">/** The less-frumious kind. */</span></span><br><span class="line"><span class="attr">MANXOME</span>: <span class="string">&#x27;manxome&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>Typedefs 可方便地用于定义 records 类型，或 unions 的别名，复杂函数，或者 泛型类型。Typedefs 不适合用来定义字段很多的 records，因为其不支持对每个字段进行文档书写，也不适合用于模板或递归引用中。对于大型 records 使用 @record。</li><li>方法与函数注释<br>在方法和命名函数中，必须记录参数和返回类型，除非相同签名@overrides省略所有类型。必要时应记录此类型。如果函数没有非空的return语句，则可以省略返回类型。</li></ul><p>  如果方法，参数和返回描述（但不是类型）在方法的其余JSDoc或其签名中显而易见，则可以省略。</p><p>  方法的描述应使用第三人称。</p><p>  如果方法覆盖超类方法，则它必须包含@override注释。覆盖的方法从超类方法继承所有JSDoc注释（包括可见性注释），并且应在覆盖的方法中将其省略。但是，如果在类型注释中完善了任何类型，则必须显式指定所有@param和@return注释。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A class that does something. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Operates on an instance of MyClass and returns something.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!MyClass&#125;</span> </span>obj An object that for some reason needs detailed</span></span><br><span class="line"><span class="comment">*     explanation that spans multiple lines.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!OtherClass&#125;</span> <span class="variable">obviousOtherClass</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>Whether something occurred.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">someMethod</span>(<span class="params">obj, obviousOtherClass</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@override </span>*/</span></span><br><span class="line"><span class="function"><span class="title">overriddenMethod</span>(<span class="params">param</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Demonstrates how top-level functions follow the same rules.  This one</span></span><br><span class="line"><span class="comment">* makes an array.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;TYPE&#125;</span> <span class="variable">arg</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;!Array&lt;TYPE&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@template <span class="variable">TYPE</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">arg</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>  如果只需要记录函数的参数和返回类型，则可以选择在函数签名中使用内联JSDocs。 这些内联JSDocs指定不带标签的return和param类型,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /** <span class="title">string</span> */ <span class="title">foo</span>(<span class="params"><span class="comment">/** number */</span> arg</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>  如果需要描述或标签，请在方法上方使用单个JSDoc注释。 例如，返回值的方法需要@return标记。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">arg</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">bar</span>(<span class="params">arg</span>)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以下写法是错误的:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illegal inline JSDocs.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>*/</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Function description. */</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>  在匿名函数中，注释通常是可选的。 如果自动类型推断不足或显式注释提高了可读性，则对param进行注释并返回如下类型：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>*/</span></span><br><span class="line"><span class="function">(<span class="params"><span class="comment">/** !Array&lt;string&gt; */</span> items</span>) =&gt;</span> &#123;</span><br><span class="line">doSomethingWith(items);</span><br><span class="line"><span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>命名</p><ul><li>适用于所有标识符的规则<br>可用于标识符的有 ASCII 字符，数字，还有下划线 _ 以及不太常用的 $ (一些框架里面比如 Angular 会用)。</li></ul><p>  标识符取名尽量表意。不要怕名字太长，因为代码是给人看的，别人能看懂最重要。不要使用带歧义的缩写或者项目之外的人看不懂的缩写，也不要通过删除某个单词中的字符来发明缩写，例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">errorCount          <span class="comment">// No abbreviation.</span></span><br><span class="line">dnsConnectionIndex  <span class="comment">// Most people know what &quot;DNS&quot; stands for.</span></span><br><span class="line">referrerUrl         <span class="comment">// Ditto for &quot;URL&quot;.</span></span><br><span class="line">customerId          <span class="comment">// &quot;Id&quot; is both ubiquitous and unlikely to be misunderstood.</span></span><br></pre></td></tr></table></figure><p>  不建议的写法例：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n                   <span class="comment">// Meaningless.</span></span><br><span class="line">nErr                <span class="comment">// Ambiguous abbreviation.</span></span><br><span class="line">nCompConns          <span class="comment">// Ambiguous abbreviation.</span></span><br><span class="line">wgcConnections      <span class="comment">// Only your group knows what this stands for.</span></span><br><span class="line">pcReader            <span class="comment">// Lots of things can be abbreviated &quot;pc&quot;.</span></span><br><span class="line">cstmrId             <span class="comment">// Deletes internal letters.</span></span><br><span class="line">kSecondsPerDay      <span class="comment">// Do not use Hungarian notation.</span></span><br></pre></td></tr></table></figure><ul><li><p>标识符类型的命名规则</p><ul><li>包名<br>包名全是<strong>lowerCamelCase</strong>。例如，<code> my.exampleCode.deepSpace</code>但不是<code>my.examplecode.deepspace</code>或<code>my.example_code.deep_space</code>。</li><li>类名<br>定义类，接口，记录和 typedef 名称时,使用大写开头的驼峰<strong>UpperCamelCase</strong>。</li></ul><p>  未被导出的类只本地使用，并没有用 @private 标识，所以命名上不需要以下划线结尾。</p><p>  类型名称通常为名词或名词短语。比如，Request，ImmutableList，或者 VisibilityMode。此外，接口名有时会是一个形容词或形容短语（比如 Readable）。</p><ul><li>方法名<br>方法名使用小写开头的驼峰。私有方法需以下划线结尾。</li></ul><p>  方法名一般为动词或动词短语。比如<code>sendMessage</code>或者<code>stop_</code>。属性的 Getter 或 Setter 不是必需的，如果有的话，也是小写驼峰命名且需要类似这样 <code>getFoo</code>(对于布尔值使用 isFoo 或 hasFoo 形式)， <code>setFoo(value)</code>。</p><p>  单元测试代码中的方法名会出现用下划线来分隔组件形式。一种典型的形式是这样的 <code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如 <code>testPop_emptyStack</code>。对于这种测试代码中的方法，命名上没有统一的要求。</p><ul><li>枚举名<br>枚举使用大写开头的驼峰，和类相似，一般一个单数形式的名词。枚举中的元素写成<code>CONSTANT_CASE</code>。</li><li>常量名<br>常量写成 CONSTANT_CASE：所有字母使用大写，以下划线分隔单词。私有静态属性可以用内部变量代替，所以不会有使用私有枚举的情况，也就无需将常量以下划线结尾来命名。<ul><li>常量的定义<br>每个常量都是 @const 标识的静态属性或模块内部通过<code>const</code>声明的变量，但并不是所有 @const 标识的静态属性或 <code>const</code>声明的变量都是常量。需要常量时，先想清楚该对象是否真的不可变。例如，如果该对象中可观察状态中任何一个可被改变，那么几乎可以肯定它不是常数。只是想着不去改变它的值是不够的，我们要求它需要从本质上来说应该一成不变,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@const </span>*/</span> <span class="built_in">exports</span>.NAMES = ImmutableList.of(<span class="string">&#x27;Ed&#x27;</span>, <span class="string">&#x27;Ann&#x27;</span>);</span><br><span class="line"><span class="comment">/** <span class="doctag">@enum </span>*/</span> <span class="built_in">exports</span>.SomeEnum = &#123; <span class="attr">ENUM_CONSTANT</span>: <span class="string">&#x27;value&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">let</span> letVariable = <span class="string">&#x27;non-const&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="comment">/** <span class="doctag">@const <span class="type">&#123;string&#125;</span> </span>*/</span> <span class="built_in">this</span>.nonStatic = <span class="string">&#x27;non-static&#x27;</span>; &#125; &#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;string&#125;</span> </span>*/</span> MyClass.staticButMutable = <span class="string">&#x27;not @const, can be reassigned&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="comment">/** Set&lt;string&gt; */</span> mutableCollection = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="comment">/** ImmutableSet&lt;SomeMutableType&gt; */</span> mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">const</span> Foo = goog.require(<span class="string">&#x27;my.Foo&#x27;</span>);  <span class="comment">// mirrors imported name</span></span><br><span class="line"><span class="keyword">const</span> logger = log.getLogger(<span class="string">&#x27;loggers.are.not.immutable&#x27;</span>);</span><br></pre></td></tr></table></figure>常量的名称通常是名词或名词短语。</li><li>本地别名<br>给导入的变量起别名来提高可读性是可行的。函数中也有使用别名的情况。别名必需是<code>const</code>类型。</li></ul></li><li>非常量字段名<br>非常量字段（静态或其他）使用小写开头的驼峰，如果是私有的私有的则以下划线结尾。</li></ul><p>  一般是名词或名词短语。例如 <code>computedValues</code>，<code>index_</code>。</p><ul><li>参数名<br>参数使用小写开头的驼峰形式。即使参数需要一个构造器来初始化时，也是这一规则。</li></ul><p>  公有方法的参数名不能只使用一个字母。</p><p>  <strong>例外：</strong>如果三方库需要，参数名可以用 $ 开头。此例外不适用于其他标识符（e.g. 本地变量或属性）。</p><ul><li>局部变量名<br>如上所述，除了模块本地（顶级）常量外，本地变量名称都用<strong>lowerCamelCase</strong>形式编写。 函数作用域中的常量仍遵循lowerCamelCase形式。 请注意，即使变量包含构造函数，也将使用<strong>lowerCamelCase</strong>形式。</li><li>模板参数名<br>模板参数力求简洁，用一个单词，一个字母表示，全部使用大写，例如 TYPE，THIS。</li><li>模板本地名<br>未导出的模块本地名称是隐式私有的。 它们未被标记为@private，并且不以下划线结尾。这适用于类，函数，变量，常量，枚举和其他模块本地标识符。</li></ul></li><li><p>驼峰：定义<br>有时将一个英文短语转成驼峰有很多形式，例如首字母进行缩略，IPv6 以及 iOS 这种都有出现。为保证代码可控，本规范规定出如下规则。</p><ul><li>将短语移除撇号转成<strong>ASCII</strong>表示。例如 Müller’s algorithm 表示成 Muellers algorithm。</li><li>将上述结果拆分成单词，以空格或其他不发音符号（中横线）进行分隔。<ul><li>推荐的做法：如果其中包含一个已经常用的驼峰翻译，直接提取出来（e.g. AdWords 会成为 adwords）。需要注意的是 iOS 本身并不是个驼峰形式，它不属性任何形式，所以它不适用本条规则。</li></ul></li><li>将所有字母转成小写，然后将以下情况中的首字母大写：<ul><li>每个单词的首字母，这样便得到了大写开头的驼峰</li><li>除首个单词的其他所有单词的首字母，这样得到小写开头的驼峰</li></ul></li><li>将上述结果合并。</li></ul></li></ul><p>  过程中原来名称中的大小写均被忽略，例：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prose form               | Correct            | Incorrect</span><br><span class="line">-------------            | -------------      | -------------</span><br><span class="line"><span class="string">&quot;XML HTTP request&quot;</span>       | XmlHttpRequest     | XMLHTTPRequest</span><br><span class="line"><span class="string">&quot;new customer ID&quot;</span>        | newCustomerId      | newCustomerID</span><br><span class="line"><span class="string">&quot;inner stopwatch&quot;</span>        | innerStopwatch     | innerStopWatch</span><br><span class="line"><span class="string">&quot;supports IPv6 on iOS?&quot;</span>  | supportsIpv6OnIos  | supportsIPv6OnIOS</span><br><span class="line"><span class="string">&quot;YouTube importe&quot;</span>        | YouTubeImporter    | YoutubeImporter</span><br></pre></td></tr></table></figure><p>  可以接受，但不推荐。</p><p>  <strong>注意：一些英文词汇通过中横线连接的方式是有歧义的，比如 “nonempty” 和 “non-empty” 都是正确写法，所以方法名 checkNonempty checkNonEmpty 都算正确。</strong></p></li><li><p>格式化</p></li></ul><p><strong>术语解释：</strong>代码块（block-like construct）指类，函数，方法这些元素的正文部分，或花括号包裹的代码部分。参考数组字面量,对象字面量的定义，数组或对象也可以被视作一个类似于块的构造。<br><strong>提示:使用 clang-format。社区已经做了大量努力以使得 clang-format 能够很好地处理 JavaScript 文件。其中也集成了几位著名代码开发者的努力。</strong><br>    - 大括号(花括号)<br>        - 括号用于各种流程控制结构<br>        括号用在各种控制结构中（譬如 if，else，for，do，while 等），即使结构中只包含一句代码。第一条指令的非空块状结构必须另起一行。<br>        错误的写法,例:<br>        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someVeryLongCondition())</span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; foo.length; i++) bar(foo[i]);</span><br></pre></td></tr></table></figure><br>        **例外:**如果指令可以完全地用写在一行里，那么可以不用大括号以增加可读性,例:’if (shortCondition()) foo();`</p><pre><code>    - 非空代码块：K&amp;R 风格    非空代码块使用的花括号遵循 Kernighan and Ritchie 风格 (也即 [Egyptian brackets](https://blog.codinghorror.com/new-programming-jargon/))：        - 左花括号不另起新行        - 左花括号后紧跟换行        - 右花括号前需要换行        - 如果右花括号结束了语句，或者它是函数、类、类中的方法的结束括号，则其后面需要换行。如果后面紧跟的是 else，catch 或 while，或逗号，分号以及右括号，则不需要跟一个换行。        例:    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>foo */</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params">foo</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (condition(foo)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Note: this might fail.</span></span><br><span class="line">something();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">recover();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 空代码块：应紧凑    对于空代码块打开的时候就应立即闭合，中间不留空格，换行以及其他任何字符（`&#123;&#125;`），除非该代码块处于一个连续的声明语境中（譬如这些带有多个代码块的语句 `if/else`，`try/catch/finally`）,例:`function doNothing() &#123;&#125;`。    错误的写法，例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherCondition) &#123;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure>- 代码块中的缩进：2个空格每当新开一个区块或块状结构，增加两个空格的缩进。区块结束之后，缩进恢复到前一级水平。缩进对该区块内的代码和注释同样有要求。    - 数组字面量：可作为块状结构    任何数组都可以按块状结构的格式书写。例如，以下的写法都是有效（不代表全部写法）：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b =</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">someMethod(foo, [</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">], bar);</span><br></pre></td></tr></table></figure>    允许其他组合，尤其是在强调元素之间的语义分组时，而不是只用来减小较大数组的垂直大小。    - 对象字面量：可作为块状结构    对象字面量也可以当作代码块处理，规则与上面数组字面量类似。以下写法都是合法的：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b =</span><br><span class="line">&#123;<span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = &#123;<span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">someMethod(foo, &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">&#125;, bar);</span><br></pre></td></tr></table></figure>    - 类    类的声明（无论是内容声明[declarations]还是表达式声明[expressions]）都像块状结构一样缩进。在类的方法声明和类中的内容声明（表达式结束时仍然需要加分号）的右大括号（后一个大括号）之后不加分号。其中可以使用关键字extends，但是不要用@extends的JS注文（JSDoc），除非你继承了一个模板类型（templatized type）,例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.Empty = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@extends <span class="type">&#123;Foo&lt;string&gt;&#125;</span> </span>*/</span></span><br><span class="line">foo.Bar = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@override </span>*/</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.method() / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@interface </span>*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frobnicator</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>message */</span></span><br><span class="line"><span class="function"><span class="title">frobnicate</span>(<span class="params">message</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 函数表达式    当声明匿名函数时，函数正文在原有缩进水平上增加两个空格的缩进，例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">prefix.something.reallyLongFunctionName(<span class="string">&#x27;whatever&#x27;</span>, <span class="function">(<span class="params">a1, a2</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Indent the function body +2 relative to indentation depth</span></span><br><span class="line"><span class="comment">// of the &#x27;prefix&#x27; statement one line above.</span></span><br><span class="line"><span class="keyword">if</span> (a1.equals(a2)) &#123;</span><br><span class="line">someOtherLongFunctionName(a1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">andNowForSomethingCompletelyDifferent(a2.parrot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">some.reallyLongFunctionCall(arg1, arg2, arg3)</span><br><span class="line">.thatsWrapped()</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Indent the function body +2 relative to the indentation depth</span></span><br><span class="line"><span class="comment">// of the &#x27;.then()&#x27; call.</span></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">result.use();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>    - Switch语句    就像其他块状结构，该语句的缩进方式也是+2。        开始新的一条Switch标签，格式要像开始一个新的块状结构，新起一行，缩进+2。适当时候可以用块状结构来明确Switch全文范围。而到下一条Switch标签的开始行，缩进（暂时）还原到原缩进水平。        在break和下一条Switch标签之间可以适当地空一行。    例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (animal) &#123;</span><br><span class="line"><span class="keyword">case</span> Animal.BANDERSNATCH:</span><br><span class="line">handleBandersnatch();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Animal.JABBERWOCK:</span><br><span class="line">handleJabberwock();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown animal&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 声明语句    - 一个声明占一行    每个声明语句后都跟换行。    - 分号是必需的    语句后需用分号结束。不能依赖于编辑器的自动分号插入功能。- 最大列宽：80对于 JavaScript 源码，规定其单行长度不超过 80 字符。除以下列出的情形外，超出的时候需要根据下面的换行规则来进行换行操作。例外的情形：    - `goog.module`，`goog.require`和`goog.requireType`语句    - ES模块的`import`和`export from`语句- 换行**术语解释：**换行指将一个表达式拆分成多行展示。    并没有一个全面准确的的规则来指导每种场景下该如何换行，相反，对同一段代码往往存在多种合法的换行方式。    **提示：尽管换行大多时候是为了满足列宽限制，但在满足的情况下，编码过程中每个人做法也不尽相同，这是可以的。抽取方法或变量有可能会规避掉换行的问题。**        - 何处该换行        换行的的准则是：尽量在优先级高的语法层面（higher syntactic level）进行，例：        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">currentEstimate =</span><br><span class="line">calc(currentEstimate + x * currentEstimate) /</span><br><span class="line"><span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>        不推荐的写法，例：            <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentEstimate = calc(currentEstimate + x *</span><br><span class="line">currentEstimate) / <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>        上面示例中，语法优先级从高到低依次为：赋值，除法，函数调用，参数，数字常量。        操作符的规则：        - 请在运算符之后换行（注意这和JAVA谷歌代码风格不同）。“.”并不是一个运算符，所以不适用上述规则。        - 方法和构造函数之后的左圆括号不能换行。        - 逗号紧跟前面的代码。        **注意：换行首要目的是保持代码整洁，当最小行数能满足需求时，换行是不需要的。**    - 换行后后续行至少有4个空格的缩进    当发生换行时，第一行后面跟着的其他行至少缩进 4 个空格，除非满足代码块的缩进规则，可另说。    换行后后续跟随多行时，缩进可适当大于 4 个空格。通常，语法中低优先级的后续行以 4 的倍数进行缩进，如果只有两行并且处于同一优先级，则保持一样的缩进即可。- 空格    - 垂直方向的空格    以下场景需要有一个空行：        - 类或对象中的方法间        例外的情形：对象中属性间的空行是可选的。如果有的话，一般是用来将属性进行分组。                - 方法体中，尽量少地使用空行来进行代码的分隔。函数体开始和结束都不要加空行。                - 类或对象中首个方法前及最后一个方法后的空行，既不提倡也不反对。            连续多个空行是允许的，但不鼓励这么做。    - 水平方向的空格    水平方向的空格根据出现的位置不同分为三类：行首（一行的开始），行尾（一行的结束）以及行间（一行中除去行首及行尾的部分）。行首的空格（i.e. 缩进）无处不在。行尾的空格是禁止的。        除了 Javascript 本身及其他规则的要求，还有字面量，注释，JSDoc 等需要的空格外，单个的 ASCII 类型的空格在以下情形中也是需要的。    - 将关键字（比如 `if`，`for`，`catch`）与括号（`(`）分隔。        - 将关键字（`else`，`catch`）与闭合括号（`&#125;`） 分隔。        - 对于左花括号有两种例外：            - 作为函数首个参数的对象之前，数组中首个对象元素 （`foo(&#123;a: [&#123;c: d&#125;]&#125;)`）。                - 在模板表达式中，因为模板语法的限制不能加空格（`abc$&#123;1 + 2&#125;def`）。            - 二元，三元操作符的两边。        - 逗号或分号后，但其前面是不允许有空格的。        - 对象字面量中冒号后面。        - 双斜线（//）两边。这里可以使用多个空格，但也不是必需的。        - JSDoc 注释及其两边        比如简写的类型声明`this.foo = /** @type &#123;number&#125; */ (bar);` 或 `function(/** string */ foo) &#123;;` 或 `baz(/* buzz= */ true)`    - 水平对齐:不鼓励    **术语解释：**水平对齐是在代码中添加可变数量的附加空格的一种做法，目的是使某些标记直接出现在前几行中其他标记的下面。    下面的示例中展示了正常的代码及带水平对齐的代码，后者是不推荐的:    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">tiny</span>: <span class="number">42</span>, <span class="comment">// this is great</span></span><br><span class="line"><span class="attr">longer</span>: <span class="number">435</span>, <span class="comment">// this too</span></span><br><span class="line">&#125;;</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">tiny</span>:   <span class="number">42</span>,  <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="attr">longer</span>: <span class="number">435</span>, <span class="comment">// may leave it unaligned</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>    这种做法是允许的，但 Google 风格里面不推荐。甚至在已经存在的代码中也不鼓励继续使用这种方式进行维护。    **注意：对齐可以增加可读性，但是对后续的维护增加了困难。考虑到后续改写代码可能只会该代码中的一行。修改可能会导致规则允许下格式的崩坏。这常常会错使代码编写者（比如你）调整附近几行的空格，从而导致一系列的格式重写。这样，只是一行的修改就会有一个“爆炸半径”（对附近代码的影响）。这么做最多会让你做一些无用功，但是至少是个失败的历史版本，降低了阅读者的速度，也会导致一些合并冲突。**    - 函数参数    本规则更倾向于把所有函数的参数放在函数名的同一行。如果这么做让代码超出了80字符的限制，那么就必须做基于可读性的自动换行。为了节约空间，最好每行都接近80字符，或者一个参数一行来增加可读性。缩进4个空格。允许和圆括号对齐，但是不推荐。</code></pre><p>下列就是最常见的函数参数对齐模式：<br>        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arguments start on a new line, indented four spaces. Preferred when the</span></span><br><span class="line"><span class="comment">// arguments don&#x27;t fit on the same line with the function name (or the keyword</span></span><br><span class="line"><span class="comment">// &quot;function&quot;) but fit entirely on the second line. Works with very long</span></span><br><span class="line"><span class="comment">// function names, survives renaming without reindenting, low on space.</span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree</span>)</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the argument list is longer, wrap at 80. Uses less vertical space,</span></span><br><span class="line"><span class="comment">// but violates the rectangle rule and is thus not recommended.</span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params">veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,</span></span></span><br><span class="line"><span class="params"><span class="function">tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator</span>)</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Four-space, one argument per line.  Works with long function names,</span></span><br><span class="line"><span class="comment">// survives renaming, and emphasizes each argument.</span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">veryDescriptiveArgumentNumberOne,</span></span></span><br><span class="line"><span class="params"><span class="function">veryDescriptiveArgumentTwo,</span></span></span><br><span class="line"><span class="params"><span class="function">tableModelEventHandlerProxy,</span></span></span><br><span class="line"><span class="params"><span class="function">artichokeDescriptorAdapterIterator</span>)</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    - 分组括号（Grouping parentheses）：推荐的写法<br>    只有代码作者和审阅者都觉得如果不分组不会引起歧义，并且加了分组也不会让代码变得更易读，那么分组可以省略。因为，不是每个人都将操作符优先级熟记于心。</p><pre><code>对于这些关键字，不要添加额外的分组 `delete`，`typeof`，`void`，`return`，`throw`，`case`，`in`，`of` 以及 `yield`。类型转换时需要使用括号强制分组：`/** @type &#123;!Foo&#125; */ (foo)`。- 注释本规则讨论注释的写法。JSDoc 相关的注释单独在上面已经讨论过了。    - 块注释风格    块状注释与被注释代码保持相同缩进。`/* ... */ `和 `//` 都是。对于多行的` /* ... */ `注释，后续注释行以`*`开头且与上一行缩进保持一致。参数的注释紧随参数之后，用于在函数名或参数名无法完全表达其意思的情况,例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is</span></span><br><span class="line"><span class="comment">* okay.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// And so</span></span><br><span class="line"><span class="comment">// is this.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is fine, too. */</span></span><br></pre></td></tr></table></figure>    不要将JSDoc（`/ **…* /`）用于实现注释。    - 参数名称注释    每当值和方法名称未能充分传达含义时，都应使用“参数名称”注释，并且将方法重构得更清晰是不可行的。 它们的首选格式是值之前使用`=`：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(obviousParam, <span class="comment">/* shouldRender= */</span> <span class="literal">true</span>, <span class="comment">/* name= */</span> <span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>                为了与周围的代码保持一致，可以将它们放在值后面，而不使用`=`：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(obviousParam, <span class="literal">true</span> <span class="comment">/* shouldRender */</span>, <span class="string">&#x27;hello&#x27;</span> <span class="comment">/* name */</span>);</span><br></pre></td></tr></table></figure></code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>保持一致性.</p><p>当你在编辑代码之前，先花一些时间查看一下现有代码的风格。比如，如果现有的代码给算术运算符添加了空格，你也应该添加。</p><p>代码风格中一个关键点是整理一份常用词汇表, 开发者认同它并且遵循, 这样在代码中就能统一表述。 这里提出了一些全局上的风格规则, 但也要考虑自身情况形成自己的代码风格。 但如果你添加的代码和现有的代码有很大的区别, 这就让阅读者感到很不和谐。 所以, 避免这种情况的发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>人生——读书笔记</title>
    <link href="http://example.com/2020/02/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F/"/>
    <id>http://example.com/2020/02/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F/</id>
    <published>2020-02-13T11:54:00.000Z</published>
    <updated>2021-08-07T05:59:13.574Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>如果此时此刻有人和我说：人生如梦，世事难料。我肯定请他坐下来喝两杯畅谈一下人生!<br>必须承认,以往很多时候，年纪轻轻的我不曾真正好好珍惜眼前的一切,即便一些大道理烂熟于心。从某种程度上来说，我和高加林一样：受过教育,想要更好的生活。但生活常常和我或者说我们开玩笑，一切在惊喜和挫败往复循环，它教会我们很多东西,但大多情况下，我们会先失去一些东西，比如友情，或者一些物质上东西，然后再深刻地体会到某些道理，然而不是深切感受完就可以避免以后发生类似的事情给我们带来的伤害。<br>高加林生于农村，长于县城，书中说多年的教育洗去他身上的泥土气息，我是认同的，他受教育的时间远多于在农村老家生活的时间，且几乎没有劳作，同时他能一眼看尽农村人的一生，这无疑坚定了他想扎根城市的决心。<br>高明楼的儿子勉勉强强上完高中走后门夺走了高加林的教师工作，断了高加林的念想，高加林的父母老老实实本本分分一辈子，这样的受打击的事情让一家人感到怎样的无助和绝望，我无法想象。这里我是替他们一家打抱不平的；<br>回归农民，高玉德把轻松的活交给儿子，儿子第一天上县城的表现让人唏嘘，却也因此开启了和巧珍的爱情。经历心里的麻木和生理上的痛苦，还有巧珍热烈且温柔的爱，高的心态渐渐平和，但身边人对于他想回到城里的想法清清楚楚。生活过得去，却失去了实现梦想的机会，这里我是同情他的，因为这也是真实生活中一些人真实的样子；<br>而后高加林的叔叔坐着”大领导”的位置归来，马占胜又一手包办高加林的工作，高的前程似乎又得见光明。回到城里的他，生活和事业都有了很大的起色，我是高兴的。后来黄亚萍对他展开热烈的爱情攻势，一边是内心真正爱着的巧珍，一边是象征着梦想的未来，最终选择他选择和中学同学”私定终身”，抛弃巧珍。在更远更大的天地向他招手时候，再一次出现人生波折，高被检举，再次回到农村已然物是人非，巧珍已嫁为他人妇。此刻她仍然盼着高能够好好活下去，自己去为高谋出路，高也后悔不已。看到这里我也经历一系列情绪波折，开始非常佩服作者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果此时此刻有人和我说：人生如梦，世事难料。我肯定请他坐下来喝两杯畅谈一下人生!&lt;br&gt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文学" scheme="http://example.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>跨域及解决方案</title>
    <link href="http://example.com/2020/02/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2020/02/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-02-12T09:24:11.000Z</published>
    <updated>2021-08-07T05:59:13.635Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="跨域问题的产生"><a href="#跨域问题的产生" class="headerlink" title="跨域问题的产生"></a>跨域问题的产生</h2><p>前端开发人员都知道,浏览器安全的基石是”同源策略”（same-origin policy）.<br>同源策略是 1995 年由 Netscape 公司引入浏览器.目前所有浏览器都实行这个策略.它主要是为了防止XSS,CSRF攻击.</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>URL的构成——http://主机名 . 域名（端口号、参数、查询等可选）</p><p>此外,我们还要知道域是分层管理的,像中国的行政级别:<br>最高层的域是根域(root)”.”,就是一个点,像国家主席一样.全球只有13个根域服务器,基本数都在美国,中国一台根域服务器都没有.</p><p>根域的下一层就是第二层次的顶级域(TLD),像各省的省长.它也就是俗称的”域名后缀”,顶级域划分方法:</p><ul><li>按国家划分: .cn(中国)、.tw(台湾)、.hk(香港)等</li><li>按组织性质划分: .org、.net、.com、.gov、.cc等</li><li>反向域: arpa(这是反向解析的特殊顶级域)</li></ul><p>顶级域的下一层就是普通的域,公司或个人在互联网上注册的域名一般都是这些普通的域,如baidu.com.</p><p><strong>注意点:</strong></p><ul><li>顶级域名就是一级域名</li><li>N级域名就是在N-1级域名前追加一级</li></ul><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>这里的”同源”指的是:</p><ul><li><strong>协议相同</strong></li><li><strong>域名相同</strong></li><li><strong>端口相同</strong></li></ul><p>带来的限制:</p><ul><li><strong>Cookie、LocalStorage 和 IndexDB 无法读取</strong></li><li><strong>DOM无法获得</strong></li><li><strong>AJAX请求不能发送</strong></li></ul><p>但是有三个标签是允许跨域加载资源的:</p><ul><li><strong>&lt;img src=””&gt;</strong></li><li><strong>&lt;link href=””&gt;</strong></li><li><strong>&lt;script src=””&gt;</strong></li></ul><h2 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h2><p>当协议、子域名、主域名、端口号任意一个不相同时,都是不同的域.<br>不同域之间相互请求资源,就称为”<strong>跨域</strong>“,常见跨域场景如下所示:<br><img src="%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.png" alt="跨域及解决方案.md"></p><p><strong>注意点:</strong></p><ul><li>如果是协议和端口造成的跨域问题,”前台”是无能为力的</li><li>在跨域问题上,仅仅是通过”URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断.</li></ul><p>这里你或许有两个疑问:</p><ul><li>在跨域的情况下,请求被怎么处理了?<br>  跨域并不是请求发不出去,请求能发出去,服务端能收到请求并正常响应,只是响应结果被浏览器拦截了.</li><li>为什么提交表单可以避免跨域问题,Ajax就不行?<br>  跨域的目的是为了组织用户读到另一个域名下的内容,Ajax可以获取响应,这里存在有安全隐患,故而浏览器拦截了响应;表单则只是提交数据,不会获取新的内容,所以可以发去跨域请求.</li></ul><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h4 id="CORS跨域资源共享-Cross-Origin-Resource-Sharing"><a href="#CORS跨域资源共享-Cross-Origin-Resource-Sharing" class="headerlink" title="CORS跨域资源共享(Cross-Origin Resource Sharing)"></a>CORS跨域资源共享(Cross-Origin Resource Sharing)</h4><p>CORS 需要浏览器和后端同时支持,实现 CORS 通信的关键是后端.目前几乎所有浏览器都支持 CORS, IE则不能低于IE10.<br>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS. 该属性可以表示哪些域名可以访问资源,如果设置通配符则表示所有网站都可以访问资源.<br>虽然设置 CORS 和前端没什么关系,但是通过这种方式解决跨域问题的话,会在发送请求时出现两种情况,分别为简单请求和非简单请求(需预检请求).</p><p><strong>简单请求:</strong></p><p>使用下面任意HTTP方法的:</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>Content-Type 的值仅限于下列三者之一:</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>对于简单请求,浏览器会直接发送 CORS 请求,具体说来就是在 header 中加入 Origin 请求头字段.同样,在响应头中,返回服务器设置的相关 CORS 头部字段, Access-Control-Allow-Origin 字段为允许跨域请求的源.请求时浏览器在请求头的 Origin 中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回,具体如下:<br><img src="%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2.png" alt="跨域及解决方案.md"><br><strong>非简单请求:</strong></p><p>使用下面任意HTTP方法的:</p><ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul><p>Content-Type 的值不属于下列三者之一:</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>当符合非简单请求(预检请求)的条件时,浏览器会自动先发送一个options请求,如果服务端支持该请求,则会将真正的请求发送到后端;反之,控制台将会抛出错误.</p><p>如果非简单请求(预检请求)发送成功，则会在头部多返回以下字段:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://localhost:8000  //该字段表明可供那个源跨域</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT        // 该字段表明服务端支持的请求方法</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header       // 实际请求将携带的自定义请求首部字段</span><br></pre></td></tr></table></figure><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li>原理:利用**&lt;script&gt;**标签没有跨域限制的漏洞,网页可以得到从其它来源动态产生 JSON 数据.JSONP 请求必须要对方的服务器做支持才可以.</li><li>JSONP和AJAX对比:二者都是客户端遵循向服务器发送请求,从服务器获取数据的方式.但AJAX属于同源策略,JSONP不是.</li></ul><p>看个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;mera http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSONP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;http://a2.att.hudong.com/36/48/19300001357258133412489354717.jpg&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3.png" alt="跨域及解决方案.md"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;跨域问题的产生&quot;&gt;&lt;a href=&quot;#跨域问题的产生&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中Promise</title>
    <link href="http://example.com/2020/02/11/JavaScript%E4%B8%ADPromise/"/>
    <id>http://example.com/2020/02/11/JavaScript%E4%B8%ADPromise/</id>
    <published>2020-02-11T09:16:41.000Z</published>
    <updated>2021-08-07T05:59:13.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="Promise-出现的原因"><a href="#Promise-出现的原因" class="headerlink" title="Promise 出现的原因"></a>Promise 出现的原因</h2><p>在 Promise 出现以前,处理一个Ajax请求,大概是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: data&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, result)<span class="comment">// 成功的回调，result为异步拿到的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看起来还不错,但需求变化了,现在需要根据第前面的结果继续请求,代码大概如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: data&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: result1&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: result2&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result3</span>)</span>&#123;</span><br><span class="line">            $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: result3&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result4</span>)</span>&#123;</span><br><span class="line">                ......</span><br><span class="line">                $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: resultn&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">resultn+<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上就是<strong>回调地狱</strong>,更糟糕的是,我们可能还要对每次请求的结果进行一些处理,代码会更加臃肿,后期维护也非常痛苦!</p><p>那么总结一下回调地狱的特点:</p><ul><li>代码臃肿</li><li>可读性差</li><li>耦合度过高,可维护性差</li><li>代码复用性差</li><li>容易出现Bug</li><li>只能在回调里处理异常</li></ul><p>后来出现了Promise,它以一种更加友好的代码组织方式,解决了异步嵌套的问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 请求结果<span class="number">1</span> = 请求<span class="number">1</span>();</span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">2</span> = 请求<span class="number">2</span>(请求结果<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">3</span> = 请求<span class="number">3</span>(请求结果<span class="number">2</span>); </span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">4</span> = 请求<span class="number">2</span>(请求结果<span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">5</span> = 请求<span class="number">3</span>(请求结果<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>类似与上面同步的写法.于是Promise规范诞生了!</p><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><p>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.</p><p>优点:</p><ul><li>异步操作将以同步的流程表达出来,避免了层层嵌套的回调函数.</li><li>Promise 对象提供了统一的接口,使得控制异步操作更容易.</li></ul><p>缺点:</p><ul><li>无法取消,一旦新建就会立即执行,无法中途取消.</li><li>若不设置回调函数,promise 内部会抛出错误,不会反映到外部</li></ul><h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h2><p>** Promise 规范 **有很多,如 Promise/A , Promise/B , Promise/D 以及 Promise/A 的升级版 Promise/A+ ,最终ES6采用了 <strong>Promise/A+</strong> 规范.</p><p>Promise 规范:</p><ul><li>英文版: <a href="https://promisesaplus.com/">https://promisesaplus.com/</a></li><li>中文版: <a href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/">http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/</a></li></ul><p>总结如下:</p><ul><li><p>一个 Promise 对象有种个状态,并且状态一旦改变,便不能再被更改为其他状态.</p><ul><li><strong>pending</strong>: 异步任务正在执行.</li><li><strong>fulfilled</strong>: 异步任务执行成功.</li><li><strong>rejected</strong>: 异步任务执行失败.</li></ul></li><li><p><strong>then</strong>方法可以被同一个 Promise 调用多次,且必须返回一个 Promise</p></li></ul><h2 id="Promise-语法"><a href="#Promise-语法" class="headerlink" title="Promise 语法"></a>Promise 语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;<span class="comment">/* executor */</span>&#125;   );</span><br></pre></td></tr></table></figure><ul><li>Promise构造函数接受一个函数作为参数,该函数的两个参数分别是resolve和reject.它们是两个函数,由 JavaScript 引擎提供,不用自己部署.</li><li>resolve 函数的作用:将Promise实例的状态从”pending”到”fulfilled”,在异步操作成功时调用,并将异步操作的结果,作为参数传递出去.</li><li>reject 函数的作用:将Promise实例的状态从”pending”到”rejected”,在异步操作失败时调用,并将异步操作报出的错误，作为参数传递出去.</li></ul><p>例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(promise);<span class="comment">//Promise &#123; &#x27;Cola&#x27; &#125;</span></span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">//Cola</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise);<span class="comment">//Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure><p>输出顺序:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123; <span class="string">&#x27;Cola&#x27;</span> &#125;</span><br><span class="line">Cola</span><br></pre></td></tr></table></figure><h2 id="Promise-常用API"><a href="#Promise-常用API" class="headerlink" title="Promise 常用API"></a>Promise 常用API</h2><ul><li>Promise.resolve()</li><li>Promise.reject()</li><li>Promise.then(成功回调函数，失败回调函数)</li><li>Promise.then(成功回调函数).catch(失败回调函数)</li><li>Promise.then(成功回调函数).catch(失败回调函数).finally(成功失败都执行的函数)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I like &#x27;</span> + data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是finally&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Promise.all(iterable):方法返回一个 Promise 实例,此实例在 iterable 参数内所有的 promise 都”完成（resolved）”或参数中不包含 promise 时回调完成（resolve）;如果参数中 promise 有一个失败（rejected）,此实例回调失败（reject）,失败原因的是第一个失败 promise 的结果.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="string">&#x27;like&#x27;</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">//[ &#x27;I&#x27;, &#x27;like&#x27;, &#x27;Cola&#x27; ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Promise.race(iterable):返回一个 promise,一旦迭代器中的某个promise解决或拒绝,返回的 promise就会解决或拒绝.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);<span class="comment">//two</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Promise-出现的原因&quot;&gt;&lt;a href=&quot;#Promise-出现的原因&quot;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的同步异步和执行机制</title>
    <link href="http://example.com/2020/02/10/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2020/02/10/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-10T07:23:13.000Z</published>
    <updated>2021-08-07T05:59:13.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>##JavaScript中的单线程<br>技术的出现总是和应用场景密切相关.<br>JavaScript诞生于1995年,主要用于处理表单验证操作,也就是实现用户和浏览器的交互.</p><p>由此带来一个思考:这门语言为什么是单线程?<br>作为浏览器脚本语言,JavaScript 的主要用途是与用户互动,以及操作 DOM.这决定了它只能是单线程,否则会带来很复杂的同步问题.比如,假定JavaScript同时有两个线程,一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以,<strong>为了避免复杂性，从一诞生,JavaScript 就是单线程,这已经成了这门语言的核心特征,将来也不会改变.</strong></p><p>为了利用多核 CPU 的计算能力,HTML5 提出 <strong>Web Worker 标准</strong>,允许 JavaScript 脚本创建多个线程,但是子线程完全受主线程控制,且不得操作 DOM.所以,<strong>这个新标准并没有改变 JavaScript 单线程的本质.</strong></p><p>那么单线程的特点就很明显了:</p><ul><li>实现起来比较简单,执行环境相对单纯；</li><li>只要有一个任务耗时很长,后面的任务都必须排队等着,会拖延整个程序的执行.<br>(常见的浏览器无响应(假死),往往就是因为某一段Javascript代码长时间运行(比如死循),导致整个页面卡在这个地方,其他任务无法执行.)</li></ul><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>在JS中,同步意味着在很多情况下CPU在等待:后一个任务等待前一个任务结束,然后再执行,程序的执行顺序与任务的排列顺序是一致的、同步的;也就是说当一件事情没有处理完成,JS会一直处理它,直至完成,才会开始下一件事情,这样可能会堵塞代码执行;</p><p>异步则是指每一个任务有一个或多个回调函数(callback),前一个任务结束后,不是执行后一个任务,而是执行回调函数,后一个任务则是不等前一个任务结束就执行,所以程序的执行顺序与任务的排列顺序是不一致的、异步的.</p><p>一句话概括就是:<strong>同步等结果,异步不等结果.</strong></p><h2 id="JavaScript的执行机制"><a href="#JavaScript的执行机制" class="headerlink" title="JavaScript的执行机制"></a>JavaScript的执行机制</h2><p>流程图如下:<br><img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/1.png" alt="JavaScript的同步异步和执行机制.md"><br>注意点:</p><ul><li>JS代码分为同步任务和异步任务.</li><li>同步任务进入主线程执行,异步任务进入<strong>Event Table(事件表)</strong>,当事件表中的异步任务完成后会在**Event Queue(事件队列)**中注册回调函数.</li><li>主线程中的任务全部完成后,才会执行<strong>Event Queue中</strong>的任务.</li><li>JS解析器会不断重复检查主线程执行栈是否为空,然后重复第3步,这称为<strong>Event Loop(事件循环)</strong>.</li></ul><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>JS代码的类型如下图所示:<br><img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/2.png" alt="JavaScript的同步异步和执行机制.md"></p><p>宏任务主要有:</p><ul><li>script代码段</li><li>setTimeout</li><li>setInterval</li><li>I/O</li></ul><p>微任务主要有:</p><ul><li>process.nextTick</li><li>Promise</li></ul><p>注意点:</p><ul><li>任务有**宏任务(Macro Task)<strong>和</strong>微任务(Micro Task)**之分,这对JS代码的执行有更细致的影响.</li><li>异步任务中的宏任务和微任务会进入不同的<strong>Event Queue(事件队列)</strong>,即<strong>Event Queue</strong>又可以分为宏任务队列和微任务队列.</li><li><strong>setInterval</strong>会按照设定的时间间隔重复地在<strong>Event Queue</strong>中注册回调函数,如果某一段时间主线程代码执行太久,那么<strong>setInterval</strong>的回调函数可能阻塞到一起执行,无法保持设定的时间间隔,如果此时<strong>setInterval</strong>用于动画,则体现为卡顿.</li></ul><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><p><img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/3.png" alt="JavaScript的同步异步和执行机制.md"></p><p>通常来说,页面中JS的执行顺序是这样的:</p><ul><li>第一轮事件循环:<br>  1.主线程执行JS整段(宏代码),将ajax、setTimeOut、promise等回调函数注册到<strong>Event Queue</strong>中,并区分宏任务和微任务.<br>  2.主线程提取并执行<strong>Evene Queue</strong>中的ajax、promise等所有微任务,并注册微任务中的异步任务到<strong>Event Queue</strong>(如果有).</li><li>第二轮事件循环:<br>  1.主线程提取并执行<strong>Evene Queue</strong>中的第一个宏任务,注册该任务中的异步任务到<strong>Evene Queue</strong>(如果有).<br>  2.执行<strong>Evene Queue</strong>中所有的微任务,并注册微任务中的异步任务到<strong>Evene Queue</strong>(如果有).</li><li>类似的循环:宏任务没执行完一个,就清空一次时间队列中的微任务.<br>注意点:<strong>事件队列中分”宏任务队列”和”微任务队列”，每执行一次任务都可能注册新的宏任务或微任务到相应的任务队列中.</strong></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记作 set1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    <span class="comment">// set4</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// pro2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记作 pro1</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    <span class="comment">// set3</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记作 set2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="comment">// 记作 pro3</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终输出 : 1 6 7 2 4 5 9 10 11 8 3</span></span><br></pre></td></tr></table></figure><ul><li><p>第一轮事件循环:<br>  1.将整段script作为第一个宏任务进入主线程,遇到console.log,输出1.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/4.png" alt="JavaScript的同步异步和执行机制.md"><br>  2.遇到set1,其回调函数被分发到宏任务<strong>Event Queue</strong>中.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/5.png" alt="JavaScript的同步异步和执行机制.md"><br>  3.遇到pro1,new Promise直接执行,输出6.then被分发到微任务<strong>Event Queue</strong>中.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/6.png" alt="JavaScript的同步异步和执行机制.md"><br>  4.遇到set2,其回调函数被分发到宏任务<strong>Event Queue</strong>中.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/7.png" alt="JavaScript的同步异步和执行机制.md"><br>  5.主线程的整段JS代码(宏任务)执行完成,开始清空所有微任务;主线程执行微任务pro1,输出7;遇到set3，注册回调函数。<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/8.png" alt="JavaScript的同步异步和执行机制.md"></p></li><li><p>第二轮事件循环<br>  1.主线程执行队列中第一个宏任务set1,输出2;遇到set4,注册回调;再遇到pro2,new Promise直接执行,输出4,并注册回调.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/9.png" alt="JavaScript的同步异步和执行机制.md"><br>  2.set1(宏任务)执行完,开始清空微任务,主线程执行微任务pro2,输出5;<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/10.png" alt="JavaScript的同步异步和执行机制.md"></p></li><li><p>第三轮事件循环<br>  1.主线程执行队列中第一个宏任务set2，输出9；代码中遇到了pro3，new promise()直接输出10，并注册回调；<br>  2.set2宏任务执行完毕，开始情况微任务，主线程执行微任务pro3，输出11。</p></li><li><p>类似循环…</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##JavaScript中的单线程&lt;br&gt;技术的出现总是和应用场景密切相关.&lt;br&gt;Ja</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
