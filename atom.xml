<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可乐加冰</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-03T13:27:33.356Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HJY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue 和 React 区别</title>
    <link href="http://example.com/2023/05/22/Vue%E5%92%8CReact%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2023/05/22/Vue%E5%92%8CReact%E5%8C%BA%E5%88%AB/</id>
    <published>2023-05-22T12:45:44.000Z</published>
    <updated>2023-08-03T13:27:33.356Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 和 React 和共通之处在于：</p><ul><li>数据驱动视图</li><li>组件化</li><li>Virtual DOM</li></ul><p>不同之处在于：</p><ul><li>核心思想</li><li>写法</li><li>Diff 算法</li><li>响应式原理</li></ul><h2 id="数据驱动视图"><a href="#数据驱动视图" class="headerlink" title="数据驱动视图"></a>数据驱动视图</h2><p>数据变化的时候，相应的视图会得到更新，开发者只需要关注数据的变化而不用再去手动的操作DOM</p><p>Vue 数据驱动是通过 MVVM 这种框架来实现的，MVVM框架主要包含3个部分:Model、View和 ViewModel</p><ul><li>Model:指的是数据部分，对应到前端就是 JavaScript 对象</li><li>View:指的是视图部分，对应前端就是 DOM</li><li>ViewModel:就是连接视图与数据的中间件（getter/setter）</li></ul><p>再来看 React， 需要先了解以下概念</p><ul><li>pending：当前所有等待更新的<code>state队列</code></li><li>isBatchingUpdates：React中用于标识当前是否处理批量更新状态，默认false</li><li>dirtyComponent：当前所有待更新state的<code>组件队列</code></li></ul><p>React 通过<code>setState</code>实现数据驱动视图，通过<code>setState</code>来引发一次组件的更新过程从而实现页面的重新渲染(除非shouldComponentUpdate返回false)：</p><ul><li><code>setState()</code>首先将接收的第一个参数state存储在pending队列中（state）</li><li>判断当前React是否处于批量更新状态，是的话就将需要更新state的组件添加到dirtyComponents中（组件）</li><li>不是的话，它会遍历dirtyComponents的所有组件，调用updateComponent方法更新每个dirty组件（开启批量更新事务）</li></ul><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>Vue</p><ul><li>Vue 依赖手机，自动优化，数据可变</li><li>Vue 递归监听 data 的所有属性，直接修改</li><li>当数据发生改变，自动找到引用数据的组件，进行重新渲染</li></ul><p>React</p><ul><li>React 基于状态机，手动优化，数据不可变，需要 setState 驱动新的 State 替换老的 State</li><li>当数据改变时，以组件为根目录，默认全部重新渲染</li></ul><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul><li>组件是独立和可复用的代码组织单元，它能够大幅提高应用开发效率、测试性、复用性，使开发者使用小型、独立和通常可复用的组件构建大型应用</li><li>调试方便，可维护性高，使得整个应用的耦合度降低</li></ul><p>Vue 和 React 通过将页面拆分成一个一个小的可复用单元来提高代码的复用率和开发效率</p><ul><li>React 推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js</li><li>Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 HTML、CSS、JS 写在同一个文件(vue也支持JSX写法)</li></ul><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟 DOM（Virtual DOM）本质上是JS 和 DOM 之间的一个映射缓存，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象，它主要存储在内存中。主要来说：</p><ul><li>虚拟dom是一个js对象，存储在内存之中。</li><li>虚拟dom能够描述真实dom（存在一个对应关系）</li><li>当数据变化的时候，生成新的DOM，对比新旧虚拟 DOM 的差异，将差异更新到真实 DOM 上（也就是Diff过程）</li><li>减少直接操作 DOM（框架给我们提供了屏蔽底层 DOM 书写的方式，减少频繁的整更新 DOM ，同时也使得数据驱动视图）</li><li>为函数式UI编程提供可能</li><li>可以跨平台，渲染到DOM（web）之外的平台。比如ReactNative，Weex</li></ul><p>Vue 和 React 通用流程：vue template/react jsx -&gt; render函数 -&gt; 生成VNode -&gt; 当有变化时，新老VNode Diff -&gt; Diff算法对比，并真正去更新真实 DOM</p><p>两者对Diff算法的优化基本上思路是相同的（Diff 算法借助元素的 Key 判断元素是新增、删除、修改，从而减少不必要的元素重渲染）：</p><ul><li>tag不同认为是不同节点</li><li>只比较同一层级，不跨级比较</li><li>同一层级的节点用key唯一标识，tag和key都相同则认为是同一节点</li></ul><p>DOM 的更新策略不同：</p><ul><li>React 会自顶向下全 Diff<br>  当状态发生改变时，组件树就会自顶向下的全 Diff, 重新 render 页面， 重新生成新的虚拟 DOM TREE, 新旧 DOM TREE 进行比较， 进行 patch 打补丁方式，局部更新 DOM</li><li>Vue 会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树<br>  把这些 data 属性 全部转为 getter/setter。同时 watcher 实例对象会在组件渲染时，将属性记录为dep，当 dep 项中的 setter 被调用时，通知 watcher 重新计算，使得关联组件更新</li></ul><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>Vue 的核心思想是尽可能的降低前端开发的门槛，是一个灵活易用的渐进式双向绑定的MVVM框架。它的整体思想仍然是拥抱经典的 HTML (结构)+ CSS (表现)+ JS (行为)的形式，通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</p><p>React 的特色在于函数式编程、数据不可变以及单向数据流的理念。函数式编程最大的好处是其稳定性（无副作用）和可测试性（输入相同，输出一定相同），所以通常大家说的React适合大型应用，根本原因还是在于其函数式编程</p><h3 id="核心思想不同导致的一些差异"><a href="#核心思想不同导致的一些差异" class="headerlink" title="核心思想不同导致的一些差异"></a>核心思想不同导致的一些差异</h3><p>主要是写法和API差异</p><p>Vue 推崇 template模板、options API，这样更契合传统 Web 开发者的直觉和习惯，但也不可避免的引入了更多概念和API，比如template模板中需要理解slot、filter、指令等概念和api，options API中需要理解watch、computed（依赖收集）等概念和api</p><p>而 React 推崇 JSX、 HOC、 all in JS，其本身由于 FP 的特性，本质上核心只有一个Virtual DOM + Diff算法，所以API非常少</p><h2 id="组件通信方法"><a href="#组件通信方法" class="headerlink" title="组件通信方法"></a>组件通信方法</h2><p>Vue:</p><ul><li>父-&gt;子<ul><li>props: 父组件使用props属性向子组件传递数据</li><li>slot</li><li>$refs</li><li>$children</li></ul></li><li>子-&gt;父<ul><li>事件形式：子$emit，父监听</li><li>$parent</li></ul></li><li>兄弟组件<ul><li>中央总线new Bus()，发布/订阅模式，其实此方法也可以用在跨级、父子间通讯</li><li>借助同一父组件通过props传递数据，也就是利用父组件实现中转传递(会增加子组件和父组件之间的耦合度)</li></ul></li><li>跨级组件<ul><li>层层组件传递props</li><li>provide/inject</li></ul></li></ul><p>React:</p><ul><li>父-&gt;子<ul><li>props: 父组件使用props属性向子组件传递数据</li><li>ref: 获取整个子组件对象，可以调用子组件中的函数</li></ul></li><li>子-&gt;父<ul><li>利用回调函数：父组件使用props属性向子组件传递一个函数，子组件携带自己的数据并通过调用该函数向父组件传递数据</li></ul></li><li>兄弟组件<ul><li>自定义事件机制：发布/订阅模式，通过向事件对象上添加监听器和触发事件来实现组件之间的通信</li><li>借助同一父组件通过props传递数据，也就是利用父组件实现中转传递(会增加子组件和父组件之间的耦合度)</li></ul></li><li>跨级组件<ul><li>层层组件传递props</li><li>使用context：生产/消费者模式</li></ul></li></ul><h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><p>Vue:</p><ul><li>原生事件使用标准 Web 事件</li><li>Vue组件自定义事件机制，是父子组件通信基础</li></ul><p>React:</p><ul><li>自身实现了一套自己的事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等</li><li>所有事件并没有绑定到具体的dom节点上而是绑定在了document 上，然后由统一的事件处理程序来处理，同时也是基于浏览器的事件机制（冒泡），所有节点的事件都会在 document 上触发</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue 和 React 和共通之处在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据驱动视图&lt;/li&gt;
&lt;li&gt;组件化&lt;/li&gt;
&lt;li&gt;Virtual DOM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同之处在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心思想&lt;/li&gt;
&lt;li&gt;写法&lt;/li&gt;
&lt;li&gt;D</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS工作原理和流程</title>
    <link href="http://example.com/2023/05/13/HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2023/05/13/HTTPS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2023-05-13T13:37:42.000Z</published>
    <updated>2023-08-12T09:54:24.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h2><p>提到 HTTP ，大家的第一印象就是不安全，那它到底是哪里不安全呢？</p><p>先说说 HTTP 的基本信息：它属于应用层的协议， 基于TCP/IP，通过 TCP 协议进行传输，依靠 IP 协议进行寻址</p><p>网络中的数据是以包的形式在网络模型各层之间传递的，而 HTTP 的数据报文在这些层之间都是没有加密的明文，那么它就会引发以下的一些问题：</p><ul><li>内容可能被窃听<br>  通信时，中间会经历很多个阶段，而每个阶段报文内容都有可能会被窃听</li><li>无法验证接收报文的完整性（可能会被篡改）<br>  无法验证接收到报文是否被篡改，比如说被删除了一部分或者新增了一部分</li><li>没有验证通信双方的身份（可能被冒充）<br>  无法判断请求是来自何方，出自谁手</li></ul><h2 id="什么是-HTTPS？"><a href="#什么是-HTTPS？" class="headerlink" title="什么是 HTTPS？"></a>什么是 HTTPS？</h2><p>HTTPS 中的 S 代表“安全”。HTTPS 使用 TLS（或 SSL）来加密HTTP 请求和响应</p><p>TLS 使用一种称为公钥加密的技术：密钥有两个，即公钥和私钥，其中公钥通过服务器的 SSL 证书与客户端设备共享。当客户端打开与服务器的连接时，这两个设备使用公钥和私钥商定新的密钥（称为会话密钥），以加密它们之间的后续通信。</p><p>然后，所有 HTTP 请求和响应都使用这些会话密钥进行加密，使任何截获通信的人都只能看到随机字符串，而不是明文</p><h2 id="HTTPS-做了什么？"><a href="#HTTPS-做了什么？" class="headerlink" title="HTTPS 做了什么？"></a>HTTPS 做了什么？</h2><p>HTTPS 解决了 HTTP 存在的问题，也就是它解决了三个问题：</p><ul><li>加密：HTTPS 通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动，访问记录等，从而窃取用户信息</li><li>数据一致性：数据在传输的过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接收的就是什么</li><li>身份认证：是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别），它可以防止中间人攻击并建立用户信任。</li></ul><p>HTTPS 采用混合加密机制，也就是对称加密与非对称加密混用来实现加密机制</p><p>首先得先了解几个概念：</p><ul><li>加密：将明文变换为密文的过程</li><li>解密：加密的逆过程，即由密文恢复出原明文的过程</li><li>密钥：指某个用来完成加密、解密、完整性验证等密码学应用的秘密信息</li><li>对称加密：加密和解密采用同一个密钥</li><li>非对称加密：加密和解密的时候采用的是不同的密钥</li></ul><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>非对称加密相比对称加密更加复杂，效率更低，在前端业务中一般都是存在大量的 HTTP 请求，所以非对称加密的低效是无法被接受的。此外，非对称加密的场景只在服务端保存私钥，也就是说一对公私钥只能单向传输数据，因此可以用来确认通信安全以及服务端返回证书。确认安全之后，传输数据采用的就是速度更快的对称加密，因此可以简单记忆如下阶段：</p><ul><li>证书交换验证阶段–&gt;非对称加密<ul><li>客户端发起 HTTPS 请求</li><li>服务端返回 HTTPS 证书</li><li>客户端验证证书是否合法，不合法则提示警告</li></ul></li><li>数据传输阶段–&gt;对称加密<ul><li>当证书验证合法后，在本地生成随机密码串</li><li>通过公钥加密随机密码串，并把结果传给服务器端</li><li>服务端通过撕咬对接机密码解密</li><li>服务端通过客户端传入的随机密码穿构建对称加密算法，对返回结果内容进行加密后传输</li></ul></li></ul><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><p>确保数据完整性，也就意味着数据安全没有被第三方篡改，这时候就需要通过 <strong>数字签名</strong></p><p>数字签名是一段由发送者生成的特殊加密校验码，用于传输过程中确认报文的完整性。数字签名涉及到了两种技术：非对称加密 和 数字摘要。生成数字摘要的算法通过 MD5 和 SHA 这种不可逆算法，将不定长的报文内容提取出定长的数字摘要</p><p>假设现在有通信双方A和B，两者之间使用两套非对称加密机制</p><p>现在A向B发消息，那么，如果在发送过程中，有人修改了里面密文消息，B拿到的密文，解密之后得到明文，并非A所发送的，信息不正确</p><p>要解决两个问题</p><ul><li>A的身份认证</li><li>A发送的消息完整性</li></ul><p>那么就要进行以下操作：</p><ul><li>将明文进行摘要运算后得到摘要（消息完整性）</li><li>再将摘要用A的私钥加密（身份认证），得到数字签名，将密文和数字签名一块发给B</li><li>B收到报文后，使用相同的摘要算法提取出摘要，将数字签名用A的公钥进行解密后，得到正确的摘要</li></ul><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>上面加密的过程也存在一个问题，安全的本质是使用密钥进行加密。但是如果密钥本身就有问题，那么安全也就无从谈起，因此这个密钥必须是通信双方认可的。这个工作不能交给客户端做，也不能服务端做，一半交给第三方权威机构 – 数字证书认证机构（CA，Certificate Authority）</p><p>认证机关的公开密钥必须安全地转交给客户端，使用通信方式是，如何安全转交是一件很困难的事，因此多数浏览器发布版本时，都会是现在内置常用认证机关的公钥</p><p>浏览器是如何确保 CA 证书的合法性？<br>浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：</p><ul><li>验证域名、有效期等信息</li><li>判断证书来源是否合法<ul><li>每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证</li></ul></li><li>判断证书是否被篡改<ul><li>需要与 CA 服务器进行校验</li></ul></li><li>判断证书是否已吊销<ul><li>通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率</li></ul></li></ul><h2 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h2><p>HTTPS 的整个通信过程可以分为两大阶段：</p><ul><li>证书验证</li><li>数据传输阶段<ul><li>非对称加密</li><li>对称加密</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202308121754920.png"></p><ul><li>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)</li><li>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等</li><li>客户端解析证书并对其进行验证<ul><li>如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信</li><li>如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密</li></ul></li><li>客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥</li><li>服务器在收到随机码 KEY 之后会使用私钥B将其解密<br>  经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了</li><li>双方使用对称加密愉快地传输所有数据</li></ul><h2 id="HTTPS-绝对安全吗"><a href="#HTTPS-绝对安全吗" class="headerlink" title="HTTPS 绝对安全吗"></a>HTTPS 绝对安全吗</h2><p>HTTPS 也会被抓包，只不过内容被加密过</p><p>但是用户可以主动对证书进行授权，如果用户授权通过，那么代理软件是可以对传输内容进行解密的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;HTTP-存在的问题&quot;&gt;&lt;a href=&quot;#HTTP-存在的问题&quot; class</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2新特性</title>
    <link href="http://example.com/2023/04/20/HTTP2%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2023/04/20/HTTP2%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2023-04-20T14:43:25.000Z</published>
    <updated>2023-08-12T09:51:26.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HTTP/2 基于 SPDY 协议，该协议是谷歌自行开发的，主要是为了解决 HTTP/1.1 效率不高的问题，该协议在 Chrome 浏览器上证明可行后，就被当做 HTTP/2 的基础</p><p>HTTP/2是 HTTP 协议自 1999年 HTTP/1.1 发布后的首个更新版本，2015 年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3</p><h2 id="HTTP-2-的优势"><a href="#HTTP-2-的优势" class="headerlink" title="HTTP/2 的优势"></a>HTTP/2 的优势</h2><p>与 HTTP/1.1 相比，HTTP/2 有着很多优势：</p><ul><li>HTTP/2 采用二进制格式而非文本格式</li><li>HTTP/2 是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</li><li>HTTP/2 使用报头压缩，降低了开销</li><li>HTTP/2 让服务器可以将响应主动“推送”到客户端缓存中</li></ul><p>总的来说，HTTP/2 相比 HTTP/1.1 的修改并不会破坏现有程序的工作，但是新的程序可以借由新特性得到更好的速度</p><p>HTTP/2 基于 SPDY 协议，不同的地方在于：</p><ul><li>HTTP/2 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP/2 消息头的压缩算法采用<code>HPACK</code>，而 SPDY 采用 <code>DEFLATE</code></li></ul><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><ul><li>HTTP/1.1 的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制</li><li>HTTP/2 是一个彻底的二进制，头信息和数据体都是二进制，并且统称为<code>帧</code><ul><li>头信息帧</li><li>数据帧</li></ul></li></ul><p>HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了 HTTP/1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202308121746472.png"></p><p>在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码，其中 HTTP/1.x 的首部信息会被封装到 <code>HEADER frame</code>，而相应的 Request Body 则封装到 `DATA frame`` 里面</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多</p><h3 id="多路复用-Multiplexing-二进制分帧"><a href="#多路复用-Multiplexing-二进制分帧" class="headerlink" title="多路复用 (Multiplexing)/ 二进制分帧"></a>多路复用 (Multiplexing)/ 二进制分帧</h3><p><strong>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息</strong></p><p>在 HTTP/1.1 中浏览器客户端在同一时间，针对同一域名下的请求由一定的数量限制。因而超过限制数目的请求会被阻塞，这也是一些站点有多个静态资源 CDN 域名的原因之一</p><p>多路复用的特性就避免了建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个个的帧，这些帧对应着逻辑流中的消息，并行地在同一个TCP连接上双向交换信息</p><h4 id="帧和流的关系"><a href="#帧和流的关系" class="headerlink" title="帧和流的关系"></a>帧和流的关系</h4><ul><li>帧是最小的数据单位</li><li>每个请求/响应的所有数据包，称为一个数据流，每个流都有独一无二的编号（数据流ID）<br>  客户端发送的数据流ID为奇数，服务端发出的为偶数</li><li>每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流</li></ul><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202308121747464.png"></p><h4 id="多路复用的本质"><a href="#多路复用的本质" class="headerlink" title="多路复用的本质"></a>多路复用的本质</h4><p>在一个 TCP 连接中存在多个流，也就是可以同时发送多个请求，对端可以通过帧中的标识知道该帧属于哪个请求</p><p>在客户端，这些帧乱序发送，到对端后可以通过帧首部的流标识符重新组织，这样就避免了旧版的队头阻塞问题，极大提升了传输性能</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202308121748035.png"></p><h4 id="传输细节"><a href="#传输细节" class="headerlink" title="传输细节"></a>传输细节</h4><p>数据流发送一半时，客户端/服务器可以发送信号（RST_STEAM帧），取消这个流，而 HTTP/1.1取消数据流的唯一方式就是关闭 TCP 连接</p><p>客户端还可以指定数据流的优先级，优先级越高，服务器就会越早回应</p><p>给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。但是 TCP 层面的队首阻塞是 HTTP/2 无法解决的（HTTP 只是应用层协议，TCP 是传输层协议），TCP 的阻塞问题是因为传输阶段可能会丢包，一旦丢包就会等待重新发包，阻塞后续传输，这个问题虽然有滑动窗口（Sliding Window）这个方案，但是只能增强抗干扰，并没有彻底解决</p><h3 id="首部压缩（Header-Compression）"><a href="#首部压缩（Header-Compression）" class="headerlink" title="首部压缩（Header Compression）"></a>首部压缩（Header Compression）</h3><p>当一个客户端向相同服务器请求许多资源时，将有大量请求看上去一样的，加之 HTTP 协议无状态，每次请求都必须附上所有信息，所以很多字段都是重复的，每次都传输，会浪费很多带宽且影响速度，故而 HTTP/2 维护了一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202308121749798.png"></p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送</p><p>比如，浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能</p><h4 id="Nginx-实现"><a href="#Nginx-实现" class="headerlink" title="Nginx 实现"></a>Nginx 实现</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl</span>                      <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>          /etc/nginx/certs/example.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>      /etc/nginx/certs/example.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> SSLv3 TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">      <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">      <span class="attribute">http2_push</span> /style.css;</span><br><span class="line">      <span class="attribute">http2_push</span> /example.png;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后多了两行http2_push命令。它的意思是，如果用户请求根路径/，就推送style.css和example.png</p><h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p><p>一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2 default_server;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> ssl/certificate.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> ssl/key.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line">    <span class="attribute">http2_push_preload</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> = /demo.html &#123;</span><br><span class="line">        <span class="attribute">add_header</span> Set-Cookie <span class="string">&quot;session=1&quot;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> Link $resources;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">map</span> $http_cookie $resources &#123;</span><br><span class="line">    &quot;~*session=1&quot; &quot;&quot;;</span><br><span class="line">    <span class="attribute">default</span> <span class="string">&quot;&lt;/style.css&gt;; as=style; rel=preload&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">HTTP 的发展</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html">HTTP/2 服务器推送（Server Push）教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;HTTP/2 基于 SPDY 协议，该协议是谷歌自行开发的，主要是为了解决 HTTP/1.1 效率不高的问题，该协议在 Chrome 浏览器</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP的演变</title>
    <link href="http://example.com/2023/04/10/HTTP%E7%9A%84%E6%BC%94%E5%8F%98/"/>
    <id>http://example.com/2023/04/10/HTTP%E7%9A%84%E6%BC%94%E5%8F%98/</id>
    <published>2023-04-10T11:33:44.000Z</published>
    <updated>2023-08-12T09:51:59.535Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="HTTP-概述"><a href="#HTTP-概述" class="headerlink" title="HTTP 概述"></a>HTTP 概述</h2><p>超文本传输协议（HyperText Transfer Protocol）是一种用于分布式、协作式和超媒体信息系统的<strong>应用层协议</strong>，它为 Web 浏览器与 Web 服务器之间的通信而设计，是万维网的数据通信的基础</p><p>HTTP 具备几个特征：</p><ul><li>遵循经典的<strong>客户端—服务端模型</strong>，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应</li><li>无状态，这意味着服务器不会在两个请求之间保留任何数据（状态）</li></ul><h2 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h2><h3 id="万维网的发明"><a href="#万维网的发明" class="headerlink" title="万维网的发明"></a>万维网的发明</h3><p>1989 年，当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 Mesh，在随后的 1990 年项目实施期间被更名为万维网（World Wide Web）。它在现有的 TCP 和 IP 协议基础之上建立，由四个部分组成：</p><ul><li>一个用来表示超文本文档的文本格式，超文本标记语言（HTML）。</li><li>一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。</li><li>一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 WorldWideWeb。</li><li>一个服务器用于提供可访问的文档，即 httpd 的前身。<br>这四个部分完成于 1990 年底，且第一批服务器已经在 1991 年初在 CERN 以外的地方运行了。1991 年 8 月 16 日，Tim Berners-Lee 在公开的超文本新闻组上发表的文章被视为是万维网公共项目的开始。</li></ul><p>HTTP 在应用的早期阶段非常简单，后来被称为 HTTP/0.9，有时也叫做单行（one-line）协议。</p><h3 id="HTTP-0-9——单行协议"><a href="#HTTP-0-9——单行协议" class="headerlink" title="HTTP/0.9——单行协议"></a>HTTP/0.9——单行协议</h3><p>最初版本的 HTTP 协议并没有版本号，后来它的版本号被定位为0.9，以区分后来的版本</p><p>HTTP/0.9 极其简单，请求由单行指令构成，以唯一可用的<code>GET</code>方法开头，其后跟资源的路径</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /mypage.html</span><br></pre></td></tr></table></figure><p>而响应也非常简单：只有响应文档本身：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  这是一个非常简单的 HTML 页面</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTTP/0.9 的响应内容不包含 HTTP 头，这意味着只有 HTML 文件可以传送，无法传输其它类型的文件，也没有状态码和错误代码</p><h3 id="HTTP-1-0——构建可拓展性"><a href="#HTTP-1-0——构建可拓展性" class="headerlink" title="HTTP/1.0——构建可拓展性"></a>HTTP/1.0——构建可拓展性</h3><p>在 1991-1995 年，这些新扩展并没有被引入到标准中以促进协助工作，而仅仅作为一种尝试。服务器和浏览器添加这些新扩展功能，但出现了大量的互操作问题。直到 1996 年 11 月，一份新文档（<a href="https://datatracker.ietf.org/doc/html/rfc1945">RFC 1945</a>）被发表出来，文档 RFC 1945 定义了 HTTP/1.0，但它是狭义的，并不是官方标准。新增了一下主要内容：</p><ul><li>协议版本信息现在会随着每个请求发送（HTTP/1.0 被追加到了 GET 行）</li><li>状态码会在响应开始时发送，使浏览器能了解请求执行成功或失败，，并相应调整行为（如更新或使用本地缓存）</li><li>引入了 HTTP 头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活，更具扩展性</li><li>具备了传输除纯文本 HTML 文件以外其他类型文档的能力</li><li>除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段</li></ul><p>请求格式如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/mypage.html</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>NCSA_Mosaic/2.0 (Windows 3.1)</span><br><span class="line"></span><br><span class="line"><span class="dts"><span class="number">200</span> OK</span></span><br><span class="line"><span class="dts"><span class="symbol">Date:</span> Tue, <span class="number">15</span> Nov <span class="number">1994</span> <span class="number">08</span>:<span class="number">12</span>:<span class="number">31</span> GMT</span></span><br><span class="line"><span class="dts"><span class="symbol">Server:</span> CERN/<span class="number">3.0</span> libwww/<span class="number">2.17</span></span></span><br><span class="line"><span class="dts">Content-Type: text/html</span></span><br><span class="line"><span class="dts"><span class="params">&lt;HTML&gt;</span></span></span><br><span class="line"><span class="dts">一个包含图片的页面</span></span><br><span class="line"><span class="dts">  <span class="params">&lt;IMG SRC=&quot;/myimage.gif&quot;&gt;</span></span></span><br><span class="line"><span class="dts"><span class="params">&lt;/HTML&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="一些常见的头信息字段"><a href="#一些常见的头信息字段" class="headerlink" title="一些常见的头信息字段"></a>一些常见的头信息字段</h4><ul><li><p>Content-Type<br>  服务器回应客户端时，需要告知其数据格式（<code>MIME type</code>）：</p><ul><li>text/html</li><li>text/css</li><li>image/png</li><li>image/gif</li><li>application/javascript</li><li>application/octet-stream</li></ul></li><li><p>Content-Encoding<br>  由于传输的数据可能比较大，可以将数据进行压缩：</p><ul><li><p>content-encoding: gzip</p></li><li><p>Content-Encoding: compress</p></li><li><p>Content-Encoding: deflate</p><p>而客户在请求时，可以通过Accept-Encoding字段说明自己可以接受哪些压缩方法：<code>Accept-Encoding: gzip, deflate</code></p></li></ul></li></ul><h3 id="HTTP-1-1——标准化的协议"><a href="#HTTP-1-1——标准化的协议" class="headerlink" title="HTTP/1.1——标准化的协议"></a>HTTP/1.1——标准化的协议</h3><p>HTTP/1.0 多种不同的实现方式在实际运用中显得有些混乱。自 1995 年开始，即 HTTP/1.0 文档发布的下一年，就开始修订 HTTP 的第一个标准化版本。在 1997 年初，HTTP1.1 标准发布</p><p>HTTP/1.1 消除了大量歧义内容并引入了多项改进：</p><ul><li>连接可以复用，节省了多次打开 TCP 连接加载网页文档资源的时间(<code>Connection: keep-alive</code>)</li><li>增加管线化技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟<ul><li>举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求</li><li>一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是 Content-length 字段的作用，声明本次回应的数据长度:<code>Contene-Length: 3000</code>,在 1.0 版中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了</li></ul></li><li>支持响应分块(<code>Transfer-Encoding: chunked</code>)</li><li>引入额外的缓存控制机制</li><li>引入内容协商机制，包括语言、编码、类型等，并允许客户端和服务器之间约定以最合适的内容进行交换</li><li>凭借<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host">Host</a>标头，能够使不同域名配置在一个 IP 地址的服务器上(虚拟主机的兴起)</li></ul><p>一个典型的请求流程，所有请求都通过一个连接实现，看起来就像这样:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/zh-CN/docs/Glossary/Simple_header</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>developer.mozilla.org</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header</span><br><span class="line"></span><br><span class="line"><span class="yaml"><span class="number">200</span> <span class="string">OK</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Connection:</span> <span class="string">Keep-Alive</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Content-Encoding:</span> <span class="string">gzip</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Content-Type:</span> <span class="string">text/html;</span> <span class="string">charset=utf-8</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Date:</span> <span class="string">Wed,</span> <span class="number">20</span> <span class="string">Jul</span> <span class="number">2016 10:55:30 </span><span class="string">GMT</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Etag:</span> <span class="string">&quot;547fa7e369ef56031dd3bff2ace9fc0832eb251a&quot;</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Keep-Alive:</span> <span class="string">timeout=5,</span> <span class="string">max=1000</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Last-Modified:</span> <span class="string">Tue,</span> <span class="number">19</span> <span class="string">Jul</span> <span class="number">2016 00:59:33 </span><span class="string">GMT</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Server:</span> <span class="string">Apache</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Transfer-Encoding:</span> <span class="string">chunked</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Vary:</span> <span class="string">Cookie,</span> <span class="string">Accept-Encoding</span></span></span><br><span class="line"><span class="yaml"></span></span><br><span class="line"><span class="yaml"><span class="string">(content)</span></span></span><br><span class="line"><span class="yaml"></span></span><br><span class="line"><span class="yaml"></span></span><br><span class="line"><span class="yaml"><span class="string">GET</span> <span class="string">/static/img/header-background.png</span> <span class="string">HTTP/1.1</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Host:</span> <span class="string">developer.mozilla.org</span></span></span><br><span class="line"><span class="yaml"><span class="attr">User-Agent:</span> <span class="string">Mozilla/5.0</span> <span class="string">(Macintosh;</span> <span class="string">Intel</span> <span class="string">Mac</span> <span class="string">OS</span> <span class="string">X</span> <span class="number">10.9</span><span class="string">;</span> <span class="string">rv:50.0)</span> <span class="string">Gecko/20100101</span> <span class="string">Firefox/50.0</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Accept:</span> <span class="string">*/*</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Accept-Language:</span> <span class="string">en-US,en;q=0.5</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate,</span> <span class="string">br</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Referer:</span> <span class="string">https://developer.mozilla.org/zh-CN/docs/Glossary/Simple_header</span></span></span><br><span class="line"><span class="yaml"></span></span><br><span class="line"><span class="yaml"><span class="number">200</span> <span class="string">OK</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Age:</span> <span class="number">9578461</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Cache-Control:</span> <span class="string">public,</span> <span class="string">max-age=315360000</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Connection:</span> <span class="string">keep-alive</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Content-Length:</span> <span class="number">3077</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Content-Type:</span> <span class="string">image/png</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Date:</span> <span class="string">Thu,</span> <span class="number">31</span> <span class="string">Mar</span> <span class="number">2016 13:34:46 </span><span class="string">GMT</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Last-Modified:</span> <span class="string">Wed,</span> <span class="number">21</span> <span class="string">Oct</span> <span class="number">2015 18:27:50 </span><span class="string">GMT</span></span></span><br><span class="line"><span class="yaml"><span class="attr">Server:</span> <span class="string">Apache</span></span></span><br><span class="line"><span class="yaml"></span></span><br><span class="line"><span class="yaml"><span class="string">(image</span> <span class="string">content</span> <span class="string">of</span> <span class="number">3077 </span><span class="string">bytes)</span></span></span><br></pre></td></tr></table></figure><p>HTTP/1.1 在 1997 年 1 月以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">RFC 2068</a> 文件发布</p><h3 id="超过15年的拓展"><a href="#超过15年的拓展" class="headerlink" title="超过15年的拓展"></a>超过15年的拓展</h3><p>由于 HTTP 协议的可扩展性使得创建新的头部和方法是很容易的。即使 HTTP/1.1 协议进行过两次修订，RFC 2616 发布于 1999 年 6 月，而另外两个文档 <a href="https://datatracker.ietf.org/doc/html/rfc7230">RFC 7230</a>-<a href="https://datatracker.ietf.org/doc/html/rfc7235">RFC 7235</a> 发布于 2014 年 6 月（在 HTTP/2 发布之前）。HTTP/1.1 协议已经稳定使用超过 15 年了</p><h4 id="HTTP-用于安全传输"><a href="#HTTP-用于安全传输" class="headerlink" title="HTTP 用于安全传输"></a>HTTP 用于安全传输</h4><p>通过加密来保证服务器和客户端之间交换消息的真实性</p><p>额外的加密传输层：SSL</p><p>SSL 在标准化道路上最终成为了 TLS</p><h4 id="HTTP-用于复杂应用"><a href="#HTTP-用于复杂应用" class="headerlink" title="HTTP 用于复杂应用"></a>HTTP 用于复杂应用</h4><p>在 2000 年，一种新的使用 HTTP 的模式被设计出来：具象状态传输（representational state transfer） (或者说 REST)，RESTful API 在 2010 年变得非常流行</p><p>自 2005 年以来，可用于 Web 页面的 API 大大增加，其中几个 API 为特定目的扩展了 HTTP 协议，大部分是新的特定 HTTP 头：</p><ul><li>Server-sent events，服务器可以偶尔推送消息到浏览器</li><li>WebSocket，一个新协议，可以通过升级现有 HTTP 协议来建立</li></ul><h4 id="放松安全措施——基于当前的-Web-模型"><a href="#放松安全措施——基于当前的-Web-模型" class="headerlink" title="放松安全措施——基于当前的 Web 模型"></a>放松安全措施——基于当前的 Web 模型</h4><p>HTTP 和 Web 安全模型——<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>是互不相关的。事实上，当前的 Web 安全模型是在 HTTP 被创造出来后才被发展的！这些年来，已经证实了它如果能通过在特定的约束下移除一些这个策略的限制来管的宽松些的话，将会更有用。这些策略导致大量的成本和时间被花费在通过转交到服务端来添加一些新的 HTTP 头来发送。这些被定义在了<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CORS">跨源资源共享</a>（CORS）和<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略</a>（CSP）规范里。</p><p>不只是这大量的扩展，很多的其他的头也被加了进来，有些只是实验性的。比较著名的有 DNT（Do Not Track）来控制隐私，X-Frame-Options，还有很多</p><h3 id="HTTP-2——为了更优异的表现"><a href="#HTTP-2——为了更优异的表现" class="headerlink" title="HTTP/2——为了更优异的表现"></a>HTTP/2——为了更优异的表现</h3><p>这些年来，网页愈渐变得的复杂，甚至演变成了独有的应用，可见媒体的播放量，增进交互的脚本大小也增加了许多：更多的数据通过 HTTP 请求被传输。HTTP/1.1 链接需要请求以正确的顺序发送，理论上可以用一些并行的链接（尤其是 5 到 8 个），带来的成本和复杂性堪忧。比如，HTTP 管线化（pipelining）就成为了 Web 开发的负担。为此，在 2010 年早期，谷歌通过实践了一个实验性的 SPDY 协议。这种在客户端和服务器端交换数据的替代方案引起了在浏览器和服务器上工作的开发人员的兴趣。明确了响应数量的增加和解决复杂的数据传输，SPDY 成为了 HTTP/2 协议的基础。</p><p>HTTP/2 在 HTTP/1.1 有几处基本的不同：</p><ul><li>HTTP/2 采用二进制格式而非文本格式</li><li>这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP/1.x 中顺序和阻塞的约束。</li><li>压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li><li>让服务器可以将响应主动“推送”到客户端缓存中</li></ul><h4 id="后-HTTP-2-进化"><a href="#后-HTTP-2-进化" class="headerlink" title="后 HTTP/2 进化"></a>后 HTTP/2 进化</h4><p>随着 HTTP/2.的发布，就像先前的 HTTP/1.x 一样，HTTP 没有停止进化，HTTP 的扩展性依然被用来添加新的功能。特别的，我们能列举出 2016 年里 HTTP 的新扩展：</p><ul><li>对 Alt-Svc 的支持允许了给定资源的位置和资源鉴定，允许了更智能的 CDN 缓冲机制。</li><li>客户端提示（client hint） 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。</li><li>在 Cookie 头中引入安全相关的的前缀，现在帮助保证一个安全的 Cookie 没被更改过。</li></ul><h4 id="HTTP-2-不足之处"><a href="#HTTP-2-不足之处" class="headerlink" title="HTTP/2 不足之处"></a>HTTP/2 不足之处</h4><ul><li>建立连接时间长(本质上是TCP的问题)</li><li>队头阻塞问题</li></ul><h3 id="HTTP-3——基于-QUIC-的-HTTP"><a href="#HTTP-3——基于-QUIC-的-HTTP" class="headerlink" title="HTTP/3——基于 QUIC 的 HTTP"></a>HTTP/3——基于 QUIC 的 HTTP</h3><p>HTTP 的下一个主要版本，HTTP/3 有这与 HTTP 早期版本的相同语义，但在传输层部分使用 QUIC (en-US) 而不是 TCP。到 2022 年 10 月，26% 的网站正在使用 HTTP/3。</p><p>QUIC 旨在为 HTTP 连接设计更低的延迟。类似于 HTTP/2，它是一个多路复用协议，但是 HTTP/2 通过单个 TCP 连接运行，所以在 TCP 层处理的数据包丢失检测和重传可以阻止所有流。QUIC 通过 UDP 运行多个流，并为每个流独立实现数据包丢失检测和重传，因此如果发生错误，只有该数据包中包含数据的流才会被阻止。</p><p>RFC 9114 定义的 HTTP/3 被大多数主流浏览器所支持，包括 Chromium（及其他的变体，例如 Chrome 和 Edge）和 Firefox。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP">MDN</a></p><p><a href="https://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">HTTP 的发展</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;HTTP-概述&quot;&gt;&lt;a href=&quot;#HTTP-概述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>二进制数据处理（尚未完成）</title>
    <link href="http://example.com/2023/03/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2023/03/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2023-03-22T13:45:32.000Z</published>
    <updated>2023-07-19T01:25:53.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="ArrayBuffer，二进制数组"><a href="#ArrayBuffer，二进制数组" class="headerlink" title="ArrayBuffer，二进制数组"></a>ArrayBuffer，二进制数组</h2><p>在web开发中，经常要用到二进制数据来处理文件相关的操作，比如上传、下载各种文档和图像</p><p><strong>在JS中基本的的二进制对象是<code>ArrayBuffer</code>，它本质上是一段固定长度的连续内存空间的引用</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ArrayBuffer，二进制数组&quot;&gt;&lt;a href=&quot;#ArrayBuffe</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS继承的几种方式</title>
    <link href="http://example.com/2023/03/07/JS%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2023/03/07/JS%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2023-03-07T13:32:01.000Z</published>
    <updated>2023-08-03T13:30:37.654Z</updated>
    
    <content type="html"><![CDATA[<p>许多OO语言都支持两种继承方式：</p><ul><li>接口继承</li><li>实现继承</li></ul><p>而 ECMA 只支持实现继承，主要依靠原型链来实现</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>核心思想：重写原型对象，代之以一个新类型的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.getName(); <span class="comment">// Parent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child2.getName(); <span class="comment">// Parent</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>父类新增原型方法/属性，子类都能访问到</li><li>简单，易于实现</li></ul><p>缺点：</p><ul><li>引用类型的属性被所有实例共享</li><li>创建子类实例时，不能像父类构造函数传参</li></ul><h2 id="借用构造函数继承（经典继承）"><a href="#借用构造函数继承（经典继承）" class="headerlink" title="借用构造函数继承（经典继承）"></a>借用构造函数继承（经典继承）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.color = [<span class="string">&#x27;red&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;Child1&#x27;</span>);</span><br><span class="line">child1.color.push(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1); <span class="comment">// Child &#123; name: &#x27;Child1&#x27;, color: [ &#x27;red&#x27;, &#x27;green&#x27; ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;Child2&#x27;</span>);</span><br><span class="line">child2.color.push(<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2); <span class="comment">// Child &#123; name: &#x27;Child2&#x27;, color: [ &#x27;red&#x27;, &#x27;blue&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>避免了引用类型的属性被所有子类实例所共享</li><li>可以在子类中向父类构造函数传参</li></ul><p>缺点：</p><ul><li>无法实现函数复用</li><li>在父类原型中定义的方法，对于子类不可见</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>这种方式的核心思想在于:通过结合原型链继承和经典继承两种方式，融合了二者的优点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.color = [<span class="string">&#x27;red&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;Child1&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">child1.color.push(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1); <span class="comment">// Child &#123; name: &#x27;Child1&#x27;, color: [ &#x27;red&#x27;, &#x27;green&#x27; ], age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;Child2&#x27;</span>, <span class="number">17</span>);</span><br><span class="line">child2.color.push(<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2); <span class="comment">// Child &#123; name: &#x27;Child2&#x27;, color: [ &#x27;red&#x27;, &#x27;blue&#x27; ], age: 17 &#125;</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>调用了两次父类构造函数</li></ul><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>核心思想：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;kelly&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">const</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">&#x27;person1&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1); <span class="comment">// &#123; name: &#x27;person1&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">person2.friends.push(<span class="string">&#x27;taylor&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123; name: &#x27;person&#x27;, friends: [ &#x27;daisy&#x27;, &#x27;kelly&#x27;, &#x27;taylor&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><p>缺点:</p><ul><li>包含引用类型的属性值始终会共享相应的值</li></ul><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>核心思想：创建一个仅用于封装继承过程的函数，并在该函数中以某种形式来增强对象，最后返回该对象（和原型式继承紧密相关）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="built_in">Object</span>.create(o);</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;daisy&#x27;</span>, <span class="string">&#x27;kelly&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>不能复用函数而降低效率</li><li>无法传递参数</li></ul><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>核心思想：结合借用构造函数产地参数和寄生模式实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prototype = createObj(parent.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">    prototype.constructor = parent; <span class="comment">// 增强对象</span></span><br><span class="line">    child.prototype = prototype; <span class="comment">// 指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.color = [<span class="string">&#x27;red&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Child, Parent);</span><br><span class="line"></span><br><span class="line">Parent.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;Child1&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">child1.color.push(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1); <span class="comment">// Parent &#123; name: &#x27;Child1&#x27;, color: [ &#x27;red&#x27;, &#x27;green&#x27; ], age: 18 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;Child2&#x27;</span>, <span class="number">17</span>);</span><br><span class="line">child2.color.push(<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2); <span class="comment">// Parent &#123; name: &#x27;Child2&#x27;, color: [ &#x27;red&#x27;, &#x27;blue&#x27; ], age: 17 &#125;</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>高效率：只调用了一次父类构造函数</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《JavaScript高级程序教程（第3版）》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;许多OO语言都支持两种继承方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口继承&lt;/li&gt;
&lt;li&gt;实现继承&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 ECMA 只支持实现继承，主要依靠原型链来实现&lt;/p&gt;
&lt;h2 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件总线机制</title>
    <link href="http://example.com/2023/01/12/%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2023/01/12/%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%9C%BA%E5%88%B6/</id>
    <published>2023-01-12T14:19:22.000Z</published>
    <updated>2023-07-19T01:24:30.830Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>事件总线(EventBus) 是一种消息传递的方式</p><p>它可以让两个没有关联的组件进行通信，起到数据传输的作用</p><p>举个例子，当<code>module N</code>发布了<code>Event 1</code>消息，订阅该消息的<code>module 1</code>就会收到相关消息（过程如下所示）</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202302071430325.png"></p><h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>现在有一所学校，学校里面有一些事件发生，学生能够根据事件类型做出相应的动作</p><p>用代码表述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventBus就是事件总线，这里可以思考一下它应该具备什么功能以及如何编写</span></span><br><span class="line"><span class="keyword">let</span> EB = <span class="keyword">new</span> EventBus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生对事件类型做出的反应</span></span><br><span class="line">EB.$on(<span class="string">&#x27;上课&#x27;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>到上课地点`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">EB.$on(<span class="string">&quot;教室上课&quot;</span>, <span class="function">(<span class="params">name, course</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>去教室上<span class="subst">$&#123;course&#125;</span>课`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> id = EB.$on(<span class="string">&quot;户外上课&quot;</span>, <span class="function">(<span class="params">name, course</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>去户外上<span class="subst">$&#123;course&#125;</span>课`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">EB.$once(<span class="string">&quot;献血&quot;</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>去献血`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学校中事件发生</span></span><br><span class="line">EB.$emit(<span class="string">&#x27;上课&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>); <span class="comment">// 学生张三到上课地点</span></span><br><span class="line">EB.$emit(<span class="string">&#x27;上课&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>); <span class="comment">// 学生李四到上课地点</span></span><br><span class="line">EB.$emit(<span class="string">&#x27;教室上课&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;编程&#x27;</span>); <span class="comment">// 学生张三去教室上编程课</span></span><br><span class="line">EB.$emit(<span class="string">&#x27;户外上课&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;田径&#x27;</span>); <span class="comment">// 学生张三去户外上田径课</span></span><br><span class="line">EB.$off(<span class="string">&#x27;户外上课&#x27;</span>, id);</span><br><span class="line">EB.$emit(<span class="string">&#x27;户外上课&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>);</span><br><span class="line">EB.$emit(<span class="string">&#x27;献血&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>); <span class="comment">// 学生王五去献血</span></span><br><span class="line">EB.$emit(<span class="string">&#x27;献血&#x27;</span>, <span class="string">&#x27;马六&#x27;</span>);</span><br><span class="line"><span class="comment">// console.log(EB)</span></span><br><span class="line">EB.$clear()</span><br><span class="line"><span class="comment">// console.log(EB)</span></span><br></pre></td></tr></table></figure><p>从上面的代码可以大概了解到，事件总线应该具备五种方法，对应着下一部分的API设计</p><h2 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h2><ul><li>发布消息（emit）<ul><li>能够表示消息类型，可能还携带参数</li></ul></li><li>订阅消息（on）<ul><li>能够知道具体的消息类型，并执行回调，回调的参数就是发布消息时携带的参数</li></ul></li><li>取消订阅（off）<ul><li>能够知道具体的消息类型，取消订阅该消息类型，即回调函数不再执行</li></ul></li><li>仅订阅一次消息（once）<ul><li>能够知道具体的消息类型，执行一次回调后，再次接收相同消息，不再执行回调</li></ul></li><li>清除某个或所有事件（clear）<ul><li>如果指定了某个消息类型，则清除该消息类型的回调，否则全部清除</li></ul></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="基础实现（仅包含订阅和发布）"><a href="#基础实现（仅包含订阅和发布）" class="headerlink" title="基础实现（仅包含订阅和发布）"></a>基础实现（仅包含订阅和发布）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventObj = &#123;&#125;; <span class="comment">// interface EveneObj &#123; [name: string]: Function[] &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $on(name, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.eventObj[name]) &#123;</span><br><span class="line">           <span class="comment">// 如果尚未注册，用数组来收集回调函数</span></span><br><span class="line">            <span class="built_in">this</span>.eventObj[name] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.eventObj[name].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $emit(name) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventList = <span class="built_in">this</span>.eventObj[name];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> callback <span class="keyword">of</span> eventList) &#123;</span><br><span class="line">           <span class="comment">// 执行回调</span></span><br><span class="line">            callback(<span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> EB = <span class="keyword">new</span> EventBus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">EB.$on(<span class="string">&#x27;上课&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">&quot;该上课了&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">EB.$on(<span class="string">&quot;上课&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">&quot;做笔记&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">EB.$on(<span class="string">&quot;下课&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">&quot;下课啦！&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">EB.$emit(<span class="string">&#x27;上课&#x27;</span>);</span><br><span class="line">EB.$emit(<span class="string">&#x27;下课&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="如何在发布消息时携带参数"><a href="#如何在发布消息时携带参数" class="headerlink" title="如何在发布消息时携带参数"></a>如何在发布消息时携带参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$on(name, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.eventObj[name]) &#123;</span><br><span class="line">       <span class="built_in">this</span>.eventObj[name] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.eventObj[name].push(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$emit(name, ...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> eventList = <span class="built_in">this</span>.eventObj[name];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> callback <span class="keyword">of</span> eventList) &#123;</span><br><span class="line">      callback(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一次订阅"><a href="#一次订阅" class="headerlink" title="一次订阅"></a>一次订阅</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新的数据结构</span></span><br><span class="line"><span class="built_in">this</span>.onceObj = &#123;&#125;; <span class="comment">// interface OnceEventObj &#123; [key: string]: Function[] &#125;</span></span><br><span class="line"></span><br><span class="line">$once(eventName, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.onceObj[eventName]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.onceObj[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.onceObj[eventName].push(callback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里引入一个id参数，标识每个回调，同时修改eventObj的结构</span></span><br><span class="line"><span class="comment">// interface EventObj &#123; [key: string]: &#123; [id: number]: Function &#125; &#125;</span></span><br><span class="line">$off(eventName, id) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id) &#123;</span><br><span class="line">        <span class="comment">// 传入了id则删除对应的回调</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName][id];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.eventObj[eventName]).length) &#123;</span><br><span class="line">          <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则删除整个事件的所有回调</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清除事件"><a href="#清除事件" class="headerlink" title="清除事件"></a>清除事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$clear(eventName: string = <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 未提供事件名称，默认清除所有事件</span></span><br><span class="line">    <span class="keyword">if</span> (!eventName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventObj = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除指定事件</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="终版（TS版本）"><a href="#终版（TS版本）" class="headerlink" title="终版（TS版本）"></a>终版（TS版本）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> EventObj &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: &#123; [id: <span class="built_in">number</span>]: <span class="built_in">Function</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> OnceEventObj &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">Function</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="attr">eventObj</span>: EventObj</span><br><span class="line">    <span class="comment">/** 每个函数的ID */</span></span><br><span class="line">    <span class="attr">callbcakId</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">onceObj</span>: OnceEventObj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eventObj = &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.callbcakId = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.onceObj = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $on(eventName: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="built_in">Function</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.eventObj[eventName]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventObj[eventName] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> id = <span class="built_in">this</span>.callbcakId++;</span><br><span class="line">        <span class="built_in">this</span>.eventObj[eventName][id] = callback;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $emit(eventName: <span class="built_in">string</span>, ...args: <span class="built_in">any</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> eventList = <span class="built_in">this</span>.eventObj[eventName];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> id <span class="keyword">in</span> eventList) &#123;</span><br><span class="line">            <span class="keyword">typeof</span> eventList[id] === <span class="string">&#x27;function&#x27;</span> &amp;&amp; eventList[id](...args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> onceEvent = <span class="built_in">this</span>.onceObj[eventName];</span><br><span class="line">        <span class="keyword">if</span> (onceEvent) &#123;</span><br><span class="line">            onceEvent.forEach(<span class="function">(<span class="params">callback</span>) =&gt;</span> callback(...args));</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.onceObj[eventName];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $off(eventName: <span class="built_in">string</span>, <span class="attr">id</span>: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (id) &#123;</span><br><span class="line">            <span class="comment">// 传入了id则删除对应的回调</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName][id];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.eventObj[eventName]).length) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则删除整个事件的所有回调</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $once(eventName: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="built_in">Function</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.onceObj[eventName]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.onceObj[eventName] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.onceObj[eventName].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $clear(eventName: <span class="built_in">string</span> = <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 未提供事件名称，默认清除所有事件</span></span><br><span class="line">        <span class="keyword">if</span> (!eventName) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventObj = &#123;&#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除指定事件</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="built_in">this</span>.eventObj[eventName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> EB = <span class="keyword">new</span> EventBus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">EB.$on(<span class="string">&#x27;上课&#x27;</span>, <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>到上课地点`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">EB.$on(<span class="string">&quot;教室上课&quot;</span>, <span class="function">(<span class="params">name: <span class="built_in">string</span>, course: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>去教室上<span class="subst">$&#123;course&#125;</span>课`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> id = EB.$on(<span class="string">&quot;户外上课&quot;</span>, <span class="function">(<span class="params">name: <span class="built_in">string</span>, course: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>去户外上<span class="subst">$&#123;course&#125;</span>课`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">EB.$once(<span class="string">&quot;献血&quot;</span>, <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`学生<span class="subst">$&#123;name&#125;</span>去献血`</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">EB.$emit(<span class="string">&#x27;上课&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">EB.$emit(<span class="string">&#x27;上课&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">EB.$emit(<span class="string">&#x27;教室上课&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;编程&#x27;</span>);</span><br><span class="line">EB.$emit(<span class="string">&#x27;户外上课&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;田径&#x27;</span>);</span><br><span class="line">EB.$off(<span class="string">&#x27;户外上课&#x27;</span>, id);</span><br><span class="line">EB.$emit(<span class="string">&#x27;户外上课&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;足球&#x27;</span>);</span><br><span class="line">EB.$emit(<span class="string">&#x27;献血&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>);</span><br><span class="line">EB.$emit(<span class="string">&#x27;献血&#x27;</span>, <span class="string">&#x27;马六&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(EB)</span><br><span class="line">EB.$clear()</span><br><span class="line"><span class="built_in">console</span>.log(EB)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="为什么不被推荐使用"><a href="#为什么不被推荐使用" class="headerlink" title="为什么不被推荐使用"></a>为什么不被推荐使用</h2><p>事件总线使用起来非常简单，但是！</p><ul><li>随着事件的推移，注册的事件可能越来越多，如果没有及时清理相关事件，整个对象占用的内存会越来越大</li><li>当逻辑变得复杂时大量使用事件总线，会让数据流混乱，难以预测，这样在调试代码时难以定位或修改</li></ul><h2 id="替代方式"><a href="#替代方式" class="headerlink" title="替代方式"></a>替代方式</h2><ul><li>状态提升<ul><li>有时我们需要在兄弟组件间传递数据，这种情况可以把共享<em>状态提升</em>到最近的共同父组件中去</li></ul></li><li>使用状态管理工具<ul><li>主流前端开发框架都有相应的状态管理方案，比如redux、mobx、Vuex</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>替代chrome中的Event.path</title>
    <link href="http://example.com/2022/12/22/%E6%9B%BF%E4%BB%A3chrome%E4%B8%AD%E7%9A%84Event.path/"/>
    <id>http://example.com/2022/12/22/%E6%9B%BF%E4%BB%A3chrome%E4%B8%AD%E7%9A%84Event.path/</id>
    <published>2022-12-22T09:39:41.000Z</published>
    <updated>2023-07-19T01:25:51.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="Event-path和Event-composedPath"><a href="#Event-path和Event-composedPath" class="headerlink" title="Event.path和Event.composedPath"></a>Event.path和Event.composedPath</h2><p>在开发过程时，有时需要获取事件冒泡/捕获过程的所有元素，在不同的浏览器中，获取的方法可能不一样</p><p>chrome作为常用的浏览器，可以通过<code>event.path</code>属性来获取，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>event.path测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>组织/部门<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;department&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;dev&quot;</span>&gt;</span>研发组<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;administrative&quot;</span>&gt;</span>行政组<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>公关组<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> target = <span class="built_in">document</span>.getElementById(<span class="string">&quot;dev&quot;</span>)</span></span><br><span class="line"><span class="javascript">    target.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> path = evt.path;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;研发组点击事件的path:&#x27;</span>, path)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Chrome</code>(版本：108.0.5359.124)操作结果：</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202212221729070.png"></p><p><code>Firefox</code>(版本：108.0.1)操作结果：</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202212221730228.png"></p><p>该属性返回事件路径，但并不是一个标准属性，不过在 <code>chrome</code> 浏览器中存在，而<code>Firefox</code>不存在</p><p>当 <code>Event.path</code> 取不到值时就取 <code>Event.composedPath</code></p><p><code>Event.composedPath</code>的兼容性如下：</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202212221734027.png"></p><p>在2021年12月份，<code>chrome</code>官方团队发布<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1277431">issue</a>，将要移除<code>event.path</code></p><h2 id="现有项目如何处理"><a href="#现有项目如何处理" class="headerlink" title="现有项目如何处理"></a>现有项目如何处理</h2><p>现有项目和依赖的第三方库/包都有可能受到影响，在这种情况下可以添加polyfill作为成本较小的解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Event.prototype.path) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Event.prototype, <span class="string">&quot;path&quot;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.composedPath();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>如何支持IE？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">e, d, w</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!e.composedPath) &#123;</span><br><span class="line">    e.composedPath = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.path) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.path;</span><br><span class="line">      &#125; </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">this</span>.target;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.path = [];</span><br><span class="line">    <span class="keyword">while</span> (target.parentNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.path.push(target);</span><br><span class="line">      target = target.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.path.push(d, w);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.path;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(Event.prototype, <span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Event-path和Event-composedPath&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="Chrome" scheme="http://example.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>canvas渲染上下文设置填充样式，在安卓机型上不生效</title>
    <link href="http://example.com/2022/11/03/canvas%E6%B8%B2%E6%9F%93%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E6%A0%B7%E5%BC%8F%EF%BC%8C%E5%9C%A8%E5%AE%89%E5%8D%93%E6%9C%BA%E5%9E%8B%E4%B8%8A%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <id>http://example.com/2022/11/03/canvas%E6%B8%B2%E6%9F%93%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E6%A0%B7%E5%BC%8F%EF%BC%8C%E5%9C%A8%E5%AE%89%E5%8D%93%E6%9C%BA%E5%9E%8B%E4%B8%8A%E4%B8%8D%E7%94%9F%E6%95%88/</id>
    <published>2022-11-03T08:50:03.000Z</published>
    <updated>2022-11-03T08:58:04.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="探究起因"><a href="#探究起因" class="headerlink" title="探究起因"></a>探究起因</h2><p>在阅读一些框架源码（比方说Vue)时发现，开发者们使用<code>Object.create(null)</code>来初始化一个新对象，而我们一般在非面向工具链/基建开发时，惯常使用字面量，那么它们有什么区别呢？</p><p><strong>省流：当设置透明度时，尽量使用<code>ctx.fillStyle = &#39;rgb(174, 238, 238, 0.5)&#39;;</code>的形式，而非<code>ctx.fillStyle = &#39;#AEEEEE80&#39;;</code>后者在安卓真机（华为自带浏览器下必现）下无效</strong></p><p>今天客户反馈在安卓机型下打开我们的签署页面，水印的颜色和透明度不管如何设置，都不生效，而IOS的表现正常</p><p>关键代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">ctx.fillStyle = colorRgb(color, transparency);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取颜色的16进制 （颜色+透明度）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>color 颜色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>transparency 透明度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> convertColor = <span class="function">(<span class="params">color: string, transparency: number</span>) =&gt;</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> getPureColor = <span class="function">(<span class="params">color: string</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> plainColor = color?.substring(<span class="number">1</span>); <span class="comment">// 去掉#</span></span><br><span class="line">        <span class="keyword">const</span> isColorShort = plainColor?.length === <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> isColorShort ? plainColor.split(<span class="string">&#x27;&#x27;</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;v&#125;</span><span class="subst">$&#123;v&#125;</span>`</span>).join(<span class="string">&#x27;&#x27;</span>) : plainColor;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> getAlpha = <span class="function">(<span class="params">transparency: number</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> alpha = <span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">256</span> * transparency), <span class="number">10</span>).toString(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> alpha.length &gt; <span class="number">1</span> ? alpha : <span class="string">`0<span class="subst">$&#123;alpha&#125;</span>`</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;getPureColor(color)&#125;</span><span class="subst">$&#123;getAlpha(transparency)&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以 颜色：#AEEEEE，透明度：0.5 为例，转化后得到结果#AEEEEE80，将结果赋值给ctx.fillStyle，在PC端使用chrome浏览器调试表现正常，但是在安卓真机上无效</p><p>左图为透明度为1，右图透明度为0.2，在华为自带浏览器下测试结果对比图如下：</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202211031656919.png"></p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202211031656710.png"></p><p>完整demo如下，可以用node起一个服务，在手机上打开：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>canvas颜色和透明度不生效<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vconsole@latest/dist/vconsole.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">new</span> <span class="built_in">window</span>.VConsole();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span></span><br><span class="line"><span class="javascript">            canvas.width = <span class="number">1000</span>;</span></span><br><span class="line"><span class="javascript">            canvas.height = <span class="number">1000</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="javascript">            ctx.font = <span class="string">&quot;20px Microsoft YaHei&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ctx.fillStyle = convertColor(&#x27;#AEEEEE&#x27;, 0.2);</span></span></span><br><span class="line"><span class="javascript">            ctx.fillStyle = convertColor(<span class="string">&#x27;#AEEEEE&#x27;</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 绘制文字水印</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span></span><br><span class="line"><span class="javascript">                    ctx.fillText(<span class="string">&quot;Hello world&quot;</span>, <span class="number">150</span> * (i), <span class="number">50</span> * (j + <span class="number">1</span>));</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="javascript">         * 获取颜色的16进制 （颜色+透明度）</span></span></span><br><span class="line"><span class="comment"><span class="javascript">         *</span></span></span><br><span class="line"><span class="comment"><span class="javascript">         * <span class="doctag">@param </span>color 颜色</span></span></span><br><span class="line"><span class="comment"><span class="javascript">         * <span class="doctag">@param </span>transparency 透明度</span></span></span><br><span class="line"><span class="comment"><span class="javascript">         * <span class="doctag">@returns</span></span></span></span><br><span class="line"><span class="comment"><span class="javascript">         */</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> convertColor = <span class="function">(<span class="params">color, transparency</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> getPureColor = <span class="function">(<span class="params">color</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> plainColor = color?.substring(<span class="number">1</span>); <span class="comment">// 去掉#</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> isColorShort = plainColor?.length === <span class="number">3</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> isColorShort ? plainColor.split(<span class="string">&#x27;&#x27;</span>).map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;v&#125;</span><span class="subst">$&#123;v&#125;</span>`</span>).join(<span class="string">&#x27;&#x27;</span>) : plainColor;</span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> getAlpha = <span class="function">(<span class="params">transparency</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> alpha = <span class="built_in">parseInt</span>(<span class="built_in">String</span>(<span class="number">256</span> * transparency), <span class="number">10</span>).toString(<span class="number">16</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> alpha.length &gt; <span class="number">1</span> ? alpha : <span class="string">`0<span class="subst">$&#123;alpha&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;getPureColor(color)&#125;</span><span class="subst">$&#123;getAlpha(transparency)&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;探究起因&quot;&gt;&lt;a href=&quot;#探究起因&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>探究Safari对于canvas的限制</title>
    <link href="http://example.com/2022/10/25/%E6%8E%A2%E7%A9%B6Safari%E5%AF%B9%E4%BA%8Ecanvas%E7%9A%84%E9%99%90%E5%88%B6/"/>
    <id>http://example.com/2022/10/25/%E6%8E%A2%E7%A9%B6Safari%E5%AF%B9%E4%BA%8Ecanvas%E7%9A%84%E9%99%90%E5%88%B6/</id>
    <published>2022-10-25T03:32:52.000Z</published>
    <updated>2022-10-25T06:29:01.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="探究起因"><a href="#探究起因" class="headerlink" title="探究起因"></a>探究起因</h2><p>之前使用<code>canvas</code>做了一个绘制水印的功能，可以简单理解成进入A页面后，从接口获取绘制水印的配置，然后在A页面的某个区域使用<code>canvas</code>加盖一层水印</p><p>开发和测试都在chrome浏览器上进行，期间均表现正常，直到交付给客户几个月后接到反馈，其APP内嵌我们开发的H5页面，先后出现了以下问题：</p><ul><li>Android机型正常进入页面，偶尔水印不加载</li><li>在IOS下打开页面后无法正常加载，控制台有报错</li><li>在华为鸿蒙系统下APP直接闪退</li></ul><p>嚯，问题还挺多，一个比一个严重- -！那接下来看看，是什么问题导致以上现象</p><p><strong>下文使用我另外写的一个demo做演示</strong></p><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h4 id="第一个问题相对来说比较简单，这里简单说说"><a href="#第一个问题相对来说比较简单，这里简单说说" class="headerlink" title="第一个问题相对来说比较简单，这里简单说说"></a>第一个问题相对来说比较简单，这里简单说说</h4><p>使用Android机型进行测试，确实是偶现不加载的情况，经过反复调试，发现在弱网情况下，没有请求接口，这里调整了请求的顺序就解决了</p><h4 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h4><p>一开始在chrome和Firefox下均未复现，后来发现仅在iPhone真机Safari下才能复现，报错如下：</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202210251104583.png"></p><p>难道ctx是null吗，结合部分代码调试后查看确实没有获取到渲染上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">canvas.width = <span class="number">10000</span>;</span><br><span class="line">canvas.height = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">ctx.font = <span class="string">&quot;20px Microsoft YaHei&quot;</span>;</span><br></pre></td></tr></table></figure><p>这时想起来Safari对于canvas的使用有一些限制（或者说是优化），印象中该浏览器对于canvas的数量有一定限制，emmm，我的代码中只有一个canvas，应该和这个限制没有关系</p><p>然后我开始搜索Safari对于使用canvas有什么限制/webkit内核对于canvas的限制，好的，没找到什么蛛丝马迹。于是开始面向google编程，翻一翻有没有人遇到过相似的问题</p><p>在一篇文章中有人提到 Safari对于画布大小有限制，于是我修改宽高，均缩小10倍，也就是渲染的区域缩小了100倍，刷新页面后正常加载了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.width = <span class="number">1000</span>;</span><br><span class="line">canvas.height = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>问题解决了是针不戳啊，那具体的尺寸是多少等解决完所有问题再研究下</p><h4 id="第三个问题"><a href="#第三个问题" class="headerlink" title="第三个问题"></a>第三个问题</h4><p>APP闪退，刚开始初步判断可能是客户环境webview做了某些处理，和我们H5页面没有什么关系，于是请教APP开发大佬，大佬一顿排查后得出结论：在华为鸿蒙系统下，H5页面渲染太久了，导致闪退</p><p>好家伙，那这个情况还是因为受到了画布大小影响？！</p><p>于是让测试同学在响应系统上通过APP打开H5页面，确实是没有再发生闪退…</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202210251153265.png"></p><p>那至此bug全部解决</p><h2 id="探究Safari对于canvas的限制"><a href="#探究Safari对于canvas的限制" class="headerlink" title="探究Safari对于canvas的限制"></a>探究Safari对于canvas的限制</h2><p>已知：Safari采用webkit内核</p><p>解：去github上clone一份源码瞅瞅</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/WebKit/WebKit.git</span><br></pre></td></tr></table></figure><p>（下面贴的源码均在<code>Source/WebCore/html/HTMLCanvasElement.cpp</code>文件中，可以直接翻阅，clone下来太久啦）</p><p>Safari 在实现<code>canvas</code>时对内存进行了限制，在不同设备上允许使用的内存不同，具体根据设备 RAM 的大小计算，一旦超出限制，使用 getContext(‘2d’) 将会返回 null</p><p>C++源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CanvasRenderingContext2D* <span class="title">HTMLCanvasElement::createContext2d</span><span class="params">(<span class="keyword">const</span> String&amp; type, CanvasRenderingContext2DSettings&amp;&amp; settings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ASSERT_UNUSED</span>(HTMLCanvasElement::<span class="built_in">is2dType</span>(type), type);</span><br><span class="line">    <span class="built_in">ASSERT</span>(!m_context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we don&#x27;t use more pixel memory than the system can support.</span></span><br><span class="line">    <span class="keyword">size_t</span> requestedPixelMemory = <span class="number">4</span> * <span class="built_in">width</span>() * <span class="built_in">height</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">activePixelMemory</span>() + requestedPixelMemory &gt; <span class="built_in">maxActivePixelMemory</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> message = <span class="built_in">makeString</span>(<span class="string">&quot;Total canvas memory use exceeds the maximum limit (&quot;</span>, <span class="built_in">maxActivePixelMemory</span>() / <span class="number">1024</span> / <span class="number">1024</span>, <span class="string">&quot; MB).&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>().<span class="built_in">addConsoleMessage</span>(MessageSource::JS, MessageLevel::Warning, message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_context = CanvasRenderingContext2D::<span class="built_in">create</span>(*<span class="keyword">this</span>, <span class="built_in">WTFMove</span>(settings), <span class="built_in">document</span>().<span class="built_in">inQuirksMode</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(IOSURFACE_CANVAS_BACKING_STORE)</span></span><br><span class="line">    <span class="comment">// Need to make sure a RenderLayer and compositing layer get created for the Canvas.</span></span><br><span class="line">    <span class="built_in">invalidateStyleAndLayerComposition</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;CanvasRenderingContext2D*&gt;(m_context.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>canvas</code> 的内存占用空间为 <code>4 * width * height</code>，这里的4指每个像素的RGBA</p><p>允许使用的最大内存空间由 <code>maxActivePixelMemory</code> 这个函数计算，这个函数计算规则如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">HTMLCanvasElement::maxActivePixelMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxActivePixelMemoryForTesting)</span><br><span class="line">        <span class="keyword">return</span> *maxActivePixelMemoryForTesting;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> maxPixelMemory;</span><br><span class="line">    <span class="keyword">static</span> std::once_flag onceFlag;</span><br><span class="line">    std::<span class="built_in">call_once</span>(onceFlag, [] &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS_FAMILY)</span></span><br><span class="line">        maxPixelMemory = <span class="built_in">ramSize</span>() / <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        maxPixelMemory = std::<span class="built_in">max</span>(<span class="built_in">ramSize</span>() / <span class="number">4</span>, <span class="number">2151</span> * MB);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxPixelMemory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再查找源码对于画布大小的限制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">maxCanvasArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCanvasAreaForTesting)</span><br><span class="line">        <span class="keyword">return</span> *maxCanvasAreaForTesting;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Firefox limits width/height to 32767 pixels, but slows down dramatically before it</span></span><br><span class="line">    <span class="comment">// reaches that limit. We limit by area instead, giving us larger maximum dimensions,</span></span><br><span class="line">    <span class="comment">// in exchange for a smaller maximum canvas size. The maximum canvas size is in device pixels.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS_FAMILY)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4096</span> * <span class="number">4096</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">16384</span> * <span class="number">16384</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过实际测试，在iPhone的Safari中，<code>canvas</code>的最大可用宽高确实是4096</p><p>具体可以看参考文章中的<a href="https://blog.csdn.net/lefex/article/details/121072900">Safari难道是下一个IE？兼容性这么“差”</a></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>另外在chrome、Firefox中，过大的宽高（100000），也无法正常展示，如下所示：</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202210251358465.png"></p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202210251400897.png"></p><p>没有探讨释放<code>canvas</code>占用的内存，大家有兴趣可以尝试一下</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>MDN</p><p><a href="https://stackoverflow.com/questions/40482586/getcontext2d-returns-null-in-safari-10">stackoverflow</a></p><p><a href="https://blog.csdn.net/lefex/article/details/121072900">Safari难道是下一个IE？兼容性这么“差”</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;探究起因&quot;&gt;&lt;a href=&quot;#探究起因&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入探究Object.create（尚未完成）</title>
    <link href="http://example.com/2022/10/17/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Object.create/"/>
    <id>http://example.com/2022/10/17/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6Object.create/</id>
    <published>2022-10-17T13:12:03.000Z</published>
    <updated>2022-10-25T06:32:23.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="探究起因"><a href="#探究起因" class="headerlink" title="探究起因"></a>探究起因</h2><p>在阅读一些框架源码（比方说Vue)时发现，开发者们使用<code>Object.create(null)</code>来初始化一个新对象，而我们一般在非面向工具链/基建开发时，惯常使用字面量，那么它们有什么区别呢？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN</a></p><p><a href="https://stackoverflow.com/questions/15518328/is-creating-js-object-with-object-createnull-the-same-as">stackoverflow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;探究起因&quot;&gt;&lt;a href=&quot;#探究起因&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DNS基础知识</title>
    <link href="http://example.com/2022/09/18/DNS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/09/18/DNS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-09-18T13:23:15.000Z</published>
    <updated>2023-08-12T09:41:44.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS 全称 <code>Domain Name System</code>，即域名系统</p><p>DNS 是网络请求要走的第一步，我们日常访问的网站使用的 <code>HTTP/HTTPS`` 协议的下层是</code>TCP/IP` ，而通过其中的 IP 协议，才能知道将数据包发送到何处</p><p>由于 IP 长且难记，通过 IP 访问网站不方便，后来通过发明了 DNS 服务器，这个时候我们访问网站输入网站域名，DNS服务器就解析我们的域名为 IP， 这样我们实际访问的就是对应的 IP 地址</p><p>它实质上是一个​​域名​​和 ​​IP​​相互映射的分布式数据库，有了它我们就可以通过域名更方便的访问互联网</p><h2 id="域名的树状结构"><a href="#域名的树状结构" class="headerlink" title="域名的树状结构"></a>域名的树状结构</h2><p>想要知道如何解析域名，还得从域名的树状结构说起</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202308121736650.png"></p><p>最顶层的域名是根域名（root），然后是顶级域名（top-level domain，简写 TLD），再是一级域名、二级域名、三级域名</p><ul><li>根域名</li></ul><p>所有域名的起点都是根域名，它写作一个点.，放在域名的结尾，可以省略不写（任何一个域名结尾加一个点，浏览器都可以正常解读）</p><p>根域名服务器全世界一共有13台（都是服务器集群）</p><ul><li>顶级域名</li></ul><p>根域名的下一级是顶级域名。它分成两种：通用顶级域名（gTLD，比如 .com 和 .net）和国别顶级域名（ccTLD，比如 .cn 和 .us）</p><ul><li>一级域名</li></ul><p>一级域名就是你在某个顶级域名下面，自己注册的域名</p><p>比如，a.b.com就是我在顶级域名，.b就是一级域名</p><ul><li>二级域名</li></ul><p>二级域名是一级域名的子域名，是域名拥有者自行设置的，不用得到许可</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>DNS解析分为<code>递归查询</code>与<code>迭代查询</code>：</p><ul><li>主机向本地域名服务器的查询一般都是采用递归查询<br>  如果主机向本地域名服务器查询的是未知的 IP 地址，那么本地域名服务器就以 DNS 客户的身份向其它根域名服务器继续发出查询请求报文，也就是替主机继续查询，而不是让主机自己进行下一步查询</li><li>本地域名服务器向根域名服务器的查询的迭代查询<br>  当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所查询的 IP 地址，要么告诉本地域名服务器下一步应该向哪个域名服务器查询（以便本地域名服务器进行后续查询）</li></ul><h2 id="DNS缓存机制"><a href="#DNS缓存机制" class="headerlink" title="DNS缓存机制"></a>DNS缓存机制</h2><p>用户输入 URL 以后，浏览器首先要查询域名对应服务器的 IP 地址，这个操作一般需要耗费 20-120 毫秒时间，而DNS 查询完成之前，浏览器无法从服务器下载任何数据，因此基于性能考虑，ISP、局域网、操作系统、浏览器都会有相应的 DNS 缓存机制：</p><ul><li>IE 缓存 30 分钟，可以通过注册表中 DnsCacheTimeout 项设置</li><li>Firefox 缓存 1 分钟，通过 network.dnsCacheExpiration 配置</li><li>Chrome 缓存 1 分钟，通过 chrome://net-internals/#dns 配置</li></ul><h2 id="DNS存在的问题"><a href="#DNS存在的问题" class="headerlink" title="DNS存在的问题"></a>DNS存在的问题</h2><ul><li>查询路径过长导致业务访问延时</li><li>缓存时间不统一</li><li>DNS 劫持（被黑客劫持信息，插入广告）</li><li>根服务器停止服务的风险</li></ul><h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><p><code>X-DNS-Prefetch-Control</code>头控制着浏览器的 DNS 预解析功能:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ruanyifeng.com/blog/2022/08/dns-query.html">DNS 查询原理详解</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch">X-DNS-Prefetch-Control</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="DNS" scheme="http://example.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>CDN基础知识</title>
    <link href="http://example.com/2022/09/11/CDN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/09/11/CDN%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-09-11T13:13:14.000Z</published>
    <updated>2023-08-12T09:43:28.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>CDN 全称 Content Delivery Network，即内容分发网络，它的主要作用：<strong>为了加速网站的访问</strong></p><p>它是一组分布在各个地区的服务器，这些服务器存储着数据副本，因此服务器可以根据服务器与用户的距离来判断使用使用哪些服务器最优，<strong>使用户就近获取所需内容</strong></p><h2 id="为什么有-CDN"><a href="#为什么有-CDN" class="headerlink" title="为什么有 CDN"></a>为什么有 CDN</h2><p>当下的互联网应用都包含大量的静态内容，但静态内容以及一些准动态内容又是最耗费带宽的，特别是针对全国甚至全世界的大型网站，如果这些请求都指向主站的服务器的话，不仅是主站服务器受不了，单端口500M左右的带宽也扛不住，所以大多数网站都需要CDN服务。</p><p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响（尤其是电商网站），任何的企业都渴望自己站点有更快的访问速度。而 HTTP 传输时延对 web 的访问速度的影响很大，在绝大多数情况下是起决定性作用的：</p><ul><li>物理层上的原因是光速有限、信道有限</li><li>TCP/IP 协议的一些特点：协议上的原因有丢包、慢启动、拥塞控制等</li></ul><h3 id="前端开发中的应用"><a href="#前端开发中的应用" class="headerlink" title="前端开发中的应用"></a>前端开发中的应用</h3><p>在前端开发中，CDN允许快速传输加载互联网内容所需的资产，包括HTML页面、JavaScript文件、样式表、图像和视频，有以下几点好处：</p><ul><li>通过 CDN 向用户分发传输相关库的静态资源文件，可以降低我们自身服务器的请求压力</li><li>大多数 CDN 在全球都有服务器，所以 CDNs 上的服务器在地理位置上可能比你自己的服务器更接近你的用户（地理距离会按比例影响延迟）</li><li>CDNs 已经配置了恰当的缓存设置（使用 CDN 节省了在你的服务器中对静态资源文件的配置）</li></ul><h3 id="CDN-的其它作用"><a href="#CDN-的其它作用" class="headerlink" title="CDN 的其它作用"></a>CDN 的其它作用</h3><ul><li>跨运营商、跨地域的全网覆盖<br>  互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速</li><li>保障网站安全<br>  CDN 的负载均衡和分布式存储技术，可以增强网站的可靠性，相当于无形中给主站加了一道屏障，应对绝大部分的互联网攻击</li><li>异地备援<br>  当某个服务器发生意外故障时，系统会调用其它临近的正常的服务器节点进行服务</li><li>节约成本<br>  投入使用 CDN 加速可以实现网站的全国铺设，不用考虑购买服务器和后续托管运维，服务器之间的镜像同步，节省了人力、精力和财力</li><li>可以更专注业务本身<br>  CDN 加速厂商一般都会提供一站式服务，业务不仅局限于 CDN，还有配套的云存储、大数据服务等，全天运维监控支持，保证网络随时畅通，能够放心使用</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>从上面的描述中不难看出 CDN 的工作原理：将主站的资源缓存在 CDN 的各节点，当请求命中某个节点的资源缓存时，就能立即返回客户端，这样不仅可以减轻主站服务器的压力，也能一定程度上避免网络拥塞，提高了用户访问资源的速度和体验</p><p><img src="https://raw.githubusercontent.com/HJY-xh/pictures/master/pictures/202308121738801.png"></p><ul><li>当用户访问某个URL，经过本地DNS系统解析，DNS 系统会最终将域名的解析权交给 CNAME 指向的 CDN 专用 DNS 服务器。</li><li>CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。</li><li>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</li><li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li><li>基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址：<ul><li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li><li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li><li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li><li>全局负载均衡设备把服务器的 IP 地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CDN">MDN</a></p><p><a href="https://zhuanlan.zhihu.com/p/113037678">CDN原理简单介绍</a></p><p><a href="https://www.huaweicloud.com/zhishi/cdn001.html">CDN的加速原理是什么？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="CDN" scheme="http://example.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中extends用法小结</title>
    <link href="http://example.com/2022/08/22/TypeScript%E4%B8%ADextends%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://example.com/2022/08/22/TypeScript%E4%B8%ADextends%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2022-08-22T14:12:31.000Z</published>
    <updated>2022-08-31T09:17:36.455Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><code>extends</code>关键字在TS中有多种用法，单独使用时，常见有以下几种情况</p><ul><li>继承/拓展</li><li>约束</li><li>条件判断</li></ul><h2 id="继承-扩展"><a href="#继承-扩展" class="headerlink" title="继承/扩展"></a>继承/扩展</h2><h4 id="单个-多个接口"><a href="#单个-多个接口" class="headerlink" title="单个/多个接口"></a>单个/多个接口</h4><p>这种用法和类的继承相似，看个🌰</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog继承Animal并扩展一个run方法</span></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="attr">run</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog: Dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;狗子&#x27;</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也支持多重继承</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Blackdog <span class="keyword">extends</span> Animal, Dog &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展类的接口"><a href="#扩展类的接口" class="headerlink" title="扩展类的接口"></a>扩展类的接口</h4><p>除了上面的常见用法，接口还可以继承类的私有成员和受保护成员，而不仅仅是公共成员</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Runnable <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: 缺少属性 state</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>一个接口可以继承/扩展一个或多个现有接口</li><li>一个接口也可以继承/扩展一个类。如果该类包含私有或受保护成员，则该接口只能由该类或其子类实现</li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>此处说的约束，一般指泛型约束，即对泛型的类型进行约束控制</p><p>在编写方法的时候，可能会需要对参数的类型做一些限制，比方说入参有一个<code>length</code>属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Error: 类型“T”上不存在属性“length”</span></span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行约束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123;length: <span class="built_in">number</span>&#125;&gt;(arg: T): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>和三目表达式类似，看看官网的示例和说明</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeType <span class="keyword">extends</span> OtherType ? TrueType : FalseType;</span><br></pre></td></tr></table></figure><blockquote><p>When the type on the left of the <code>extends</code> is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).</p></blockquote><p><strong>如果extends前面的类型能够赋值给extends后面的类型，那么表达式判断为真，否则为假</strong></p><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A1 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A2 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A的类型为string</span></span><br><span class="line"><span class="keyword">type</span> A = A2 <span class="keyword">extends</span> A1 ? <span class="built_in">string</span> : <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str: A = <span class="string">&#x27;this is string&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A1，A2两个接口，满足A2的接口一定可以满足A1，所以条件为真，A的类型取string</p><h4 id="结合泛型使用"><a href="#结合泛型使用" class="headerlink" title="结合泛型使用"></a>结合泛型使用</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A1 = <span class="string">&#x27;x&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> A2 = <span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> A3 = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>A1、A2的结果也就是常规的用法，很容易得出结果，但是A3结合了泛型，这里有一个<code>Distributive Conditional Types</code>的概念</p><blockquote><p>When conditional types act on a generic type, they become <em>distributive</em> when given a union type</p></blockquote><p><em>如果extends前面的参数是一个泛型类型，当传入该参数的是联合类型，则使用分配律计算最终的结果。分配律是指，将联合类型的联合项拆成单项，分别代入条件类型，然后将每个单项代入得到的结果再联合起来，得到最终的判断结果。</em></p><p>以上面的A3为例，进行推导</p><p>P<T>中T是一个泛型参数。在A3的定义中，给T传入的是’x’和’y’的联合类型’x’ | ‘y’，满足分配律，于是’x’和’y’被拆开，分别代入P<T></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; =&gt; P&lt;<span class="string">&#x27;x&#x27;</span>&gt; | P&lt;<span class="string">&#x27;y&#x27;</span>&gt;</span><br><span class="line"><span class="comment">// &#x27;x&#x27;代入得到</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="comment">// &#x27;y&#x27;代入得到</span></span><br><span class="line"><span class="string">&#x27;y&#x27;</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure><p>然后将每一项代入得到的结果联合起来，得到string | number</p><p>满足两个要点即可适用分配律：第一，参数是泛型类型，第二，代入参数的是联合类型</p><h4 id="特殊的never"><a href="#特殊的never" class="headerlink" title="特殊的never"></a>特殊的never</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never是所有类型的子类型</span></span><br><span class="line"><span class="keyword">type</span> A1 = <span class="built_in">never</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> A2 = P&lt;<span class="built_in">never</span>&gt; <span class="comment">// never</span></span><br></pre></td></tr></table></figure><p><strong>never被认为是空的联合类型</strong>，也就是说，没有联合项的联合类型，所以还是满足上面的分配律，然而因为没有联合项可以分配，所以<code>P&lt;T&gt;</code>的表达式其实根本就没有执行，所以A2的定义也就类似于永远没有返回的函数一样，是never类型的</p><h4 id="防止条件判断中的分配"><a href="#防止条件判断中的分配" class="headerlink" title="防止条件判断中的分配"></a>防止条件判断中的分配</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="string">&#x27;x&#x27;</span>] ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> A1 = P&lt;<span class="string">&#x27;x&#x27;</span> | <span class="string">&#x27;y&#x27;</span>&gt; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">type</span> A2 = P&lt;<span class="built_in">never</span>&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>在条件判断类型的定义中，将泛型参数使用<code>[]</code>括起来，即可阻断条件判断类型的分配，此时，传入参数T的类型将被当做一个整体，不再分配</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.typescripttutorial.net/typescript-tutorial/typescript-extend-interface/">How to Extend Interfaces in TypeScript</a></li><li><a href="https://www.typescripttutorial.net/typescript-tutorial/typescript-generic-constraints/">TypeScript Generic Constraints</a></li><li><a href="https://juejin.cn/post/6998736350841143326">TS关键字extends用法总结</a></li><li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">Conditional Types</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;关键字在TS中有多种用法，单独使用时，常见有以下</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的any、unknown、never如何理解</title>
    <link href="http://example.com/2022/08/15/TypeScript%E4%B8%AD%E7%9A%84any%E3%80%81unknown%E3%80%81never%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2022/08/15/TypeScript%E4%B8%AD%E7%9A%84any%E3%80%81unknown%E3%80%81never%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3/</id>
    <published>2022-08-15T13:06:41.000Z</published>
    <updated>2022-08-31T02:51:25.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>在TS中使用<code>any</code>类型，可以用来表示允许赋值给变量任意类型，这种方式与直接使用JS没有太大差别，无法享受到TS的类型检查，在可能出错的地方也不会发现错误。</p><p><code>any</code>类型本质上是类型系统的一个逃逸舱，那我们在什么情况下会使用该类型呢？</p><ul><li>无法确定当前类型时</li><li>逐步向TS迁移时</li></ul><p><strong>而在编写代码的过程中，明确知道类型的时候，有时为了偷懒，使用了<code>any</code>，这是一种不好的行为。</strong></p><p>而以下种种原因，可能都会对我们是否使用<code>any</code>有影响：</p><ul><li>添加类型时，需要编写大量代码，而<code>any</code>工作量很少</li><li>已经通过必要的运行时检查以防御性的方式编写了代码，以确保没有错误</li><li>有些参数很难正确输入，但是<code>any</code>更容易</li><li>不知道参数是什么</li><li>类型增加了很多复杂性，有时<code>any</code>更简单</li></ul><p>使用<code>any</code>还会造成类型污染的问题：即<code>any</code>类型的对象会导致后续的属性类型都会变成<code>any</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: any = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.name = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h2><p>在TS的3.0版本中，引入了<code>unknown</code>类型，它可以这样理解成：**<code>unknown</code>类型是<code>any</code>的类型安全版本。**</p><p>这意味着如果要在TS中使用<code>unknown</code>类型时，需要知道它所指的类型，也就自然地推导出使用该类型的变量前，需要对该变量的类型进行断言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">value: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// @ts-ignore: Object is of type &#x27;unknown&#x27;.</span></span><br><span class="line">  value.toFixed(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type assertion:</span></span><br><span class="line">  (value <span class="keyword">as</span> number).toFixed(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缩小为更具体的类型范围，包括 typeof 运算符，instanceof 运算符和自定义类型保护函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">       value.toFixed(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unknown</code>类型只能被赋值给<code>any</code>类型和<code>unknown</code>类型本身。</p><p>因为只有能够保存任意类型值的容器才能保存<code>unknown</code> 类型的值，所以这个限制很合理。毕竟我们不知道变量中存储了什么类型的值。</p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code>类型表示的是那些永不存在的值的类型，<code>never</code>类型是任何类型的子类型，也可以赋值给任何类型。</p><p>然而，没有类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）,<code>never</code>用于那些永不可发生的情况:</p><ul><li>一个从来不会有返回值的函数（如：如果函数内含有 <code>while(true) &#123;&#125;</code>）；</li><li>一个总是会抛出错误的函数（如：<code>function foo() &#123; throw new Error(&#39;Not Implemented&#39;) &#125;</code>，foo 的返回类型是 never）；</li></ul><h3 id="与-void-的差异"><a href="#与-void-的差异" class="headerlink" title="与 void 的差异"></a>与 void 的差异</h3><p><code>void</code>表示没有任何类型，<code>never</code>表示永远不存在的值的类型</p><h2 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h2><ul><li><code>any</code>和<code>unknown</code>是TS中所谓的顶级类型：当把类型看作是值的集合时，any 和 unknown 是包含所有值的集合</li><li><code>never</code>类型是TS中的底层类型：空集</li></ul><h2 id="以下或许是最佳实践"><a href="#以下或许是最佳实践" class="headerlink" title="以下或许是最佳实践"></a>以下或许是最佳实践</h2><ul><li>如果不是有意忽略类型检查，不使用<code>any</code></li><li>如果要用<code>any</code>，可以考虑用<code>unknown</code>代替（进行断言后使用）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://wanago.io/2020/01/27/understanding-any-and-unknown-in-typescript-difference-between-never-and-void/">understanding-any-and-unknown-in-typescript-difference-between-never-and-void</a></p></li><li><p><a href="https://mariusschulz.com/blog/the-unknown-type-in-typescript">The unknown Type in TypeScript</a></p></li><li><p><a href="https://www.51cto.com/article/676734.html">使用 TypeScript 中的 Any 类型前，你需要了解的一切</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;any&quot;&gt;&lt;a href=&quot;#any&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript中的一些小技巧</title>
    <link href="http://example.com/2022/07/18/TypeScript%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2022/07/18/TypeScript%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2022-07-18T12:18:34.000Z</published>
    <updated>2023-07-19T01:28:11.643Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><strong>为什么通常来说类型声明的使用优先于类型断言</strong></p><p>：类型声明更够更有效地帮助我们进行类型检查</p><p>假设有如下定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要声明一个该类型变量时，可以有两种做法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student_1: Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student_2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">&#125; <span class="keyword">as</span> Person</span><br></pre></td></tr></table></figure><p>在常规情况下声明变量类型，优先使用第一种方式，这样能够帮助我们进行类型检查，这种错误提示显然是非常有用的，而使用断言时，有可能出现某个属性并不在断言的类型中的情况，这种情况下并没有报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student_3: Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">10</span> <span class="comment">// 报错：“age”不在类型“Person”中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student_4 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">10</span> <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">as</span> Person</span><br></pre></td></tr></table></figure><p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除，虽然最终转化出来的js能够运行正常，但这也会让同事感到迷惑</p><p><strong>什么时候使用类型断言？</strong></p><p>：只有你比TypeScript知道得更多的时候</p><p>举个🌰：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;submit-btn&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.sign-confirm-button&#x27;</span>)! <span class="keyword">as</span> HTMLButtonElement;</span><br></pre></td></tr></table></figure><p>由于TypeScript并不能访问到DOM，而作为开发者的我们，明确知道此处是一个按钮，这里就可以合理地断言成<code>HTMLButtonElement</code>，而非自动推断的<code>Element | null</code></p><p><strong>为什么尽量不使用包装类型</strong></p><ul><li><p>string 和 String</p></li><li><p>number 和 Number</p></li><li><p>boolean 和 Boolean</p></li><li><p>symbol 和 Symbol</p></li><li><p>bigint 和 BigInt</p></li></ul><p>用<code>string</code>举例，当我们在在字符串字面量上访问诸如 charAt 之类的方法时，JavaScript 将其包装在一个 String 对象中，调用该方法，然后丢弃该对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalCharAt = <span class="built_in">String</span>.prototype.charAt;</span><br><span class="line"><span class="built_in">String</span>.prototype.charAt = <span class="function"><span class="keyword">function</span>(<span class="params">pos</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="keyword">typeof</span> <span class="built_in">this</span>, pos);</span><br><span class="line"> <span class="keyword">return</span> originalCharAt.call(<span class="built_in">this</span>, pos);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;primitive&#x27;</span>.charAt(<span class="number">3</span>));</span><br><span class="line"><span class="comment">//String &#123;&#x27;primitive&#x27;&#125; &#x27;object&#x27; 3</span></span><br><span class="line"><span class="comment">// m</span></span><br></pre></td></tr></table></figure><p>字符串和字符串对象不相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;John&quot;</span> === <span class="string">&quot;John&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;John&quot;</span> === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;John&quot;</span>) === <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在 TypeScript 中，可以将字符串基本类型 <code>string</code> 赋值给包装类型 <code>String</code>，但无法反过来将 <code>String</code> 赋值给 <code>string</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNameLength</span>(<span class="params">studentName: <span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> studentName.length; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line">getNameLength(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStudent</span>(<span class="params">studentName: <span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;John&#x27;</span>].includes(studentName); <span class="comment">// 报错：类型“String”的参数不能赋给类型“string”的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时的值仍然是原始值，而不是对象，但是 TypeScript 允许这些声明，因为原始类型可以分配给对象包装器，这样看起来有些迷惑，所以最好统一使用原始类型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么通常来说类型声明的使用优先于类型断言&lt;/strong&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TCP 协议详解</title>
    <link href="http://example.com/2022/06/21/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/06/21/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-06-21T12:17:32.000Z</published>
    <updated>2023-08-12T09:57:09.514Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>除了三次握手，四次挥手，TCP  还有很多细节需要掌握，知其然知其所以然</p><ul><li>TCP  为什么可靠？————连接确认！关闭确认！收到数据确认！各种确认！！</li><li>因为网络或其他原因，对方收不到数据怎么办？–超时重试</li><li>网络情况千变万化，超时时间怎么确定？–根据RTT动态计算</li><li>反反复复，不厌其烦的重试，导致网络拥塞怎么办？—慢启动，拥塞避免，快速重传，快速恢复</li><li>发送速度和接收速度不匹配怎么办？–滑动窗口</li><li>滑动窗口滑的过程中，他一直告诉我处理不过来了，不让传数据了怎么办？–ZWP</li><li>滑动窗口滑的过程中，他处理得慢，就理所当然的每次让我发很少的数据，导致网络利用率很低怎么办？—Nagle</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="TCP-连接的特点"><a href="#TCP-连接的特点" class="headerlink" title="TCP  连接的特点"></a>TCP  连接的特点</h3><ul><li>面向连接</li><li>可靠传输</li><li>提供字节流服务</li></ul><h3 id="TCP-如何保证可靠性"><a href="#TCP-如何保证可靠性" class="headerlink" title="TCP  如何保证可靠性"></a>TCP  如何保证可靠性</h3><ul><li>分块传输：数据被分割成最合适的数据块（UDP的数据长度不变）</li><li>等待确认：通过定时器等待接收端发送确认请求，收不到确认则重发</li><li>确认回复：收到确认后发送确认回复</li><li>数据校验：保持首部和数据的校验和，检测数据传输过程有无变化</li><li>乱序重排：接收端能重排序数据，以正确的顺序交给应用端</li><li>重复丢弃：接收端能丢弃重复的数据包</li><li>流量缓冲：两端有固定大小的缓冲区（滑动窗口），防止速度不匹配造成数据丢失</li></ul><h3 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h3><p>TCP  数据被封装在 IP 数据报中</p><ul><li>TCP  首部数据通常包含20个字节（不包括任选字段）</li><li>第1-2两个字节：源端口号</li><li>第3-4两个字节：目的端口号<blockquote><p>源端口号+ip首部中的源ip地址+目的端口号+ip首部中的目的ip地址，唯一的确定了一个 TCP  连接，对应编码级别的socket</p></blockquote></li><li>第5-8四个字节：32位序号。TCP 提供全双工服务，两端都有各自的序号，<strong>编号：解决网络包乱序的问题</strong><blockquote><p>序号如何生成：TCP 基于时钟生成一个序号，每4微秒加一，到2^32-1时又从0开始(不能是固定写死的，否则断网重连时序号重复使用会乱套)</p></blockquote></li><li>第9-12四个字节：32位确认序列号。上次成功收到数据字节序号加1，ack为1才有效，<strong>确认号：解决丢包的问题</strong></li><li>第13位字节：首部长度。因为任选字段长度可变</li><li>后面6bite：保留</li><li>随后6bite：标识位。<strong>控制各种状态</strong><ul><li>URG：为1时，表示紧急指针有效</li><li>ACK：确认标识，连接建立成功后，总为1。为1时确认号有效</li><li>PSH：接收方应尽快把这个报文交给应用层</li><li>RST：复位标识，重建连接</li><li>SYN：建立新连接时，该位为0</li><li>FIN：关闭连接标识</li></ul></li><li>第15-16两个字节：窗口大小。接收端期望接收的字节数。<strong>解决流量控制的问题</strong></li><li>第17-18两个字节：校验和。由发送端计算和存储，由接收端校验。<strong>解决数据正确性问题</strong></li><li>第19-20两个字节：紧急指针</li></ul><h2 id="连接的建立与释放"><a href="#连接的建立与释放" class="headerlink" title="连接的建立与释放"></a>连接的建立与释放</h2><h3 id="三次握手、四次挥手"><a href="#三次握手、四次挥手" class="headerlink" title="三次握手、四次挥手"></a>三次握手、四次挥手</h3><p>TCP 连接是全双工的，数据在两个方向上能同时传递，这是决定握手和挥手次数一个基本原因</p><p>Q: 为什么是三次握手？</p><p>A: 要确保双方，同时能发数据和收数据</p><ul><li>第一次握手：证明了发送方能发数据</li><li>第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据</li><li>第三次握手：确保了发送方能收数据</li><li>实际上是四个维度的信息交换，不过中间两步合并为一次握手了，四次握手浪费，两次握手不能保证“双方同时具备收发功能”</li></ul><p>Q: 为什么是四次挥手</p><p>A: TCP 支持半关闭（发送一方结束发送还能接收数据的功能），每个方向都要单独关闭，收到关闭通知需要发送确认回复</p><p>Q: 为什么要支持半关闭</p><p>A: 原因如下：</p><ul><li>客户端需要通知服务端，它的数据已经传输完毕，同时仍要接收来自服务端的数据</li><li>使用半关闭的单连接效率要比使用两个TCP 连接更好</li></ul><h3 id="TCP-连接和关闭对应的状态"><a href="#TCP-连接和关闭对应的状态" class="headerlink" title="TCP 连接和关闭对应的状态"></a>TCP 连接和关闭对应的状态</h3><ul><li>服务端等待客户端连接时，处于Listen监听状态</li><li>客户端主动打开请求，发送SYN时处于SYN_SENT发送状态</li><li>客户端收到syn和ack，并回复ack时，处与Established状态等待发送报文</li><li>服务端收到ack确认后，也处于Established状态等待发送报文</li><li>客户端发送fin后，处于fin_wait_1状态</li><li>服务端收到fin并发送ack时，处于close_wait状态</li><li>客户端收到ack确认后，处于fin_wait_2状态</li><li>服务端发送fin后，处于last_ack状态</li><li>客户端收到fin后发送ack，处于time_wait状态</li><li>服务端收到ack后，处于closed状态</li></ul><h4 id="time-wait状态"><a href="#time-wait状态" class="headerlink" title="time_wait状态"></a>time_wait状态</h4><ul><li>也称为2MSL等待状态，MSL：Maximum Segment LifetIme，报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间，根据不同的tcp实现自行设定(常用值为30s，1min，2min。linux一般为30s)</li><li>主动关闭的一方发送最后一个ack所处的状态</li><li>这个状态必须维持2MSL等待时间<ul><li>预留足够的时间给接收端收ack。设想一个场景，最后这个ack丢失了，接收方没有收到，这时候接收方会重新发送fin给发送方，这个等待时间就是为了防止这种情况发生，让发送方重新发送ack</li><li>在这2MSL等待时间内，该连接（socket，ip+port）将不能被使用</li></ul></li></ul><h3 id="复位报文段"><a href="#复位报文段" class="headerlink" title="复位报文段"></a>复位报文段</h3><p>一个报文段从源地址发往目的地址，只要出现错误，都会发出复位的报文段，首部字段的RST是用于“复位”的。这些错误包括以下情况：</p><ul><li>端口没有在监听</li><li>异常中止：通过发送RST而不是fin来中止连接</li></ul><h2 id="数据的传输"><a href="#数据的传输" class="headerlink" title="数据的传输"></a>数据的传输</h2><h3 id="TCP-传输的数据分类"><a href="#TCP-传输的数据分类" class="headerlink" title="TCP 传输的数据分类"></a>TCP 传输的数据分类</h3><p>TCP 处理的数据包括两类，有不同的特点，需要不同的传输技术：</p><ul><li>交互数据传输：量小，报文段为微小分组，大量微小分组，在广域网传输会增加拥堵的出现</li><li>成块数据传输：量大，报文段常常满</li></ul><h3 id="交互数据的传输技术"><a href="#交互数据的传输技术" class="headerlink" title="交互数据的传输技术"></a>交互数据的传输技术</h3><ul><li>经受时延的确认<ul><li>TCP 收到数据后，并不会立马发送ack确认，会与将要发送的数据一起发送，以减少开销</li></ul></li><li>Nagle算法<ul><li>解决什么问题：微小分组导致在广域网出现的拥堵问题</li><li>核心：减少了通过广域网传输的小分组数目</li><li>原理：要求一个 TCP 连接上最多只能有一个未被确认的未完成的分组，该分组的确认到达之前，不能发送其他分组。TCP 收集这些分组，确认到来之前以一个分组的形式发出去</li><li>优点：自适应。确认到达的快，数据发送越快。确认慢，发送更少的组</li><li>使用注意：局域网很少使用该算法。且有些特殊场景需要禁用该算法</li></ul></li></ul><h3 id="成块数据传输"><a href="#成块数据传输" class="headerlink" title="成块数据传输"></a>成块数据传输</h3><p><strong>主要使用滑动窗口协议，该协议解决了发送方和接收方速率不匹配时，保证可靠传输和包乱序的问题</strong></p><p>机制：</p><ul><li>接收方根据目前缓冲区大小，通知发送方目前能接收的最大值</li><li>发送方根据接收方的处理能力来发送数据</li></ul><p>接收方给发送方的这个值成为窗口大小</p><p>tcp缓冲区的数据结构如下：</p><p><strong>拥塞窗口是为了防止出现发送方发送速度过快，导致中转路由器拥堵的问题</strong></p><p>机制：</p><ul><li>发送方增加一个拥塞窗口（cwnd），每次收到ack，窗口值加1,</li><li>取拥塞窗口和接收方发来的窗口大小取最小值发送</li></ul><p>这个机制存在的问题：</p><ul><li><p>零窗口<br>  当接收方处理速度慢，发送方发送速度快，窗口大小就慢慢被调为0</p></li><li><p>糊涂窗口综合征<br>  接收方太忙，取不完数据，导致发送方越来越小，这是因为数据比tcp和ip头小太多，网络利用率太低</p><p>  此时避免对小的窗口大小做响应</p><ul><li>发送端：使用前面说到的Nagle算法</li><li>接收端：窗口大小小于某个值，直接ack（0），阻止发送数据，等到窗口变大后再发</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904070000410631">一文彻底搞懂 TCP三次握手、四次挥手过程及原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了三次握手，四次挥手，TCP  还有很多细节需要掌握，知其然知其所以然&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>lodash常用方法</title>
    <link href="http://example.com/2022/05/18/lodash%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/05/18/lodash%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2022-05-18T13:08:44.000Z</published>
    <updated>2023-07-19T01:27:24.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>将数组（array）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果<code>array</code> 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块</p><p><strong>入参</strong></p><ol><li><code>array</code> <em>(Array)</em>: 需要处理的数组</li><li><code>[size=1]</code> <em>(number)</em>: 每个数组区块的长度</li></ol><p><strong>返回值</strong></p><p><em>(Array)</em>: 返回一个包含拆分区块的新数组（注：相当于一个二维数组）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> result = _.chunk(arr, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ], [ &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27; ], [ &#x27;g&#x27; ] ]</span></span><br></pre></td></tr></table></figure><h3 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h3><p>创建一个新数组，包含原数组中所有的非假值元素。例如<code>false</code>, <code>null</code>,<code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, 和 <code>NaN</code> 都是被认为是“假值”</p><p><strong>入参</strong></p><ol><li><code>array</code> <em>(Array)</em>: 需要处理的数组</li></ol><p><strong>返回值</strong></p><p><em>(Array)</em>: 返回过滤掉假值的新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="keyword">const</span> result = _.compact(arr);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ &#x27;a&#x27;, true ]</span></span><br></pre></td></tr></table></figure><h3 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h3><p>创建一个具有唯一<code>array</code>值的数组，每个值不包含在其他给定的数组中。（注：即创建一个新数组，这个数组中的值，为第一个数字（<code>array</code> 参数）排除了给定数组中的值。）该方法使用<a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero"><code>SameValueZero</code></a>做相等比较。结果值的顺序是由第一个数组中的顺序确定</p><p><strong>入参</strong></p><ol><li><code>array</code> <em>(Array)</em>: 要检查的数组</li><li><code>[values]</code> <em>(…Array)</em>: 排除的值</li></ol><p><strong>返回值</strong></p><p><em>(Array)</em>: 返回过滤掉假值的新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;可乐&#x27;</span>, <span class="string">&#x27;雪碧&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;雪碧&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(_.difference(arr1, arr2)); <span class="comment">// [ &#x27;可乐&#x27; ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想要比较引用类型，可以使用`differenceBy`</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [&#123; <span class="attr">name</span>: <span class="string">&#x27;可乐&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;雪碧&#x27;</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> arr2 = [&#123; <span class="attr">name</span>: <span class="string">&#x27;雪碧&#x27;</span> &#125;];</span><br><span class="line"><span class="built_in">console</span>.log(_.difference(arr1, arr2)); <span class="comment">// [ &#123; name: &#x27;可乐&#x27; &#125;, &#123; name: &#x27;雪碧&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [&#123; <span class="attr">name</span>: <span class="string">&#x27;可乐&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;雪碧&#x27;</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> arr2 = [&#123; <span class="attr">name</span>: <span class="string">&#x27;雪碧&#x27;</span> &#125;];</span><br><span class="line"><span class="built_in">console</span>.log(_.differenceBy(arr1, arr2, <span class="function">(<span class="params">item</span>) =&gt;</span> item.name)); <span class="comment">// [ &#123; name: &#x27;可乐&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure><h3 id="flattenDeep"><a href="#flattenDeep" class="headerlink" title="flattenDeep"></a>flattenDeep</h3><p>将<code>array</code>递归为一维数组</p><p><strong>入参</strong></p><ol><li><code>array</code> <em>(Array)</em>: 需要处理的数组</li></ol><p><strong>返回值</strong></p><p><em>(Array)</em>:返回一个的新一维数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>]]];</span><br><span class="line"><span class="keyword">const</span> result = _.flattenDeep(arr);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>创建一个去重后的<code>array</code>数组副本。使用了<a href="http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero"><code>SameValueZero</code></a> 做等值比较。只有第一次出现的元素才会被保留</p><p><strong>入参</strong></p><ol><li><code>array</code> <em>(Array)</em>: 要检查的数组</li></ol><p><strong>返回值</strong></p><p><em>(Array)</em>:返回新的去重后的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> result = _.uniq(arr);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [ 1, 2 ]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想要去重引用类型，可以使用`unionBy`</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [&#123; <span class="attr">name</span>: <span class="string">&#x27;可乐&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;可乐&#x27;</span> &#125;];</span><br><span class="line"><span class="built_in">console</span>.log(_.unionBy(arr1, <span class="function">(<span class="params">item</span>) =&gt;</span> item.name)); <span class="comment">// [ &#123; name: &#x27;可乐&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><p>创建一个对象，key 是 <code>iteratee</code> 遍历 <code>collection</code>(集合) 中的每个元素返回的结果。 分组值的顺序是由他们出现在 <code>collection</code>(集合) 中的顺序确定的。每个键对应的值负责生成 key 的元素组成的数组。iteratee 调用 1 个参数： <em>(value)</em></p><p><strong>入参</strong></p><p>1.<code>collection</code> <em>(Array|Object)</em>: 一个用来迭代的集合。</p><p>2.<code>[iteratee=_.identity]</code> <em>(Array|Function|Object|string)</em>: 这个迭代函数用来转换key</p><p><strong>返回值</strong></p><p><em>(Array)</em>:返回新的去重后的数组</p><h2 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h2><h3 id="omit"><a href="#omit" class="headerlink" title="omit"></a>omit</h3><p>这个对象由忽略属性之外的<code>object</code>自身和继承的可枚举属性组成</p><p><strong>入参</strong></p><ol><li><code>object</code> <em>(Object)</em>: 来源对象。</li><li><code>[props]</code> <em>(…(string|string[]))</em>: 要被忽略的属性</li></ol><p><strong>返回值</strong></p><p><em>(Object)</em>: 返回一个组成聚合的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.omit(object, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])); <span class="comment">// &#123; b: &#x27;2&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="omitBy"><a href="#omitBy" class="headerlink" title="omitBy"></a>omitBy</h3><p>这个对象忽略 <code>predicate</code>（断言函数）判断不是真值的属性后，<code>object</code>自身和继承的可枚举属性组成。<code>predicate</code>调用与2个参数：*(value, key)*</p><p><strong>入参</strong></p><ol><li><code>object</code> <em>(Object)</em>: 来源对象</li><li><code>[predicate=_.identity]</code> <em>(Function)</em>: 调用每一个属性的函数</li></ol><p><strong>返回值</strong></p><p><em>(Object)</em>: 返回新对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.omitBy(object, <span class="function">(<span class="params">key, value</span>) =&gt;</span> <span class="keyword">typeof</span> object[value] === <span class="string">&#x27;number&#x27;</span>)); <span class="comment">// &#123; b: &#x27;2&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h3><p>创建一个从 <code>object</code> 中选中的属性的对象</p><p><strong>入参</strong></p><ol><li><code>object</code> <em>(Object)</em>: 来源对象。</li><li><code>[props]</code> <em>(…(string|string[]))</em>: 要被选中的属性</li></ol><p><strong>返回值</strong></p><p><em>(Object)</em>: 返回新对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.pick(object, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])); <span class="comment">// &#123; a: 1, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="pickBy"><a href="#pickBy" class="headerlink" title="pickBy"></a>pickBy</h3><p>创建一个对象，这个对象组成为从 <code>object</code> 中经 <code>predicate</code> 判断为真值的属性。 <code>predicate</code>调用2个参数：*(value, key)*。</p><p><strong>入参</strong></p><ol><li><code>object</code> <em>(Object)</em>: 来源对象。</li><li><code>[predicate=_.identity]</code> <em>(Function)</em>: 调用每一个属性的函数</li></ol><p><strong>返回值</strong></p><p><em>(Object)</em>: 返回新对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(_.pickBy(object, _.isNumber)); <span class="comment">// &#123; a: 1, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>根据 <code>object</code>对象的<code>path</code>路径获取值。 如果解析 value 是 <code>undefined</code> 会以 <code>defaultValue</code> 取代</p><p><strong>入参</strong></p><ol><li><code>object</code> <em>(Object)</em>: 要检索的对象</li><li><code>path</code> <em>(Array|string)</em>: 要获取属性的路径</li><li><code>[defaultValue]</code> <em>(*)</em>: 如果解析值是 <code>undefined</code> ，这值会被返回</li></ol><p><strong>返回值</strong></p><p><em>(*)</em>: 返回解析的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="string">&#x27;a&#x27;</span>: [&#123; <span class="string">&#x27;b&#x27;</span>: &#123; <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span> &#125; &#125;] &#125;;</span><br><span class="line"> </span><br><span class="line">_.get(object, <span class="string">&#x27;a[0].b.c&#x27;</span>); <span class="comment">// 3</span></span><br><span class="line">_.get(object, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]); <span class="comment">// 3</span></span><br><span class="line">_.get(object, <span class="string">&#x27;a.b.c&#x27;</span>, <span class="string">&#x27;default&#x27;</span>); <span class="comment">// &#x27;default&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数组操作&quot;&gt;&lt;a href=&quot;#数组操作&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Sass、Less的区别</title>
    <link href="http://example.com/2022/03/27/Sass%E3%80%81Less%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/27/Sass%E3%80%81Less%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-27T13:32:01.000Z</published>
    <updated>2023-08-03T13:26:43.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预处理器带来了什么"><a href="#预处理器带来了什么" class="headerlink" title="预处理器带来了什么"></a>预处理器带来了什么</h2><p>CSS (Cascading Style Sheets，层叠样式表)，是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言</p><p>CSS 预处理器通过引入一些特性，让 CSS 具备了编程的潜力，使 CSS 的编写更加动态</p><h2 id="二者相似之处"><a href="#二者相似之处" class="headerlink" title="二者相似之处"></a>二者相似之处</h2><p>Sass、Less 在语法上有些共性，比如下面这些：</p><ul><li>支持变量</li><li>支持混入</li><li>支持运算</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul><li>Less 基于 JavaScript ，是在客户端处理的</li><li>Sass 基于 Ruby ,是在服务端处理的</li></ul><h3 id="变量符号"><a href="#变量符号" class="headerlink" title="变量符号"></a>变量符号</h3><p>Less 用 <code>@</code>，Sass 用 <code>$</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@color:</span> <span class="number">#00c</span>; <span class="comment">/* 蓝色 */</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: <span class="number">#00c</span>; <span class="comment">/* 蓝色 */</span></span><br></pre></td></tr></table></figure><h3 id="SCSS-支持条件语句，LESS-不支持"><a href="#SCSS-支持条件语句，LESS-不支持" class="headerlink" title="SCSS 支持条件语句，LESS 不支持"></a>SCSS 支持条件语句，LESS 不支持</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@if</span> 条件 &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">@else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> to <span class="number">10</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 不包含10;</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">10</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 包含10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> item in a, b, c, d&#123;</span><br><span class="line">    <span class="comment">//item表示每一项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用外部-CSS-文件方式不同"><a href="#引用外部-CSS-文件方式不同" class="headerlink" title="引用外部 CSS 文件方式不同"></a>引用外部 CSS 文件方式不同</h3><p>如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线</p><p>例如，将文件命名为 _colors.scss，便不会编译_colors.css 文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;colors&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="颜色函数"><a href="#颜色函数" class="headerlink" title="颜色函数"></a>颜色函数</h3><p>调整色相时，SCSS 使用<code>adjust_hue()</code>，LESS 使用<code>spin()</code></p><h2 id="一些常见的疑问"><a href="#一些常见的疑问" class="headerlink" title="一些常见的疑问"></a>一些常见的疑问</h2><p>Sass 与 Scss 是什么关系?</p><p>Sass的缩排语法并不直观，也不能将 CSS 代码加入到 Sass 里面，因此 Sass 语法进行了改良，Sass 3 就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;预处理器带来了什么&quot;&gt;&lt;a href=&quot;#预处理器带来了什么&quot; class=&quot;headerlink&quot; title=&quot;预处理器带来了什么&quot;&gt;&lt;/a&gt;预处理器带来了什么&lt;/h2&gt;&lt;p&gt;CSS (Cascading Style Sheets，层叠样式表)，是一种用来为结</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>网络相关常见知识点汇总</title>
    <link href="http://example.com/2022/02/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2022/02/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</id>
    <published>2022-02-19T08:11:41.000Z</published>
    <updated>2022-02-25T06:55:39.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://www.png8.com/imgs/2022/02/7f0a206c63646d10.png" alt="网络相关常见知识点汇总.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6908327746473033741">「2021」高频前端面试题汇总之计算机网络篇</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="思维导图" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
