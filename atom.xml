<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可乐加冰</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-06T01:29:52.988Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HJY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 如何实现单例模式</title>
    <link href="http://example.com/2022/01/05/JavaScript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/05/JavaScript%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-05T14:56:59.000Z</published>
    <updated>2022-01-06T01:29:52.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式，也叫单子模式，是一种常用的软件设计模式，属于<code>创建型模式</code>的一种。</p><p>保证一个类<code>仅有一个实例</code>，并提供一个访问它的<code>全局访问点</code>。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>全局变量符合单例模式吗？</strong></p><p>不是。但我们经常会把变量当成单例来使用，看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>通过字面量创建对象时，对象<code>person</code>确实是独一无二的，如果该变量在全局作用域下声明，就可以在代码中的任何地方使用它。</p><p>但是全局变量存在一些问题：</p><ul><li>污染命名空间（变量名冲突）</li><li>不易维护 (被覆盖)</li></ul><p>并且随着项目的体积和功能增大，出现问题的概率也会增大。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先我们要清楚 JS 是一门<code>没有类</code>的语言，ES6 出现类也是原型的语法糖。也正因为没有类，在 JS 中实现单例模式也只需要一个<code>唯一</code>的对象，这是很自然的做法。</p><p>这里以一个登录弹窗为例，实践一下单例模式。</p><p>假设现在有一个登录按钮，点击后能够出现登录弹窗：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;loginBtn&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先来写创建登录弹窗的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doCreateLoginModal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> modal = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  modal.style.display = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  modal.textContent = <span class="string">&quot;登录弹窗&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(modal);</span><br><span class="line">  <span class="keyword">return</span> modal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来就是单例模式的重点了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getInstance = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createLoginModal = getInstance(doCreateLoginModal);</span><br></pre></td></tr></table></figure><p>这里可以发现返回的结果被封装在闭包（内部的函数被保存到了外部）产生的作用域中，外部是访问不到这两个变量的，这就避免了对全局的命名污染。</p><p>先看这段代码中产生的闭包：</p><p>最后一行外部的<code>createLoginModal</code>变量保存了<code>getInstance</code>中的匿名函数，该拥有<code>getInstance</code>作用域的访问权限。</p><p>再仔细看<code>return result || (result = fn.apply(this, arguments));</code>这条语句：</p><p>第一次调用方法时，<code>result</code>为<code>undefined</code>,会执行<code>result = fn.apply(this, arguments)</code>,这里利用传入的<code>fn</code>调用生成登录弹窗的方法生成登录弹窗，并被赋值给<code>result</code>，使得之后<code>createLoginModal</code>再被调用时，返回第一次创建的登录弹窗。</p><p>最后给按钮绑定点击事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loginBtn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;loginBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line">loginBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> loginModal = createLoginModal();</span><br><span class="line">  loginModal.style.display = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/HJY-xh/plantTrees/blob/master/Demos/%5BJavaScript%5D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%BC%B9%E7%AA%97/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html">完整代码</a></p><h2 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h2><p>惰性单例指的是在需要的时候菜创建对象实例。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式-维基百科</a></p><p>书目</p><ul><li><p>JavaScript 设计模式与开发实践</p></li><li><p>JavaScript 设计模式</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React Hook解析</title>
    <link href="http://example.com/2021/12/28/React%20Hook%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/12/28/React%20Hook%E8%A7%A3%E6%9E%90/</id>
    <published>2021-12-28T12:23:54.000Z</published>
    <updated>2022-01-25T08:34:05.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><p>带着以下问题学习：</p><ul><li>Hook解决了什么问题？</li><li>Hook有哪些优势？</li><li>为什么有Hook？</li><li>useState方括号有什么用？</li><li>为什么每次更新的时候都要运行 Effect?</li><li>useMemo 和 shouldComponentUpdate 有什么区别？</li></ul><h2 id="Hook概述"><a href="#Hook概述" class="headerlink" title="Hook概述"></a>Hook概述</h2><ul><li><p>React 16.8的新增特性</p></li><li><p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性（是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数）</p></li></ul><h2 id="Hook的动机"><a href="#Hook的动机" class="headerlink" title="Hook的动机"></a>Hook的动机</h2><ul><li>在无需修改组件结构的情况下复用状态逻辑</li></ul><p>在组件之间复用状态逻辑很难</p><p>Hook出现之前，将可复用性行为”附加“到组件的解决方案有<code>render props</code>和<code>高阶组件</code>，但是这类方案需要重新组织组件结构，可能会很麻烦，进而让代码难以理解。</p><ul><li>Hook将组件中相互关联的部分拆分成更小的函数（比如监听事件、请求数据），而并非强制按照生命周期划分</li></ul><p>组件期初很简单，但是逐渐会被状态逻辑和副作用充斥，相关关联且需要对照修改的代码被拆分（监听事件），不相关的代码在同一个方法中（<code>componentDidMount</code>、<code>componentWillUnmount</code>)组合在一起，容易产生bug。</p><ul><li>降低学习门槛</li></ul><p>对class的学习（需要理解JS中的this工作方式）</p><h2 id="Hook使用规则"><a href="#Hook使用规则" class="headerlink" title="Hook使用规则"></a>Hook使用规则</h2><ul><li><p>只能在函数最外层调用Hook。不要在循环、条件判断或者子函数中调用</p><p>  这样能够确保Hook在每一次渲染中都按照同样的顺序被调用</p></li><li><p>只能在React的函数组件中调用Hook（包括自定义的Hook）</p></li></ul><h2 id="常见的Hook"><a href="#常见的Hook" class="headerlink" title="常见的Hook"></a>常见的Hook</h2><ul><li><p>基础 Hook</p><ul><li>useState</li><li>useEffect<ul><li>说明<pre><code>  - 可以把该Hook看做是`componentDidMount`、`componentDidUpdate`、`componentWillUnmout`三个函数的组合  - React保证了每次运行effect的同时，DOM都已经更新完毕  - 与`componentDidMount`或`componentDidUpdate`不同，使用useEffect调度的effect不会阻塞浏览器更新屏幕，这让应用看起来响应更快  - effect中可选的清除机制在组件卸载的时候触发</code></pre></li><li>使用技巧<pre><code>  - 使用多个 Effect 实现关注点分离（按照代码的用途分离它们），React将按照effect声明的顺序一次调用组建的每一个effect  - 跳过 Effect 进行性能优化（第二个参数）</code></pre></li></ul></li><li>useContext<pre><code>接收一个 context 对象（`React.createContext` 的返回值）并返回该 context 的当前值</code></pre></li></ul></li><li><p>额外的 Hook</p><ul><li>useReducer<br>useState 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</li><li>useCallback<br>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</li><li>useMemo<br>可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证<br>可以使用它缓存一些相对耗时的计算，也非常适合用于存储引用类型的数据，可以传入对象字面量，匿名函数等，甚至是 React Element</li><li>useRef<br>useRef 返回一个可变的 ref 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）</li><li>useImperativeHandle<ul><li>useImperativeHandle 可以在使用 ref 时自定义暴露给父组件的实例值</li><li>在大多数情况下，应当避免使用 ref 这样的命令式代码</li><li>useImperativeHandle 应当与 <code>forwardRef</code> 一起使用</li></ul></li><li>useLayoutEffect<br>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染</li><li>useDebugValue<br>useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签,它接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值</li></ul></li></ul><h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中</p><p>字应该始终以 use 开头，这样可以一眼看出其符合 Hook 的规则</p><p>自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p>函数组件执行函数<code>renderWithHooks</code></p><ul><li>作用<br>它是调用<code>function组件</code>函数的主要函数，从源码中看，它首先会置空即将调和渲染的<code>workInProgress树</code>的<code>memoizedState</code>和<code>updateQueue</code>，把新的hooks信息挂载到这两个属性上，然后在组件<code>commit阶段</code>，将<code>workInProgress树</code>替换成<code>current树</code>，替换真实的DOM元素节点。并在current树保存hooks信息。</li><li>步骤<ul><li>执行函数组件</li><li>改变<code>ReactCurrentDispatcher</code>对象</li></ul></li></ul></li><li><p>初始化hooks</p><p>  相关hook实际执行的函数:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useState: mountState, <span class="comment">// 初始化useState</span></span><br><span class="line"><span class="attr">useEffect</span>: mountEffect, <span class="comment">// 初始化useEffect</span></span><br><span class="line"><span class="attr">useLayoutEffect</span>: mountLayoutEffect, <span class="comment">// 初始化useLayoutEffect</span></span><br><span class="line"><span class="attr">useMemo</span>: mountMemo, <span class="comment">// 初始化useMemo</span></span><br><span class="line"><span class="attr">useReducer</span>: mountReducer, <span class="comment">// 初始化useReducer</span></span><br><span class="line"><span class="attr">useRef</span>: mountRef, <span class="comment">// 初始化useRef</span></span><br><span class="line"><span class="attr">useCallback</span>: mountCallback, <span class="comment">// 初始化useCallback</span></span><br></pre></td></tr></table></figure><p>  <code>mountWorkInProgressHook</code>生成hook链表</p><ul><li>在一个函数组件第一次渲染时，每个hook执行，都会产生一个hook对象，并形成链表结构，绑定在<code>workInProgress</code>的<code>memoizedState</code>属性上</li><li>hook上的状态，绑定在当前hook对象的<code>memoizedState</code>属性上</li><li>对于effect副作用钩子，会绑定在<code>workInProgress.updateQueue</code>上，等到<code>commit阶段</code>，dom树构建完成，再执行每个 effect 副作用钩子。</li></ul></li><li><p>更新hooks</p><p>  相关hook实际执行的函数:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useState: updateState, <span class="comment">// 得到最新的state</span></span><br><span class="line"><span class="attr">useEffect</span>: updateEffect, <span class="comment">// 更新updateQueue</span></span><br><span class="line"><span class="attr">useLayoutEffect</span>: updateLayoutEffect,</span><br><span class="line"><span class="attr">useMemo</span>: updateMemo,</span><br><span class="line"><span class="attr">useReducer</span>: updateReducer,</span><br><span class="line"><span class="attr">useRef</span>: updateRef, <span class="comment">// 获取ref对象</span></span><br><span class="line"><span class="attr">useCallback</span>: updateCallback</span><br></pre></td></tr></table></figure><p>  <code>updateWorkInProgressHook</code>更新hook链表，找到对应的hooks</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">官方文档</a></p><p><a href="https://juejin.cn/post/6844904165500518414">React Hooks 最佳实践</a></p><p><a href="https://juejin.cn/post/6864438643727433741">react-hooks如何使用？</a></p><p><a href="https://juejin.cn/post/6944863057000529933#heading-0">一文吃透react-hooks原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题列表&quot;&gt;&lt;a href=&quot;#问题列表&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法</title>
    <link href="http://example.com/2021/12/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/12/19/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-19T02:41:09.000Z</published>
    <updated>2021-12-23T07:18:00.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="常见的排序"><a href="#常见的排序" class="headerlink" title="常见的排序"></a>常见的排序</h2><p><img src="https://s2.loli.net/2021/12/13/JeNhZmiWYlv85Ot.png"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>说明：重复遍历要排序的数列，一次比较两个元素，按排序顺序交换元素值，不断遍历直到没有再需要交换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [...input];</span><br><span class="line">    <span class="keyword">const</span> length = output.length;</span><br><span class="line">    <span class="keyword">let</span> hasSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output[j] &gt; output[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = output[j];</span><br><span class="line">                output[j] = output[j + <span class="number">1</span>];</span><br><span class="line">                output[j + <span class="number">1</span>] = temp;</span><br><span class="line">                hasSwap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasSwap) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>说明：遍历数组，找到数据应该插入的位置将其插入即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [...input];</span><br><span class="line">    <span class="keyword">const</span> length = output.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> temp = output[i];</span><br><span class="line">        <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; output[j] &gt; temp) &#123;</span><br><span class="line">            output[j + <span class="number">1</span>] = output[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        output[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>说明: 每一次从待排序的数据元素中选出最小（或最大）的一个元素，放到已排序数组的末尾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [...input];</span><br><span class="line">    <span class="keyword">const</span> length = output.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output[j] &lt; output[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = output[i];</span><br><span class="line">        output[i] = input[minIndex];</span><br><span class="line">        output[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>说明：归并的的核心思想是分治。它把数组从中间划分成两个数组，一直递归把子数组划分成更小的数组，知道数组中元素个数为1时进行排序。按大小顺序合并两个数组，接着按照递归的顺序返回，不断合并排好序的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> length = input.length;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> left = input.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">const</span> right = input.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>说明：它是冒泡排序的一种改进，通过元素之间的比较和交换位置来达到排序的目的。快排在每一轮挑选一个基准元素，把剩下的元素同它进行比较，大于它的放到数列的一边，小于它的放到数列的另一边，一轮比较完成后，整个序列以选取的基准元素位为界，左侧均小于基准元素，右侧均大于基准元素。但左右两侧内部并不是有序的(左右两侧关键字个数也不一定相同)。进而继续将左右两侧分别再以这种方式进行排序，直到将序列拆分的剩余一个关键字为止，整个序列即变成有序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> input; &#125;</span><br><span class="line">    <span class="keyword">const</span> left = [];</span><br><span class="line">    <span class="keyword">const</span> right = [];</span><br><span class="line">    <span class="keyword">const</span> middle = input.splice(<span class="built_in">Math</span>.round(input.length / <span class="number">2</span>), <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">        (middle &gt; input[i] ? left : right).push(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [...quickSort(left), middle, ...quickSort(right)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常见的排序&quot;&gt;&lt;a href=&quot;#常见的排序&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript思维导图</title>
    <link href="http://example.com/2021/12/09/TypeScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://example.com/2021/12/09/TypeScript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2021-12-09T13:34:11.000Z</published>
    <updated>2022-01-06T01:31:21.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://s2.loli.net/2021/12/10/GpcItLvliHzMWRA.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>深入理解 TypeScript</p><p><a href="https://www.typescriptlang.org/">https://www.typescriptlang.org/</a></p><p><a href="https://www.tslang.cn/index.html">https://www.tslang.cn/index.html</a></p><p><a href="https://stackoverflow.com/questions/28818849/how-do-the-different-enum-variants-work-in-typescript">https://stackoverflow.com/questions/28818849/how-do-the-different-enum-variants-work-in-typescript</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="思维导图" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>DOM基本操作思维导图</title>
    <link href="http://example.com/2021/11/16/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2021/11/16/DOM%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-11-16T13:01:11.000Z</published>
    <updated>2022-01-06T01:33:50.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><img src="https://i.loli.net/2021/11/25/pkRSm7J3saNxV2z.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/11/25/pkRS</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="思维导图" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>深入了解eval</title>
    <link href="http://example.com/2021/10/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3eval/"/>
    <id>http://example.com/2021/10/26/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3eval/</id>
    <published>2021-10-26T11:29:04.000Z</published>
    <updated>2022-01-11T07:50:24.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="相关定义和描述"><a href="#相关定义和描述" class="headerlink" title="相关定义和描述"></a>相关定义和描述</h2><p>eval 是全局对象上的一个函数，会把传入的字符串当做 JavaScript 代码执行，它通常被用来执行动态创建的代码。</p><p>语法很简单：</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">eval</span>(string) <span class="comment">// 一个表示 JavaScript 表达式、语句或一系列语句的字符串。表达式可以包含变量与已存在对象的属性。</span></span><br></pre></td></tr></table></figure></blockquote><p>举个🌰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&quot;console.log(&#x27;hello, eval&#x27;)&quot;</span>;</span><br><span class="line"><span class="built_in">window</span>.eval(string);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/25/3jKtcFlqQmuZE2G.png"></p><p>先提出问题：eval这个方法很强大，且兼容性很好，但是为什么很少使用？</p><p><img src="https://i.loli.net/2021/10/25/vr74wlehWzH6k8u.png"></p><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><h3 id="返回最后一个表达式的值"><a href="#返回最后一个表达式的值" class="headerlink" title="返回最后一个表达式的值"></a>返回最后一个表达式的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;1+1+1&#x27;</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 = <span class="string">&#x27;let x; x = 1;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">&#x27;let x, y; x = 1; y = 2;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">eval</span>(str);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(string1); <span class="comment">// 1</span></span><br><span class="line">test(string2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="函数作为字符串被定义时需要”-“和”-“作为前缀和后缀"><a href="#函数作为字符串被定义时需要”-“和”-“作为前缀和后缀" class="headerlink" title="函数作为字符串被定义时需要”(“和”)“作为前缀和后缀"></a>函数作为字符串被定义时需要”(“和”)“作为前缀和后缀</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcStr1 = <span class="string">&#x27;function test() &#123;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> funcStr2 = <span class="string">&#x27;(function test() &#123;&#125;)&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(funcStr1)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(funcStr2)); <span class="comment">// [Function: test]</span></span><br></pre></td></tr></table></figure><h3 id="直接调用和间接调用"><a href="#直接调用和间接调用" class="headerlink" title="直接调用和间接调用"></a>直接调用和间接调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>, y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;x + y&#x27;</span>));  <span class="comment">// 直接调用，使用本地作用域，结果是 4</span></span><br><span class="line">    <span class="keyword">const</span> geval = <span class="built_in">eval</span>; <span class="comment">// 等价于在全局作用域调用</span></span><br><span class="line">    <span class="built_in">console</span>.log(geval(<span class="string">&#x27;x + y&#x27;</span>)); <span class="comment">// 间接调用，使用全局作用域，结果是 2</span></span><br><span class="line">    <span class="built_in">console</span>.log((<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;this&#x27;</span>)); <span class="comment">// 另一个间接调用的例子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;this&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>逗号操作符：对它的每个操作数求值（从左到右），并返回最后一个操作数的值</p></blockquote><p>这里使用逗号操作符，于是返回表达式中的最后一项，然后为eval传入’this’字符串，来立即执行这个表达式，这里其实就是把全局对象给打印出来</p><h2 id="黑魔法"><a href="#黑魔法" class="headerlink" title="黑魔法"></a>黑魔法</h2><h3 id="欺骗词法作用域"><a href="#欺骗词法作用域" class="headerlink" title="欺骗词法作用域"></a>欺骗词法作用域</h3><p><strong>原理：JavaScript中的eval(str)函数可以接受一个字符串为参数，并将字符串内容视为好像在书写时就存在于eval()函数所在位置的代码。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(str); <span class="comment">// 欺骗</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&quot;var b = 3;&quot;</span>, <span class="number">1</span>); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure><p>这个例子中<code>var b = 3;</code>这条语句会被当做本来就在那里，因此foo函数内部的变量b遮蔽了外部的变量b</p><h4 id="严格模式下的表现"><a href="#严格模式下的表现" class="headerlink" title="严格模式下的表现"></a>严格模式下的表现</h4><p>在严格模式下，eval在运行时会有自己的词法作用域，意味着其中的声明无法修改所在的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span></span><br><span class="line">    <span class="built_in">eval</span>(str);</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">&quot;var a = 2;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="使用时有哪些坑"><a href="#使用时有哪些坑" class="headerlink" title="使用时有哪些坑"></a>使用时有哪些坑</h2><h3 id="eval不容易调试"><a href="#eval不容易调试" class="headerlink" title="eval不容易调试"></a>eval不容易调试</h3><p>调试困难，且可读性非常差（没有行号）</p><p>用chromeDev、VSCode等工具无法打断点调试</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>JavaScript 通常被认为是一门解释型的语言，但是现代的 JavaScript 引擎不再只是解释 JavaScript，也会对其进行编译。</p><p>V8 为了提高 JS的运行性能，在运行之前会先将JS编译为本地的机器码，然后再去执行机器码（JIT）。</p><blockquote><p>现代JavaScript解释器将javascript转换为机器代码。 这意味着任何变量命名的概念都会被删除。 因此，任意一个eval的使用都会强制浏览器进行冗长的变量名称查找，以确定变量在机器代码中的位置并设置其值。 另外，新内容将会通过 eval() 引进给变量， 比如更改该变量的类型，因此会强制浏览器重新执行所有已经生成的机器代码以进行补偿。</p></blockquote><p><strong>eval破坏了JS引擎优化</strong></p><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>当使用来源不可靠的第三方代码时，无法保证不碰到恶意代码</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">MDN</a></p><p><a href="https://github.com/mqyqingfeng/blog/issues/3">JavaScript深入之词法作用域和动态作用域</a></p><p><a href="http://nodejs.cn/learn/the-v8-javascript-engine">V8 JavaScript 引擎</a></p><p>《你不知道的JavaScript》 上卷</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;相关定义和描述&quot;&gt;&lt;a href=&quot;#相关定义和描述&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="网络攻击" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>Redux和Mobx的异同</title>
    <link href="http://example.com/2021/10/10/Redux%E5%92%8CMobx%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>http://example.com/2021/10/10/Redux%E5%92%8CMobx%E7%9A%84%E5%BC%82%E5%90%8C/</id>
    <published>2021-10-10T11:53:01.000Z</published>
    <updated>2022-02-16T10:07:31.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="二者主要概念"><a href="#二者主要概念" class="headerlink" title="二者主要概念"></a>二者主要概念</h2><p><a href="https://hjy-xh.github.io/2021/09/13/MobX%E8%AE%B0%E5%BD%95/">MobX</a></p><p><a href="https://hjy-xh.github.io/2020/12/03/Redux%E8%AE%B0%E5%BD%95/">Redux</a></p><h2 id="函数式编程相关知识"><a href="#函数式编程相关知识" class="headerlink" title="函数式编程相关知识"></a>函数式编程相关知识</h2><p><a href="https://hjy-xh.github.io/2020/11/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/">读书笔记:Javascript函数式编程指南（一）</a></p><p><a href="https://hjy-xh.github.io/2021/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/">读书笔记:Javascript函数式编程指南（二）</a></p><p><a href="https://hjy-xh.github.io/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/">读书笔记:Javascript函数式编程指南（三）</a></p><p><a href="https://hjy-xh.github.io/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/">读书笔记:Javascript函数式编程指南（四）</a></p><h2 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h2><ul><li><p>设计思想：函数式 VS 面向对象</p><p><code>Redux</code>遵循函数式编程思想，<code>MobX</code>则更多从面向对象和响应式编程的角度来考虑问题</p><p>可以从<code>Redux</code>的<code>reducer</code>中看出来，它就是一个纯函数，只依赖入参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(state, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MobX</code>将状态包装成可观察对象，一但状态对象变更，就重新渲染视图</p></li><li><p>对store管理：单一store VS 多个store</p><p><code>store</code>是应用管理数据的地方，在<code>Redux</code>中，应用的所有数据都集中在一个大的<code>store</code>中；<code>MobX</code>则通常是按照模块来将应用状态划分，在多个独立的<code>store</code>中管理</p></li><li><p>数据可变性：不可变 VS 可变</p><p><code>Redux</code>状态对象通常是不可变的，一般是在原来的状态对象基础上返回一个新的状态对象；<code>MobX</code>则可以直接使用新的值更新状态对象</p></li><li><p>整体差异</p><p><code>Redux</code>提供可以进行时间回溯的开发工具，同时因为它使用纯函数以及更少的抽象，让调试变得更加容易；<code>MobX</code>使用起来相对简单，但是其中有更多的抽象和封装，所以调试起来会更加复杂，同时结果也更难以预测</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://cn.redux.js.org/">Redux 中文官网</a></p><p><a href="https://www.redux.org.cn/">Redux 中文文档</a></p><p><a href="https://juejin.cn/post/6844903562095362056">你需要Mobx还是Redux？</a></p><p><a href="https://tech.youzan.com/mobx_vs_redux/">我为什么从Redux迁移到了Mobx</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二者主要概念&quot;&gt;&lt;a href=&quot;#二者主要概念&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>MobX记录</title>
    <link href="http://example.com/2021/09/23/MobX%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/09/23/MobX%E8%AE%B0%E5%BD%95/</id>
    <published>2021-09-23T14:56:31.000Z</published>
    <updated>2022-02-16T10:07:20.179Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>简单、可扩展的状态管理</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li><p>简单直接</p><ul><li>编写无模板的极简代码来精准描述意图</li></ul></li><li><p>轻松实现最优渲染</p><ul><li>所有对数据的变更和使用都会在运行时被追踪到，并构成一个截取所有状态和输出之间关系的依赖树。这样保证了那些依赖于状态的计算只有在真正需要的时候才会运行，就像React组件一样。无需使用记忆化或选择器之类容易出错的次优技巧来对组件进行手动优化。</li></ul></li><li><p>架构自由</p><ul><li>它可以让你在任意UI框架之外管理你的应用状态。这样会使你的代码低耦合、可移植和更加容易测试</li></ul></li></ul><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><ul><li>Mobx &gt;= 5 版本运行在任何<code>支持 ES6 proxy</code>的浏览器。</li><li>Mobx 4 可以运行在任何支持ES5的浏览器上，而且也讲进行持续地维护。MobX 4 和 5 的API是相同的，并且语义上也能达到相同的效果，只是Mobx 4 存在一些局限性<ul><li>Observable 数组不是真正的数组，所以它们无法通过<code>Array.isArray()</code> 的检查。最常见的处理方法是在传递给第三方库之前，你经常需要先对其进行<code>.slice()</code>操作，从而得到一个浅拷贝的真正数组</li><li>向一个已存在的 observable 对象中添加属性不会被自动捕获。要么使用 observable 映射来替代，要么使用工具函数中方法来对想要动态添加属性的对象进行读/写/迭代</li></ul></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>State(状态)</li></ul><p>状态是驱动应用的数据。</p><p>可以用任何数据结构来存储状态，如JS基本数据类型、引用类型、普通对象、类实例、数组和映射</p><p>通常有像待办事项列表数据这样的<code>领域特定状态</code>，还有像当前已选元素的<code>视图状态</code>（状态就像是有数据的excel表格）</p><ul><li>Action(动作)</li></ul><p>Action(动作)是任意可以改变State(状态)的代码,比如用户事件处理、后端推送数据处理、调度器事件处理等</p><p>使用Action可以更好地组织代码，并防止在无意中修改State</p><p>如果是在严格模式下使用 MobX的话，MobX 会强制只有在动作之中才可以修改状态</p><ul><li>Derivations(派生)</li></ul><p>任何来源是State并且不需要进一步交互的东西都是Derivation<br> 多种形式：</p><ul><li>用户界面</li><li>派生数据，比如剩下的待办事项的数量</li><li>后端集成，比如把变化发送到服务器端<br>两种类型：</li><li>Computed values（计算值） 它们是永远可以使用纯函数从当前可观察状态中衍生出的值</li><li>Reactions（反应）他们是当状态改变时需要自动发生的副作用 (命令式编程和响应式编程之间的桥梁，或者说得更明确一些，它们最终都需要实现I / O 操作)</li></ul><p>黄金法则：如果想创建一个基于当前状态的值时，使用<code>computed</code></p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>MobX使用单向数据流，利用Action改变State，进而更新所有受影响的View</p><p><img src="https://zh.mobx.js.org/assets/action-state-view.png"></p><ul><li>所有的Derivations将在State改变时自动且原子化的更新，引测不可能观察中间值</li><li>所有的Derivations默认将会同步更新，这意味着Action可以在State改变之后安全的直接获取computed值</li><li>Computed value的更新是惰性的，任何Computed value在需要它们的副作用发生之前都是不激活的</li><li>所有的Computed value都应该是纯函数，它们不应该修改State</li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>MobX使用<code>Object.defineProperty</code>来拦截对数据的访问，一旦值发生变化，就会调用<code>React</code>的<code>render</code>方法重新渲染视图或者触发<code>autorun</code></p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><ul><li><p>Autorun</p><ul><li>用法：autorun(effect: (reaction) =&gt; void)</li><li>说明：autorun 函数接受一个函数作为参数，每当该函数所观察的值发生变化时，它都应该运行。 当你自己创建 autorun 时，它也会运行一次</li></ul></li><li><p>Reaction</p><ul><li>用法：<ul><li>5：reaction(() =&gt; data, (data, reaction) =&gt; { sideEffect }, options?)</li><li>6：reaction(() =&gt; value, (value, previousValue, reaction) =&gt; { sideEffect }, options?)</li></ul></li><li>说明：<ul><li>reaction 类似于 autorun，但可以让你更加精细地控制要跟踪的可观察对象。 它接受两个函数作为参数：第一个，data 函数，其是被跟踪的函数并且其返回值将会作为第二个函数，effect 函数，的输入。 重要的是要注意，副作用只会对 data 函数中被访问过的数据做出反应，这些数据可能少于 effect 函数中实际使用的数据</li><li>一般的模式是在 data 函数中返回你在副作用中需要的所有数据， 并以这种方式更精确地控制副作用触发的时机。 与 autorun 不同，副作用在初始化时不会自动运行，而只会在 data 表达式首次返回新值之后运行</li></ul></li></ul></li><li><p>When</p><ul><li>用法：<ul><li>when(predicate: () =&gt; boolean, effect?: () =&gt; void, options?)</li><li>when(predicate: () =&gt; boolean, options?): Promise</li></ul></li><li>说明：when 会观察并运行给定的 predicate 函数，直到其返回 true。 一旦 predicate 返回了 true，给定的 effect 函数就会执行并且自动执行器函数将会被清理掉。</li></ul></li></ul><h2 id="集成React"><a href="#集成React" class="headerlink" title="集成React"></a>集成React</h2><p>MobX 可以独立于 React 运行, 但是他们通常是结合在一起使用</p><p>常用的两个包：</p><ul><li>mobx-react</li><li>mobx-react-lite</li></ul><p><code>mobx-react</code>中引用了<code>mobx-react-lite</code>包，它提供了很多在新项目中不再需要的特性，其中有：</p><ul><li>对于React class components的支持</li><li>Provider 和 inject ，MobX的这些东西在有React.createContext替代后变得不必要了</li><li>特殊的观察对象 propTypes</li></ul><p>要注意 mobx-react 是全量包，也会暴露 mobx-react-lite包中的任何方法,其中包含对函数组件的支持。 如果你使用 mobx-react，那就不要添加 mobx-react-lite 的依赖和引用了</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>区分<code>computed</code>和<code>auturun</code><br>如果想响应式的产生一个可以被其它observer使用的值，使用<code>@compouted</code>;如果想要达到一个效果，使用<code>autorun</code>（打印日志，发起网络请求等这样命令式的副作用）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.mobx.js.org/">MobX 中文文档</a></p><p><a href="https://mobx.js.org/README.html">MobX</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="MobX" scheme="http://example.com/tags/MobX/"/>
    
  </entry>
  
  <entry>
    <title>React中Fiber的简单实现</title>
    <link href="http://example.com/2021/09/11/React%E4%B8%ADFiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/09/11/React%E4%B8%ADFiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-11T15:14:54.000Z</published>
    <updated>2022-02-16T10:05:10.131Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><a href="https://github.com/HJY-xh/frame-course/blob/master/React/Fiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/Fiber%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.md">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HJY-xh/frame-cou</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化的前世今生</title>
    <link href="http://example.com/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://example.com/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2021-08-19T12:23:54.000Z</published>
    <updated>2022-01-06T01:28:03.543Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>近年来 Web 应用变得更加复杂与庞大，Web 前端技术的应用范围也更加广泛。通过直接编写 JavaScript、CSS、HTML 开发 Web 应用的方式已经无法应对当前 Web 应用的发展。</p><p>站在巨人的肩膀往回看，好在 JavaScript 模块化出现，解决了前端痛点，并且推动前端工程化。</p><h2 id="那什么是模块化呢？-为什么需要它呢？"><a href="#那什么是模块化呢？-为什么需要它呢？" class="headerlink" title="那什么是模块化呢？ 为什么需要它呢？"></a>那什么是模块化呢？ 为什么需要它呢？</h2><p>模块化可以理解成是将一个复杂的系统分解为多个模块以方便组织和编码。</p><p>很久以前，网页开发要通过命名空间的方式来组织代码。像 jQuery 就是将他的 API 都放在 <code>window.$</code> 下，在加载完 jQuery 后，其它模块再通过 <code>window.$</code> 去使用。</p><p>那这么做会有一些问题，其中包括：</p><ul><li>命名空间冲突</li><li>无法合理地管理项目地依赖和版本</li><li>无法方便地控制依赖的加载顺序</li></ul><p>可以预见，当项目越大，维护成本也越高，因此用模块化的思想来组织代码。</p><p>回顾前端模块化的前世今生，按时间先后可以总结为以下几个过程</p><ul><li>刀耕火种时代</li><li>CommonJS 模块规范及在 Node.js 里的实现</li><li>AMD 异步模块定义</li><li>ESM ECMAScript 模块系统</li></ul><h2 id="刀耕火种时代"><a href="#刀耕火种时代" class="headerlink" title="刀耕火种时代"></a>刀耕火种时代</h2><p>我们都知道 HTML 的 <code>&lt;script&gt;</code> 元素用于嵌入或引用可执行脚本。</p><p>在互联网早期，Web1.0 时代，页面比较简单，大多时候只是展示内容，使用内嵌的方式或者引用单个 JavaScript 文件就可以满足业务需求。</p><p>当功能变得复杂时，单个 JavaScript 文件代码量也变多，此时可以将 JavaScript 分为多个文件，但需要处理好各个 <code>&lt;script&gt;</code> 标签的书写顺序。</p><p>这个时期针对 JavaScript 源码的组织，谈不上模块化。即便采用了文件拼接（concat）这样的处理技术，其先后顺序也需要人工维护。</p><h2 id="CommonJS-模块规范及在-Node-js-里的实现"><a href="#CommonJS-模块规范及在-Node-js-里的实现" class="headerlink" title="CommonJS 模块规范及在 Node.js 里的实现"></a>CommonJS 模块规范及在 Node.js 里的实现</h2><p>这是一种被广泛使用的 JavaScript 模块化规范，其核心思想是通过<code>require</code>方法来<strong>同步加载</strong>依赖的其他模块，通过<code>module.export</code>导出需要暴露的接口。</p><p>它的流行得益于 Node.js 采用了这种方法。</p><p>它的优点在于：</p><ul><li>代码可复用于 Node.js 环境下并运行</li><li>有很多遵循此规范的 Npm 包</li></ul><p>它的缺点在于：</p><ul><li>代码无法直接运行在浏览器环境下，需要通过工具转换成标准的 ES5</li></ul><p>CommonJS 还可以细分为 CommonJS1 和 CommonJS2，区别在于 CommonJS1 只能通过<code>export.xx = xx</code>的方式导出，而 CommonJS2 在 CommonJS1 的基础上加入了<code>module.export = xx</code>的导出方式。CommonJS 通常指 CommonJS2。</p><p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><p>Node.js 在解析与执行每个模块之前，会先加上一层包装，类似于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模块代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以，模块作用域实际上是一个函数作用域；而 <code>__dirname</code>、<code>__filename</code>、<code>require</code>、<code>module</code> 等模块常量/变量都是外部传入的参数。</p><h2 id="AMD-异步模块定义"><a href="#AMD-异步模块定义" class="headerlink" title="AMD 异步模块定义"></a>AMD 异步模块定义</h2><p>AMD（Asynchronous Module Definition）即异步模块定义。AMD 规范中，各个依赖可以异步加载而不影响正常逻辑，非常适用于浏览器环境。AMD 规范的核心 API 只有一个简单的 <code>define()</code>函数。</p><p>AMD 模块系统的经典实现库是 require.js。</p><p>例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(id?: <span class="built_in">String</span>, dependencies?: <span class="built_in">String</span>[], <span class="attr">factory</span>: <span class="built_in">Function</span>|<span class="built_in">Object</span>);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><code>id</code> 是模块的名字，它是可选的参数。</p><p><code>dependencies</code> 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 <code>factory</code> 中。如果没有指定 <code>dependencies</code>，那么它的默认值是 <code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code>。</p><p><code>factory</code> 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p><p>AMD 规范平时用得很少，这里举一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;myModule&quot;</span>, [<span class="string">&quot;jquery&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $ 是 jquery 模块的输出</span></span><br><span class="line">  $(<span class="string">&quot;body&quot;</span>).text(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;myModule&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">myModule</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>这里我们再来看看它的优点：</p><ul><li>可在不转换代码的情况下直接在浏览器中运行</li><li>可异步加载依赖</li><li>可并行加载多个依赖</li><li>代码可运行在浏览器环境和 Node.js 环境下</li></ul><p>AMD 的缺点在于 JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。</p><h2 id="ESM-ECMAScript-模块系统"><a href="#ESM-ECMAScript-模块系统" class="headerlink" title="ESM ECMAScript 模块系统"></a>ESM ECMAScript 模块系统</h2><p>前面所提到的所有模块化解决方案，都是利用 JavaScript 语言本身的特性，实现的封装。而鉴于模块系统的重要性、必要性，TC39 委员会也对其标准化极为上心。2015 年推出的 ECMAScript 6 标准正式定义了 JavaScript 的模块系统。</p><p>需要记住的是：</p><ul><li>它在语言层面上实现了模块化。</li><li>浏览器厂商和 Node.js 都宣布要原生支持该规范。它将逐渐取代 CommonJS、AMD 规范，成为浏览器和服务器通用的模块解决方法</li></ul><p>它的工作原理是模块文件只加载、执行一次。</p><p>虽然 ES6 模块是终极模块化方案，但它目前无法直接运行在大部分 JavaScript 运行环境下，必须通过工具转换成标准的 ES5 后才能正常运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;近年来 Web 应用变得更加复杂与庞大，Web 前端技术的应用范围也更加广泛。通过直接编</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>webpack笔记</title>
    <link href="http://example.com/2021/08/05/webpack%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/05/webpack%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-05T13:09:33.000Z</published>
    <updated>2022-01-10T07:59:19.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h2><ul><li>webpack是用来解决什么问题的 ？</li><li>它有什么亮点 ？</li><li>loader 和 plugin 有什么区别 ？</li><li>运行原理 ？</li><li>如何编写 Loader?</li><li>Webpack 和 Rollup 有什么相同点与不同点？</li></ul><h2 id="webpack-作用"><a href="#webpack-作用" class="headerlink" title="webpack 作用"></a>webpack 作用</h2><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><p>根据官网的高度概述，我们可以简单理解<code>webpack</code>是一个针对<code>JavaScript</code>项目的打包工具。</p><p><img src="https://s2.loli.net/2022/01/06/M17foghaR2QwBbv.png"></p><p>简单浏览一遍官方文档，再看看上面这张图，就会发现<code>webpack</code>的关键点在于<code>模块处理</code>和<code>打包</code>,在webpack构建的流程中，通过<code>loader</code>处理非 JS 文件，将其转换为 webpack 能够处理的有效模块，使用各式各样的<code>plugin</code>在构建时的关键步骤进行一些操作（比如按需加载，代码压缩等），最终输出浏览器能使用的静态资源。</p><h3 id="这里思考一下为什么需要模块化呢？"><a href="#这里思考一下为什么需要模块化呢？" class="headerlink" title="这里思考一下为什么需要模块化呢？"></a>这里思考一下为什么需要模块化呢？</h3><p><a href="https://hjy-xh.github.io/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">答案</a></p><h3 id="那怎么理解模块化呢？"><a href="#那怎么理解模块化呢？" class="headerlink" title="那怎么理解模块化呢？"></a>那怎么理解模块化呢？</h3><p>在<code>webpack</code>中，核心思想就是一切皆模块，比如说一张图片，一个SCSS文件。</p><p>这样做的好处就是能够清晰地描述出各个模块之间依赖关系，便于<code>webpack</code>对模块进行组合、打包。</p><h2 id="为什么是-webpack"><a href="#为什么是-webpack" class="headerlink" title="为什么是 webpack"></a>为什么是 webpack</h2><p>这些年前框框架、工具非常多，那为什么<code>webpack</code>更受青睐呢？</p><h3 id="这里来分析一下其它的工具"><a href="#这里来分析一下其它的工具" class="headerlink" title="这里来分析一下其它的工具"></a>这里来分析一下其它的工具</h3><ul><li><p>基于任务执行的工具</p><p>  比如说：<a href="https://www.gulpjs.com.cn/">gulp</a>、<a href="https://www.gruntjs.net/">grunt</a></p><p>  <strong>这些工具能够自动执行指定的任务。</strong>它们简单高效，社区活跃，有着丰富的插件，可以方便打造各种工作流。</p></li><li><p>基于模块化打包的工具</p><p>  比如说：<a href="https://browserify.org/">browserify</a>、<a href="https://www.webpackjs.com/">webpack</a>、<a href="https://www.rollupjs.com/">rollup</a></p><p>  在 Node 环境下，如果需要引用组件，使用<code>require</code>关键字即可，这类工具就是这个模式，还可以实现按需加载、异步加载模块</p></li><li><p>整合型工具</p><p>  比如说：<a href="https://fis.baidu.com/">FIS3</a>、<a href="https://elemefe.github.io/cooking/">cooking</a></p><p>  这类工具使用了多种技术栈实现的脚手架工具，好处是即开即用，缺点就是它们约束了技术选型，并且学习成本相对较高。</p></li></ul><h3 id="为什么选用-webpack"><a href="#为什么选用-webpack" class="headerlink" title="为什么选用 webpack"></a>为什么选用 webpack</h3><ul><li>大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，<code>webpack</code>可以为这些新项目提供一站式的解决方案</li><li><code>webpack</code> 有良好的生态链和维护团队，能提供良好的开发体验和保证质量</li><li><code>webpack</code> 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>entry: 入口<br>  <code>webpack</code>执行构建的第一步就从入口开始，可以抽象理解为输入</li><li>module: 模块<br>  在<code>webpack</code>中一切皆模块，一个文件就是一个模块，<code>webpack</code>会从入口开始递归遍历找出所有依赖的模块</li><li>chunk: 代码块<br>  一个<code>Chunk</code>由多个模块组合而成，它是代码合并、分割的产物</li><li>loader: 模块转换器<br>  <code>webpack</code>使用它把原内容转换成浏览器能够使用的文件</li><li>plugin: 插件拓展<br>  <code>webpack</code>在构建流程中的特定时机注入扩展逻辑来改变构建结果</li><li>output: 输出结果<br>  <code>webpack</code>经过一系列处理后，输出的最终结果</li></ul><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p><code>webpack</code> 只能理解<code>JavaScript</code>和<code>JSON</code>文件，这是<code>webpack</code>开箱可用的自带能力。</p><p><code>loader</code>让<code>webpack</code>能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>处理文件时可以使用多个<code>loader</code>,<code>loader</code>的执行顺序和配置中的顺序是相反的。也就是说最后一个<code>loader</code>先执行，它接收源文件作为参数，处理之后把处理结果传给下一个<code>loader</code></p><h3 id="常用的-loader"><a href="#常用的-loader" class="headerlink" title="常用的 loader"></a>常用的 loader</h3><ul><li>css-loader<br>  加载<code>CSS</code>、支持模块化、压缩、文件导入等特性</li><li>style-loader<br>  把<code>CSS</code>代码注入到<code>JavaScript</code>中，通过<code>DOM</code>操作去加载<code>CSS</code></li><li>file-loader<br>  把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件</li><li>url-loader<br>  它和 filr-loader 类似，但是能在文件很小的情况下以<code>base64</code>的方式把文件内容注入到代码中</li><li>babel-loader<br>  让开发者能够在项目中使用新的<code>JavaScript</code>特性</li></ul><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>插件是<code>webpack</code>的<strong>支柱</strong>功能。</p><p>插件目的在于解决<code>loader</code>无法实现的其他事。</p><p><code>webpack</code>自身也是构建于插件系统之上。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在<code>webpack</code>运行的生命周期中会广播出许多事件，插件可以监听这些事件，在合适的时机通过<code>webpack</code>提供的API改变输出结果，在这个过程中插件可以访问到<code>compile</code>和<code>compilation</code>，通过钩子拦截<code>webpack</code>的执行。</p><h3 id="常用的-plugin"><a href="#常用的-plugin" class="headerlink" title="常用的 plugin"></a>常用的 plugin</h3><ul><li>clean-webpack-plugin<br>  每次打包后自动清理<code>output.path</code>内的文件，只保留本次构建的结果</li><li>html-webpack-plugin<br>  创建一个<code>html</code>文件，并把<code>webpack</code>打包后的静态文件自动插入到这个<code>html</code>文件当中</li><li>DefinePlugin<br>  这是一个定义全局变量的插件,定义的变量可以在<code>webpack</code>打包范围内任意<code>JavaScript</code>环境内访问</li><li>MiniCssExtractPlugin<br>  将<code>CSS</code>单独打包成一个文件，它为每个包含<code>CSS</code>和<code>JavaScript</code>文件都创建一个<code>CSS</code>文件，结合<code>html-webpack-plugin</code>插件，以<code>link</code>的形式插入到<code>html</code>文档中</li><li>babel-loader<br>  让开发者能够在项目中使用新的<code>JavaScript</code>特性</li><li>webpack-merge<br>  该插件用于合并配置</li><li>webpack-bundle-analyzer<br>  项目打包后进行性能分析</li></ul><h2 id="构建流程和原理"><a href="#构建流程和原理" class="headerlink" title="构建流程和原理"></a>构建流程和原理</h2><p>构建之前先了解几个名词：</p><ul><li>Compiler：编译管理器，<code>webpack</code>启动后会创建<code>compiler</code>对象，该对象一直存活直到结束退出</li><li>Complilation：单次编译过程的管理器，比如<code>watch=true</code>时，运行过程中只有一个<code>compiler</code>，但每次文件变更触发重新编译时，都会创建一个新的<code>compilation</code>对象</li><li>Dependence：依赖对象，<code>webpack</code>基于该类型记录模块间依赖关系</li><li>Module：<code>webpack</code>内部所有资源都会以<code>module</code>对象形式存在，所有关于资源的操作、转译、合并都是以<code>module</code>为基本单位进行的</li><li>Chunk：编译完成准备输出时，<code>webpack</code>会将<code>module</code>按特定的规则组织成一个一个的<code>chunk</code>，这些<code>chunk</code>某种程度上跟最终输出一一对应</li></ul><p>构建流程：</p><ul><li><p>初始化阶段</p><ul><li>初始化参数：从配置文件、配置对象、Shell参数中读取，进行错误检查，与默认配置结合得出最终的参数</li><li>创建编译器对象：用上一步得到的参数创建<code>Compiler</code>对象</li><li>初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化RuleSet集合、加载配置的插件等</li><li>开始编译：执行<code>compiler</code>对象的<code>run</code>方法</li><li>确定入口：根据配置中的<code>entry</code>找出所有的入口文件，调用<code>compilition.addEntry</code>将入口文件转换为<code>dependence</code>对象</li></ul></li><li><p>构建阶段</p><ul><li>编译模块：根据<code>entry</code>对应的<code>dependence</code>创建<code>module</code>对象，调用<code>loader</code>将模块转移为标准JS内容，调用JS解释器将内容转换为AST对象，从中找出该模块依赖的模块，再递归这个步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>完成模块编译：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的<code>依赖关系图</code></li></ul></li><li><p>生成阶段</p><ul><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的<code>Chunk</code>，再把每个<code>Chunk</code>转换成一个单独的文件加入到输出列表。这个步骤是可以修改输出内容的最后机会</li><li>写入文件系统：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul></li></ul><p>源码中的一些重要方法：</p><ul><li><strong>webpack_require</strong>: 我们在模块化开发的时候，通常会使用ES Module或者CommonJS规范导入导出以来的模块，webpack在打包的时候，会统一替换成自己的__webpack_require__来实现模块的引入和导出，从而实现模块缓存机制，以及抹平不同模块规范之间的一些差异性</li><li>__webpack_modules__：存放了编译后的各个文件模块的JS内容</li><li>__webpack_module_cache__：用来做模块缓存</li></ul><h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><p><code>webpack</code>配置虽然简单，但是配置项非常多，每个配置项的取值可能也有很多的选择，故而优化的空间很大。</p><p>讲一些平常用的多的配置优化：</p><ul><li><p>使用<code>webpack-bundle-analyzer</code>插件</p><p>  可以看到项目各模块大小，进行按需优化</p><p>  stat表示文件的输入大小，parsed表示文件的输出大小，gzip表示通过gzip压缩运行解析的包/模块大小</p></li><li><p>使用<code>tree shaking</code>擦除无用代码</p><p>  移除<code>JavaScript</code>上下文中的未引用代码</p></li><li><p>开启<code>scope hosting</code>减少函数申明和内存开销</p><p>  这个名词直译过来就是作用域提升，它把所有的代码按照引用顺序放在一个函数作用域里面，适当的重命名变量防止冲突</p></li><li><p>使用<code>splitChunksPlugin</code>分离页面公共文件，抽取公共代码</p></li><li><p>使用多进程多实例解析资源</p></li><li><p>使用<code>DLLPlugin</code>对基础依赖库进行分包，减少编译次数</p><p>  DllPlugin动态链接库插件，其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。dll中大多包含的是常用的第三方模块，如react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。</p></li></ul><p>总结来看，可以使用大量插件对编译过程进行优化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.webpackjs.com/concepts/">官网</a></p><p><a href="https://juejin.cn/post/6943468761575849992">当面试官问Webpack的时候他想知道什么</a></p><p><a href="https://juejin.cn/post/6949040393165996040">一文吃透 Webpack 核心原理</a></p><p><a href="https://tsejx.github.io/webpack-guidebook/basic/build-tool/">构建工具</a></p><p>书目：</p><ul><li>深入浅出 Webpack</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题列表&quot;&gt;&lt;a href=&quot;#问题列表&quot; class=&quot;headerlink&quot; title=&quot;问题列表&quot;&gt;&lt;/a&gt;问题列表&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;webpack是用来解决什么问题的 ？&lt;/li&gt;
&lt;li&gt;它有什么亮点 ？&lt;/li&gt;
&lt;li&gt;loader 和 </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="webpack" scheme="http://example.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>React中render的实现</title>
    <link href="http://example.com/2021/07/19/React%E4%B8%ADrender%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/07/19/React%E4%B8%ADrender%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-19T14:03:04.000Z</published>
    <updated>2022-01-25T08:34:08.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><a href="https://github.com/HJY-xh/frame-course/blob/master/React/render%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/render%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.md">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/HJY-xh/frame-cou</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的作用域</title>
    <link href="http://example.com/2021/06/11/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/06/11/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-06-11T11:16:33.000Z</published>
    <updated>2022-01-06T01:30:53.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="作用域的定义"><a href="#作用域的定义" class="headerlink" title="作用域的定义"></a>作用域的定义</h2><blockquote><p>当前的执行上下文。值和表达式在其中 “可见” 或可被访问到的上下文。如果一个变量或者其他表达式不 “在当前的作用域中”，那么它就是不可用的。作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。</p></blockquote><p>从上面的定义出发，可以简单概括为：作用域决定了变量与函数的可访问范围，即<code>作用域控制着变量与函数的可见性和生命周期</code>。</p><h2 id="作用域分类"><a href="#作用域分类" class="headerlink" title="作用域分类"></a>作用域分类</h2><p>作用域分为两种</p><ul><li>全局作用域</li><li>函数作用域</li></ul><h3 id="全局作用域特性"><a href="#全局作用域特性" class="headerlink" title="全局作用域特性"></a>全局作用域特性</h3><ul><li>全局作用域在当 JavaScript 开始要解释执行代码的时候被创建，整个程序结束的时候被销毁</li><li>全局对象在不同的宿主环境下是不同的，在浏览器环境下，全局对象即为<code>window</code>，代表一个浏览器窗口，由浏览器创建，可以直接调用</li><li>全局作用域中声明的变量和函数会作为<code>window</code>对象的属性和方法保存，作用域为全局，在任何地方都能访问到</li></ul><h3 id="局部作用域特性"><a href="#局部作用域特性" class="headerlink" title="局部作用域特性"></a>局部作用域特性</h3><ul><li>调用函数时，函数作用域被创建，函数执行完毕，其作用域被销毁</li><li>每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的</li><li>在函数作用域中可以访问到全局作用域的变量，在函数外无法直接访问到函数作用域内的变量</li><li>在函数作用域中访问变量，会现在自身作用域中查找，如果没有找到，则回到函数的上一级作用域中查找，一直到全局作用域</li></ul><h2 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h2><p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>总结：Javascript 引擎会沿着作用域链(Scope Chain) 寻找需要的变量。</p><h2 id="作用域的深层次理解"><a href="#作用域的深层次理解" class="headerlink" title="作用域的深层次理解"></a>作用域的深层次理解</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p><ul><li>在执行函数前，会创建一个执行上下文的内部对象 AO（作用域）</li><li>这个内部对象时预编译时被创建出来的，在函数被调用时，会先进行预编译</li><li>在全局代码执行前会创建一个执行上下文的对象 GO</li></ul><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><h3 id="函数作用域预编译"><a href="#函数作用域预编译" class="headerlink" title="函数作用域预编译"></a>函数作用域预编译</h3><ul><li>创建 AO 对象</li><li>找形参和变量声明，将函数内的变量和形参名作为 AO 对象的属性名，值为 undefined</li><li>将实参和形参相统一</li><li>在函数体中找函数声明，值赋予函数体</li></ul><h3 id="全局作用域预编译"><a href="#全局作用域预编译" class="headerlink" title="全局作用域预编译"></a>全局作用域预编译</h3><ul><li>创建 GO 对象</li><li>找变量声明，将变量名作为 GO 对象的属性名，值为 undefined</li><li>找函数声明，值值赋予函数体</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Scope">Scope（作用域）</a></p><p><a href="https://medium.com/itsems-frontend/javascript-scope-and-scope-chain-ca17a1068c96">Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：往外找</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/3">JavaScript 深入之词法作用域和动态作用域</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/4">JavaScript 深入之执行上下文栈</a></p><p><a href="https://github.com/mqyqingfeng/Blog/issues/6">JavaScript 深入之作用域链</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;作用域的定义&quot;&gt;&lt;a href=&quot;#作用域的定义&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（四）</title>
    <link href="http://example.com/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://example.com/2021/04/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2021-04-16T02:13:29.000Z</published>
    <updated>2022-01-11T07:51:22.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h1 id="四-函数式编程——针对复杂应用的设计模式"><a href="#四-函数式编程——针对复杂应用的设计模式" class="headerlink" title="四.函数式编程——针对复杂应用的设计模式"></a>四.函数式编程——针对复杂应用的设计模式</h1><p>（读书笔记：JavaScript函数式编程指南）</p><p>今日分享</p><ul><li>命令式错误处理异常方式的问题</li><li>使用容器，以防访问无效数据</li><li>用 Functor 的实现来做数据转换</li></ul><blockquote><p>空引用是一个价值数十亿美元的错误。<br>——Tony Hoare，InfoQ</p></blockquote><h2 id="命令式错误处理的不足"><a href="#命令式错误处理的不足" class="headerlink" title="命令式错误处理的不足"></a>命令式错误处理的不足</h2><p>在许多情况下都会发生 JavaScript 错误，特别是在与服务器通信时，或是在试图访问一个为 null 对象的属性时。</p><p>因此，开发者在编程时总是需要做好最坏的打算。在命令式编程世界中，异常是通过 try-catch 处理的。</p><h3 id="用-try-catch-处理错误"><a href="#用-try-catch-处理错误" class="headerlink" title="用 try-catch 处理错误"></a>用 try-catch 处理错误</h3><p>JavaScript 的异常处理机制通常会以大多数现代语言都有的 try-catch 语句来完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ERROR&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以该语句包裹住你认为不太安全的代码，一旦有异常发生，JavaScript 会立即终止程序，并创建导致该问题的指令的函数调用堆栈跟踪。有关错误的具体细节，如消息、行号和文件名，被填充到 Error 类型的对象中，并传递到 catch 块中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> student = findStudentById(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ERROR&quot;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 try-catch 后的代码将不能组合或连在一起，对于函数式编程来说，这将会严重影响代码设计。</p><h3 id="函数式程序不应抛出异常"><a href="#函数式程序不应抛出异常" class="headerlink" title="函数式程序不应抛出异常"></a>函数式程序不应抛出异常</h3><p>命令式的 JavaScript 代码结构有很多缺陷，而且也会与函数式的设计有兼容性问题。会抛出异常的函数存在以下问题：</p><ul><li>难以与其他函数组合或链接</li><li>违反了引用透明性，因为抛出异常会导致函数调用出现另一出口，所以不能确保单一的可预测的返回值</li><li>会引起副作用，因为异常会在函数调用之外对堆栈引发不可预料的影响</li><li>违反非局域性的原则，因为用于恢复异常的代码与原始的函数调用渐行渐远。当发生错误时，函数离开局部栈与环境</li><li>不能只关注函数的返回值，调用者需要负责声明 catch 块中的异常匹配类型来管理特定的异常</li><li>当有多个异常条件时会出现嵌套的异常处理块</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;inner&quot;</span>, ex.message);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;outer&quot;</span>, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;inner&quot; &quot;oops&quot;</span></span><br><span class="line"><span class="comment">// &quot;finally&quot;</span></span><br><span class="line"><span class="comment">// &quot;outer&quot; &quot;oops&quot;</span></span><br></pre></td></tr></table></figure><p>那函数式编程真的不需要抛出异常吗？</p><p>该作者不这么认为。在实践中，很多因素是在控制范围之外的，而且依赖库也有抛出异常的可能。对于某些边缘情况，使用异常可能颇有效率。异常应该由一个地方抛出，而不应该随处可见。</p><h3 id="空值（null）检查问题"><a href="#空值（null）检查问题" class="headerlink" title="空值（null）检查问题"></a>空值（null）检查问题</h3><p>另一种跟抛出异常一样烦人的错误是 null 返回值。虽然 null 返回值保证了函数的出口只有一个，但是也并没有好到哪去——给使用函数的用户带来需要 null 检查的负担。比如获取学生地址与国家的 getCountry 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserCountry</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> school = student.getSchool();</span><br><span class="line">  <span class="keyword">if</span> (school !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> addr = school.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (addr !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> country = addr.getCountry();</span><br><span class="line">      <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Error extracting country info&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数很容易实现，但是需要大量的判空检查。不管是使用 try-catch 还是 null 检查，都是被动的解决方式。</p><h2 id="一种更好的解决方案——Functor"><a href="#一种更好的解决方案——Functor" class="headerlink" title="一种更好的解决方案——Functor"></a>一种更好的解决方案——Functor</h2><p>函数式以一种完全不同的方法应对软件系统的错误处理。其思想说起来也非常简单，就是创建一个安全的容器，来存放危险代码,比方说 try-catch 就可以看作存放着会抛出异常的函数的保险箱。而保险箱可以看作一种容器。</p><p>在函数式编程中，仍然会包裹这些危险代码，但可以不用 try-catch 块。使用函数式数据类型是解决不纯性的主要手段。不过，首先从最简单的类型开始。</p><h3 id="包裹不安全的值"><a href="#包裹不安全的值" class="headerlink" title="包裹不安全的值"></a>包裹不安全的值</h3><p>将值包裹起来是函数式编程的一个基本设计模式，因为它直接地保证了值不会被任意篡改。这有点像把值保护起来，只能通过 map 操作来访问该容器中的值。实际上数组的 map，而数组也是值的容器。我们将继续扩展更广义的 map 的概念。</p><p>其实，可以映射函数到更多类型，而不仅仅是数组。在函数式 JavaScript 中，map 只不过是一个函数，由于引用透明性，只要输入相同，map 永远会返回相同的结果。当然，还可以认为 map 是可以使用 lambda 表达式变换容器内的值的途径。比如，对于数组，就可以通过 map 转换值，返回包含新值的新数组。</p><p>下面用 Wrapper 解释一下这个概念</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123; <span class="comment">// 存储任意类型值的简单类型</span></span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map ::  A -&gt; B</span></span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123; <span class="comment">// 用一个函数来 map 该类型（就像数组一样）</span></span><br><span class="line">    <span class="keyword">return</span> f(<span class="built_in">this</span>.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Wrapper (&#x27;</span> + <span class="built_in">this</span>.value + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wrap :: A -&gt; Wrapper(A)</span></span><br><span class="line"><span class="keyword">const</span> wrap = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="keyword">new</span> Wrapper(val); <span class="comment">// 能够根据值快速创建 Wrapper 的帮助函数</span></span><br></pre></td></tr></table></figure><p>要访问包裹内的对象，唯一办法是 map 一个 Ramda 的 identity 函数（注意，Wrapper 类型并没有 get 方法）。虽然 JavaScript 允许用户方便地访问这个值，但重要的是，一旦该值进入容器，就不应该能被直接获取或转化（就像一个虚拟的屏障），如图1 所示：</p><p><img src="https://i.loli.net/2021/08/08/1FiDH4MEVbfOJS9.png"></p><p>Wrapper 类型使用 map 安全地访问和操作值。在这种情况下，通过映射 identity 函数就能在容器中提取值。</p><p>下面是获取值的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedValue = wrap(<span class="string">&#x27;Get Functional&#x27;</span>);</span><br><span class="line">wrappedValue.map(R.identity); <span class="comment">// &#x27;Get Functional&#x27; &lt;--- 值的提取</span></span><br></pre></td></tr></table></figure><p>其实还可以映射任何函数到该容器，比如变换该值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrappedValue.map(R.toUpper); <span class="comment">// &#x27;GET FUNCTIONAL&#x27; &lt;--- 对内部值应用函数</span></span><br></pre></td></tr></table></figure><p>如此一来，所有对值的操作都必须借助 Wrapper.map “伸入”容器，从而使值得到一定的保护。但是 null 或者 undefined 的情况仍然存在，还是需要在映射的函数中去处理。接下来看看解决的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedNull = wrap(<span class="literal">null</span>);</span><br><span class="line">wrappedNull.map(doWork); <span class="comment">// doWork 被赋予了空值检查的责任</span></span><br></pre></td></tr></table></figure><p>就像这个例子，由于直接调用函数，完全可以交给 Wrapper 类型来做错误处理。换句话说，可以在调用函数之前，检查 null、空字符串或者负数，等等。因此，Wrapper.map 的语义就由具体的 Wrapper 类型来确定。</p><p>继续来看看 map 的变种——fmap：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmap :: (A -&gt; B) -&gt; Wrapper[A] -&gt; Wrapper[B]</span></span><br><span class="line">Wrapper.prototype.fmap = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(f(<span class="built_in">this</span>.valve)); <span class="comment">// &lt;--- 先将返回值包裹到容器中，再返回给调用者</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>fmap 知道如何在上下文中应用函数值。它会先打开该容器，应用函数到值，最后把返回的值包裹到一个新的同类型容器中。拥有这种函数的类型称为 Functor。</strong></p><h3 id="Functor-定义"><a href="#Functor-定义" class="headerlink" title="Functor 定义"></a>Functor 定义</h3><p>从本质上讲，Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。<br>下面是 fmap 的一般定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmap :: (A -&gt; B) -&gt; Wrapper(A) -&gt; Wrapper(B) <span class="comment">// &lt;--- Wrapper 可以是任何容器类型</span></span><br></pre></td></tr></table></figure><p>fmap 函数接受一个从 A-&gt;B 的函数，以及一个 Wrapper(A) Functor，然后返回包裹着结果的新 Functor —— Wrapper(B)。图 2 显示了用 increment 函数作为 A-&gt;B 的映射函数，只是这里的 A 和 B 为同一类型。</p><p><img src="https://i.loli.net/2021/08/08/WLrdu1SBHiDy735.png"></p><p>图 2 Wrapper 内的值 1，在应用函数 increment 后再次包裹成新的容器。</p><p>要注意的是，<strong>fmap 在每次调用都会返回一个新的副本，是不可变的。</strong></p><p>在开始解决更实际的问题之前，再来看一个简单的例子。试用 Functor 来完成简单的 2 + 3 = 5。首先柯里化 add 函数，这样就得到了 plus3 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = R.curry(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="keyword">const</span> plus3 = plus(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>现在可以把数字 2 放到 Wrapper 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>再调用 fmap 把 plus3 映射到容器上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> five = two.fmap(plus3); <span class="comment">//-&gt; Wrapper(5) &lt;--- 返回一个具有上下文包裹的值</span></span><br><span class="line">five.map(R.identity); <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure><p>fmap 返回同样类型的结果，可以通过映射 R.identity 来提取它的值。不过需要注意的是，值会一直在容器中，因此可以 fmap 任意次函数来转换值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(plus3).fmap(plus10); <span class="comment">//-&gt; Wrapper(15)</span></span><br></pre></td></tr></table></figure><p>光看代码可能不够直观，图 3 更清楚地解释了如何 fmapplus3。</p><p><img src="https://i.loli.net/2021/08/08/XUa6k7sG4vZ81rS.png"></p><p>图 3 Wrapper 容器中的值是 2。Functor 会将其打开，应用 fmap 的函数，再包裹函数的返回值到新的容器中。<br>fmap 函数会返回同样的类型，这样就可以链式地继续使用 fmap。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> isFive = two.fmap(plus3).fmap(R.equals(<span class="number">5</span>)); <span class="comment">//-&gt; Wrapper(true) &lt;--- 返回一个具有上下文包裹的值</span></span><br></pre></td></tr></table></figure><p>这种链式的函数调用是不是非常眼熟？其实很多人一直在使用 Functor 却没有意识到而已。比如 Array的 map 和 filter 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map :: (A -&gt; B) -&gt; <span class="built_in">Array</span>(A) -&gt; <span class="built_in">Array</span>(B)</span><br><span class="line"><span class="attr">filter</span> :: (A -&gt; <span class="built_in">Boolean</span>) -&gt; <span class="built_in">Array</span>(A) -&gt; <span class="built_in">Array</span>(A)</span><br></pre></td></tr></table></figure><p>map 和 filter 都返回同样类型的 Functor，因此可以不断地链接。来看看另一个 Functor：compose。<br>正如之前分享提到的，这是从一个函数到另一个函数的映射（也保持类型不变）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose :: (B -&gt; C) -&gt; (A -&gt; B) -&gt; (A -&gt; C)</span><br></pre></td></tr></table></figure><p>Functor 有如下一些重要的<strong>属性约束</strong>:</p><ul><li><strong>必须是无副作用的。</strong> 若映射 R.identity 函数可以获得上下文中相同的值，即可证明 Functor 是无副作用的：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap(<span class="string">&#x27;Get Functional&#x27;</span>).fmap(R.identity); <span class="comment">//-&gt; Wrapper(&#x27;Get Functional&#x27;)</span></span><br></pre></td></tr></table></figure><ul><li><strong>必须是可组合的。</strong> 这个属性的意思是 fmap 函数的组合，与分别 fmap 函数是一样的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(R.compose(plus3, R.add(<span class="number">5</span>))).map(R.identity); <span class="comment">//-&gt; 10</span></span><br></pre></td></tr></table></figure><p>Functor 的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。其实际目的只是创建一个上下文或一个抽象，以便可以安全地应用操作到值，而又不改变原始值。这也是 map 可以将一个数组转换到另一个数组，而不改变原数组的原因。而 Functor 就是这个概念的推广。</p><p>Functor 本身并不需要知道如何处理 null。例如 Ramda 中的 R.compose，在收到为 null 的函数引用时就会抛出异常。这完全是预期的行为，并不是设计上的缺陷。因为 Functor 映射从一个类型到另一类型的函数。还有一个更为具体化的函数式数据类型——Monad。Monad 可以简化代码中的错误处理，进而更流畅地进行函数组合。但是它跟 Functor 有什么关系呢？其实，Monad 就是 Functor“伸入”的容器。</p><p>如果写过 jQuery 代码，那么应该觉得 Monad 很面熟。</p><p>Monad 只是给一些资源提供了抽象，例如一个简单的价值，一个 DOM 元素、事件或 AJAX 调用，这样就可以安全地处理其中包含的数据。比如，jQuery 就可以看作 DOM 的 Monad：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#student-info&#x27;</span>).fadeIn(<span class="number">3000</span>).text(student.fullname());</span><br></pre></td></tr></table></figure><p>这段代码的行为之所以像 Monad，是因为 jQuery 可以将 fadeIn 和 text 行为安全地应用到 DOM 上。如果 student-info 面板不存在，将方法应用到空的 jQuery 对象上只会什么也不发生，而不会抛出任何异常。Monad 旨在安全地传送错误，这样应用才具有较好的容错性。</p><h2 id="使用-Monad-函数式地处理错误"><a href="#使用-Monad-函数式地处理错误" class="headerlink" title="使用 Monad 函数式地处理错误"></a>使用 Monad 函数式地处理错误</h2><p>Monad 用于函数式地解决传统错误处理的问题。但在深入这个话题之前，先来了解使用 Functor 的局限性。使用 Functor 可以安全地应用函数到其内部的值，并且返回一个不可变的新 Functor。但如果它遍布在代码中，就会有一些让人不那么顺心的地方。下面来看一个通过 id 获取学生地址的例子。对于这个例子，大概需要两个函数——findStudent 和 getAddress，这两个函数都给值包裹上一个安全的上下文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findStudent = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(find(db, id)); <span class="comment">// &lt;--- 包裹对象获取逻辑，以避免找不到对象所造成的问题</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(student.fmap(R.prop(<span class="string">&quot;address&quot;</span>))); <span class="comment">// 用 Ramda 的 R.prop()函数来 map 对象以获取其地址， 再将结果包裹起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这两个函数组合在一起：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> studentAddress = R.compose(</span><br><span class="line">  getAddress,</span><br><span class="line">  findStudent(DB(<span class="string">&#x27;student&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>虽然成功地避免了所有的错误处理代码，但是结果却出乎意料。返回的值是被包裹了两层的 address对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentAddress(<span class="string">&#x27;666&#x27;</span>); <span class="comment">//-&gt; Wrapper(Wrapper(address))</span></span><br></pre></td></tr></table></figure><p>为了提取这个值，需要两次应用 R.identity 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentAddress(<span class="string">&#x27;666&#x27;</span>).map(R.identity).map(R.identity);</span><br></pre></td></tr></table></figure><p>在自己的代码中见到两层这样的代码还可以勉强接受，如果出现三四层呢？这个时候，Monad 可以成为更好的解决方案。</p><h3 id="Monad：从控制流到数据流"><a href="#Monad：从控制流到数据流" class="headerlink" title="Monad：从控制流到数据流"></a>Monad：从控制流到数据流</h3><p>Monad 和 Functor 类似，但在处理某些情况时可以带来一些特殊的逻辑。下面就用简单的例子来看看Monad 到底有什么特殊的功能。假如有一个函数 half::Number -&gt;Number（见图 4）：</p><p><img src="https://i.loli.net/2021/08/08/bPwu5ENr4mpAQoU.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper(<span class="number">2</span>).fmap(half); <span class="comment">//-&gt; Wrapper(1)</span></span><br><span class="line">Wrapper(<span class="number">3</span>).fmap(half); <span class="comment">//-&gt; Wrapper(1.5)</span></span><br></pre></td></tr></table></figure><p>图 4 Functor 可以将函数应用到包裹的值上。例子中包裹的值会被 2 除。<br>不过，Functor 只管应用函数到值并将结果包裹起来，并不能加额外的逻辑。如果想要限制 half 只应用到偶数，而输入是一个奇数，该怎么办？或许可以返回 null 或抛出异常，但更好的策略是让该函数能给合法的数字返回正确的结果，并忽略不合法的数字。<br>现在假设有一个名为 Empty 的类似 Wrapper 的容器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Empty = <span class="function"><span class="keyword">function</span> (<span class="params">_</span>) </span>&#123;</span><br><span class="line">  ; <span class="comment">// 无操作。 Empty 不会存储任何值，其代表着“空”或“无”的概念</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// map :: (A -&gt; B) -&gt; A -&gt; B</span></span><br><span class="line">Empty.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;; <span class="comment">// &lt;--- 类似，将函数 map 到 Empty 上会跳过该操作</span></span><br><span class="line"><span class="comment">// empty :: _ -&gt; Empty</span></span><br><span class="line"><span class="keyword">const</span> empty = <span class="function">() =&gt;</span> <span class="keyword">new</span> Empty();</span><br></pre></td></tr></table></figure><p>为了实现 half 以满足新的需求，可以通过以下方式完成（见图 5）：</p><p><img src="https://i.loli.net/2021/08/08/YvoIHae8QUJfq6x.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">Number</span>.isFinite(n) &amp;amp;&amp;amp; (n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// &lt;--- 区分奇偶数的工具函数</span></span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">val</span>) =&gt;</span> isEven(val) ? wrap(val / <span class="number">2</span>) : empty(); <span class="comment">// &lt;--- half 函数只会操作偶数，否则会返回一个空的容器</span></span><br><span class="line">half(<span class="number">4</span>); <span class="comment">//-&gt; Wrapper(2)</span></span><br><span class="line">half(<span class="number">3</span>); <span class="comment">//-&gt; Empty</span></span><br></pre></td></tr></table></figure><p>图 5 函数 half 可以根据输入返回一个包裹好的值或空容器。<br>Monad 用于创建一个带有一定规则的容器，而 Functor 并不需要了解其容器内的值。Functor 可以有效地保护数据，然而当需要组合函数时，即可以用Monad 来安全并且无副作用地管理数据流。在前面的例子中，对于奇数会返回 Empty 而不是 null。所以此后如果想应用函数，就不必在意可能会出现的异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half(<span class="number">4</span>).fmap(plus3); <span class="comment">//-&gt; Wrapper(5)</span></span><br><span class="line">half(<span class="number">3</span>).fmap(plus3); <span class="comment">//-&gt; Empty &lt;--- 容器知道该如何应用函数，即便其值是非法的</span></span><br></pre></td></tr></table></figure><p>除此之外，Monad 还适用于解决其他问题。这里只讨论如何使用 Monad 来解决命令式错误处理的问题，从而使代码更可读、更易于推理。</p><p>以下两个概念非常重要。</p><ul><li>Monad:为 Monadic 操作提供抽象接口。</li><li>Monadic 类型: 该接口的具体实现。</li></ul><p>Monadic 类型类似于上面提到的的 Wrapper 对象。不过每个 Monad 都有不同的用途，可以定义不同的语义便于确定其行为（例如 map 或 fmap）。使用这些类型可以进行链式或嵌套操作，但都应遵循下列接口定义。</p><ul><li>类型构造函数: 创建 Monadic 类型（类似于 Wrapper 的构造函数）。</li><li>unit 函数: 可将特定类型的值放入 Monadic 结构中（类似于 wrap 和前面看到的 empty 函数）。对于 Monad 的实现来说，该函数也被称为 of 函数。</li><li>bind 函数: 可以链式操作，后文将使用更简短的 map。</li><li>join 函数: 将两层 Monadic 结构合并成一层。这会对嵌套返回 Monad 的函数特别有用。<br>将这一个接口应用到 Wrapper 类型，就可以重构成以下这种形式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// unit 函数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">a</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wrapper(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// bind 函数（ Functor）</span></span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> Wrapper.of(f(<span class="built_in">this</span>.value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 压平嵌套的 Wrapper</span></span><br><span class="line">  <span class="function"><span class="title">join</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(!(<span class="built_in">this</span>.value <span class="keyword">instanceof</span> Wrapper)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.value.join();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个当前结构的文本描述</span></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Wrapper (<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 使用 Functor 的 map 将数据提升到容器中，这样就可以无任何副作用。通常还可以用_.identity 函数来检查其内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Wrapper.of(<span class="string">&#x27;Hello Monads!&#x27;</span>)</span><br><span class="line">.map(R.toUpper)</span><br><span class="line">.map(R.identity); <span class="comment">//-&gt; Wrapper(&#x27;HELLO MONADS!&#x27;)</span></span><br></pre></td></tr></table></figure><p>map 操作被视为一种中立的 functor，因为它无非只是映射函数到对象，然后关闭它。之后，Monad 给map 加入特殊的功能。join 函数用于逐层扁平化嵌套结构，就像剥洋葱一样。这可以用来消除之前用functor 时发现的问题，如下 所示。<br>扁平化 Monadic 结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findObject :: DB -&gt; String -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> findObject = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(find(db, id));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// getAddress :: Student -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(student.map(R.prop(<span class="string">&#x27;address&#x27;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> studentAddress = R.compose(getAddress, findObject(DB(<span class="string">&#x27;student&#x27;</span>)));</span><br><span class="line">studentAddress(<span class="string">&#x27;444-44-4444&#x27;</span>).join().get(); <span class="comment">// Address</span></span><br></pre></td></tr></table></figure><p>该代码返回一组嵌套的 wrapper，其中 join 操作用于将这种嵌套结构压平成单一的层：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wrapper.of(Wrapper.of(Wrapper.of(<span class="string">&#x27;Get Functional&#x27;</span>))).join();</span><br><span class="line"><span class="comment">//-&gt; Wrapper(&#x27;Get Functional&#x27;)</span></span><br></pre></td></tr></table></figure><p>图 6 为 join 操作的示意图，递归扁平化嵌套结构的 Monad，像剥洋葱一样：</p><p><img src="https://i.loli.net/2021/08/08/dAocQ8O6PJMTUVk.png"></p><p>Monad 通常有更多的操作，这里提及的最小接口只是其整个 API 的子集。一个 Monad 本身只是抽象，没有任何实际意义。只有实际的实现类型才有丰富的功能。大多数函数式编程的代码只用一些常用的类型就可以消除大量的样板代码，同时还能完成同样的工作。</p><p>Monad 实例丰富，例如：Maybe、Either 和 IO，大家有兴趣可以自行查看。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>面向对象抛异常的机制让函数变得不纯，把大部分的责任都推到了调用者的尝试——try-catch逻辑上</li><li>把值包裹到容器中的模式是为了构建无副作用的代码，把可能不纯的变化包裹成引用透明的过程</li><li>使用Functor将函数应用到容器中的值，这是无副作用地、不可变地访问和修改操作</li><li>Monad是函数式中用来降低应用复杂度的设计模式，通过这种模式可以将函数编排成安全的数据流程</li><li>交错的组合函数和Monadic类型是非常有弹性而且强大的，如Maybe、Either和IO</li></ul><p><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html">阮一峰：图解 Monad</a><br><a href="https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">阮一峰：函数式编程入门教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;四-函数式编程——针对复杂应用的设计模式&quot;&gt;&lt;a href=&quot;#四-函数式编程</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为什么打开一个页面，会有4个进程？</title>
    <link href="http://example.com/2021/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BC%9A%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F/"/>
    <id>http://example.com/2021/03/22/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BC%9A%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F/</id>
    <published>2021-03-22T05:07:12.000Z</published>
    <updated>2022-01-20T03:06:49.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="简单回答"><a href="#简单回答" class="headerlink" title="简单回答"></a>简单回答</h2><p>因为打开1个页面，至少需要1个浏览器进程、1个网络进程、1个GPU进程以及1个渲染进程</p><h2 id="相关思维导图"><a href="#相关思维导图" class="headerlink" title="相关思维导图"></a>相关思维导图</h2><p><img src="https://s2.loli.net/2022/01/09/P5xs9HKBg1WpLiD.png"></p><h2 id="前置知识：线程和进程"><a href="#前置知识：线程和进程" class="headerlink" title="前置知识：线程和进程"></a>前置知识：线程和进程</h2><p>进程资源分配的最小单元，线程是CPU调度的最小单元。</p><p>二者都是一个时间段的描述，是CPU工作时间段的描述，是运行中的程序指令的一种描述，这需要与程序中的代码区别开来。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这个问题与浏览器的发展相关，浏览器是从单进程时代发展到多进程时代。</p><h3 id="单进程时代"><a href="#单进程时代" class="headerlink" title="单进程时代"></a>单进程时代</h3><p>顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，其中包含JS引擎、渲染引擎、网络进程、插件进程、GPU进程等等。</p><p>如此之多的功能模块在一个进程中，使得浏览器面临以下的窘境：</p><ul><li>不稳定<br>  插件容易崩溃</li><li>不流畅<br>  所有功能模块都在一个进程中，从线程和进程的关系得知，这意味着同一时刻只有一个模块可以运行，效率不高</li><li>不安全<br>  恶意插件、恶意脚本</li></ul><h3 id="多进程时代"><a href="#多进程时代" class="headerlink" title="多进程时代"></a>多进程时代</h3><p>这里以Chrome浏览器为例，它也是第一个采用多进程架构的浏览器，这个架构<strong>能容许许多个程序同事运行而互不影响</strong></p><p><img src="https://s2.loli.net/2022/01/09/Vmk68QIpOBgZGoU.png"></p><p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p><ul><li>更高的资源占用</li><li>更复杂的体系结构</li></ul><h3 id="关于安全沙箱"><a href="#关于安全沙箱" class="headerlink" title="关于安全沙箱"></a>关于安全沙箱</h3><p>采用多进程架构的好处之一是可以使用安全沙箱，沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源，</p><h2 id="各个进程的作用"><a href="#各个进程的作用" class="headerlink" title="各个进程的作用"></a>各个进程的作用</h2><p>这里仍以Chrome浏览器为例</p><ul><li>浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储功能</li><li>渲染进程：核心任务就是将HTML、CSS和JavaScript转换为用户可以与之交互的网页(排版引擎Blink、JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程，出于安全考虑，渲染进程都是运行在沙箱模式下)</li><li>GPU进程：该进程的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器的普遍需求。最后，Chrome在其多进程架构上也引入了GPU进程。</li><li>网络进程：主要负责页面的网络资源加载</li><li>插件进程：主要负责插件的运行，因为插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程不会对浏览器和页面造成影响</li></ul><h2 id="标题的答案"><a href="#标题的答案" class="headerlink" title="标题的答案"></a>标题的答案</h2><p>打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1688297">进程和线程的概念、区别及进程线程间通信</a></p><p><a href="https://codeantenna.com/a/Xr9k4lpBJn">Chrome为什么打开一个页面，会有4个进程?</a></p><p><a href="https://cloud.tencent.com/developer/news/414508">Chrome架构：仅仅打开了1个页面，为什么有4个进程？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单回答&quot;&gt;&lt;a href=&quot;#简单回答&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（三）</title>
    <link href="http://example.com/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://example.com/2021/03/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-03-05T06:33:22.000Z</published>
    <updated>2022-01-11T07:51:26.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h1 id="三-函数式编程——模块化且可重用的代码"><a href="#三-函数式编程——模块化且可重用的代码" class="headerlink" title="三.函数式编程——模块化且可重用的代码"></a>三.函数式编程——模块化且可重用的代码</h1><p>（读书笔记：JavaScript函数式编程指南）</p><p>今日分享</p><ul><li>方法链与函数管道的比较</li><li>管道函数的兼容条件</li><li>柯里化的函数求值</li><li>部分应用和函数绑定（略）</li></ul><h2 id="1-方法链与函数管道的比较"><a href="#1-方法链与函数管道的比较" class="headerlink" title="1 方法链与函数管道的比较"></a>1 方法链与函数管道的比较</h2><p>之前提到了连接一系列函数的方法链，从而揭示了一种与众不同的函数式编程风格。还有一种称为管道的方法也可以用来连接函数。</p><p>函数的输入和输出对于了解函数本身是十分重要的。<code>Haskell</code>（发音为/ˈhæskəl/）中使用一种符号来描述函数。<br>如图一：</p><p><img src="https://i.loli.net/2021/08/08/tnKNhbJXykumAFe.png"></p><p>在函数式编程中，函数是输入和输出类型之间的数学映射。举例来说，一个简单的函数 isEmpty，它接收一个字符串并返回一个布尔值，就像这样表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isEmpty :: <span class="built_in">String</span> -&gt; <span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure><p>如图二：</p><p><img src="https://i.loli.net/2021/08/08/zD8JNZ3AucwUmQ1.png"></p><p>该函数是所有 String 类型输入值到所有 Boolean 值之间的引用透明映射。该函数<code>JavaScript</code>的<code>lambda</code>描述形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isEmpty :: String -&gt; Boolean</span></span><br><span class="line"><span class="keyword">const</span> isEmpty = <span class="function">(<span class="params">s</span>) =&gt;</span> !s || !s.trim();</span><br></pre></td></tr></table></figure><p>了解函数作为类型映射的性质是理解如何将函数链接和管道化的关键:</p><ul><li>方法链接（紧耦合，有限的表现力）</li><li>函数的管道化（松耦合，灵活）</li></ul><h3 id="1-1-方法链接"><a href="#1-1-方法链接" class="headerlink" title="1.1 方法链接"></a>1.1 方法链接</h3><p><code>map</code>和<code>filter</code>函数都以一个数组作为输入并返回一个新的数组。这些函数都可以通过<code>Lodash</code>封装的隐式对象紧密地连接在一起，从而在后台实现对新数据结构的创建。<br>这是上一次分享中一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names) <span class="comment">//&lt;--- 初始化函数链（创建惰性计算函数链来处理给定的数组）</span></span><br><span class="line">  .filter(isValid) <span class="comment">//&lt;--- 去除非法值</span></span><br><span class="line">  .map(<span class="function">(<span class="params">s</span>) =&gt;</span> s.replace(<span class="regexp">/_/</span>, <span class="string">&quot; &quot;</span>)) <span class="comment">//&lt;--- 规范化值</span></span><br><span class="line">  .uniq() <span class="comment">// &lt;---去掉重复元素</span></span><br><span class="line">  .map(_.startCase) <span class="comment">//&lt;--- 大写首字母</span></span><br><span class="line">  .sort()</span><br><span class="line">  .value(); <span class="comment">//&lt;--- 执行函数链中的所有函数</span></span><br><span class="line"><span class="comment">//-&gt; [&#x27;Alonzo Church&#x27;, &#x27;Haskell Curry&#x27;, &#x27;Jon Von Neumann&#x27;, &#x27;Stephen Kleene&#x27;]</span></span><br></pre></td></tr></table></figure><p>比较命令式代码，这的确是一个能够极大提高代码可读性的语法改进。然而，它与方法所属的对象紧紧地耦合在一起，限制链中可以使用的方法数量，也就限制了代码的表现力。这样就只能够使用由<code>Lodash</code>提供的操作，而无法轻松地将不同函数库的（或自定义的）函数连接在一起。(尽管使用 mixin 的方法可以扩展一个对象的功能，但这就需要自己去管理 mixin 对象本身。这里不做讨论)</p><p>从高阶函数角度来看，可以一组对数组操作的简单方法序列表示为图三所示的形式。打破函数链的约束就能够自由地排列所有独立的函数操作，而可以使用函数管道来实现这一目的。</p><p><img src="https://i.loli.net/2021/08/08/FMG4nCA3bhuK81v.png"></p><h3 id="1-2-函数的管道化"><a href="#1-2-函数的管道化" class="headerlink" title="1.2 函数的管道化"></a>1.2 函数的管道化</h3><p>函数式编程能够消除方法链中存在的限制，使得任何函数的组合都更加灵活。管道是松散结合的有向函数序列，一个函数的输出会作为下一个函数的输入。图四抽象地说明了以不同类型对象作为输入的函数的连接方式。</p><p><img src="https://i.loli.net/2021/08/08/1zSkQ9sacgx3ODE.png"></p><p>这也是面向对象设计模式中的管道与过滤器模式，它是从函数式编程衍变而来的（其中的过滤器就是各个函数）。</p><p>比较图三和图四就会发现一个关键的区别：方法链接通过对象的方法紧密连接；而管道以函数作为组件，将函数的输入和输出松散地连接在一起。但是，为了实现管道，被连接的函数必须在元数（arity）和类型上相互兼容。</p><h2 id="2-管道函数的兼容条件"><a href="#2-管道函数的兼容条件" class="headerlink" title="2 管道函数的兼容条件"></a>2 管道函数的兼容条件</h2><p>面向对象的编程在一些特定情况下（其中之一是认证与授权）偶尔会使用管道。而函数式编程将管道视为构建程序的唯一方法。</p><p>通常来说，对于不同的任务，问题的定义与解决方案间总是存在很大的差异。因此，特定的计算必须在特定的阶段进行。这些阶段由不同的函数表征，而所选函数的输入和输出需要满足以下两个兼容条件。</p><ul><li>类型——函数的返回类型必须与接收函数的参数类型相匹配。</li><li>元数——接收函数必须声明至少一个参数才能处理上一个函数的返回值。</li></ul><h3 id="2-1-函数的类型兼容条件"><a href="#2-1-函数的类型兼容条件" class="headerlink" title="2.1 函数的类型兼容条件"></a>2.1 函数的类型兼容条件</h3><p>在设计函数管道时，函数的返回类型与函数的接收参数之间具有一定程度的兼容性是极其重要的。</p><p>由于<code>JavaScirpt</code>是弱类型语言，因此从类型角度来看，无须像使用一些静态类型语言一样太过关注类型。因此，如果一个对象在应用中表现得像某个特定类型，那么它就是该类型。这也被称为鸭子类型：“如果走起来像鸭子，并且像鸭子一样叫，那这就是一只鸭子。”</p><p><code>JavaScript</code>的动态调度机制会尝试在对象中查找属性与方法，而不关注类型信息。虽然这非常灵活，但开发者仍然需要了解一个函数所期望的参数类型。使用清晰的定义（例如在代码中使用 <code>Haskell</code> 符号标记）可以使程序更易理解。</p><p>正式地讲，仅当 f 的输出类型等同于函数 g 的输入时，两个函数 f 和 g 是类型兼容的。举例来说，一个处理用户输入的简单程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trim :: <span class="built_in">String</span> -&gt; <span class="built_in">String</span> &lt;--- 截掉首末空白符</span><br><span class="line"><span class="attr">normalize</span> :: <span class="built_in">String</span> -&gt; <span class="built_in">String</span> &lt;--- 去除横线</span><br></pre></td></tr></table></figure><p>此时，<code>normalize</code>的输入与<code>trim</code>的输出服从兼容性的对应关系，因此可以在一个简单的管道序列中调用它们:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trim :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> trim = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// normalize :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> normalize = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/\-/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">normalize(trim(<span class="string">&quot; 444-44-4444 &quot;</span>));</span><br><span class="line"><span class="comment">//-&gt; &#x27;444444444&#x27; &lt;--- 手动构建系列管道调用两个函数（之后会涉及如何自动化这一过程）。使用带有首末空白符的输入测试</span></span><br></pre></td></tr></table></figure><p>类型固然重要，但在<code>JavaScript</code>中，更关键的是函数元数的兼容性。</p><h2 id="2-2-函数与元数：元组的应用"><a href="#2-2-函数与元数：元组的应用" class="headerlink" title="2.2 函数与元数：元组的应用"></a>2.2 函数与元数：元组的应用</h2><p>元数定义为函数所接收的参数数量，也被称为函数的长度（length）。尽管在其他编程范式中，元数是最基本的，但在函数式编程中，引用透明的必然结果就是，声明的函数参数数量往往与其复杂性成正比。例如，操作一个字符串的函数很可能比具有 3 个或 4 个参数的函数简单得多：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isValid :: String -&gt; Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValid</span>(<span class="params">str</span>) </span>&#123; &lt;--- 使用简单</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// makeAsyncHttp:: String, String, Array -&gt; Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAsyncHttp</span> (<span class="params">method, url, data</span>) </span>&#123; <span class="comment">//&lt;--- 难以使用，因为必须先计算出所有参数</span></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只具有单一参数的纯函数是最简单的，因为其实现目的非常单纯，也就意味着职责单一。因此，应该尽可能地使用具有少量参数的函数，这样的函数更加灵活和通用。然而，总是使用一元函数并非那么容易。例如，在真实世界中，isValid 函数可能会额外返回一个描述错误信息的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isValid :: <span class="built_in">String</span> -&gt; (<span class="built_in">Boolean</span>, <span class="built_in">String</span>) <span class="comment">// &lt;--- 返回含有验证状态或错误信息的结构体</span></span><br><span class="line">isValid(<span class="string">&#x27; 444-444-44444&#x27;</span>); <span class="comment">//-&gt; (false, &#x27;Input is too long!&#x27;)</span></span><br></pre></td></tr></table></figure><p>但如何返回两个不同的值呢？函数式语言通过一个称为元组的结构来做到这一点。元组是有限的、有序的元素列表，通常由两个或三个值成组出现，记为<code>(a, b,c)</code>。由此，可以使用一个元组作为<code>isValid</code>函数的返回值——它将状态与可能的错误消息捆绑，作为单个实体返回，并随后传递到另一个函数中（如果需要的话）。</p><p>下面详细探讨一下元组。元组是不可变的结构，它将不同类型的元素打包在一起，以便将它们传递到其他函数中。将数据打包返回的方式还包括字面对象或数组等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">status</span> : <span class="literal">false</span>, or <span class="keyword">return</span> [<span class="literal">false</span>, <span class="string">&#x27;Input is too long!&#x27;</span>];</span><br><span class="line">message: <span class="string">&#x27;Input is too long!&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但当涉及函数间的数据传输时，元组能够具有更多的优点。</p><ul><li>不可变的——一旦创建，就无法改变一个元组的内部内容。</li><li>避免创建临时类型——元组可以将可能毫不相关的数据相关联。而定义和实例化一些仅用于数据分组的新类型使得模型复杂并令人费解。</li><li>避免创建异构数组——包含不同类型元素的数组使用起来颇为困难，因为会导致代码中充满大量的防御性类型检查。传统上，数组意在存储相同类型的对象。</li></ul><p><code>JavaScript</code>并不原生地支持<code>Tuple</code>数据类型。例如，给定一个<code>Scala</code>中的元组定义：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = (<span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>);</span><br></pre></td></tr></table></figure><p>可以像这样访问各个元素：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumAnglesTriangle = (t._1 + t._2 + t._3 = <span class="number">180</span>);</span><br></pre></td></tr></table></figure><p>但是<code>JavaScript</code>已经提供了实现元组所需的所有工具,实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Tuple = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="comment">/* types */</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> typeInfo = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>); <span class="comment">// &lt;--- 读取参数作为元组的元素类型</span></span><br><span class="line">  <span class="keyword">const</span> _T = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="comment">/* values */</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;--- 声明内部类型_T，以保障类型与值匹配</span></span><br><span class="line">    <span class="keyword">const</span> values = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>); <span class="comment">// &lt;--- 提取参数作为元组内的值</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      values.some(</span><br><span class="line">        <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">          val <span class="comment">// &lt;--- 检查非空值。函数式数据类型不允许空值</span></span></span></span><br><span class="line"><span class="params"><span class="function">        </span>) =&gt;</span> val === <span class="literal">null</span> || val === <span class="literal">undefined</span></span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;Tuples may not have any null values&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (values.length !== typeInfo.length) &#123;</span><br><span class="line">      <span class="comment">// &lt;--- 按照定义类型的个数检查元组的元数</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Tuple arity does not match its prototype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    values.map(<span class="function"><span class="keyword">function</span> (<span class="params">val, index</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// &lt;--- 使用 checkType 检查每一个值都能匹配其类型定义。其中的元素都可以通过_n 获取， n 为元素的索引（注意是从 1 开始）</span></span><br><span class="line">      <span class="built_in">this</span>[<span class="string">&quot;_&quot;</span> + (index + <span class="number">1</span>)] = checkType(typeInfo[index])(val);</span><br><span class="line">    &#125;, <span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">Object</span>.freeze(<span class="built_in">this</span>); <span class="comment">// &lt;--- 让元组实例不可变</span></span><br><span class="line">  &#125;;</span><br><span class="line">  _T.prototype.values = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;--- 提取元组中的元素，也可以使用 ES6 的解构赋值把元素赋值到变量上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[k];</span><br><span class="line">    &#125;, <span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> _T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkType :: Type -&gt; Type -&gt; Type | TypeError</span></span><br><span class="line"><span class="keyword">const</span> checkType = curry2(<span class="function"><span class="keyword">function</span> (<span class="params">typeDef, actualType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (R.is(typeDef, actualType)) &#123;</span><br><span class="line">    <span class="comment">// &lt;--- 使用 R.is()检查类型信息</span></span><br><span class="line">    <span class="keyword">return</span> actualType;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">&quot;Type mismatch. Expected [&quot;</span> +</span><br><span class="line">        typeDef +</span><br><span class="line">        <span class="string">&quot;] but found [&quot;</span> +</span><br><span class="line">        <span class="keyword">typeof</span> actualType +</span><br><span class="line">        <span class="string">&quot;]&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="string">&quot;Curry&quot;</span>); <span class="comment">//-&gt; String</span></span><br><span class="line">checkType(<span class="built_in">Number</span>)(<span class="number">3</span>); <span class="comment">//-&gt; Number</span></span><br><span class="line">checkType(<span class="built_in">Date</span>)(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">//-&gt; Date</span></span><br><span class="line">checkType(<span class="built_in">Object</span>)(&#123;&#125;); <span class="comment">//-&gt; Object</span></span><br><span class="line">checkType(<span class="built_in">String</span>)(<span class="number">42</span>); <span class="comment">//-&gt; Throws TypeError</span></span><br></pre></td></tr></table></figure><p>上面定义的元组对象是不可变且长度固定的数据结构，是可用于在函数间通讯的存储了 n 个不同类型值的异构集合。举例来说，可以用元组来快速构建如<code>Status</code>这样的值对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Status = Tuple(<span class="built_in">Boolean</span>, <span class="built_in">String</span>);</span><br></pre></td></tr></table></figure><p>下面利用元组来完成用户输入验证：使用了元组的 isValid 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trim :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> trim = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/^\s*|\s*$/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// normalize :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> normalize = <span class="function">(<span class="params">str</span>) =&gt;</span> str.replace(<span class="regexp">/\-/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// isValid :: String -&gt; Status</span></span><br><span class="line"><span class="keyword">const</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Status(<span class="literal">false</span>, <span class="string">&quot;Invald input. Expected non-empty value!&quot;</span>); <span class="comment">// &lt;--- 声明包含状态（ Boolean）和消息（ String）的类型Status</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Status(<span class="literal">true</span>, <span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">isValid(normalize(strim(<span class="string">&quot;444-44-4444&quot;</span>))); <span class="comment">//-&gt; (true, &#x27;Success!&#x27;)</span></span><br></pre></td></tr></table></figure><p>在软件开发过程中，二元组出现得非常频繁，将其设定为一等的对象非常具有实际意义。在<code>ES6</code>解构赋值特性的支持下，可以简明地将元组值映射到变量中。如下代码使用元组创建了一个名为<code>StringPair</code>的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StringPair = Tuple(<span class="built_in">String</span>, <span class="built_in">String</span>);</span><br><span class="line"><span class="keyword">const</span> name = <span class="keyword">new</span> StringPair(<span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>);</span><br><span class="line">[first, last] = name.values();</span><br><span class="line">first; <span class="comment">//-&gt; &#x27;Barkley&#x27;</span></span><br><span class="line">last; <span class="comment">//-&gt; &#x27;Rosser&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fullname = <span class="keyword">new</span> StringPair(<span class="string">&quot;J&quot;</span>, <span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>); <span class="comment">// &lt;--- 抛出元素不匹配的错误</span></span><br></pre></td></tr></table></figure><p>元组是减少函数元数的方式之一，但还可以使用更好的方式去应对那些不适于元组的情况。通过引入函数柯里化不仅可以降低元数，还可以增强代码的模块化和可重用性。</p><h2 id="3-柯里化的函数求值"><a href="#3-柯里化的函数求值" class="headerlink" title="3 柯里化的函数求值"></a>3 柯里化的函数求值</h2><p>将函数的返回值作为参数传递给一元函数是十分容易的，但如果目标函数需要更多参数呢？</p><p>为了理解<code>JavaScript</code>的柯里化，首先必须了解柯里化的求值和常规（非柯里化的）求值之间的区别。</p><p><code>JavaScript</code>是允许在缺少参数的情况下对常规或非柯里化函数进行调用的。换句话说，如果定义一个函数<code>f(a, b, c)</code>，并只在调用时传递<code>a</code>，<code>JavaScript</code>运行时的调用机制会将<code>b</code>和<code>c</code>设为<code>undefined</code>。如图五：</p><p><img src="https://i.loli.net/2021/08/08/nlyjCQxwFL8kYpS.png"></p><p>再看柯里化函数，它要求所有参数都被明确地定义，因此当使用部分参数调用时，它会返回一个新的函数，在真正运行之前等待外部提供其余的参数。图六能够直观地表现这一点：</p><p><img src="https://i.loli.net/2021/08/08/a4dMPNFtcZzWObu.png"></p><p>柯里化是一种在所有参数被提供之前，挂起或“延迟”函数执行，将多参函数转换为一元函数序列的技术。具有三个参数的柯里化函数的定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curry(f) :: (a,b,c) -&gt; f(a) -&gt; f(b)-&gt; f(c)</span><br></pre></td></tr></table></figure><p>以上符号描述表明，<code>curry</code>是一种从函数到函数的映射，将输入<code>(a, b, c)</code>分解为多个分离的单参数调用。在纯函数式编程语言中（如<code>Haskell</code>），柯里化是原生特性，是任何函数定义中的组成部分。由于<code>JavaScript</code>原生不支持柯里化函数，因此需要编写一些代码来实现它。</p><p>我们先从二元参数的手动柯里化例子开始，代码如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">firstArg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;--- 第一次调用 curry2，获得第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">secondArg</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// &lt;--- 第二次调用获得第二个参数</span></span><br><span class="line">      <span class="keyword">return</span> fn(firstArg, secondArg); <span class="comment">// &lt;--- 将两个参数应用到函数 fn 上</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化是一种词法作用域（闭包），其返回的函数只不过是一个接收后续参数的简单嵌套函数包装器。以下是一个简单应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = curry2(<span class="function"><span class="keyword">function</span> (<span class="params">last, first</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StringPair(<span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">[first, last] = name(<span class="string">&quot;Curry&quot;</span>)(<span class="string">&quot;Haskell&quot;</span>).values(); <span class="comment">// &lt;--- 当给定两个参数时，函数会完全求值</span></span><br><span class="line">first; <span class="comment">//-&gt; &#x27;Curry&#x27;</span></span><br><span class="line">last; <span class="comment">//-&gt; &#x27;Haskell&#x27;</span></span><br><span class="line">name(<span class="string">&quot;Curry&quot;</span>); <span class="comment">//-&gt; Function &lt;--- 当只提供一个参数时，返回一个函数，而不是将第二个参数当作 undefined</span></span><br></pre></td></tr></table></figure><p>curry2 能够胜任简单的任务，但是当构建更复杂的功能时，就需要能够自动处理任意数量参数的柯里化函数。</p><p><code>curry</code>是一个很长且复杂的函数，因此与其去解释它令人头疼的实现，不如讨论更为有用的东西（者可以在<code>Lodash</code>和<code>Ramda</code>中找到<code>curry</code>及其另两个版本<code>curryRight</code>和<code>curryN</code>的实现）。可以使用<code>R.curry</code>对任意数量参数的函数进行自动的柯里化。</p><p>可以将自动柯里化想象为基于声明参数的数量人工创建对应嵌套函数作用域的过程。柯里化<code>fullname</code>函数如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fullname :: (String, String) -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> fullname = <span class="function"><span class="keyword">function</span> (<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个参数会被通过如下形式转换成多个一元函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fullname :: String -&gt; String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> fullname =<span class="function"><span class="keyword">function</span> (<span class="params">first</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">last</span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看一些柯里化的实际应用。尤其是，它可以用于实现以下两种流行的设计模式。</p><ul><li>仿真函数接口</li><li>实现可重用模块化函数模板</li></ul><h3 id="3-1-仿真函数工厂"><a href="#3-1-仿真函数工厂" class="headerlink" title="3.1 仿真函数工厂"></a>3.1 仿真函数工厂</h3><p>在面向对象世界中，接口是用于定义子类必须实现的契约抽象类型。如果创建的接口包含函数<code>findStudent(id)</code>，那么实体类必须实现此函数。下面这段<code>Java</code>示例代码说明了这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentStore</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">findStudent</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbStudentStore</span> <span class="keyword">implements</span> <span class="title">StudentStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudent</span><span class="params">(String ssn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ResultSet rs = jdbcStmt.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            String id = rs.getString(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">&quot;firstname&quot;</span>) +</span><br><span class="line">            rs.getString(<span class="string">&quot;lastanme&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Student(id, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStudentStore</span> <span class="keyword">implements</span> <span class="title">StudentStore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudent</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> cache.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码显示了同一个接口的两个实现：一个从数据库读取；另一个从缓存读取。</p><p>但是从调用代码的角度来看，它只关心方法的调用而并不关心来自哪个对象。这就是面向对象设计模式中工厂方法模式的美妙之处。只要使用一个函数工厂就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StudentStore store = getStudentStore();</span><br><span class="line">store.findStudent(<span class="string">&quot;444-44-4444&quot;</span>);</span><br></pre></td></tr></table></figure><p>当然，函数式编程的实现是不容错过的，其解决方案就是柯里化。通过分别创建在存储数据和数组中查找学生对象的函数，就能够将这段<code>Java</code>代码翻译为<code>JavaScript</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchStudentFromDb :: DB -&gt; (String -&gt; Student)</span></span><br><span class="line"><span class="keyword">const</span> fetchStudentFromDb = R.curry(<span class="function"><span class="keyword">function</span> (<span class="params">db, ssn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;--- 在 DB对象中查找</span></span><br><span class="line">  <span class="keyword">return</span> find(db, ssn);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// fetchStudentFromArray :: Array -&gt; (String -&gt; Student)</span></span><br><span class="line"><span class="keyword">const</span> fetchStudentFromArray = R.curry(<span class="function"><span class="keyword">function</span> (<span class="params">arr, ssn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;--- 在数组中查找</span></span><br><span class="line">  <span class="keyword">return</span> arr[ssn];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于这两个函数都是柯里化的，因此可以使用一个通用工厂方法<code>findStudent</code>将函数的定义与求值分离，而其具体的实现细节可能是任意一个查找函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findStudent = useDb ? fetchStudentFromDb(db) : fetchStudentFromArray(arr);</span><br><span class="line">findStudent(<span class="string">&quot;444-44-4444&quot;</span>);</span><br></pre></td></tr></table></figure><p>现在<code>findStudent</code>可以传递给其他模块，而其调用者无须了解其具体实现。从可重用的角度来看，柯里化也能够帮助开发者创建函数模板。</p><h3 id="3-2-创建可重用的函数模板"><a href="#3-2-创建可重用的函数模板" class="headerlink" title="3.2 创建可重用的函数模板"></a>3.2 创建可重用的函数模板</h3><p>假设开发者需要配置不同的日志函数来处理应用程序中的不同状态，比如错误、警告以及调试信息等。函数模板会根据创建时的参数数量来定义一系列的相关函数。这里用一个日志相关的库<code>Log4js</code>举例子。以下是一些基本设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Log4js.getLogger(<span class="string">&quot;StudentEvents&quot;</span>);</span><br><span class="line">logger.info(<span class="string">&quot;Student added successfully!&quot;</span>);</span><br></pre></td></tr></table></figure><p>在<code>Log4js</code>的辅助下，还可以做到更多。假设需要在弹出的窗口中显示消息，可以通过配置一个<code>appender</code>来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.addAppender(<span class="keyword">new</span> Log4js.JSAlertAppender());</span><br></pre></td></tr></table></figure><p>也可以通过配置一个布局，使其输出 JSON 而不是纯文本格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appender.setLayout(<span class="keyword">new</span> Log4js.JSONLayout());</span><br></pre></td></tr></table></figure><p>开发者可能设置很多的配置，而将这些代码复制并粘贴到每个文件中会导致大量重复。使用柯里化来定义一个可重用的函数模板（如下所示的日志函数模板），将带来最大的灵活性和重用性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="keyword">function</span> (<span class="params">appender, layout, name, level, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> appenders = &#123;</span><br><span class="line">    <span class="comment">// &lt;--- 预设 appenders</span></span><br><span class="line">    <span class="attr">alert</span>: <span class="keyword">new</span> Log4js.JSAlertAppender(),</span><br><span class="line">    <span class="attr">console</span>: <span class="keyword">new</span> Log4js.BrowserConsoleAppender(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> layouts = &#123;</span><br><span class="line">    <span class="comment">// &lt;--- 预设布局layouts</span></span><br><span class="line">    <span class="attr">basic</span>: <span class="keyword">new</span> Log4js.BasicLayout(),</span><br><span class="line">    <span class="attr">json</span>: <span class="keyword">new</span> Log4js.JSONLayout(),</span><br><span class="line">    <span class="attr">xml</span>: <span class="keyword">new</span> Log4js.XMLLayout(),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> appender = appenders[appender];</span><br><span class="line">  appender.setLayout(layouts[layout]);</span><br><span class="line">  <span class="keyword">const</span> logger = <span class="keyword">new</span> Log4js.getLogger(name);</span><br><span class="line">  logger.addAppender(appender);</span><br><span class="line">  logger.log(level, message, <span class="literal">null</span>); <span class="comment">// &lt;--- 使用配置好的logger 打印消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过柯里化 logger，可以集中管理和重用适用于任何场合的日志配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = R.curry(logger)(<span class="string">&quot;alert&quot;</span>, <span class="string">&quot;json&quot;</span>, <span class="string">&quot;FJS&quot;</span>);</span><br><span class="line">log(<span class="string">&quot;ERROR&quot;</span>, <span class="string">&quot;Error condition detected!!&quot;</span>);</span><br><span class="line"><span class="comment">// -&gt; this will popup an alert dialog with the requested message</span></span><br></pre></td></tr></table></figure><p>如果要在一个函数或文件中记录多条错误日志，可以灵活地设置除最后一个参数之外的其他参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> logError = R.curry(logger)(<span class="string">&quot;console&quot;</span>, <span class="string">&quot;basic&quot;</span>, <span class="string">&quot;FJS&quot;</span>, <span class="string">&quot;ERROR&quot;</span>);</span><br><span class="line">logError(<span class="string">&quot;Error code 404 detected!!&quot;</span>);</span><br><span class="line">logError(<span class="string">&quot;Error code 402 detected!!&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>curry</code>函数的后续调用在后台被执行，最终生产一个一元函数。事实上，可以通过现有的函数创建新函数，并将任意数量的参数传递给它们，从而逐步实现函数构建。除了能够有效提升代码的可重用性之外，将多元函数转换为一元函数才是柯里化的主要动机。</p><p>柯里化的可替代方案是部分应用和函数绑定，它们受到<code>JavaScript</code>语言的适度支持，以产生更小的功能，在插入功能管道时也能很好地工作。</p><h2 id="4-部分应用和函数绑定"><a href="#4-部分应用和函数绑定" class="headerlink" title="4 部分应用和函数绑定"></a>4 部分应用和函数绑定</h2><p>部分应用是一种通过将函数的不可变参数子集初始化为固定值来创建更小元数函数的操作。简单来说，如果存在一个具有五个参数的函数，给出三个参数后，就会得到一个、两个参数的函数。和柯里化一样，部分应用也可以用来缩短函数的长度，但又稍有不同。因为柯里化的函数本质上是部分应用的函数，所以这两种技术往往会被互相混淆。它们的主要区别在于参数传递的内部机制与控制。</p><p>柯里化在每次分步调用时都会生成嵌套的一元函数。在底层，函数的最终结果是由这些一元函数的逐步组合产生的。同时，curry 的变体允许同时传递一部分参数。因此，可以完全控制函数求值的时间与方式。</p><p>部分应用将函数的参数与一些预设值绑定（赋值），从而产生一个拥有更少参数的新函数。该函数的闭包中包含了这些已赋值的参数，在之后的调用中被完全求值。</p><p>现在，既然已经明确两者的不同，下面继续研究<code>partial</code>函数可能的实现方式，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">this</span>, boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">let</span> placeholder = &lt;&lt;partialPlaceholderObj&gt;&gt;; <span class="comment">// &lt;--- 库中的具体占位符实现，像 Lodash 会使用下画线对象作为占位符。其他的实现使用 undefined 来表示应该略过该参数</span></span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// &lt;--- 使用部分应用的参数创建新的函数</span></span><br><span class="line">        <span class="keyword">let</span> position = <span class="number">0</span>, length = args.length;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            args[i] = boundArgs[i] === placeholder <span class="comment">// &lt;--- 其中 placeholder 对象略过了定义函数的参数</span></span><br><span class="line">            ? <span class="built_in">arguments</span>[position++] : boundArgs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (position &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            args.push(<span class="built_in">arguments</span>[position++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args); <span class="comment">// &lt;--- 使用 fn.apply()给定函数合适的上下文，并将参数列表应用到函数的参数上</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于部分应用和函数绑定的讨论，再次使用<code>Lodash</code>，因为它对函数绑定提供了比<code>Ramda</code>更好的支持。然而从表面来看，<code>_.partial</code>与<code>R.curry</code>的使用方式非常相似，并且都支持使用各自的占位符对象对参数进行占位。应用于之前看到的 logger 函数，就通过部分应用部分参数来创建更具体的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> consoleLog = _.partial(logger, <span class="string">&quot;console&quot;</span>, <span class="string">&quot;json&quot;</span>, <span class="string">&quot;FJS Partial&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面用该函数加强对<code>curry</code>与<code>partial</code>之间差异的认识。在应用了三个参数之后，生成的<code>consoleLog</code>函数会在调用时接收另外的两个参数（一次性的，而不是一步一步地传入）。与柯里化不同，只使用一个参数调用<code>consoleLog</code>并不会返回一个新的函数，而是会以<code>undefined</code>作为最后一个参数<br>来执行。但是，可以像下面这样继续使用_.partial 将部分参数应用于<code>consoleLog</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> consoleInfoLog = _.partial(consoleLog, <span class="string">&quot;INFO&quot;</span>);</span><br><span class="line">consoleInfoLog(<span class="string">&quot;INFO logger configured with partial&quot;</span>);</span><br></pre></td></tr></table></figure><p>柯里化是一种部分应用的自动化使用方式，这是它与<code>partial</code>本身的主要区别。另一种类似的<code>JavaScript</code>原生技术称为函数绑定，即<code>Function.prototype.bind()</code>。但其作用与<code>partial</code>有所不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = _.bind(logger, <span class="literal">undefined</span>, <span class="string">&quot;console&quot;</span>, <span class="string">&quot;json&quot;</span>, <span class="string">&quot;FJS Binding&quot;</span>);</span><br><span class="line">log(<span class="string">&quot;WARN&quot;</span>, <span class="string">&quot;FP is too awesome!&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>_.bind</code>的第二个参数<code>undefined</code>是什么呢？使用绑定能够创建绑定函数，该函数可在一个所属对象的上下文中执行（传递<code>undefined</code>表示该函数将在全局作用域中运行）。来看看<code>_.partial</code>和<code>_.bind</code>的一些实际用途：</p><ul><li>核心语言扩展</li><li>惰性函数绑定</li></ul><h3 id="4-1-核心语言扩展"><a href="#4-1-核心语言扩展" class="headerlink" title="4.1 核心语言扩展"></a>4.1 核心语言扩展</h3><p>在增强语言的表现力方面，部分应用可用于扩展如 String 或 Number 这样的核心数据类型的实用功能。注意，如果语言中加入了可造成冲突的新方法，以这种方式扩展语言可能会使代码很难在平台升级的过程中移植。考虑下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Take the first N characters</span></span><br><span class="line"><span class="built_in">String</span>.prototype.first = _.partial(<span class="built_in">String</span>.prototype.substring, <span class="number">0</span>, _); <span class="comment">// &lt;--- 使用占位符，可以部分应用 substring 一个参数 0，从而创建期待一个偏移量参数的函数</span></span><br><span class="line"><span class="string">&quot;Functional Programming&quot;</span>.first(<span class="number">3</span>); <span class="comment">// -&gt; &#x27;Fun&#x27;</span></span><br><span class="line"><span class="comment">// Convert any name into a Last, First format</span></span><br><span class="line"><span class="built_in">String</span>.prototype.asName = _.partial(</span><br><span class="line">  <span class="built_in">String</span>.prototype.replace,</span><br><span class="line">  <span class="regexp">/(\w+)\s(\w+)/</span>,</span><br><span class="line">  <span class="string">&quot;$2, $1&quot;</span></span><br><span class="line">); <span class="comment">// &lt;--- 部分应用参数来创建具体的行为</span></span><br><span class="line"><span class="string">&quot;Alonzo Church&quot;</span>.asName(); <span class="comment">//-&gt; &#x27;Church, Alonzo&#x27;</span></span><br><span class="line"><span class="comment">// Converts a string into an array</span></span><br><span class="line"><span class="built_in">String</span>.prototype.explode = _.partial(<span class="built_in">String</span>.prototype.match, <span class="regexp">/[\w]/gi</span>); <span class="comment">// &lt;--- 部分应用 match 方法，给定具体的正则表达式，得到能将字符串转换成数组的函数</span></span><br><span class="line"><span class="string">&quot;ABC&quot;</span>.explode(); <span class="comment">//-&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line"><span class="comment">// Parses a simple URL</span></span><br><span class="line"><span class="built_in">String</span>.prototype.parseUrl = _.partial(</span><br><span class="line">  <span class="built_in">String</span>.prototype.match, <span class="comment">//&lt;--- 部分应用 match 方法，给定具体的正则表达式，得到能将字符串转换成数组的函数</span></span><br><span class="line">  <span class="regexp">/(http[s]?|ftp):\/\/([^:\/\s]+)\.([^:\/\s]&#123;2,5&#125;)/</span></span><br><span class="line">);</span><br><span class="line"><span class="string">&quot;http://example.com&quot;</span>.parseUrl(); <span class="comment">// -&gt; [&#x27;http&#x27;, &#x27;example&#x27;, &#x27;com&#x27;]</span></span><br></pre></td></tr></table></figure><p>在实现自己的函数之前，首先要进行存在性检查，以便适用于新的语言版本升级：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">String</span>.prototype.explode) &#123;</span><br><span class="line">  <span class="built_in">String</span>.prototype.explode = _.partial(<span class="built_in">String</span>.prototype.match, <span class="regexp">/[\w]/gi</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些特定情况下，部分应用会失效，例如当用于（如<code>setTimeout</code>）延迟函数时。这时就需要使用函数绑定来实现。</p><h3 id="4-2-延迟函数绑定"><a href="#4-2-延迟函数绑定" class="headerlink" title="4.2 延迟函数绑定"></a>4.2 延迟函数绑定</h3><p>当期望目标函数使用某个所属对象来执行时，使用函数绑定来设置上下文对象就变得尤为重要。</p><p>例如，浏览器中的<code>setTimeout</code>和<code>setInterval</code>等函数，如果不将 this 的引用设为全局上下文，即<code>window</code>对象，是不能正常工作的。传递 undefined 在运行时正确设置它们的上下文。例如，<code>setTimeout</code>可用于创建一个简单的调度对象来执行延迟的任务。以下是使用<code>_.bind</code> 和<code>_.partial</code>的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scheduler = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> delayedFn = _.bind(<span class="built_in">setTimeout</span>, <span class="literal">undefined</span>, _, _);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">delay5</span>: _.partial(delayedFn, _, <span class="number">5000</span>),</span><br><span class="line">    <span class="attr">delay10</span>: _.partial(delayedFn, _, <span class="number">10000</span>),</span><br><span class="line">    <span class="attr">delay</span>: _.partial(delayedFn, _, _),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">Scheduler.delay5(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  consoleLog(<span class="string">&quot;Executing After 5 seconds!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>Scheduler</code>，可以将任何一段代码包含在函数体中延迟的执行（运行时是无法确保计时器的精准的，但这是另一个问题）。由于 <code>bind</code> 和 <code>partial</code> 都是返回另一个函数的函数，因此可以很容易地嵌套使用。如前面的代码所示，每一个延迟操作都基于函数绑定和部分应用函数的合。在函数式编程中，函数绑定并不像部分应用那么有用，而且使用起来也比较投机，因为它会重新设置函数的上下文。</p><p>部分应用和柯里化都是十分有用的技术。柯里化技术使用得非常广泛，通常用于创建可抽象函数行为的函数包装器，可预设其参数或对其部分求值。其优势源于具有较少参数的纯函数比较多参数的函数更易使用。两种方法都有助于向函数提供正确的参数，这样函数就不必在减少为一元函数时公然地访问其作用域之外的对象。这种分离参数获取逻辑的方式使得函数具有更好的可重用性。更重要的是，它简化了函数的组合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;三-函数式编程——模块化且可重用的代码&quot;&gt;&lt;a href=&quot;#三-函数式编程—</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 var，let 和 const 有什么区别</title>
    <link href="http://example.com/2021/02/05/JavaScript%20%E4%B8%AD%E7%9A%84%20var%EF%BC%8Clet%20%E5%92%8C%20const%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/02/05/JavaScript%20%E4%B8%AD%E7%9A%84%20var%EF%BC%8Clet%20%E5%92%8C%20const%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2021-02-05T13:09:05.000Z</published>
    <updated>2022-01-06T01:34:32.127Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="区别概述"><a href="#区别概述" class="headerlink" title="区别概述"></a>区别概述</h2><ul><li>变量提升</li><li>暂时性死区</li><li>块级作用域</li><li>重复声明</li><li>修改声明的变量</li><li>使用</li></ul><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>var 声明的变量存在提升，即变量可以在声明之前调用，提升时不做初始化操作，故只为 undefined</p><p>let、const 不存在变量提升，故而用这两个关键字时，一定要在声明后使用</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>var 不存在暂时性死区</p><p>let、const 存在暂时性死区，在变量被声明之后，才可以获取或使用该变量</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>var 不存在块级作用域</p><p>let、const 存在块级作用域</p><h3 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h3><p>var 允许重复声明变量</p><p>let 和 const 在同一作用域不允许重复声明变量</p><h3 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h3><p>var 和 let 可以随意修改声明的变量的值</p><p>const 一般用来声明一个只读的常量，一旦声明，常量的值就不能改变。<br>但实际上 const 保证的是变量指向的内存地址不变</p><ul><li>对于简单类型的数据，值就保存在变量指向的内存地址，因此等同于常量。</li><li>对于复杂类型的数据，变量指向的内存地址保存的是一个指向实际数据的指针，const 只能保证这个指针是固定的，至于实际指向的数据是可以变的</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var">面试官：说说 var、let、const 之间的区别</a><br><a href="https://es6.ruanyifeng.com/#docs/let">let 和 const 命令</a><br><a href="https://chinese.freecodecamp.org/news/javascript-var-let-and-const/">JavaScript 中的 Var，Let 和 Const 有什么区别</a><br><a href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson09.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88scope%EF%BC%89">块级作用域：var 缺陷以及为什么要引入 let 和 const</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;区别概述&quot;&gt;&lt;a href=&quot;#区别概述&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记:Javascript函数式编程指南（二）</title>
    <link href="http://example.com/2021/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2021/01/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0:Javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-01-15T03:33:09.000Z</published>
    <updated>2021-08-08T03:05:36.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>今日分享: 如何创建易于推断的代码</p><h2 id="轻数据结构，重操作"><a href="#轻数据结构，重操作" class="headerlink" title="轻数据结构，重操作"></a>轻数据结构，重操作</h2><h3 id="理解程序中控制流"><a href="#理解程序中控制流" class="headerlink" title="理解程序中控制流"></a>理解程序中控制流</h3><p>程序为实现业务目标所要进行的路径被成为控制流。 命令式程序需要通过暴露所有的必要步骤才能极其详细地描述其控制流。这些步骤通常涉及大量的循环和分支，以及随语句执行变化的各种变量。</p><p>简单的命令式程序大致可以这样描述:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loop = optC();</span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">  <span class="keyword">var</span> condition = optA();</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    optB1();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    optB2();</span><br><span class="line">  &#125;</span><br><span class="line">  loop = optC();</span><br><span class="line">&#125;</span><br><span class="line">optD();</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://i.loli.net/2021/08/08/Oyv9LmXzZtJo4MS.png"></p><p>然而，声明式程序，特别是函数式程序，则多使用以简单拓扑连接的独立黑盒操作组合而成的较小结构化控制流，从而提升程序的抽象层次。</p><p>这些连接在一起的操作只是一些能够将状态传递至下一个操作的高阶函数，如下图所示。使用函数式开发风格操作数据结构，其实就是将数据与控制流视为一些高级组件的简单连接。</p><p>使用这种方式可以形成类似这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optA().optB().optC().optD();</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/08/qiv7BhkpG5K3ry2.png"></p><p>采用这种链式操作能够使程序简洁、流畅并富有表现力，能够从计算逻辑中很好地分离控制流，因此可以使得代码和数据更易推理。</p><h3 id="链接方法"><a href="#链接方法" class="headerlink" title="链接方法"></a>链接方法</h3><p>方法链是一种能够在一个语句中调用多个方法的面向对象编程模式。当这些方法属于同一个对象时，方法链又称为方法级联。</p><p>尽管该模式大多出现在面向对象的应用程序中，但在一些特定条件下，如操作不可变对象时，也能很好地用于函数式编程中。</p><p>既然在函数式代码中是禁止修改对象的，又如何能使用这种方法链模式呢？让我们来看一个字符串处理的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Functional Programming&quot;</span>.substring(<span class="number">0</span>, <span class="number">10</span>).toLowerCase() + <span class="string">&quot; is fun&quot;</span>;</span><br></pre></td></tr></table></figure><p>在这个中，<code>substring</code> 和 <code>toLowerCase</code> 都是（通过 this）在隶属的字符串对象上操作并返回一个新字符串的方法。JavaScript 中字符串的加号（+）运算符被重载为连接字符串操作的语法糖，它也会返回一个新的字符串。通过一系列变换后的结果与原先字符串毫无引用关系，而原先的字符串也不会有任何变化。</p><p>这种行为是理所当然的，因为按照设计，字符串是不可变的。从面向对象的角度来看，这没有什么特别的。但从函数式编程的角度来看，这是一种理想行为。</p><p>如果用更加函数式的风格重构上面的代码，它会像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(toLowerCase(substring(<span class="string">&#x27;Functional Programming&#x27;</span>, <span class="number">1</span>, <span class="number">10</span>))),<span class="string">&#x27; is fun&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这段代码符合函数式风格，所有参数都应在函数声明中明确定义，而且它没有副作用，也不会修改的原有对象。</p><p>但可以说，这样的代码写起来并没有方法链流畅。而且它也更难阅读，因为需要一层层地剥离外部函数，才能知晓内部真正发生的事情。</p><p>只要遵守不可变的编程原则，函数式中也会应用这种隶属于单个对象实例的方法链。能用该模式来处理数组变换吗？</p><h3 id="函数链"><a href="#函数链" class="headerlink" title="函数链"></a>函数链</h3><p>面向对象程序将继承作为代码重用的主要机制。子类继承了父类的所有状态和方法，例如在 Java 中，有一大堆继承于基础接口 List 的各种实体 List 类，如 ArrayList、LinkedList、DoublyLinkedList、CopyOnWrite ArrayList 等，它们都源自共同的父类，并各自添加了一些特定的功能。</p><p>函数式编程则采用了不同的方式。它不是通过创建一个全新的数据结构类型来满足特定的需求，而是使用如数组这样的普通类型，并施加在一套粗粒度的高阶操作之上，这些操作是底层数据形态所不可见的。</p><p>这些操作会作如下设计:</p><ul><li><p>接收函数作为参数，以便能够注入解决特定任务的特定行为。</p></li><li><p>代替充斥着临时变量与副作用的传统循环结构，从而减少所要维护以及可能出错的代码。</p></li></ul><p>继续之前，我们先看一些东西并暂时记住它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">firstname, lastname, ssn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._firstname = firstname;</span><br><span class="line">    <span class="built_in">this</span>._lastname = lastname;</span><br><span class="line">    <span class="built_in">this</span>._ssn = ssn;</span><br><span class="line">    <span class="built_in">this</span>._address = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>._birthYear = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">ssn</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._ssn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">firstname</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._firstname;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">lastname</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._lastname;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">address</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">birthYear</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._birthYear;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">birthYear</span>(<span class="params">year</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._birthYear = year;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">address</span>(<span class="params">addr</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._address = addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Person(<span class="subst">$&#123;<span class="built_in">this</span>._firstname&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>._lastname&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Haskell&quot;</span>, <span class="string">&quot;Curry&quot;</span>, <span class="string">&quot;111-11-1111&quot;</span>);</span><br><span class="line">p1.address = <span class="keyword">new</span> Address(<span class="string">&quot;US&quot;</span>);</span><br><span class="line">p1.birthYear = <span class="number">1900</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Barkley&quot;</span>, <span class="string">&quot;Rosser&quot;</span>, <span class="string">&quot;222-22-2222&quot;</span>);</span><br><span class="line">p2.address = <span class="keyword">new</span> Address(<span class="string">&quot;Greece&quot;</span>);</span><br><span class="line">p2.birthYear = <span class="number">1907</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;von Neumann&quot;</span>, <span class="string">&quot;333-33-3333&quot;</span>);</span><br><span class="line">p3.address = <span class="keyword">new</span> Address(<span class="string">&quot;Hungary&quot;</span>);</span><br><span class="line">p3.birthYear = <span class="number">1903</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> Person(<span class="string">&quot;Alonzo&quot;</span>, <span class="string">&quot;Church&quot;</span>, <span class="string">&quot;444-44-4444&quot;</span>);</span><br><span class="line">p4.address = <span class="keyword">new</span> Address(<span class="string">&quot;US&quot;</span>);</span><br><span class="line">p4.birthYear = <span class="number">1903</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/08/Guis8KPxqvYewbA.png"></p><h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>lambda 表达式（在 JavaScript 中也被称为箭头函数）源自函数式编程，比起传统的函数声明，它可以采用相对简洁的语法形式来声明一个匿名函数。</p><p>尽管 lambda 函数也可以写成多行形式，但单行是最普遍的形式。使用 lambda 表达式或普通函数声明语法一般只会影响到代码的可读性，其本质是一样的。</p><p>下面是一个可用于提取个人姓名的示例函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="function">(<span class="params">p</span>) =&gt;</span> p.fullname;</span><br><span class="line"><span class="built_in">console</span>.log(name(p1)); <span class="comment">//-&gt; &#x27;Haskell Curry&#x27;</span></span><br></pre></td></tr></table></figure><p><code>(P) =&gt; p.fullname</code> 这种简洁的语法糖表明它只接收一个参数 p 并隐式地返回 p.fullname。</p><p>lambda 表达式适用于函数式的函数定义，因为它总是需要返回一个值。对于单行表达式，其返回值就是函数体的值。</p><p>另一个值得注意的是一等函数与 lambda 表达式之间的关系。函数名代表的不是一个具体的值，而是一种（惰性计算的）可获取其值的描述。换句话说，函数名指向的是代表着如何计算该数据的箭头函数。这就是在函数式编程中可以将函数作为数值使用的原因。<br>之后会深入讨论惰性计算函数。</p><p>很多函数式的 JavaScript 代码都需要处理数据列表，这也就是衍生 JavaScript 的函数式语言鼻祖起名为 <code>LISP</code>（列表处理）的原因。JavaScript 5.1 本身就提供特定版本的该类操作——称为函数式<code>array extras</code>,也就是<code>forEach</code>、<code>map``reduce</code> 以及 <code>filter</code> 这些函数，它们都能够与 <code>lambda</code> 表达式良好地配合使用。</p><h3 id="代码推理"><a href="#代码推理" class="headerlink" title="代码推理"></a>代码推理</h3><p>“代码推理”到底是什么意思呢？</p><p>之前的章节用“松散”这个词来表征分析一个程序任何一个部分，并建立相应心智模型的难易程度。</p><p>该模型分为两部分：动态部分包括所有变量的状态和函数的输出，而静态部分包含可读性以及设计的表达水平。</p><p>两个部分都很重要。不可变性和纯函数会使得该模型的构建更加容易。之前的内容强调将高阶操作链接起来构成程序的价值。</p><p>命令式的程序流与函数式的程序流有着本质的不同。函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的。</p><h4 id="声明式惰性计算函数链"><a href="#声明式惰性计算函数链" class="headerlink" title="声明式惰性计算函数链"></a>声明式惰性计算函数链</h4><p>之前提到，函数式程序是由一些简单函数组成的，尽管每个函数只完成一小部分功能，但组合在一起就能够解决很多复杂的任务。</p><p>函数式编程的声明式模型将程序视为对一些独立的纯函数的求值，从而在必要的抽象层次之上构建出流畅且表达清晰的代码。这样就可以构成一个能够清晰表达应用程序意图的本体或词汇表。使用如<code>map</code>、<code>reduce</code> 和 <code>filter</code> 这样的基石来搭建纯函数，可使代码易于推理并一目了然。</p><p>这个层次的抽象的强大之处在于，它会使开发者开始认识到各种操作应该对所采用的底层数据结构不可见。从理论上说，无论是使用数组、链表、二叉树还是其他数据结构，它都不应该改变程序原本的语义。正是出于这个原因，函数式编程选择更关注于操作而不是数据结构。</p><p>例如，假设需要对一组姓名进行读取、规范化、去重，最终进行排序。首先写一个命令式的版本，然后再重构成函数式的风格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [</span><br><span class="line">  <span class="string">&quot;alonzo church&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Haskell curry&quot;</span>,</span><br><span class="line">  <span class="string">&quot;stephen_kleene&quot;</span>,</span><br><span class="line">  <span class="string">&quot;John Von Neumann&quot;</span>,</span><br><span class="line">  <span class="string">&quot;stephen_kleene&quot;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">  <span class="comment">//&lt;--- 遍历数组中的所有名字</span></span><br><span class="line">  <span class="keyword">let</span> n = names[i];</span><br><span class="line">  <span class="keyword">if</span> (n !== <span class="literal">undefined</span> &amp;amp;&amp;amp; n !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//&lt;--- 检查所有词是否都合法</span></span><br><span class="line">    <span class="keyword">let</span> ns = n.replace(<span class="regexp">/_/</span>, <span class="string">&quot; &quot;</span>).split(<span class="string">&quot; &quot;</span>); <span class="comment">//&lt;--- 数组包含格式不一致的数据。这是规范化（修复）元素的步骤</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; ns.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = ns[j];</span><br><span class="line">      p = p.charAt(<span class="number">0</span>).toUpperCase() + p.slice(<span class="number">1</span>);</span><br><span class="line">      ns[j] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.indexOf(ns.join(<span class="string">&quot; &quot;</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//&lt;--- 检查是否已存在于结果中，以去除重复的元素</span></span><br><span class="line">      result.push(ns.join(<span class="string">&quot; &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">result.sort(); <span class="comment">// &lt;--- 数组排序</span></span><br></pre></td></tr></table></figure><p>命令式代码的缺点是限定于高效地解决某个特定的问题。例如，这段代码用于解决上述的问题。比起函数式代码，其抽象水平要低得多。抽象层次越低，代码重用的概率就会越低，出现错误的复杂性和可能性就会越大。此外，函数式的实现不过是将各种黑盒组件连接在一起，将重任赋予如<code>map</code>、<code>reduce</code> 和 <code>filter</code>这些成熟且经过测试的 API。请注意，级联排列的函数调用可以使该代码更易阅读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names) <span class="comment">//&lt;--- 初始化函数链（创建惰性计算函数链来处理给定的数组）</span></span><br><span class="line">  .filter(isValid) <span class="comment">//&lt;--- 去除非法值</span></span><br><span class="line">  .map(<span class="function">(<span class="params">s</span>) =&gt;</span> s.replace(<span class="regexp">/_/</span>, <span class="string">&quot; &quot;</span>)) <span class="comment">//&lt;--- 规范化值</span></span><br><span class="line">  .uniq() &lt;</span><br><span class="line">  ---去掉重复元素</span><br><span class="line">    .map(_.startCase) <span class="comment">//&lt;--- 大写首字母</span></span><br><span class="line">    .sort()</span><br><span class="line">    .value(); <span class="comment">//&lt;--- 执行函数链中的所有函数</span></span><br><span class="line"><span class="comment">//-&gt; [&#x27;Alonzo Church&#x27;, &#x27;Haskell Curry&#x27;, &#x27;Jon Von Neumann&#x27;, &#x27;Stephen Kleene&#x27;]</span></span><br></pre></td></tr></table></figure><p>这样的代码看起来舒服很多，不仅是因为代码量的减少，还因为其结构简单明了。</p><p>现在我们可以更深刻明白为什么函数式的程序是如此优越。能够写得如此流畅与函数式编程中的纯性以及无副作用的基本原则息息相关。链中的每个函数都以一种不可变的方式来处理由上一个函数构建的新数组。Lodash 利用函数链这种模式，通过调用_.chain()提供了一种基础功能，以满足各种需求。这有助于过渡到对 point-free 编程风格的理解。pointfree 是函数式编程的特色，会在之后分享。</p><p>能够惰性地定义程序的管道不止有可读性这一个好处。由于以惰性计算方式编写的程序会在运行前定义好，因此可以使用数据结构重用或者方法融合等技术对其进行优化。这些优化不会减少执行函数本身所需的时间，但有助于消除不必要的调用。之后会更详细解释。</p><h4 id="类-SQL-的数据：函数即数据"><a href="#类-SQL-的数据：函数即数据" class="headerlink" title="类 SQL 的数据：函数即数据"></a>类 SQL 的数据：函数即数据</h4><p>比如<code>map</code>、<code>reduce</code>、<code>filter</code>等。将这些函数组成一个列表，可用来梳理数据相关的信息。如果在更高层面细细思考，就会发现这些函数与<code>SQL</code>相似，这不是偶然的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.firstname, p.birthYear <span class="keyword">FROM</span> Person p</span><br><span class="line"><span class="keyword">WHERE</span> p.birthYear <span class="operator">&gt;</span> <span class="number">1903</span> <span class="keyword">and</span> p.country <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="string">&#x27;US&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> p.firstname, p.birthYear</span><br></pre></td></tr></table></figure><p>事实证明，在构建程序时，使用查询语言来思考与函数式编程中操作数组类似——使用通用关键字表或代数方法来增强对数据及其结构的深层次思考。</p><p>Lodash 支持一种称为 mixins 的功能，可以用来为核心库扩展新的函数，并使得它们可以以相同的方式连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.mixin(&#123;</span><br><span class="line">  <span class="attr">select</span>: _.pluck,</span><br><span class="line">  <span class="attr">from</span>: _.chain,</span><br><span class="line">  <span class="attr">where</span>: _.filter,</span><br><span class="line">  <span class="attr">groupBy</span>: _.sortByOrder,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>编写类似 SQL 的 JavaScript 代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_.from(persons)</span><br><span class="line">  .where(<span class="function">(<span class="params">p</span>) =&gt;</span> p.birthYear &gt; <span class="number">1900</span> &amp;amp;&amp;amp; p.address.country !== <span class="string">&quot;US&quot;</span>)</span><br><span class="line">  .groupBy([<span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;birthYear&quot;</span>])</span><br><span class="line">  .select(<span class="string">&quot;firstname&quot;</span>, <span class="string">&quot;birthYear&quot;</span>)</span><br><span class="line">  .value();</span><br><span class="line"><span class="comment">//-&gt; [&#x27;Alan&#x27;, &#x27;Barkley&#x27;, &#x27;John&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面的代码创建了一个 SQL 关键字到对应别名函数的映射，从而可以更深刻地理解一个查询语言的函数式特性。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>另一种用于替换循环的常见技术是递归，尤其当处理一些“自相似”的问题时，可以用其来抽象迭代。对于这些类型的问题，序列函数链会显得效率低下或不适用。而递归实现了自己的处理数据的方式，从而大大缩短了标准循环的执行时间。</p><p>在 JavaScript 中，递归具有许多应用场景，例如解析 XML、HTML 文档或图形等。</p><h4 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h4><p>递归是一种旨在通过将问题分解成较小的自相似问题来解决问题本身的技术，将这些小的自相似问题结合在一起，就可以得到最终的解决方案。递归函数包含以下两个主要部分。</p><ul><li>基例（终止条件）</li><li>递归条件</li></ul><p>基例是能够令递归函数计算出具体结果的一组输入，而不必再重复下去。递归条件则处理函数调用自身的一组输入（必须小于原始值）。如果输入不变小，那么递归就会无限期地运行，直至程序崩溃。</p><p>随着函数的递归，输入会无条件地变小，最终到达触发基例的条件，以一个值作为递归过程的终止。</p><p>栗子：递归求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_.isEmpty(arr)) &#123; <span class="xml">&lt;---//  基例（终止条件）</span></span><br><span class="line"><span class="xml">        return 0;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return _.first(arr) + sum(_.rest(arr)); //&lt;--- 递归条件：使用更小一些的输入集调用自身。这里通过_.first和_.rest缩减输入集</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">sum([]); //-&gt; 0</span></span><br><span class="line"><span class="xml">sum([1,2,3,4,5,6,7,8,9]); //-&gt;</span><span class="number">45</span></span><br></pre></td></tr></table></figure><h4 id="递归定义的数据结构"><a href="#递归定义的数据结构" class="headerlink" title="递归定义的数据结构"></a>递归定义的数据结构</h4><p>person 对象示例数据中的那些名字。20 世纪 20 年代，函数式编程（lambda 演算、范畴论等）背后的数学社区非常活跃。大部分发表的研究成果都是融合一些由 Alonzo Church 这样的知名大学教授提出的思想和定理。事实上，许多数学家，如 Barkley Rosser、Alan Turing 和 Stephen Kleene 等，都是 Church 的博士生。后来他们也有了自己的博士生。下图为这种师徒关系（的一部分）的示意图。</p><p><img src="https://i.loli.net/2021/08/08/2z79CousSLvyHqc.png"></p><p>这种结构在软件中是很寻常的，它可用于建模 XML 文档、文件系统、分类法、种别、菜单部件、逐级导航、社交图谱等，所以学习如何处理它们至关重要。图 3.8 显示了一组节点，其连线表示了导师-学生这一关系。到目前为止，我们已经利用函数式技术解析过一些扁平化的数据结构，如数组。但这些操作对树形数据是无效的。因为 JavaScript 没有内置的树型对象，所以需要基于节点创建一种简单的数据结构。节点是一种包含了当前值、父节点引用以及子节点数组的对象。</p><p>节点对象的定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._val = val;</span><br><span class="line">        <span class="built_in">this</span>._parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>._children = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">isRoot</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValid(<span class="built_in">this</span>._parent); &lt;--- 之前创建的函数</span><br><span class="line">    &#125;</span><br><span class="line">    get children() &#123;</span><br><span class="line">        return this._children;</span><br><span class="line">    &#125;</span><br><span class="line">    hasChildren() &#123;</span><br><span class="line">        return this._children.length &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    get value() &#123;</span><br><span class="line">        return this._val;</span><br><span class="line">    &#125;</span><br><span class="line">    set value(val) &#123;</span><br><span class="line">        this._val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    append(child) &#123;</span><br><span class="line">        child._parent = this; //&lt;--- 设置父节点</span><br><span class="line">        this._children.push(child); //&lt;--- 将孩子节点加入孩子列表中</span><br><span class="line">        return this; //&lt;--- 返回该节点（便于方法级联）</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        return `Node (val: $&#123;this._val&#125;, children: $&#123;this._children.length&#125;)`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样创建一个新节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> church = <span class="keyword">new</span> Node(<span class="keyword">new</span> Person(<span class="string">&quot;Alonzo&quot;</span>, <span class="string">&quot;Church&quot;</span>, <span class="string">&quot;111-11-1111&quot;</span>)); <span class="comment">// &lt;--- 重复树中的所有节点</span></span><br></pre></td></tr></table></figure><p>树是包含了一个根节点的递归定义的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._root = root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">map</span>(<span class="params">node, fn, tree = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//&lt;--- 使用静态方法以免与Array.prototype.map 混淆。静态方法也能像单例函数一样高效</span></span><br><span class="line">    node.value = fn(node.value); <span class="comment">//&lt;--- 调用遍历器函数，并更新树中的节点值</span></span><br><span class="line">    <span class="keyword">if</span> (tree === <span class="literal">null</span>) &#123;</span><br><span class="line">      tree = <span class="keyword">new</span> Tree(node); <span class="comment">//&lt;--- 与 Array.prototype.map 类似。结果是一个新的结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.hasChildren()) &#123;</span><br><span class="line">      <span class="comment">//&lt;--- 如果节点没有孩子，则返回（基例）</span></span><br><span class="line">      _.map(node.children, <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;--- 将函数应用到每一个孩子节点</span></span><br><span class="line">        Tree.map(child, fn, tree); <span class="comment">//&lt;--- 递归地调用每一个孩子节点</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">root</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点的主要逻辑在于 <code>append</code> 方法。要给一个节点追加一个子节点，需要将该节点设置为子节点的 parent 引用，并把子节点添加至该节点的子节点列表中。通过从根部不断地将节点链接到其他子节点来填充一棵树，由 church 开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">church.append(rosser).append(turing).append(kleene);</span><br><span class="line">kleene.append(nelson).append(constable);</span><br><span class="line">rosser.append(mendelson).append(sacks);</span><br><span class="line">turing.append(gandy);</span><br></pre></td></tr></table></figure><p>每个节点都包裹着一个 person 对象。递归算法执行整个树的先序遍历，从根开始并且下降到所有子节点。由于其自相似性，从根节点遍历树和从任何节点遍历子树是完全一样的，这就是递归定义。为此，可以使用与 Array.prototype.map 语义类似的高阶函数 Tree.map——它接收一个对每个节点求值的函数。可以看出，无论用什么数据结构来建模（这里是树形数据结构），该函数的语义应该保持不变。从本质上讲，任何数据类型都可以使用 map 并保持其结构不变。</p><p>树的先序遍历按照以下步骤执行，从根节点开始。</p><ul><li>显示根元素的数据部分。</li><li>通过递归地调用先序函数来遍历左子树。</li><li>以相同的方式遍历右子树。</li></ul><p>下图显示了算法采用的路径：<br><img src="/tdl/tfl/pictures/202101/tapd_20278041_1610076259_80.png" alt="5.png"></p><p>函数 Tree.map 有两个必需的输入：根节点（即树的开始）以及转换每个节点数值的迭代函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree.map(church, <span class="function">(<span class="params">p</span>) =&gt;</span> p.fullname);</span><br></pre></td></tr></table></figure><p>它以先序方式遍历树，并将给定的函数应用于每个节点，输出以下结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Alonzo Church&#x27;</span>, <span class="string">&#x27;Barkley Rosser&#x27;</span>, <span class="string">&#x27;Elliot Mendelson&#x27;</span>, <span class="string">&#x27;Gerald Sacks&#x27;</span>, <span class="string">&#x27;Alan</span></span><br><span class="line"><span class="string">Turing&#x27;</span>, <span class="string">&#x27;Robin Gandy&#x27;</span>, <span class="string">&#x27;Stephen Kleene&#x27;</span>, <span class="string">&#x27;Nels Nelson&#x27;</span>, <span class="string">&#x27;Robert Constable&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用<code>map</code>、<code>reduce</code>和<code>filter</code>等高阶函数来编写高可扩展的代码。</li><li>使用 Lodash 进行数据处理，通过控制链创建控制流与数据变换明确分离的程序。</li><li>使用声明式的函数式编程能够构建出更易理解的程序。</li><li>将高阶抽象映射到 SQL 语句，从而深刻地认识数据。</li><li>递归能够解决自相似问题，并解析递归定义的数据结构。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今日分享: 如何创建易于推断的代码&lt;/p&gt;
&lt;h2 id=&quot;轻数据结构，重操作&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据类型</title>
    <link href="http://example.com/2021/01/09/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2021/01/09/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-01-09T12:11:11.000Z</published>
    <updated>2022-02-09T08:14:18.934Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://s2.loli.net/2022/02/09/7tgouUPNym1jK6A.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思维导图&quot;&gt;&lt;a href=&quot;#思维导图&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="思维导图" scheme="http://example.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Redux记录</title>
    <link href="http://example.com/2020/12/03/Redux%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2020/12/03/Redux%E8%AE%B0%E5%BD%95/</id>
    <published>2020-12-03T13:51:44.000Z</published>
    <updated>2022-01-24T10:27:17.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Redux是一个使用叫做<code>action</code>的事件来管理和更新应用状态的模式和工具库，它以集中式Store的方式对整个应用中使用的状态进行集中管理，其规则确保状态只能以可预测的方式更新。</p><h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ul><li><p>单一的数据源<br>  整个应用的<code>state</code>被存储在一棵<code>object tree</code>中，并且这个<code>object tree</code>只存在于唯一一个store中</p></li><li><p>State 是只读的<br>  改变<code>state</code>的方法就是触发<code>action</code>，<code>action</code>是一个用于描述已发生事件的普通对象</p></li><li><p>使用纯函数来执行修改<br>  为了描述<code>action</code>如何改变<code>state tree</code>，需要编写<code>reducers</code></p></li></ul><h2 id="一些重要的概念"><a href="#一些重要的概念" class="headerlink" title="一些重要的概念"></a>一些重要的概念</h2><ul><li><p>Action</p><ul><li><code>Action</code>是把数据从应用传到<code>store</code>的有效载荷。它是<code>store</code>数据的唯一来源</li><li>一般来说会通过<code>store.dispatch()</code>将<code>action</code>传到<code>store</code></li><li><code>Action</code>本质上<code>JavaScript</code>普通对象，约定<code>action</code>内必须使用一个字符串对象<code>type</code>字段来表示将要执行的动作</li></ul></li><li><p>Action创建函数</p><ul><li><code>Action创建函数</code>就是生成<code>action</code>的方法,这样做将使<code>action</code>创建函数更容易被移植和测试</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Reducer</p><ul><li><code>Reducers</code>指定了应用状态的变化如何响应<code>actions</code>并发送到<code>store</code>的,记住<code>actions</code>只是描述了有事情发生了这一事实，并没有描述如何更新<code>state</code></li><li><code>reducer</code>就是一个纯函数，接收旧的<code>state</code>和<code>action</code>，返回新的<code>state</code>:<code>(previousState, action) =&gt; newState</code></li></ul></li><li><p>Store<br><code>Store</code>有以下职责：</p><ul><li>维持应用的<code>state</code></li><li>提供<code>getState()</code>方法获取<code>state</code></li><li>提供<code>dispatch(action)</code>方法更新<code>state</code></li><li>通过<code>subscribe（listener)</code>注册监听器，并能够能够其返回的函数注销监听器</li></ul></li><li><p>Middleware</p></li></ul><p>相对于<code>Express</code>或者<code>Koa</code>的<code>middleware</code>，<code>Redux middleware</code>被用于解决不同的问题，但其中的概念是类似的。<strong>它提供的是位于<code>action</code>被发起之后，到达<code>reducer</code>之前的扩展点。</strong> 你可以利用<code>Redux middleware</code>来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p><code>Redux</code>使用<code>单向数据流</code></p><ul><li><code>State</code>描述了应用程序在特定时间点的状况</li><li>基于<code>state</code>来渲染UI</li><li>当发生某些事情时（例如用户点击按钮），<code>state</code>会根据发生的事情进行更新</li><li>基于新的<code>state</code>重新渲染UI</li></ul><p>将这些步骤分解为更详细的内容:</p><ul><li><p>初始启动</p><ul><li>使用最顶层的 root reducer 函数常见 Redux store</li><li>store 调用一次root reducer，并将返回值保存为它的初始 state</li><li>当UI首次渲染时，UI组件访问 Redux store 的当前 state，并使用该数据来决定要呈现的内容。同时监听 store 的更新，以便它们可以知道 state 是否已更改</li></ul></li><li><p>更新环节</p><ul><li>应用程序中发生了某些事情，例如用户点击按钮</li><li>dispatch 一个 action 到 React store</li><li>store 用之前的 state 和当前的 action 再次运行 reducer 函数，并将返回值保存为新的 state</li><li>store 通知所有订阅过的UI，通知它们 store 发生更新</li><li>每个订阅过 store 数据的UI组件都会检查它们需要的 state 部分是否被更新</li><li>发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页</li></ul></li></ul><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ul><li><p>Reducer的规则</p><p>  Reducer必须符合以下规则：</p><ul><li><p>仅使用<code>state</code>和action参数计算新的状态值</p></li><li><p>禁止直接修改state。必须通过复制现有的state并对复制的值进行更改的方式来做不可变更新</p></li><li><p>禁止任何异步逻辑、依赖随机值或导致其它副作用的代码</p><p>为什么这些规则很重要？</p></li><li><p>Redux的目标之一是使代码可预测。当函数的输出仅根据输入参数计算时，更容易理解该代码的工作原理并对其进行测试</p></li><li><p>如果一个函数依赖于自身之外的变量，或者行为随机，你永远不知道运行时它会发生什么</p></li><li><p>如果一个函数 mutate 了其它对象，比如它的参数，这可能会意外地改变应用程序的工作方式</p></li><li><p>Redux DevTools 的一些功能取决于你的 reducer 是否正确遵循这些规则</p></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://cn.redux.js.org/">Redux 中文官网</a></p><p><a href="https://www.redux.org.cn/">Redux 中文文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redux" scheme="http://example.com/tags/Redux/"/>
    
  </entry>
  
</feed>
