<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可乐加冰</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-07T05:59:13.910Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>HJY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise规范翻译</title>
    <link href="http://example.com/2020/11/09/PromisesA+%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/"/>
    <id>http://example.com/2020/11/09/PromisesA+%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/</id>
    <published>2020-11-09T13:30:40.000Z</published>
    <updated>2021-08-07T05:59:13.910Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><a href="https://promisesaplus.com/">原文</a></p><p>一个开放标准,通用的 JavaScript promise ,由开发者制定，供开发者使用。</p><p>Promise 用于表示一个异步操作的最终结果。与 Promise 交互的主要方式为<code>then</code>方法,该方法注册回调函数以接收 promise 的成功的结果或者失败的原因。</p><p>该规范详细说明了<code>then</code>方法的行为,所有基于 Promise/A+规范实现的 Promise 都必须以此为基础实现。因此规范应该非常稳定。尽管 Promises/A+组织可能会偶尔修改此规范以向后兼容,只有经过仔细考虑，讨论和测试后，我们才会集成大型或不向后兼容的更改。</p><p>从其发展过程来看，Promises/A+其实是把之前的<code>Promises/A提案</code>归纳总结为标准。扩展了一些现有的行为规范，并删除了一些有问题的、未明确的部分。</p><p>最终，Promises/A+规范核心内容不包括怎样处理 promises 的创建（create）,完成（fulfill）和拒绝（reject），而是选择专注于提供一个通用的，具备可互操作的<code>then</code>方法。上述的操作方法可能会在未来修改该规范时提及。</p><h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h3><p>1.1 “promise” 是一个拥有<code>then</code>方法的对象或函数，其行为符合本规范<br>1.2 “thenable” 是一个定义了<code>then</code>方法的对象或函数<br>1.3 “value” 可以是任何 JavaScript 的合法值（包括 undefined, thenable 和 promise）<br>1.4 “exception” 是一个使用<code>throw</code>语句抛出的值。<br>1.5 “reason”是一个表示 promise 失败的原因</p><h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2. 要求"></a>2. 要求</h3><h4 id="2-1-Promise-要求"><a href="#2-1-Promise-要求" class="headerlink" title="2.1 Promise 要求"></a>2.1 Promise 要求</h4><p>一个 Promise 必须处于以下三种状态中的其中一种: pending（等待）, fulfilled（完成）, 或 rejected（拒绝）。</p><p>2.1.1 当 promise 处于 pending 状态</p><ul><li><p>2.1.1.1. 可以转换到 fulfilled 或 rejected 的状态。</p><p>2.1.2 当 promise 处于 fulfilled 状态</p></li><li><p>2.1.2.1 不能再转换状态。</p></li><li><p>2.1.2.2 必须有一个值(value),且不可改变。</p><p>2.1.3 当 promise 处于 rejected 状态</p></li><li><p>2.1.3.1 不能再转换状态。</p></li><li><p>2.1.3.2 必须有一个原因(reason),且不可改变。</p></li></ul><p>这里的不可改变指的是恒等（即 <code>===</code> ），而不是意味着其内部的不可变（即仅仅是其引用地址不变，但属性值可被更改）。</p><h4 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2 then 方法"></a>2.2 then 方法</h4><p>一个 promise 必须提供一个<code>then</code>方法以读取其当前值、终值和失败原因。<br>一个 promise 的<code>then</code>方法接收两个参数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFullfilled, onRejected);</span><br></pre></td></tr></table></figure><p>2.2.1 <code>onFulfilled</code>和<code>onRejected</code>都是可选的参数:</p><ul><li><p>2.2.1.1 如果<code>onFullfilled</code>不是一个函数，则它会被忽略</p></li><li><p>2.2.1.2 如果<code>onRejected</code>不是一个函数，则它会被忽略</p><p>2.2.2 如果<code>onFulfilled</code>是一个函数</p></li><li><p>2.2.2.1 必须在 <code>promise</code> 执行结束后执行，<code>promise</code>的 value 作为第一个参数</p></li><li><p>2.2.2.2 在 <code>promise</code> 执行结束前不可被调用</p></li><li><p>2.2.2.3 不能被多次调用</p><p>2.2.3 如果<code>onRejected</code>是一个函数</p></li><li><p>2.2.3.1 必须在 <code>promise</code> 被拒绝后执行,<code>promise</code>的 reason 作为第一个参数</p></li><li><p>2.2.3.2 在 <code>promise</code> 执行结束前不可被调用</p></li><li><p>2.2.3.3 不能被多次调用</p><p>2.2.4 <code>onFulfilled</code>和<code>onRejected</code>只有在执行环境堆栈仅包含平台代码时才可被调用 <a href="####3.1">3.1</a></p><p>2.2.5 <code>onFulfilled</code>和<code>onRejected</code>必须被作为函数调用（即没有 this 值） <a href="####3.2">3.2</a></p><p>2.2.6 <code>then</code>方法可以被同一个 promise 调用多次</p></li><li><p>2.2.6.1 如果/当 <code>promise</code>是 fulfilled 状态，则所有相应的<code>onFulfilled</code>回调必须按注册顺序执行<code>then</code>方法</p></li><li><p>2.2.6.2 如果/当 <code>promise</code>是 rejected 状态，则所有相应的<code>onRejected</code>回调必须按注册顺序执行<code>then</code>方法</p><p>2.2.7 <code>then</code>方法必须返回一个 promise 对象<a href="####3.3">3.3</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure><ul><li>2.2.7.1 如果<code>onFulfilled</code>或者<code>onRejected</code>返回一个值<code>x</code> ，则运行下面的 Promise 解决过程：<code>[[Resolve]](promise2, x)</code></li><li>2.2.7.2 如果<code>onFulfilled</code>或者<code>onRejected</code>抛出一个异常<code>e</code> ，则<code>promise2</code>必须拒绝执行，并将<code>e</code>作为拒绝原因</li><li>2.2.7.3 如果<code>onFulfilled</code>不是一个函数并且<code>promise1</code>已经完成，则<code>promise2</code>必须使用与<code>promise1</code>相同的 value 来 fulfilled</li><li>2.2.7.4 如果<code>onRejected</code>不是一个函数并且<code>promise1</code>已经完成，则<code>promise2</code>必须使用与<code>promise1</code>相同的 reason 来 rejected</li></ul><h4 id="2-3-Promise-解决过程"><a href="#2-3-Promise-解决过程" class="headerlink" title="2.3 Promise 解决过程"></a>2.3 Promise 解决过程</h4><p>Promise 解决过程是一个抽象的操作,其需输入一个 promise 和一个值,我们表示为<code>[[Resolve]](promise, x)</code>,如果 x 是一个 thenable(promise),它会尝试采用 x 的状态,前提是<code>x</code>行为至少有点像 promise。否则，它作为<code>promise</code>的 fulfilled 的 value 返回。<br>对 thenables 的这种处理允许 promise 实现进行更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与不冲突的实现能良好共存。</p><p>要运行<code>[[Resolve]](promise, x)</code>, 需遵循以下步骤：</p><ul><li>2.3.1 如果<code>promise</code>和<code>x</code>指向同一对象，以<code>TypeError</code>为拒绝原因拒绝执行<code>promise</code></li><li>2.3.2 如果<code>x</code>为 Promise,则使 promise 接受 x 的状态<a href="####3.4">3.4</a><ul><li>2.3.2.1 如果<code>x</code>处于 pending,promise 需保持 pending,直至<code>x</code>被执行或拒绝</li><li>2.3.2.2 如果<code>x</code>执行完毕,用相同的值执行<code>promise</code></li><li>2.3.2.3 如果<code>x</code>被拒绝,用相同的原因拒绝<code>promise</code></li></ul></li><li>2.3.3 如果<code>x</code>为对象或者函数<ul><li>2.3.3.1 把<code>x.then</code>赋值给<code>then</code><a href="####3.5">3.5</a></li><li>2.3.3.2 如果取<code>x.then</code>的值时抛出错误<code>e</code>,则用<code>e</code>作为 promise 的拒绝原因</li><li>2.3.3.3 如果<code>then</code>是函数,将<code>x</code>作为函数的作用域<code>this</code>调用之。传递两个回调函数作为参数,第一个参数叫做<code>resolvePromise</code>,第二个参数叫做<code>rejectPromise</code>:<ul><li>2.3.3.3.1 如果<code>resolvePromise</code>以值<code>y</code>为参数被调用，则运行 <code>[[Resolve]](promise, y)</code></li><li>2.3.3.3.2 如果<code>rejectPromise</code>以拒绝原因<code>r</code>为参数被调用,则以<code>r</code>拒绝<code>promise</code></li><li>2.3.3.3.3 如果<code>resolvePromise</code>和<code>rejectPromise</code>均被调用,或者被同一参数调用了多次,则优先采用首次调用并忽略其余调用</li><li>2.3.3.3.4 如果调用<code>then</code>方法时抛出异常<code>e</code>,<ul><li>2.3.3.3.4.1 如果<code>resolvePromise</code>或<code>rejectPromise</code>已经被调用,就忽略它</li><li>2.3.3.3.4.2 否则以<code>e</code>为原因拒绝<code>promise</code></li></ul></li></ul></li><li>2.3.3.4 如果<code>then</code>不是函数,以<code>x</code>为参数执行<code>promise</code></li></ul></li><li>2.3.4 如果<code>x</code>不为对象或者函数,以<code>x</code>为参数执行<code>promise</code></li></ul><p>如果一个 promise 被一个循环的 thenable 链中的对象解决，而<code>[[Resolve]](promise, thenable)</code>的递归性质导致其被再次调用,根据上述的算法将会陷入无限递归。规范鼓励施者检测这样的递归是否存在,但不强制,如果检测到存在则以一个可识别的<code>TypeError</code>为原因来拒绝 <code>promise</code>。<a href="####3.6">3.6</a></p><h3 id="3-备注"><a href="#3-备注" class="headerlink" title="3. 备注"></a>3. 备注</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>这里的“平台代码”指的是引擎,环境和 promise 实现代码。实践中要确保<code>onFulfilled</code>和<code>onRejected</code>方法异步执行,且应该在<code>then</code>方法被调用的那一轮事件循环之后的新执行栈中执行。这可以用“宏任务”机制实现,例如<code>setTimeout</code>或者<code>setImmediate</code>,或者用“微任务”机制,例如<code>MutationObserver</code>或<code>process.nextTick</code>。由于 promise 实现被认为是平台代码,因此它本身可能包含一个任务调度队列或“trampoline”的处理程序。</p><h4 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h4><p>也就是说在严格模式（strict）中，<code>this</code>的值为<code>undefined</code>;在非严格模式中其为全局对象。</p><h4 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h4><p>代码实现在满足所有要求的情况下可以允许<code>promise2 === promise1</code>。每个实现都要文档说明其是否允许以及在何种条件下允许 p<code>romise2 === promise1</code>。</p><h4 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h4><p>一般来说,<code>x</code>如果它来自当前的实现,那么它是一个真正的 promise。该子句允许使用特定于实现的方法来采用已知符合的 promise 的状态。</p><h4 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h4><p>此过程首先存储引用<code>x.then</code>,然后测试,调用该引用,避免多次访问该<code>x.then</code>属性。这么做的原因是防止每次获取该值时,返回不同的情况（ES5 的 getter 特性可能会产生副作用）</p><h4 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h4><p>实现不应该对 thenable 链的深度设限,并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致<code>TypeError</code>异常；如果一条无限长的链上 thenable 均不相同,那么递归下去永远是正确的行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;原文&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>margin 合并</title>
    <link href="http://example.com/2020/10/26/margin%E5%90%88%E5%B9%B6/"/>
    <id>http://example.com/2020/10/26/margin%E5%90%88%E5%B9%B6/</id>
    <published>2020-10-26T10:42:31.000Z</published>
    <updated>2021-08-07T05:59:13.885Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="什么是-margin-合并"><a href="#什么是-margin-合并" class="headerlink" title="什么是 margin 合并"></a>什么是 margin 合并</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">MDN 定义</a></p><p>块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距,其大小为单个边距的最大值(或如果它们相等,则仅为其中一个),这种行为称为边距折叠.</p><p>举个 🌰</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">        writing-mode: vertical-lr;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>块级元素</strong>,但不包括浮动和绝对定位元素(他们可以让元素块状化)</li><li>只发生在垂直方向(不考虑<strong>writing-mode</strong>的情况,严格来说应该是只发生在和当前文档流方向的相垂直方向上,默认的文档流是水平流)</li></ul><h2 id="margin-合并三种场景"><a href="#margin-合并三种场景" class="headerlink" title="margin 合并三种场景"></a>margin 合并三种场景</h2><ul><li>相邻兄弟元素 margin 合并</li><li>父级和第一个/最后一个子元素</li><li>空的块级元素的 margin 合并</li></ul><h4 id="相邻兄弟元素-margin-合并"><a href="#相邻兄弟元素-margin-合并" class="headerlink" title="相邻兄弟元素 margin 合并"></a>相邻兄弟元素 margin 合并</h4><p>例子如上</p><h4 id="父级和第一个-最后一个子元素"><a href="#父级和第一个-最后一个子元素" class="headerlink" title="父级和第一个/最后一个子元素"></a>父级和第一个/最后一个子元素</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 30px;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="如何阻止这里margin合并的发生"><a href="#如何阻止这里margin合并的发生" class="headerlink" title="如何阻止这里margin合并的发生?"></a>如何阻止这里margin合并的发生?</h5><p>可以进行的操作(满足一个条件即可):</p><ul><li>父元素设置块状格式化上下文元素</li><li>父级和第一个/最后一个子元素之间添加内联元素进行分隔</li><li>父元素设置<code>border</code></li><li>父元素设置<code>padding</code></li></ul><h4 id="空的块级元素的-margin-合并"><a href="#空的块级元素的-margin-合并" class="headerlink" title="空的块级元素的 margin 合并"></a>空的块级元素的 margin 合并</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="如何阻止这里margin合并的发生-1"><a href="#如何阻止这里margin合并的发生-1" class="headerlink" title="如何阻止这里margin合并的发生?"></a>如何阻止这里margin合并的发生?</h5><p>可以进行的操作(满足一个条件即可):</p><ul><li>设置<code>height</code>或者<code>min-height</code></li><li>添加内联元素进行分隔</li><li>父元素设置<code>border</code></li><li>父元素设置<code>padding</code></li></ul><h2 id="margin-合并的计算规则"><a href="#margin-合并的计算规则" class="headerlink" title="margin 合并的计算规则"></a>margin 合并的计算规则</h2><ul><li>同向取极值<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 50px;&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 20px;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>此时两个<code>div</code>的间距为50px</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px; background-color: antiquewhite;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: -50px;&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: -20px;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时两个<code>div</code>的间距为-50px,视觉上非50px</p><ul><li>反向取差值<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom: 50px;&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: -20px;&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>此时两个<code>div</code>的间距为30px,即 50px+(-20px)</li></ul><h2 id="margin-合并的意义"><a href="#margin-合并的意义" class="headerlink" title="margin 合并的意义"></a>margin 合并的意义</h2><h4 id="为什么会有margin"><a href="#为什么会有margin" class="headerlink" title="为什么会有margin"></a>为什么会有margin</h4><p>最初CSS的设计本意就是为了图文信息的展示,有了默认的<code>margin</code>,图文就不会挤在一起,垂直方向上就可以层次分明.<br>比如说<code>&lt;p&gt;&lt;/p&gt;</code>,其<code>margin</code>默认单位为em,为什么使用相对单位?<br>浏览器的字号大小可以自定义,当我们自定义为较大值时,margin跟随变化,能够保持合适的排版.</p><h4 id="margin-合并的意义-1"><a href="#margin-合并的意义-1" class="headerlink" title="margin 合并的意义"></a>margin 合并的意义</h4><p>对于兄弟元素的<code>margin</code>合并其作用和em类似,都是为了让图文信息打得排版更舒服自然.</p><p>对于父子元素的<code>margin</code>合并的意义在于:在页面中任何地方插入和嵌套<code>&lt;div&gt;&lt;/div&gt;</code>都不会影响原来的块状布局.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 20px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在在该元素外嵌套一层<code>&lt;div&gt;&lt;/div&gt;</code>标签,如果没有合并规则,该元素和兄弟节点的间距可能就会变大,也就影响了原来的布局.</p><p>对于自身的<code>margin</code>合并的意义在于可以避免空标签的影响</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为规则的存在,它和底下的代码是一样的效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是-margin-合并&quot;&gt;&lt;a href=&quot;#什么是-margin-合并&quot;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Babel转译下的装饰器</title>
    <link href="http://example.com/2020/08/16/Babel%E8%BD%AC%E8%AF%91%E4%B8%8B%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://example.com/2020/08/16/Babel%E8%BD%AC%E8%AF%91%E4%B8%8B%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2020-08-16T11:40:50.000Z</published>
    <updated>2021-08-07T05:59:13.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h4 id="装饰器概念"><a href="#装饰器概念" class="headerlink" title="装饰器概念"></a>装饰器概念</h4><p>它是一个函数，它会通过返回一个新函数来修改传入的函数或方法的行为</p><h4 id="装饰器用法"><a href="#装饰器用法" class="headerlink" title="装饰器用法"></a>装饰器用法</h4><ul><li>装饰类方法或属性(类成员)</li><li>装饰类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = descriptor.value;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> descriptor.value === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(oldValue.apply(<span class="built_in">this</span>, args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(descriptor.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foodCategory = <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  target.category = <span class="string">&quot;food&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@foodCategory</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cola</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @log</span><br><span class="line">  <span class="function"><span class="title">color</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`red`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cola = <span class="keyword">new</span> Cola(<span class="string">&quot;Coca Cola&quot;</span>);</span><br><span class="line">cola.color(); <span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(Cola.category); <span class="comment">// food</span></span><br></pre></td></tr></table></figure><p><strong>装饰方法本质上是通过 <code>Object.defineProperty()</code> 来实现的</strong></p><p>经过babel转换之后(底下有babel详细操作):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function </span></span></span><br><span class="line"><span class="comment"> * 该函数的作用就是将数组中的方法添加到构造函数或者构造函数的原型中</span></span><br><span class="line"><span class="comment"> * 最后返回这个构造函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将props数组上的每一个对象都通过Object.defineProperty()方法</span></span><br><span class="line"><span class="comment">     * 定义到目标对象target上去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;</span><br><span class="line">            props.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">            <span class="comment">// 类的内部所有定义的方法,都是不可枚举的</span></span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">            descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;value&quot;</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;protoProps&#125;</span> </span>原型属性数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;protoProps&#125;</span> </span>静态属性数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 为构造函数prototype添加属性</span></span><br><span class="line">        <span class="comment">// (即为用构造函数生成的实例原型添加属性,可以被实例通过原型链访问到)</span></span><br><span class="line">        <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        <span class="comment">// 为构造函数添加属性</span></span><br><span class="line">        <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _class, _desc, _value, _class2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function </span></span></span><br><span class="line"><span class="comment"> * 作用是检查 Person 是否是通过 new 的方式调用</span></span><br><span class="line"><span class="comment"> * 防止构造函数被当做普通函数执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_applyDecoratedDescriptor</span>(<span class="params">target, property, decorators, descriptor, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> desc = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 这里对 descriptor 属性做了一层拷贝</span></span><br><span class="line">    <span class="built_in">Object</span>[<span class="string">&#x27;keys&#x27;</span>](descriptor).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        desc[key] = descriptor[key];</span><br><span class="line">    &#125;);</span><br><span class="line">    desc.enumerable = !!desc.enumerable;</span><br><span class="line">    desc.configurable = !!desc.configurable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有 value 或者 initializer 属性的,表明是 get 和 set 方法</span></span><br><span class="line">    <span class="comment">// initializer是 Babel 的 Class 为了与 decorator 配合而产生的一个属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> desc || desc.initializer) &#123;</span><br><span class="line">        desc.writable = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里处理多个 decorator 的情况,由类内向类外执行</span></span><br><span class="line">    desc = decorators.slice().reverse().reduce(<span class="function"><span class="keyword">function</span> (<span class="params">desc, decorator</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decorator(target, property, desc) || desc;</span><br><span class="line">    &#125;, desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void其实是javascript中的一个函数,接受一个参数,返回值永远是undefined</span></span><br><span class="line">    <span class="keyword">if</span> (context &amp;&amp; desc.initializer !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        desc.value = desc.initializer ? desc.initializer.call(context) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        desc.initializer = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (desc.initializer === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">Object</span>[<span class="string">&#x27;defineProperty&#x27;</span>](target, property, desc);</span><br><span class="line">        desc = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> descriptor.value === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, args = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">                args[_key] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(oldValue.apply(<span class="built_in">this</span>, args));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(descriptor.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foodCategory = <span class="function"><span class="keyword">function</span> <span class="title">foodCategory</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    target.category = <span class="string">&quot;food&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Cola = foodCategory(_class = (_class2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Cola</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="built_in">this</span>, Cola);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Cola, [&#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;color&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Cola;</span><br><span class="line">&#125;(), (_applyDecoratedDescriptor(_class2.prototype, <span class="string">&quot;color&quot;</span>, [log], <span class="built_in">Object</span>.getOwnPropertyDescriptor(_class2.prototype, <span class="string">&quot;color&quot;</span>), _class2.prototype)), _class2)) || _class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cola = <span class="keyword">new</span> Cola(<span class="string">&quot;Coca Cola&quot;</span>);</span><br><span class="line">cola.color();</span><br><span class="line"><span class="built_in">console</span>.log(Cola.category);</span><br></pre></td></tr></table></figure><h4 id="babel详细操作"><a href="#babel详细操作" class="headerlink" title="babel详细操作"></a>babel详细操作</h4><p>使用<code>npm init</code>初始化项目:<br>生成文件<code>pakeage.json</code>,它会将记录项目开发中所要用到的包,以及项目的详细信息</p><p>babel-cli是一种在命令行下使用Babel编译文件的简单方法,主要用于文件的输入输出<br>安装babel命令行工具:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">global</span> babel-cli</span><br></pre></td></tr></table></figure><p>安装装饰器依赖:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev babel-plugin-transform-decorators-legacy</span><br></pre></td></tr></table></figure><p>项目中创建**.babelrc**文件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;es2015&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;transform-decorators-legacy&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>文件说明:</p><ul><li><p>.babelrc<br>babel所有的操作基本都会来读取这个配置文件,除了一些在回调函数中设置options参数的,如果没有这个配置文件,会从package.json文件的babel属性中读取配置</p></li><li><p>presets<br>可以简单的把它视为 Babel Plugin 的集合</p></li><li><p>plugins<br>babel中的插件,通过配置不同的插件告诉babel,代码中有哪些是需要转译的</p></li></ul><p>使用babel命令转码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel [fileName].js</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;装饰器概念&quot;&gt;&lt;a href=&quot;#装饰器概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中offset、client、scroll</title>
    <link href="http://example.com/2020/06/10/JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/"/>
    <id>http://example.com/2020/06/10/JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/</id>
    <published>2020-06-10T13:49:20.000Z</published>
    <updated>2021-08-07T05:59:13.848Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在web前端开发中经常会碰到offset、client、scroll,容易混乱,这里记录一番.<br>先放两张图,未来好查阅 :smile:<br><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/1.png" alt="JavaScript中offset、client、scroll.md"><br><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/2.png" alt="JavaScript中offset、client、scroll.md"></p><h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>offset: 偏移量<br>它包括元素在屏幕上占用的所有可见的空间.元素的可见大小由其高度、宽度决定,包括所有的内边距<code>padding</code>,滚动条和边框<code>border</code>大小(注意:不包括外边距).</p><p>通过以下4个属性可以取得元素的偏移量:</p><ul><li>offsetHeight: offsetHeight = border-width * 2 + padding-top + padding-bottom + height</li><li>offsetWidth: offsetWidth = border-width * 2 + padding-left + padding-right + width</li><li>offsetLeft: offsetLeft = offsetParent 的padding-left + 中间元素的offsetWidth + 当前元素的margin-left</li><li>offsetTop: offsetParent 的padding-top + 中间元素的offsetHeight + 当前元素的margin-top</li></ul><p><strong>它们都是只读属性,每次访问都要重新计算,如果经常访问,可以用变量存起来,以提高性能</strong></p><p><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/3.png" alt="JavaScript中offset、client、scroll.md"></p><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><p>client: 客户区大小<br>它包括元素内容及其内边距所占据的空间大小.</p><p>通过以下2个属性可以取得元素的客户区:</p><ul><li>clientHeight: padding-top + padding-bottom + height</li><li>clientWidth: padding-left + padding-right + width</li></ul><p><strong>它们也是只读属性,每次访问都要重新计算</strong></p><p><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/4.png" alt="JavaScript中offset、client、scroll.md"></p><h2 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h2><p>scroll: 滚动大小<br>它指的是滚动内容的元素的大小.<br>有些元素(比如<code>&lt;html&gt;</code>),即使没有执行任何代码也能自动地添加滚动条;有些元素需要通过设置CSS的<code>overflow</code>属性才能滚动.</p><p>通过以下4个属性可以取得滚动的相关属性:</p><ul><li>scrollHeight: 在没有滚动条的情况下,元素实际内容的总高度</li><li>scrollWidth: 在没有滚动条的情况下,元素实际内容的总宽度</li><li>scrollLeft: 被隐藏在内容区域左侧的像素数,设置该属性可以改变元素的滚动位置</li><li>scrollTop: 被隐藏在内容区域上方的像素数,设置该属性可以改变元素的滚动位置</li></ul><p><strong>通常认为<code>&lt;html&gt;</code>元素是在web浏览器的视口中滚动的元素,所以带有垂直滚动条的页面总高度就是<code>document.documentElement.scrollHeight</code>.</strong></p><p><img src="JavaScript%E4%B8%ADoffset%E3%80%81client%E3%80%81scroll/5.png" alt="JavaScript中offset、client、scroll.md"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>直击本质——读书笔记</title>
    <link href="http://example.com/2020/05/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/"/>
    <id>http://example.com/2020/05/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-05-03T07:19:12.000Z</published>
    <updated>2021-08-07T05:59:13.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p><img src="%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8/%E7%9B%B4%E5%87%BB%E6%9C%AC%E8%B4%A8%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.JPG" alt="读书笔记--直击本质.md"></p><p>这本书让我受益很多，思维导图分享给大家。<br>以下再完善一些概念：</p><ul><li>迁移思考：迁移思考是先找到经过抽象与当前问题“表面不同、本质相似”的问题，通过借用前面问题的解决方法，解决当下问题的思维方式。它的迁移对象主要是思维模型和底层逻辑。</li><li>升维思考：跳出眼前问题的限制和常规解法，通过层级、时间、视角、边界、位置、结构的变换，重新思考问题及其解决之道的思考方式。升维思考的本质是对价值观、人生观、世界观的重新审视，拓展及重塑。比如，层级思考法和时间轴思考法是对自我价值观的审视，视角思考法是对世界观的拓展和重塑，无边界思考法是对人生观的拓展和重塑。</li><li>逆向思维：它是对司空见惯的、似乎已成定论的事物或观点反过来思考的一种思维方式。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文学" scheme="http://example.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中Object常用方法</title>
    <link href="http://example.com/2020/04/30/JavaScript%E4%B8%ADObject%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/04/30/JavaScript%E4%B8%ADObject%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2020-04-30T14:34:24.000Z</published>
    <updated>2021-08-07T05:59:13.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本篇文章尚未完成!!</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Object</code>是<code>JavaScript</code>中标准内置对象，它非常强大，虽然在日常开发中却用的不多，但十分有必要深入学习。</p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>该方法创建一个新对象，使用现有的对象提供新创建对象的__proto__.<br><code>Object.create(proto[, propertiesObject])</code><br>参数：</p><ul><li>proto为新创建对象的原型对象</li><li>propertiesObject可选，如果没有指定为undefined，这样会添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及响应的属性名称。<br>返回值：</li><li>一个新对象，带着指定原型对象和属性</li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p>先看看常用的对象定义属性并赋值的写法：密码，，，，，，，，，，，，，，，，，，。xcccccccccccccccccc.mpo[yup]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">&#x27;Cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line">这种方式简单粗暴，但是对象属性的值可以想改就改，想删就删：</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">let obj = &#123;&#125;;</span></span><br><span class="line"><span class="string">obj.name = &#x27;Cola&#x27;;</span></span><br><span class="line"><span class="string">console.log(obj);// &#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">obj.name = &#x27;Coca cola&#x27;;</span></span><br><span class="line"><span class="string">console.log(obj);// &#123; name: &#x27;Coca cola&#x27; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">delete obj.name;</span></span><br><span class="line"><span class="string">console.log(obj);// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>再来看看<code>Object.defineProperty(obj, prop, descriptor)</code><br>参数：</p><ul><li>obj为要定义属性的对象</li><li>prop为要定义或修改的属性的名称或Symbol</li><li>descriptor为要定义或修改的属性描述符<br>返回值：</li><li>被传递给函数的对象</li></ul><p><strong>ES6新增Symbol类型，，由于它独一无二的特性，可以用该类型作为对象的key</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;Coca cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br></pre></td></tr></table></figure><p>通过实践发现以这样的写法定义的属性是无法被修改和删除的，且访问对象为空。<br>要想和我们常规写法达到相同的效果，还需要修改属性描述符。<br>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符</strong>和<strong>存取描述符</strong>，用一张表来区分二者区别：<br>|   |configurable   |enumerable   |value   |writable   |get   |set   |<br>| ———— | ———— | ———— | ———— | ———— | ———— | ———— |<br>| 数据描述符  |√   |√   |√   |√   |×   |×   |<br>| 存取描述符  |√   |√   |×   |×   |√   |√   |<br>如果一个描述符不具备<code>value</code>、<code>enumerable</code>、<code>writable</code>、<code>configurable</code>任意一个键，那么它会被认为是一个数据描述符；<br>如果一个描述符同时拥有<code>value</code>或<code>writable</code>和<code>get</code>、<code>set</code>，则会产生一个异常。</p><p>下面再来看一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Cola</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;Coca cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// Coca cola</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>可以看到obj对象和我们以常用写法达到的效果一样，这是因为<code>enumerable</code>描述符能够控制对象属性是否可枚举;<code>writable</code>描述符能够控制对象属性是否可写，也就是覆盖;<code>configurable</code>描述符能够控制对象属性是否可配置，也就是将属性从对象上删除。<br>这里我们可以得出结论：除了<code>value</code>描述符，其他数据描述符的值默认为<code>false</code>。</p><p>那<code>get</code>和<code>set</code>呢，再看看以下的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute </span></span><br></pre></td></tr></table></figure><p>对照前文的表格，代码抛出异常，证实了<code>value</code>或<code>writable</code>和<code>get</code>、<code>set</code>不能同时出现。<br>那怎么使用呢，按照异常提示信息，删掉<code>value</code>和<code>writable</code>描述符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get!&#x27;</span>);</span><br><span class="line">        <span class="comment">// return obj;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">// &#123; name: [Getter/Setter] &#125;</span></span><br><span class="line">obj.name;<span class="comment">// get!</span></span><br><span class="line">obj.name = <span class="string">&#x27;Coca cola&#x27;</span>;<span class="comment">// Coca cola</span></span><br></pre></td></tr></table></figure><p>在上面代码中，每次访问<code>obj.name</code>总是返回同一个值，这是因为我们对这个属性做了特殊处理，也就是get方法做的事情；每次对<code>obj.name</code>进行赋值操作，控制台总是打印此次赋值的内容，也就是set方法做的事情。</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>该方法是ES6新添加的方法，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。<br><code>Object.assign(target, ...sources)</code><br>参数：</p><ul><li>target为目标对象</li><li>sources为源对象<br>返回值：</li><li>目标对象<br>用法示例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manA = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;manA&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(manA, &#123;</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;China&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;height&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;1.8m&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manB = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;manB&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manC = <span class="built_in">Object</span>.assign(&#123;&#125;, manA, manB, <span class="literal">null</span>, <span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">console</span>.log(manC);<span class="comment">// &#123; name: &#x27;manB&#x27;, age: 13, address: &#x27;China&#x27; &#125;</span></span><br></pre></td></tr></table></figure>实践后可以得出结论：</li><li>该方法只拷贝源对象自身的并且可枚举的属性到目标对象（其内部使用源对象存取描述符<code>get()</code>和目标对象的<code>set()</code>方法，因此它会调用相关方法）。</li><li>该方法不会因为sources参数为<code>null</code>或<code>undefined</code>而报错。</li></ul><p>深拷贝问题：<br><code>Object.assign()</code>方法只能实现浅拷贝：假如源对象的属性值是一个对象的引用，那么返回值中该属性值也直指向这个引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manA = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;manA&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">region</span>: <span class="string">&#x27;Asia&#x27;</span>,</span><br><span class="line">        <span class="attr">nationality</span>: <span class="string">&#x27;China&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manB = <span class="built_in">Object</span>.assign(&#123;&#125;, manA);</span><br><span class="line"><span class="built_in">console</span>.log(manB);<span class="comment">// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;China&#x27; &#125; &#125;</span></span><br><span class="line">manB.address.nationality = <span class="string">&#x27;Japan&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(manA)；<span class="comment">// &#123; name: &#x27;manA&#x27;, address: &#123; region: &#x27;Asia&#x27;, nationality: &#x27;Japan&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的防抖和节流</title>
    <link href="http://example.com/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>http://example.com/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2020-04-28T14:18:41.000Z</published>
    <updated>2021-08-07T05:59:13.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>防抖和节流是优化前端性能的一种手段。<br>以下情况可以考虑使用防抖和节流：</p><ul><li>DOM 频繁重绘</li><li>频繁请求后端接口</li><li>浏览器的 resize、scroll（适合用节流）</li><li>鼠标的 mounsemove、mouseover（适合用节流）</li><li>input 输入框的 keypress（适合用防抖）</li></ul><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>核心思想：当事件被触发，延迟 n 秒后执行回调函数，如果在 n 秒内再次被触发，则重新计时延迟时间。</p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(that, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>核心思想：在规定的一个单位时间内只能触发一次函数，如果在这个单位时间内出发多次函数，只有一次生效。</p><p>代码实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(that, args);</span><br><span class="line">      <span class="comment">// 在执行完fn后清空timer,throttle触发可以进入计时器</span></span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流与防抖的异同"><a href="#节流与防抖的异同" class="headerlink" title="节流与防抖的异同"></a>节流与防抖的异同</h2><p>相同：在一段时间内防止函数被频繁调用，减少资源浪费，提升性能。<br>不同：防抖是固定时间内只执行一次，节流是间隔固定时间后执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MQTT协议详解</title>
    <link href="http://example.com/2020/04/26/MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2020/04/26/MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-04-26T05:18:56.000Z</published>
    <updated>2021-08-07T05:59:13.905Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MQTT(Message Queuing Telemetry Transport,消息队列遥测传输协议)，是一种基于发布/订阅(public/subscribe)模式的轻量级物联网消息推送协议。<br>该协议构建于TCP/IP协议上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的协议。这让它成为新兴的”机器到机器（M2M)”，”物联网(IoT)”场景下的理想选择。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>MQTT协议是轻量、简单、开放和易于实现的</li><li>提供服务质量管理</li><li>采用发布/订阅模式，方便消息传递</li><li>基于TCP/IP网络连接，提供有序，无损的双向连接</li><li>假如数据不可知，不强求传输数据的类型与格式，保持灵活性</li><li>1字节固定报头，2字节心跳报文，最小化传输开销和协议交换，有效减少网络流量</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>MQTT协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力能源等领域</p><ul><li>物联网M2M通信，物联网大数据采集</li><li>Android消息推送，Web消息推送</li><li>移动即时消息，例如Facebook Messenger</li><li>智能硬件、智能家居</li><li>车联网通信、电动车站桩采集</li><li>电力、石油与能源等行业市场</li></ul><h2 id="主题和负载"><a href="#主题和负载" class="headerlink" title="主题和负载"></a>主题和负载</h2><p>MQTT传输的消息分为：主题（Topic）和负载（payload）</p><ul><li>Topic：可以理解为消息的类型，订阅者订阅（Subscribe)后，就会收到该主题的消息内容（payload）</li><li>payload：可以理解为消息的内容，失致订阅者具体要使用的内容</li></ul><h2 id="三种消息发布服务质量："><a href="#三种消息发布服务质量：" class="headerlink" title="三种消息发布服务质量："></a>三种消息发布服务质量：</h2><ul><li>至多一次：消息发布完全依赖底层TCP/IP网络，qos=0。会发生消息丢失或重复的情况，这一级别可用于如下情况，环境传感器数据，丢失一次读记录影响不大</li><li>至少一次：确保消息到达，qos=1。但消息重复可能会发生</li><li>只有一次：确保消息到底一次，qos=2。</li></ul><h2 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h2><ul><li><p>实现方式<br><img src="./MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/1.jpg" alt="MQTT协议详解.md"><br>MQTT协议具有三种身份：发布者（Publish)、代理（Broker)（服务器）、订阅者（Subscribe）<br>其中，消息的发布者和订阅者都是客户端，消息代理是服务器。消息的发布者可以同时是订阅者</p></li><li><p>网络传输与应用消息<br>MQTT会构建底层网络传输：它将简历客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。<br>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关联。</p></li><li><p>MQTT客户端<br>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p><ul><li>发布其他客户端可能会订阅的消息</li><li>订阅其他客户端发布的消息</li><li>退订或删除应用程序的消息</li><li>断开与服务器连接</li></ul></li><li><p>MQTT服务端<br>MQTT服务器已称为”消息代理”(Broker)，可以是一个应用程序或一台设备。它位于消息发布者和订阅者中间，它可以：</p><ul><li>接受来自客户的网络连接</li><li>接受客户发布的应用消息</li><li>处理来自客户端的订阅和退订请求</li><li>向订阅的客户转发应用程序消息</li></ul></li><li><p>MQTT协议中的订阅、主题、会话</p><ul><li>订阅（Subscription）<br>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每个会话中的每个订阅都有一个不同的主题筛选器。</li><li>会话（Session）<br>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。绘画存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</li><li>主题名（Topic Name）<br>连接到一个应用程序消息的标签，如果该标签与服务器的订阅相匹配，服务器就会将消息发送给订阅所匹配标签的客户端。</li><li>主题筛选器（Topic Filter）<br>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</li></ul></li><li><p>MQTT协议中的方法<br>MQTT协议中定义了一些方法，也被称之为动作，来表示对于确定资源进行的操作。资源可以是预先存在的数据或者动态生成的数据，这取决于服务器的实现，通常来说，资源指服务器上的文件或输出。主要方法有：</p><ul><li>Connect：等待与服务器建立连接</li><li>Disconnect：等待MQTT客户端完成所作的工作，并与服务器断开TCP/IP会话</li><li>Subscribe:等待完成订阅</li><li>UnSubscribe:等待服务器取消客户端的一个或多个topics订阅</li><li>Publish：MQTT客户端发送消息请求，发送完成后返回应用程序线程</li></ul></li></ul><h2 id="MQTT协议数据包结构"><a href="#MQTT协议数据包结构" class="headerlink" title="MQTT协议数据包结构"></a>MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Varibale header）、消息体（payload）三部分构成。</p><ul><li><p>固定头（Fixed header）：存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/2.jpg" alt="MQTT协议详解.md"><br>数据包类型为byte 1中bits7-4,相当于一个4位的无符号值，类型如下：<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/3.jpg" alt="MQTT协议详解.md"><br>标识位为byte 1中bits3-0,在不使用标识位的消息类型中，标识位被做为保留位。如果收到无效的标志时，接收端必须关闭网络连接：<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/4.jpg" alt="MQTT协议详解.md"></p><ul><li>DUP：发布消息的副本，用来保证消息的可靠传输。如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送</li><li>QoS：发布消息的服务质量，即：保证消息传递的次数<ul><li>00：最多一次，即：&lt;=1</li><li>01：至少一次，即：&gt;=1</li><li>10：一次，即：=1</li><li>11：预留</li></ul></li><li>RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放<br>剩余长度（Remaining Length）<br>固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为 1时，表示长度不足，需要使用二个字节继续保存。</li></ul></li><li><p>可变头（Varibale header）：存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容<br>MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识：</p></li></ul><p>很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：PUBLISH (QoS &gt; 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK<br><img src="MQTT%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/5.jpg" alt="MQTT协议详解.md"></p><ul><li>消息体（payload））：存在于部分MQTT数据包中，表示客户端收到的具体内容<br>Payload消息体位MQTT数据包的第三部分，包含CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息：<ul><li>CONNECT:消息体内容主要是客户端的ClientID、订阅的Topic、Message以及用户名和密码</li><li>SUBSCRIBE:消息内内容是一系列要订阅的主题以及QoS</li><li>SUBACK：消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复</li><li>UNSUBSCRIBE:消息体内容是要订阅的主题</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="协议" scheme="http://example.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="协议" scheme="http://example.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>霍乱时期的爱情——读书笔记</title>
    <link href="http://example.com/2020/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/"/>
    <id>http://example.com/2020/04/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/</id>
    <published>2020-04-20T13:12:03.000Z</published>
    <updated>2021-08-07T05:59:13.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>我相信爱情是有许多模样的，街头巷尾里互相搀扶的老夫老妻，小家里过着平平淡淡日子的夫妇，婚礼上很累却非常甜蜜的新人，还有拉着彼此的手在暴雨天一路奔跑的情侣等。当然，有积极正面的，热情似火的爱，也必然有阴暗扭曲，卑劣粗俗的爱，这本书让我看到关于爱情更多的细枝末节。<br>当年轻的阿里萨第一次见到费尔明娜，一生内心的纠葛就此开始。从最初的懵懂羞涩，在花园装作看书看诗集，实则等待费尔明娜路过时的那一撇，那就是心动的第一个阶段吧。彼时费尔明娜乖巧懂事，对父亲言听计从，但在阿里萨鼓起勇气送出信件的那一天，她的心态悄然变化。虽然二人几乎没有或正式的面对面的对话，但是在信中从无话不谈到私定终身，看到这里我觉得有些荒诞，但也不可否认，在那个年代这是可能发生的事情，或许这不是靠谱的爱情，但它一定是两个少男少女勇敢无畏，憧憬爱情的表现。<br>纸里包不住火，洛伦索发现女儿的地下情，愤怒之余却也拿女儿没什么办法，只能带着女儿出去旅行一场，以期让她忘记阿里萨。在经历时间和空间的考验之后，费尔明娜在代笔门廊处看见阿里萨的第一眼果断决定放弃这一段长达数年的感情，她完全没有想到阿里萨是这般模样。我想这是爱情的一种残酷，发现自己朝思暮想的另一半因为某种不合的观念，失望占据内心，想要迫切希望离开，以逃避给自己带来的情感冲击。而阿里萨也因此陷入漫长的相思之苦，在无数个日日夜夜幻想着未来继续和费尔明娜生活下去的可能。<br>医生的出现，让故事更加戏剧化，他和阿里萨是完完全全两种不同的人。医生光鲜亮丽，才华横溢，医术高超，和阿里萨奇怪装束，一身为爱情诗歌所浸染的气息形成鲜明对比。费尔明娜嫁给了医生，甜蜜旅行之后是多年的不开心，期间偶尔穿插着过往蜜月的回忆。漫长岁月不过弹指间就过去了，阿里萨对她的感情日渐病态，一边心里装着她，一边勾搭成百上千的女人满足生理上需求。漫长岁月里，阿里萨也有那么几个中意的女人，奇怪的是他从来没有放弃一直盘踞在内心的念想，也从未对其他人提起，少年时的爱慕经受了五十多年岁月的考验，尽管这种感情面目全非，阿里萨还是坚持了下去，足够令人惊叹。<br>阿里萨终于等到医生死亡的消息，不像他想象中的体面离世，跌倒死亡让阿里萨没有把竞争对手比下去的快感。即便如此，暮年的他没有浪费太多时间，再次向费尔明娜表明心意，在坚持不懈的努力下，费尔明娜意识到自己是对阿里萨那一份特殊感情。最终在他们剩下的生命里借助霍乱的掩护，阿里萨如愿和费尔明娜一起在海上漂流了下去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我相信爱情是有许多模样的，街头巷尾里互相搀扶的老夫老妻，小家里过着平平淡淡日子的夫妇，婚</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文学" scheme="http://example.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>网络攻击-XSS攻击详解</title>
    <link href="http://example.com/2020/03/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB-XSS%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2020/03/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB-XSS%E6%94%BB%E5%87%BB%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-03-10T05:39:41.000Z</published>
    <updated>2021-08-07T05:59:13.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="XSS-概念"><a href="#XSS-概念" class="headerlink" title="XSS 概念"></a>XSS 概念</h2><p>跨站脚本攻击(XSS),是最普遍的Web应用安全漏洞.</p><p>这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中,当正常用户访问该页面时,则可导致嵌入的恶意脚本代码的执行,从而达到恶意攻击用户的目的.</p><p>人们经常将跨站脚本攻击(Cross Site Scripting)缩写为 CSS ,但这会与层叠样式表(Cascading Style Sheet,CSS)的缩写混淆,因此将其改为 XSS .</p><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><ul><li>盗用 cookie ,获取敏感信息</li></ul><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>HTML 是一种超文本标记语言,通过特殊对待一些字符来区别文本和标记:小于符号(&lt;)被看作是 HTML 标签的开始,浏览器会将特定的字符误认为HTML 标签.当 HTML标签引入了 JavaScript 脚本时,浏览器就会执行.因此,当这些特殊字符不能被动态页面检查或检查出错的时候,就会产生 XSS 漏洞</p><h2 id="XSS-类型"><a href="#XSS-类型" class="headerlink" title="XSS 类型"></a>XSS 类型</h2><ul><li>反射型(非持久型):指发生请求时,XSS代码出现在请求URL中,作为参数提交到服务器,服务器解析并响应,响应结果中包含XSS代码,最后被浏览器解析并执行.这个过程像一次反射,故叫做反射型XSS.</li><li>存储型(持久型):将XSS代码存储在服务器中.</li><li>DOM跨站:指受害者端的网页脚本在修改本地页面DOM环境时未进行合理的处置,而使得攻击脚本被执行.在整个攻击过程中,服务器响应的页面并没有发生变化,引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用</li></ul><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><ul><li><p>反射型XSS<br>假如一个接口<code>http://www.test.com/xss/reflect.php</code>的代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>这里的x值没有经过处理直接输出,当客户端提交请求<code>http://www.test.com/xss/reflect.php?x=&lt;script&gt;alert(1)&lt;/script&gt;</code>,此时浏览器会触发alert()函数.</p></li><li><p>存储型XSS<br>最典型的例子就是留言板XSS,当用户提交了一条包含XSS代码的留言存储到数据库,目标用户查看留言板时,留言内容会从数据库提取并展示在页面上,浏览器发现有XSS代码,就当成HTML和JavaScript解析执行,从而触发XSS攻击.简单的可以是一个alert()弹窗,复杂一些的可以是盗用用户cookie等操作.</p></li><li><p>DOM XSS<br>DOM XSS攻击并不需要服务器参与,触发攻击靠浏览器的DOM解析,核心是运用DOM函数.<br>我们知道<code>eval()</code>函数有一个作用是将一段字符串转换成<code>JavaScript</code>语句,因此在<code>JavaScript</code>中使用<code>eval()</code>是一件有风险的事情,容易造成XSS攻击.</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;alert(&#x27;Hello world&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure><p>  可能触发DOM XSS攻击的属性有:</p><ul><li>document.referer属性</li><li>window.name属性</li><li>location属性</li><li>innerHTML属性</li><li>documen.write</li></ul></li></ul><h2 id="防范手段"><a href="#防范手段" class="headerlink" title="防范手段"></a>防范手段</h2><ul><li>入参字符过滤<br>对诸如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code>等标签进行过滤.</li><li>出参进行编码<br>像一些常见的符号,如<code>&lt;&gt;</code>在输入的时候要对其进行转换编码,这样做浏览器是不会对该标签进行解释执行的,同时也不影响显示效果.</li><li>入参长度限制<br>xss攻击要能达成往往需要较长的字符串,因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;XSS-概念&quot;&gt;&lt;a href=&quot;#XSS-概念&quot; class=&quot;header</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="网络攻击" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
    <category term="Web安全" scheme="http://example.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中对象的拓展、密封及冻结三大特性</title>
    <link href="http://example.com/2020/03/02/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95%E3%80%81%E5%AF%86%E5%B0%81%E5%8F%8A%E5%86%BB%E7%BB%93%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2020/03/02/JavaScript%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%93%E5%B1%95%E3%80%81%E5%AF%86%E5%B0%81%E5%8F%8A%E5%86%BB%E7%BB%93%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2020-03-02T09:24:20.000Z</published>
    <updated>2021-08-07T05:59:13.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>属性描述符是ES5引入的概念,它用于描述对象的特征.</p><p>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符</strong>和<strong>存取描述符</strong>.</p><blockquote><p>MDN中的描述：<br>数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。<br>存取描述符是由getter-setter函数对描述的属性。<br>描述符必须是这两种形式之一；不能同时是两者。</p></blockquote><p>数据描述符和存取描述符均具有以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)</p><ul><li><code>configurable</code>: <strong>可配置性</strong>.当且仅当该属性的 configurable 为 true 时,该属性描述符才能够被改变,同时该属性也能从对应的对象上被删除.默认为 <code>false</code>.</li><li><code>enumerable</code>: <strong>可枚举性</strong>.当且仅当该属性的enumerable为<code>true</code>时,该属性才能够出现在对象的枚举属性中.默认为 <code>false</code>.</li></ul><p>数据描述符同时具有以下可选键值：</p><ul><li><code>writable</code>: <strong>可写性</strong>.当且仅当该属性的writable为true时,value才能被赋值运算符改变.默认为 <code>false</code>.</li><li><code>value</code>: <strong>属性值</strong>.该属性对应的值.可以是任何有效的 JavaScript 值(数值,对象,函数等).默认为 <code>undefined</code>.</li></ul><p>存取描述符同时具有以下可选键值：</p><ul><li><code>get</code>: 一个给属性提供 getter 的方法,如果没有 getter 则为 <code>undefined</code>.当访问该属性时.该方法会被执行,方法执行时没有参数传入,但是会传入this对象（由于继承关系,这里的this并不一定是定义该属性的对象）.</li><li><code>set</code>: 一个给属性提供 setter 的方法,如果没有 setter 则为 <code>undefined</code>.当属性值修改时,触发执行该方法.该方法将接受唯一参数,即该属性新的参数值.</li></ul><p>描述符可同时具有的键值:<br>|            | configurable |  enumerable | value | writable | get | set<br>| ——–   | —–:  | :—-:  | :—-:  | :—-:  | :—-:  | :—-:  |<br>| <strong>数据描述符</strong> | Yes | Yes | Yes | Yes | No | No |<br>| <strong>存取描述符</strong> | Yes | Yes | No | No | Yes | Yes |</p><p>如果一个描述符不具有value,writable,get 和 set 任意一个关键字,那么它将被认为是一个数据描述符.如果一个描述符同时有(value或writable)和(get或set)关键字,将会产生一个异常.</p><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.defineProperty(obj, prop, descriptor)</p></blockquote><p>obj:在其上定义或修改属性的对象.</p><p>prop:要定义或修改的属性的名称.</p><p>descriptor:将被定义或修改的属性描述符.</p><blockquote><p>Object.defineProperties(obj, props)</p></blockquote><p>obj:在其上定义或修改属性的对象.</p><p>props:要定义其可枚举属性或修改的属性描述符的对象.对象中存在的属性描述符主要有两种:数据描述符和访问器描述符</p><blockquote><p>Object.getOwnPropertyDescriptors(obj)</p></blockquote><p>obj:任意对象.</p><blockquote><p>Object.getOwnPropertyDescriptor(obj, prop)</p></blockquote><p>obj:需要查找的目标对象.</p><p>prop:目标对象内属性名称</p><h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">price</span>: &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updatePrice&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.capacity;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 3.5, updatePrice: [Getter/Setter] &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj.updatePrice = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, color: &#x27;red&#x27;, price: 5, updatePrice: [Getter/Setter] &#125;</span></span><br></pre></td></tr></table></figure><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ul><li><p>如果属性不可配置,则不能修改它的可配置性和可枚举性,否则抛出异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;color&#x27;</span>));<span class="comment">//&#123; value: undefined, writable: false, enumerable: false, configurable: false &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果存取器属性是不可配置的，则不能修改<code>get</code>和<code>set</code>方法，也不能将它转换为数据属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Coca &#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: updateName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = val + <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: updateName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;updateName&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;Coco Cola&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: updateName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果数据属性是不可配置的,则不能将它转换为存取器属性;同时也不能将它的可写性从<code>false</code>修改成<code>true</code>，但可以从<code>true</code>修改为<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;5&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;6&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;color&#x27;</span>)); <span class="comment">//&#123; value: &#x27;red&#x27;, writable: false, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;price&#x27;</span>)); <span class="comment">//&#123; value: &#x27;5&#x27;, writable: false, enumerable: false, configurable: false &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果数据属性是不可配置且不可写的,就不能修改它的值;如果是可配置但不可写，则可以修改值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot redefine property: color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接修改值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;12&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.price); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;price&#x27;</span>)); <span class="comment">//&#123; value: &#x27;12&#x27;, writable: false, enumerable: false, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以修改writable为true后再修改值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.price = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.price); <span class="comment">//5</span></span><br></pre></td></tr></table></figure></li><li><p>严格模式下,只指定<code>get</code>时,如果对该属性赋值将会抛出类型错误异常,只指定<code>set</code>时,如果读取该属性将返回undefined,非严格模式下都不抛出异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;color&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Coca &#x27;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot set property color of #&lt;Object&gt; which has only a getter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.color); <span class="comment">//Coca Cola</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;price&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.price);<span class="comment">//undefined</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h2><p>如果一个对象可以添加新的属性,那么这个对象是可扩展的.如何检验对象是否可扩展及如何让它变得不可扩展呢？</p><h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.isExtensible(obj)</p></blockquote><p>obj：需要检测的对象</p><blockquote><p>Object.preventExtensions(obj)</p></blockquote><p>obj：将要变得不可扩展的对象</p><h4 id="用法示例-1"><a href="#用法示例-1" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新创建的对象默认是可扩展的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">//false</span></span><br><span class="line">obj.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Cola&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;Coca Cola&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//使用`Object.defineProperty`方法为不可扩展对象添加新属性会抛出异常</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;price&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">3.5</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//TypeError: Cannot define property price, object is not extensible</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Coca Cola&#x27; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;name&#x27;</span>));<span class="comment">//&#123; value: &#x27;Coca Cola&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//writable属性为false时，属性值不可修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;Coca Cola&#x27;</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line">obj.name = <span class="string">&#x27;Sprite&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h2><p>密封对象是指不可扩展，且自身所有属性都不可配置的对象.</p><p>也就是说密封对象要满足以下条件:</p><ul><li>不能添加新属性</li><li>不能删除已有属性</li><li>不能修改已有属性的可枚举性、可配置性、可写性,但可能可以修改已有属性的值的对象</li></ul><h4 id="常用API-2"><a href="#常用API-2" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.isSealed(obj)</p></blockquote><p>obj：需要检测的对象</p><blockquote><p>Object.seal(obj)</p></blockquote><p>obj：需要被密封的对象</p><h4 id="用法示例-2"><a href="#用法示例-2" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建的对象默认不是密封的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动密封</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空对象的手动密封</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//密封后不再能够添加或删除属性</span></span><br><span class="line">obj.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Coca  Cola&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//密封后如果writable为true</span></span><br><span class="line">obj.name = <span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123; name: &#x27;Pepsi  Cola&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h2><p>冻结对象要满足以下条件:</p><ul><li>不能添加新属性</li><li>不能删除已有属性</li><li>不能修改已有属性的可枚举性、可配置性、可写性</li></ul><p>即这个对象永远是不可变的.</p><h4 id="常用API-3"><a href="#常用API-3" class="headerlink" title="常用API:"></a>常用API:</h4><blockquote><p>Object.isFrozen(obj)</p></blockquote><p>obj：需要检测的对象</p><blockquote><p>Object.freeze(obj)</p></blockquote><p>obj：需要被冻结的对象</p><h4 id="用法示例-3"><a href="#用法示例-3" class="headerlink" title="用法示例:"></a>用法示例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建的对象默认不是冻结的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(obj)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当对象变得不可扩展且无属性时，也成为冻结对象</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(obj));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不可扩展的空对象是一个密封对象，同时也是冻结对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(<span class="built_in">Object</span>.preventExtensions(&#123;&#125;))); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isFrozen(<span class="built_in">Object</span>.preventExtensions(&#123;&#125;))); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &#x27;Cola&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(obj);</span><br><span class="line">console.log(Object.isFrozen(obj)); //true</span><br><span class="line"></span><br><span class="line">//对冻结对象的任何操作都会失败</span><br><span class="line">obj.name = &#x27;Coca Cola&#x27;;</span><br><span class="line">delete obj.name;</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><p><strong>注意:再严格模式下,对冻结对象的操作会抛出类型异常</strong></p><h4 id="浅冻结"><a href="#浅冻结" class="headerlink" title="浅冻结"></a>浅冻结</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: &#123;</span><br><span class="line">        <span class="attr">CocaCola</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        <span class="attr">PepsiCola</span>: <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">obj.name = <span class="string">&#x27;Sprite&#x27;</span></span><br><span class="line">obj.color.CocaCola = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, color: &#123; CocaCola: &#x27;white&#x27;, PepsiCola: &#x27;blue&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><h4 id="深冻结"><a href="#深冻结" class="headerlink" title="深冻结"></a>深冻结</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completelyFreezeObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) != <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&quot;obj不是对象&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj[key]) == <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">            completelyFreezeObj(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;属性描述符&quot;&gt;&lt;a href=&quot;#属性描述符&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Google JavaScript 编码规范部分整理</title>
    <link href="http://example.com/2020/02/17/Google%20JavaScript%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/02/17/Google%20JavaScript%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E9%83%A8%E5%88%86%E7%BF%BB%E8%AF%91%E6%95%B4%E7%90%86/</id>
    <published>2020-02-17T08:54:50.000Z</published>
    <updated>2021-08-07T05:59:13.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文参考:</p><ul><li><a href="https://google.github.io/styleguide/jsguide.html">https://google.github.io/styleguide/jsguide.html</a></li><li><a href="http://alloyteam.github.io/JX/doc/specification/google-javascript.xml">http://alloyteam.github.io/JX/doc/specification/google-javascript.xml</a></li><li><a href="https://max.book118.com/html/2019/0202/7052110006002005.shtm">https://max.book118.com/html/2019/0202/7052110006002005.shtm</a></li><li><a href="https://segmentfault.com/a/1190000012916070#item-5-22">https://segmentfault.com/a/1190000012916070#item-5-22</a></li><li><a href="https://github.com/wayou/wayou.github.io/issues/21">https://github.com/wayou/wayou.github.io/issues/21</a></li></ul><p>因本人水平有限,如有错误,可及时联系作者修改.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>JavaScript 是一种客户端脚本语言，Google 的许多开源工程中都有用到它。这份指南列出了编写 JavaScript 时需要遵守的规则，当且仅当 JavaScript 源文件遵守此处规则时，它才被描述为 Google 风格。</p><h2 id="JavaScript-语言规范"><a href="#JavaScript-语言规范" class="headerlink" title="JavaScript 语言规范"></a>JavaScript 语言规范</h2><ul><li><p>局部变量声明</p><ul><li>使用<code>const</code> 和<code>let</code><br>用 <code>const</code>或 <code>let</code> 声明所有局部变量，默认情况下使用<code>const</code>，除非需要重新分配变量。</li><li>一个变量一个声明<br>每个局部变量声明仅声明一个变量。不使用诸如 <code>let a = 1, b = 2;</code> 这样的声明形式。</li><li>在需要时进行声明，并尽快初始化<br>局部变量不是在其包含的块或类似块的结构的开头习惯性地声明的。而是将局部声明在接近首次使用它们的地方(在合理范围内)，以最大程度地减小其范围。</li><li>根据需要声明类型<br>可以在声明的局部变量上方添加JSDoc类型注释，或者如果不存在其他JSDoc，则可以在变量名称之前内联。</li></ul><p>  例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="comment">/**! Array &lt;number&gt; */</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一些描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type <span class="type">&#123;! Array &lt;number&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">const</span> data = [];</span><br></pre></td></tr></table></figure><p>  不允许混合使用内联和JSDoc样式：因为编译器将仅处理第一个JSDoc，即内联注释会丢失，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一些描述。*/</span> <span class="keyword">const</span> <span class="comment">/**！Array &lt;number&gt; */</span> 数据= [];</span><br></pre></td></tr></table></figure><p>  <strong>提示：在许多情况下，编译器可以推断出模板化类型，但不能推断其参数。当初始化字面量或构造函数调用不包含模板参数类型的任何值(例如，空数组，对象，Map和Set)或变量在闭包中修改时，在这些情况下，局部变量类型注释特别有用，否则编译器会将模板参数推断成未知。</strong></p></li><li><p>数组字面量</p><ul><li>使用逗号结尾<br>如果最后一个元素和右括号之间有换行符，请在结尾加上逗号，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [</span><br><span class="line"><span class="string">&#x27;first value&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;second value&#x27;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li>不要使用可变参数的 <code>Array构造函数</code><br>构造函数很容易因为传参不恰当而导致错误。请改用字面量形式。<br>不建议的形式，例：</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2, x3);</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1);</span><br><span class="line"><span class="keyword">const</span> a4 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure><p>  除了第三种情况外，这可以按照预期工作：如果x1为整数，那么a3则是一个长度为x1的数组，其所有元素均为<code>undefined</code>。如果x1为其他任何数字，则将引发异常。<br>  建议的写法，例：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [x1, x2, x3];</span><br><span class="line"><span class="keyword">const</span> a2 = [x1, x2];</span><br><span class="line"><span class="keyword">const</span> a3 = [x1];</span><br><span class="line"><span class="keyword">const</span> a4 = [];</span><br></pre></td></tr></table></figure><p>  在适当的时候，允许用<code>new Array(length)</code>显示分配一个给定长度的数组。</p><ul><li>非数字属性<br>请勿在数组上定义或使用非数字属性（除了<code>length</code>）。使用<code>Map</code>（或<code>Object</code>）代替。</li><li>解构<br>数组字面量可用于分配的左侧以执行解构（例如，从单个数组中解压缩多个值或可迭代时）。 可以包含最后一个rest元素（在…和变量名之间没有空格）,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, ...rest] = generateResults();</span><br><span class="line"><span class="comment">//解构赋值还可以忽略某些元素</span></span><br><span class="line"><span class="keyword">let</span> [, b,, d] = someArray</span><br></pre></td></tr></table></figure>解构也可以用于函数参数（请注意，参数名称是必需的，但会被忽略）。如果解构数组的参数是可选的，要始终指定<code>[]</code>为默认值，并在左侧提供默认值，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;!Array&lt;number&gt;=&#125;</span> </span>param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optionalDestructuring</span>(<span class="params">[a = <span class="number">4</span>, b = <span class="number">2</span>] = []</span>) </span>&#123; … &#125;;</span><br></pre></td></tr></table></figure>错误的写法，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badDestructuring</span>(<span class="params">[a, b] = [<span class="number">4</span>, <span class="number">2</span>]</span>) </span>&#123; … &#125;;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>提示：对于将多个值（解包）到一个函数的参数或返回中，在可能的情况下，优先选择对象分解而不是数组分解，因为它允许命名单个元素并为每个元素指定不同的类型。</strong></p><ul><li>展开运算符<br>数组字面量可以包含展开运算符（<code>…</code> ），以将元素从一个或多个可迭代对象中展开，而不是用更笨拙的构造<code>Array.prototype</code> 。变量紧跟在展开运算符后，没有空格。</li></ul></li><li><p>对象字面量</p><ul><li>不要使用<code>Object构造函数</code><br>虽然<code>Object 构造器</code>没有上述类似的问题, 但鉴于可读性和一致性考虑, 最好还是在字面上更清晰地指明，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure></li><li>请勿混用带引号和不带引号的键<br>对象字面量可以表示结构（具有未加引号的键和/或符号）或字典（具有引号和/或计算的键）。不要将这两种键类型混合在单个对象字面量中，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">42</span>,<span class="comment">// struct风格的未加引号的键</span></span><br><span class="line"><span class="string">&#x27;maxWidth&#x27;</span>: <span class="number">43</span> <span class="comment">// dict风格的加引号的键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这还扩展到将属性名称传递给函数，例如 <code>hasOwnProperty</code>。特别是这样做会破坏编译后的代码，因为编译器无法重命名/混淆字符串文字。<br>不建议的写法，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;&#123;width: number, maxWidth: (number|undefined)&#125;</span></span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">width</span>: <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (o.hasOwnProperty(<span class="string">&#x27;maxWidth&#x27;</span>)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  最好这样实现，例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;&#123;width: number, maxWidth: (number|undefined)&#125;</span></span>&#125; */</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">width</span>: <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (o.maxWidth != <span class="literal">null</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>计算的属性名称<br>允许使用计算的属性名称（例如<code>&#123;[&#39;key&#39;+ foo（）]：42&#125;</code>），并且将其视为dict样式（带引号的）键（即，不得与非引号的键混合使用），除非计算出的属性 是一个符号（例如[Symbol.iterator]）。 枚举值也可以用于计算键，但不应与同一字面量中的非枚举键混合使用,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;width&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">42</span>,</span><br><span class="line">[<span class="string">&#x27;max&#x27;</span> + foo()] : <span class="number">43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>方法速记<br>可以使用方法简写（<code>&#123;method（）&#123;…&#125;&#125;</code>）代替冒号后紧跟函数或箭头函数常量，从而在对象上定义方法。<br>例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">42</span>,</span><br><span class="line"><span class="function"><span class="title">getWidth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.width;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>速记属性<br>对象字面量允许使用速记属性,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">foo,</span><br><span class="line">bar,</span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.foo + <span class="built_in">this</span>.bar; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>解构<br>对象解构模式可以在分配的左侧使用，以执行解构并从单个对象解压缩多个值。<br>分解后的对象也可以用作函数参数，但应保持尽可能的简单：单个级别的未引用速记属性。 参数解构中可能不使用更深层的嵌套和计算的属性。 在解构参数的左侧指定任何默认值（<code>&#123;str =&#39;some default&#39;&#125; = &#123;&#125;</code>，而不是<code>&#123;str&#125; = &#123;str：&#39;some default&#39;&#125;</code>），如果解构对象为本身是可选的，它必须默认为<code>&#123;&#125;</code>。 可以为分解结构参数的JSDoc指定任何名称（该名称未使用，但编译器需要）,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">ordinary</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;&#123;num: (number|undefined), str: (string|undefined)&#125;</span></span>=&#125; param1</span></span><br><span class="line"><span class="comment">*     num: The number of times to do something.</span></span><br><span class="line"><span class="comment">*     str: A string to do stuff to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destructured</span>(<span class="params">ordinary, &#123;num, str = <span class="string">&#x27;some default&#x27;</span>&#125; = &#123;&#125;</span>)</span></span><br><span class="line"><span class="function">不被允许的写法，例：</span></span><br><span class="line"><span class="function">/** @<span class="title">param</span> </span>&#123;&#123;<span class="attr">x</span>: &#123;<span class="attr">num</span>: (number|<span class="literal">undefined</span>), <span class="attr">str</span>: (string|<span class="literal">undefined</span>)&#125;&#125;&#125; param1 */</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nestedTooDeeply</span>(<span class="params">&#123;x: &#123;num, str&#125;&#125;</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;&#123;num: (number|undefined), str: (string|undefined)&#125;</span></span>=&#125; param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonShorthandProperty</span>(<span class="params">&#123;num: a, str: b&#125; = &#123;&#125;</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;&#123;a: number, b: number&#125;</span></span>&#125; param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computedKey</span>(<span class="params">&#123;a, b, [a + b]: c&#125;</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;&#123;a: number, b: string&#125;</span></span>=&#125; param1 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nontrivialDefault</span>(<span class="params">&#123;a, b&#125; = &#123;a: <span class="number">2</span>, b: <span class="number">4</span>&#125;</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li><li>枚举<br>枚举是通过将@enum批注添加到对象字面量中来定义的。 定义枚举后，可能无法将其他属性添加到枚举中。 枚举必须是常量，并且所有枚举值都必须是不可变的,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Supported temperature scales.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@enum <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> TemperatureScale = &#123;</span><br><span class="line"><span class="attr">CELSIUS</span>: <span class="string">&#x27;celsius&#x27;</span>,</span><br><span class="line"><span class="attr">FAHRENHEIT</span>: <span class="string">&#x27;fahrenheit&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* An enum with two options.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@enum <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> Option = &#123;</span><br><span class="line"><span class="comment">/** The option used shall have been the first. */</span></span><br><span class="line"><span class="attr">FIRST_OPTION</span>: <span class="number">1</span>,</span><br><span class="line"><span class="comment">/** The second among two options. */</span></span><br><span class="line"><span class="attr">SECOND_OPTION</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>类</p><ul><li>构造函数<br>构造函数是可选的,子类构造函数必须在设置任何字段或以其他方式访问<code>this</code>之前调用<code>super（）</code>。<br>正确的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name, age, height</span>)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(name,age);</span><br><span class="line"><span class="built_in">this</span>.height = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>错误的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name, age, height</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.height = height;</span><br><span class="line"><span class="built_in">super</span>(name,age);</span><br><span class="line"><span class="comment">//SyntaxError: &#x27;this&#x27; is not allowed before super()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>字段<br>在构造函数中设置所有具体对象的字段（即方法以外的所有属性）。使用 @const 修饰的字段代表常量，不能被重新赋值。 使用适当的可见性注释（@private，@protected，@package）注释非公共字段，并在所有@private字段的名称后面加上下划线。 字段永远不会设置在具体类的原型上,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@private </span><span class="doctag">@const <span class="type">&#123;!Bar&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.bar_ = computeBar();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@protected </span><span class="doctag">@const <span class="type">&#123;!Baz&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.baz = computeBaz();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>提示:类在初始化之后，就不能再向其添加或删除属性了，因为这会影响虚拟机对其进行优化。如果必要，可以将之后才进行初始化的字段先赋值为 undefined，这样先占位之后，防止后面再添加新属性。对象身上的@struct 注释可以对不存在的字段的访问进行检查。类自带了这一功能。</strong></p><ul><li>计算属性<br>计算属性只能用于类的属性是 symbol 的情况。 Dict-style 类型的属性（带引号或非 symbol 的计算属性是不被允许的。对于可遍历的类，需要定义其 [Symbol.iterator] 方法。其他情况下少用 Symbol。</li></ul><p>  <strong>注意:使用其他内建的 symbol 时要格外小心（e.g. Symbol.isConcatSpreadable）,因为编译器没有对它进行垫片（向后兼容）处理，所以在旧版浏览器中会有问题</strong></p><ul><li>静态方法<br>在不影响可读性的前提下，推荐使用模块内部的函数而不是静态方法。</li></ul><p>  静态方法应该只用于基类。静态方法不应该从一个保存了实例的变量身上调用，这个实例有可能是构造器或者子类的构造器初始化而来（静态方法应该使用 @nocollapse 来注释），而且如果子类没有定义该方法的话，不应该从子类直接调用。<br>  错误的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123; <span class="comment">/** <span class="doctag">@nocollapse </span>*/</span> <span class="keyword">static</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callFoo</span>(<span class="params">cls</span>) </span>&#123; cls.foo(); &#125;  <span class="comment">// discouraged: don&#x27;t call static methods dynamically</span></span><br><span class="line">Sub.foo();  <span class="comment">// illegal: don&#x27;t call static methods on subclasses that don&#x27;t define it themselves</span></span><br></pre></td></tr></table></figure><ul><li>声明类的旧方式<br>ES6 方式的类声明是首选，但在某些情况下ES6类可能不可行。例如：<ul><li>如果存在或将要存在子类，包括框架创建的子类，还不能立即使用 ES6 风格的类声明。因为如果基类使用 ES6 方式的话，所有子类代码都需要更改。</li><li>有些框架在调用子类构造器时需要显式提供 this，而 ES6 风格的类中在调用 super 前是获取不到 this 的。</li></ul></li></ul><p>  此规则还应用于这些代码：<code>let</code>，<code>const</code>，默认参数，rest 和箭头函数。</p><p>  通过 goog.defineClass 可以进行类 ES6 方式的类声明：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> C = goog.defineClass(S, &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">S.call(<span class="built_in">this</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/** <span class="doctag">@const </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.prop = value;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">param</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params">param</span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  另外，尽管<code>goog.defineClass</code>所有新代码都应首选，但也可以使用更传统的语法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@constructor </span><span class="doctag">@extends <span class="type">&#123;S&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">S.call(<span class="built_in">this</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/** <span class="doctag">@const </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.prop = value;</span><br><span class="line">&#125;</span><br><span class="line">goog.inherits(C, S);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">param</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">C.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  如果有基类的话，实例中的属性需要在基类的构造器中定义。而方法则需要在构造器的原型上定义。</p><p>  一开始正确地定义构造器的继承关系并不是件容易的事！所以，最好使用 the Closure Library 提供的 <code>goog.inherits</code> 方法。</p><ul><li><p>不要直接操作<code>prototype</code><br>通过 class 关键字定义类比操作 prototype 更加简洁和直观。一般情况下的代码并没有必要操作原型，尽管它们对于定义旧式类声明中定义的类仍然有用。明确禁止混入和修改内置对象的原型.<br>例外:框架代码(例如Polymer或Angular)可能需要使用<code>prototype</code>s，否则实现起来会更加丑陋。</p></li><li><p>Getters and Setters<br>不要使用 JavaScript <code>getter</code>和 <code>setter</code>属性。其行为不透明出问题难追查，编译器支持上也有局限。提供正常的方法来代替他们。</p></li></ul><p>  例外：在某些情况下不可避免地会定义<code>getter</code>或<code>setter</code>（例如<code>Angular</code>和<code>Polymer</code>等数据绑定框架，或者无法与调整的外部API的兼容时）。仅在这些情况下，使用<code>getter</code>和<code>setter</code>时要格外小心，前提是它们是通过<code>get</code>和<code>set</code>简写方法关键字定义的<code>Object.defineProperties</code>（或（不是 <code>Object.defineProperty</code>，这会干扰属性重命名））。Getters不得更改可观察状态。<br>  不允许的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">get</span> <span class="title">next</span>() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.nextId++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重写 toString<br>可以重写 toString 方法，但始终应该返回成功，并且不产生副作用（side effects）。</li></ul><p>  <strong>提示:需要注意的是，特别是在 toString 中调用其他方法时，特殊情况可能导致死循环。</strong></p><ul><li><p>接口<br>接口可以通过 @interface 或 @record 来声明。通过 @record 声明的接口能够被显式（i.e. 通过 @implements）或者隐式地被类或对象实现。<br>接口上的所有非静态方法主体都必须为空块。 字段必须在类构造函数中声明为未初始化的成员,例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Something that can frobnicate.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@record</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frobnicator</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>The number of attempts before giving up. */</span></span><br><span class="line"><span class="built_in">this</span>.attempts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Performs the frobnication according to the given strategy.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!FrobnicationStrategy&#125;</span> <span class="variable">strategy</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">frobnicate</span>(<span class="params">strategy</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类<br>适当时使用抽象类。抽象类和方法必须使用注释@abstract。不要使用<code>goog.abstractMethod</code>。请参阅<a href="https://github.com/google/closure-compiler/wiki/@abstract-classes-and-methods">抽象类和方法</a>。</p></li></ul></li><li><p>函数</p><ul><li>顶级函数<br>顶级函数可以直接在导出对象上定义，也可以在本地声明，也可以选择导出,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>str */</span></span><br><span class="line"><span class="built_in">exports</span>.processString = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Process the string.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>str */</span></span><br><span class="line"><span class="keyword">const</span> processString = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Process the string.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span> = &#123;processString&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>嵌套函数及闭包<br>函数内可包含嵌套函数的定义。如果需要，可以赋值给一个 const 变量。</p></li><li><p>箭头函数<br>箭头函数提供了简洁的函数语法，并简化了嵌套函数的作用域。 优先选择箭头函数而不是function关键字，特别是对于嵌套函数。</p></li></ul><p>  推荐使用箭头函数代替 <code>f.bind(this)</code>，特别是代替 <code>goog.bind(f,this)</code>。 避免<code>const self = this</code>这样的写法。箭头函数特别适合用于可能会传参回调。</p><p>  箭头的左侧包含零个或多个参数。如果只有一个未分解的参数，则参数周围的括号是可选的。使用括号时，可以指定内联参数类型</p><p>  <strong>提示:始终都写括号是种好的做法，因为后面如果一旦新加了参数又忘记写括号则会有语法错误。</strong></p><p>  箭头的右侧包含函数的主体。 默认情况下，主体为block语句（零个或多个用花括号括起来的语句）。 如果发生以下情况之一，则主体也可能是隐式返回的单个表达式：程序逻辑要求返回值，或者void运算符位于单个函数或方法调用之前（使用void确保未定义返回，防止泄漏值并传达意图）。 如果单一表达形式提高了可读性（例如，对于简短表达或简单表达），则它是首选,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Arrow functions can be documented just like normal functions.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>numParam A number to add.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>strParam Another number to add that happens to be a string.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>The sum of the two parameters.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> moduleLocalFunc = <span class="function">(<span class="params">numParam, strParam</span>) =&gt;</span> numParam + <span class="built_in">Number</span>(strParam);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses the single expression syntax with `void` because the program logic does</span></span><br><span class="line"><span class="comment">// not require returning a value.</span></span><br><span class="line">getValue(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="keyword">void</span> alert(<span class="string">`Got <span class="subst">$&#123;result&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallbackExample</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@private <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.cachedValue_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For inline callbacks, you can use inline typing for parameters.</span></span><br><span class="line"><span class="comment">// Uses a block statement because the value of the single expression should</span></span><br><span class="line"><span class="comment">// not be returned and the expression is not a single function call.</span></span><br><span class="line">getNullableValue(<span class="function">(<span class="params"><span class="comment">/** ?number */</span> result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.cachedValue_ = result == <span class="literal">null</span> ? <span class="number">0</span> : result;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  不建议的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A function with no params and no returned value.</span></span><br><span class="line"><span class="comment">* This single expression body usage is illegal because the program logic does</span></span><br><span class="line"><span class="comment">* not require returning a value and we&#x27;re missing the `void` operator.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> moduleLocalFunc = <span class="function">() =&gt;</span> anotherFunction();</span><br></pre></td></tr></table></figure><ul><li>生成器(Generators)<br>生成器带来许多有用的抽象概念，必要时可以使用。</li></ul><p>  通过在<code>function</code>关键字后面加<code>*</code>号来定义一个生成器，后面加空格与生成器名称隔开。使用代理的<code>yield</code>时，在<code>yield</code>关键字后加<code>*</code>号,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;!Iterator&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;!Iterator&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class="line"><span class="keyword">const</span> gen2 = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">yield</span>* gen1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;!Iterator&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class="line">* <span class="function"><span class="title">gen</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>参数和返回类型<br>函数参数和返回类型通常应使用JSDoc注释记录。</p><ul><li>默认参数<br>参数列表中通过等号来指定可选参数。可选参数必须在<code>=</code>运算符的两侧都包含空格，命名上与正常参数一样（不使用 opt_ 前缀），JSDoc 指定类型时使用<code>=</code>后缀，顺序上置于正常参数之后，不要用初始化以确保代码明确。所有可选参数都需要指定默认值，哪怕它是<code>undefined</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>required This parameter is always needed.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string=&#125;</span> </span>optional This parameter can be omitted.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!Node=&#125;</span> </span>node Another optional parameter.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maybeDoSomething</span>(<span class="params">required, optional = <span class="string">&#x27;&#x27;</span>, node = <span class="literal">undefined</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@interface </span>*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interface and abstract methods must omit default parameter values.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string=&#125;</span> <span class="variable">optional</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">someMethod</span>(<span class="params">optional</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>尽量少地使用可选参数。参数不定的情况下推荐使用解构的方式，这样所定义出来的 API 更加可读。</li></ul><p>  <strong>注意：与 Python 不同，初始化可选参数时返回新的非可变对象（[] 或 {}）是可以的。因为每次可选参数被使用时，都是重新赋值，不会与上一次的复用。包括函数调用的任何表达式都会用到初始化模块，所以初始化模块应该尽量简单。避免初始化模块暴露共享可变域，这容易导致函数调用之间的无意耦合。</strong></p><ul><li>剩余参数<br>使用剩余参数而不是 arguments。JSDoc 中使用<code>...</code>标识剩余参数。剩余参数必需位于参数列表末尾。注意<code>...</code>与参数名间没有空格。也不要给剩余参数命名。千万不要给变量或参数取名<code>arguments</code>，这会覆盖内建的同名参数,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!Array&lt;string&gt;&#125;</span> </span>array This is an ordinary parameter.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;...number&#125;</span> </span>numbers The remainder of arguments are all numbers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">variadic</span>(<span class="params">array, ...numbers</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>泛型<br>定义泛型函数或方法时需在JS注文中加上@template TYPE。</p></li><li><p>扩展运算符<br>可使用展示操作符（<code>...</code>）来调用函数。当使用数组或可遍历对象解析后作为函数入参时，推荐使用展开操作符来替代 <code>Function.prototype.apply</code>。注意<code>...</code>后面没有空格,例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">...elements</span>) </span>&#123;&#125;</span><br><span class="line">myFunction(...array, ...iterable, ...generator());</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串字面量</p><ul><li>使用单引号<br>常规字符串使用单引号(<code>&#39;</code>)而非双引号(<code>&quot;</code>)来定义。<br>通常情况下，字符串不能跨行。</li></ul><p>  <strong>提示:如果字符串包含单引号字符，请考虑使用模板字符串，以避免不得不对引号进行转义。</strong></p><ul><li>模板字符串<br>使用模板字符串（<code> </code> `）替代复杂的字符串拼接，特别是参与拼接的变量很多时。模板字符串是可以跨越多行的。<br>模板字符串跨越多行时，可不受代码块缩进规则限制，如果加上缩进好看些的话也可以,例:</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arithmetic</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`Here is a table of arithmetic operations:</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a + b&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> - <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a - b&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> * <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a * b&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">$&#123;a&#125;</span> / <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a / b&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用多行接续<br>无论是常规字符串还是模板字符串中都不要使用多行接续（即在行尾加反斜杠\）。虽然 ES5 允许这么操作，但反斜杠后的空格会导致问题，并且这种形式也不易读。<br>错误的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longString = <span class="string">&#x27;This is a very long string that far exceeds the 80 \</span></span><br><span class="line"><span class="string">column limit. It unfortunately contains long stretches of spaces due \</span></span><br><span class="line"><span class="string">to how the continued lines are indented.&#x27;</span>;</span><br></pre></td></tr></table></figure>正确的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> longString = <span class="string">&#x27;This is a very long string that far exceeds the 80 &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;column limit. It does not contain long stretches of spaces since &#x27;</span> +</span><br><span class="line"><span class="string">&#x27;the concatenated strings are cleaner.&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数字字面量<br>数字可有多种呈现形式：十进制，十六进制，八进制或二进制。分别使用小写的 0x，0o，0b 前缀表示十六进制，八进制以及二进制数字。除此之外不应该出现以0开头的数字。</p></li><li><p>控制结构</p><ul><li><p>for循环<br>ES6之后一共有三种for循环,推荐使用<code>for-of</code><br><code>for-in</code>适用于字典类型（dist-style）而不要用于遍历数组。配合<code>Object.prototype.hasOwnProperty</code>来过滤掉非直接的属性。推荐使用<code>for-of </code>和<code> Object.keys</code>，其次才是 <code>for-in</code>。</p></li><li><p>异常<br>异常是语言中重要的一部分，发生异常时应尽可能抛出。始终抛出Error或子类的Error，而不是抛出字符串或其他对象作为异常。使用 <code>Error</code>时始终通过<code>new</code>来创建新实例。</p></li></ul><p>  这种处理扩展到<code>Promise</code>拒绝值，因为在异步函数中<code>Promise.reject（obj）</code>等效于<code>throw obj;</code> 。</p><p>  自定义类型的错误提供了非常好的方式展示函数中的异常。当原生错误类型不能满足需求时，应尽可能创建自定义的异常。</p><p>  遇到错误后立即抛出优于将错误进行传递。</p><p>  空的 catch 块</p><p>  响应捕获到的异常，什么也不做是非常正确的。 当确实在catch块中不执行任何操作时，但记得加注释解释一下原因,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> handleNumericResponse(response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ok) &#123;</span><br><span class="line"><span class="comment">// it&#x27;s not numeric; that&#x27;s fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure><p>  错误的写法,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">shouldFail();</span><br><span class="line">fail(<span class="string">&#x27;expected an error&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>提示:不像其他一些语言，上面示例行不通，因为会通过<code>fail</code>来捕获处理。所以使用<code>assertThrows</code>。</strong></p><ul><li><p>switch 语句<br>术语解释：switch 语句体中其实是很多组的代码块。每一组又包含一个或多个 switch 标签（<code>case Foo:</code> 或 <code>default:</code>）以及标签后跟随的代码语句。</p><ul><li>Fall-through：要加注释<br>每个 switch 标签要么通过<code>break</code>，<code>return</code>，<code>throw</code> 结束，要么通过注释直接跳过到下一标签。在发生跳过的情况时，随便加个注释都行。如果是最后一个标签可以不加,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">prepareOneOrTwo();</span><br><span class="line"><span class="comment">// fall through</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">handleOneTwoOrThree();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>default 是不能省的<br>即使 default 标签中不包含逻辑，也不要省略。</li></ul></li></ul></li><li><p>this<br>  应该只在类的构造器或方法中使用<code>this</code>，或类中的箭头函数。其他情况下使用·this·需要在函数的 JSDoc 结尾处添加 @this 注释。<br>  不要使用<code>this</code>来引用全局对象，<code>eval</code>的执行上下文，事件的触发元素，以及函数这种不必要的用法中 <code>call()</code>，<code>apply()</code> 。</p></li><li><p>相等检查<br>使用恒等运算符（=== /！==），但以下情况除外。</p><ul><li>需要强制转换的异常<br>捕捉<code>null</code>和<code>undefined</code>值：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObjectOrPrimitive == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Checking for null catches both null and undefined for objects and primitives , </span></span><br><span class="line"><span class="comment">// but does not catch other falsy values like 0 or the empty string.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>禁止使用的特性</p><ul><li>with<br>杜绝使用<code>with</code>关键字。这样的代码不易读，而且 ES5 之后就禁止掉了。</li><li>代码的动态求值<br>不要使用<code>eval</code>或<code>Function(...string) 构造器</code>代码加载器（code loader）中除外）。这些关键字很危险并且在 CSP 环境中是不工作的。</li></ul><p>  <strong>CSP 指 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">Content Security Policy (CSP)</a></strong></p><ul><li>自动分号添加<br>始终以分号结束语句（类与函数的声明除外）。</li><li>非标准的特性<br>不要使用还不是标准的特性。包括已经被移除的特性（e.g. WeakMap.clear），还未纳入标准的新特性（e.g. TC39 目前的草稿，提议，通过提议但还未完成标准制定），或一些只被部分浏览器所实现的特性。只使用包含在 ECMA-262 或 WHATWG standards 标签中的特性。但一些有自己规范的项目是可以使用这些特性的，比如 Chrome 插件或 Node.js。三方转译器提供的特性也是被禁止的。</li><li>原始类型的包装对象<br>对于原始值的包装对象（<code>Boolean</code>, <code>Number</code>, <code>String</code>, <code>Symbol</code>）不能用<code>new</code>调用，也不能用来作类型声明。<br>错误的写法,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="comment">/** Boolean */</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) alert(<span class="keyword">typeof</span> x);  <span class="comment">// alerts &#x27;object&#x27; - WAT?</span></span><br></pre></td></tr></table></figure>这些包装器可在需要类型转换时当作函数来调用（而不是使用拼接空字符串的方式来转成字符串），或用于创建 symbol。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="comment">/** boolean */</span> x = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!x) alert(<span class="keyword">typeof</span> x);  <span class="comment">// alerts &#x27;boolean&#x27;, as expected</span></span><br></pre></td></tr></table></figure></li><li>修改原生对象<br>千万不要修改原生对象，向其构造器或原型添加方法都是不行的。进行了这些操作的三方库也要避免使用。编译器在编译时会尽可能提供这些原生对象的原始版本；所以原生对象的任何东西都不要去动。</li></ul><p>  不到万不得已，不要向全局对象添加属性（e.g. 三方库需要这样做）。</p></li></ul><h2 id="JavaScript-编码风格"><a href="#JavaScript-编码风格" class="headerlink" title="JavaScript 编码风格"></a>JavaScript 编码风格</h2><ul><li><p>JSDoc<br>JSDoc 使用在了所有的类，字段以及方法上。</p><ul><li>通用形式<br>JSDoc 基本的形式如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Multiple lines of JSDoc text are written here,</span></span><br><span class="line"><span class="comment">* wrapped normally.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>arg A number to do something to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg</span>) </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>或者这种单行的形式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@const </span><span class="doctag">@private <span class="type">&#123;!Foo&#125;</span> </span>A short bit of JSDoc. */</span></span><br><span class="line"><span class="built_in">this</span>.foo_ = foo;</span><br></pre></td></tr></table></figure>如果单行形式长到需要折行，则需要切换到多行模式而不是使用单行形式。<br>有许多工具会对 JSDoc 文档进行解析以提取出有效的信息对代码进行检查和优化。所以这些注释需要好好写。</li><li>Markdown<br>JSDoc 支持 Markdown，所以必要时可包含 HTML。<br>工具会自动提取 JSDoc 的内容，其中自己书写的格式会被忽略。比如如果你写成下面这个样子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Computes weight based on three factors:</span></span><br><span class="line"><span class="comment">*   items sent</span></span><br><span class="line"><span class="comment">*   items received</span></span><br><span class="line"><span class="comment">*   last timestamp</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>最终提取出来是这样的：<br><code>Computes weight based on three factors: items sent items received last timestamp</code><br>取而代之的是，我们应该按 markdown 的语法来格式化,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Computes weight based on three factors:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  - items sent</span></span><br><span class="line"><span class="comment">*  - items received</span></span><br><span class="line"><span class="comment">*  - last timestamp</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>JSDoc标签<br>本规则可使用 JSDoc tags 的一个子集。详细列表见附录。大部分 tags 独占一行。<br>错误的写法,例：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The &quot;param&quot; tag must occupy its own line and may not be combined.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>left <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">right</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">left, right</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><p>  简单的 tag 无需额外数据（比如 @private，@const，@final，@export），可以合并到一行。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Place more complex annotations (like &quot;implements&quot; and &quot;template&quot;)</span></span><br><span class="line"><span class="comment">* on their own lines.  Multiple simple tags (like &quot;export&quot; and &quot;final&quot;)</span></span><br><span class="line"><span class="comment">* may be combined in one line.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@export </span><span class="doctag">@final</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@implements <span class="type">&#123;Iterable&lt;TYPE&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@template <span class="variable">TYPE</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!ObjType&#125;</span> </span>obj Some object.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number=&#125;</span> </span>num An optional number.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">obj, num = <span class="number">42</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@private </span><span class="doctag">@const <span class="type">&#123;!Array&lt;!ObjType|number&gt;&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.data_ = [obj, num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  关于合并及合并后的顺序没有明确的规范，代码中保持一致即可。</p><ul><li>换行<br>换行之后的 tag 块使用四个空格进行缩进。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Illustrates line wrapping for long param/return descriptions.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>foo This is a param with a description too long to fit in</span></span><br><span class="line"><span class="comment">*     one line.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>This returns something that has a description too long to</span></span><br><span class="line"><span class="comment">*     fit in one line.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">exports</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>@fileoverview 换行时不缩进。</li><li>文件头部注释<br>一个文件可以在头部有个总览。包括版权信息，作者以及默认可选的可见信息/visibility level等。文件中包含多个类时，头部这个总览显得很有必要。它可以帮助别人快速了解该文件的内容。如果写了，则应该有一个描述字段简单介绍文件中的内容以及一些依赖，或者其他信息。换行后不缩进,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@fileoverview </span>Description of file, its uses and information</span></span><br><span class="line"><span class="comment">* about its dependencies.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@package</span></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>类的注释<br>类，接口以及 records 需要有描述，参数，实现的接口以及可见性或其他适当的 tags 注释。类的描述需要告诉读者类的作用及何时使用该类，以及其他一些可以帮助别人正确使用该类的有用信息。构造器上的文本描述可省略。@constructor 和 @extends 不与 class 一起使用，除非该类是用来声明接口 @interface 或者扩展一个泛型类。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A fancier event target that does cool things.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@implements <span class="type">&#123;Iterable&lt;string&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFancyTarget</span> <span class="keyword">extends</span> <span class="title">EventTarget</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>arg1 An argument that makes this more interesting.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!Array&lt;number&gt;&#125;</span> </span>arg2 List of numbers to be processed.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">arg1, arg2</span>)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Records are also helpful.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@extends <span class="type">&#123;Iterator&lt;TYPE&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@record</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@template <span class="variable">TYPE</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listable</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;TYPE&#125;</span> </span>The next item in line to be returned. */</span></span><br><span class="line"><span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>枚举和 typedef 注释<br>所有枚举和typedef必须在上一行用适当的JSDoc标记（@typedef或@enum）进行记录。 公共枚举和typedef也必须有描述。 单个枚举项可能在上一行带有JSDoc注释的文档中。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A useful type union, which is reused often.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@typedef <span class="type">&#123;!Bandersnatch|!BandersnatchType&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> CoolUnionType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Types of bandersnatches.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@enum <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> BandersnatchType = &#123;</span><br><span class="line"><span class="comment">/** This kind is really frumious. */</span></span><br><span class="line"><span class="attr">FRUMIOUS</span>: <span class="string">&#x27;frumious&#x27;</span>,</span><br><span class="line"><span class="comment">/** The less-frumious kind. */</span></span><br><span class="line"><span class="attr">MANXOME</span>: <span class="string">&#x27;manxome&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>Typedefs 可方便地用于定义 records 类型，或 unions 的别名，复杂函数，或者 泛型类型。Typedefs 不适合用来定义字段很多的 records，因为其不支持对每个字段进行文档书写，也不适合用于模板或递归引用中。对于大型 records 使用 @record。</li><li>方法与函数注释<br>在方法和命名函数中，必须记录参数和返回类型，除非相同签名@overrides省略所有类型。必要时应记录此类型。如果函数没有非空的return语句，则可以省略返回类型。</li></ul><p>  如果方法，参数和返回描述（但不是类型）在方法的其余JSDoc或其签名中显而易见，则可以省略。</p><p>  方法的描述应使用第三人称。</p><p>  如果方法覆盖超类方法，则它必须包含@override注释。覆盖的方法从超类方法继承所有JSDoc注释（包括可见性注释），并且应在覆盖的方法中将其省略。但是，如果在类型注释中完善了任何类型，则必须显式指定所有@param和@return注释。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A class that does something. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Operates on an instance of MyClass and returns something.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!MyClass&#125;</span> </span>obj An object that for some reason needs detailed</span></span><br><span class="line"><span class="comment">*     explanation that spans multiple lines.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;!OtherClass&#125;</span> <span class="variable">obviousOtherClass</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>Whether something occurred.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">someMethod</span>(<span class="params">obj, obviousOtherClass</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@override </span>*/</span></span><br><span class="line"><span class="function"><span class="title">overriddenMethod</span>(<span class="params">param</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Demonstrates how top-level functions follow the same rules.  This one</span></span><br><span class="line"><span class="comment">* makes an array.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;TYPE&#125;</span> <span class="variable">arg</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;!Array&lt;TYPE&gt;&#125;</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@template <span class="variable">TYPE</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">arg</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>  如果只需要记录函数的参数和返回类型，则可以选择在函数签名中使用内联JSDocs。 这些内联JSDocs指定不带标签的return和param类型,例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /** <span class="title">string</span> */ <span class="title">foo</span>(<span class="params"><span class="comment">/** number */</span> arg</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>  如果需要描述或标签，请在方法上方使用单个JSDoc注释。 例如，返回值的方法需要@return标记。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">arg</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">bar</span>(<span class="params">arg</span>)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以下写法是错误的:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Illegal inline JSDocs.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>*/</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Function description. */</span> <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>  在匿名函数中，注释通常是可选的。 如果自动类型推断不足或显式注释提高了可读性，则对param进行注释并返回如下类型：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>*/</span></span><br><span class="line"><span class="function">(<span class="params"><span class="comment">/** !Array&lt;string&gt; */</span> items</span>) =&gt;</span> &#123;</span><br><span class="line">doSomethingWith(items);</span><br><span class="line"><span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>命名</p><ul><li>适用于所有标识符的规则<br>可用于标识符的有 ASCII 字符，数字，还有下划线 _ 以及不太常用的 $ (一些框架里面比如 Angular 会用)。</li></ul><p>  标识符取名尽量表意。不要怕名字太长，因为代码是给人看的，别人能看懂最重要。不要使用带歧义的缩写或者项目之外的人看不懂的缩写，也不要通过删除某个单词中的字符来发明缩写，例:</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">errorCount          <span class="comment">// No abbreviation.</span></span><br><span class="line">dnsConnectionIndex  <span class="comment">// Most people know what &quot;DNS&quot; stands for.</span></span><br><span class="line">referrerUrl         <span class="comment">// Ditto for &quot;URL&quot;.</span></span><br><span class="line">customerId          <span class="comment">// &quot;Id&quot; is both ubiquitous and unlikely to be misunderstood.</span></span><br></pre></td></tr></table></figure><p>  不建议的写法例：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n                   <span class="comment">// Meaningless.</span></span><br><span class="line">nErr                <span class="comment">// Ambiguous abbreviation.</span></span><br><span class="line">nCompConns          <span class="comment">// Ambiguous abbreviation.</span></span><br><span class="line">wgcConnections      <span class="comment">// Only your group knows what this stands for.</span></span><br><span class="line">pcReader            <span class="comment">// Lots of things can be abbreviated &quot;pc&quot;.</span></span><br><span class="line">cstmrId             <span class="comment">// Deletes internal letters.</span></span><br><span class="line">kSecondsPerDay      <span class="comment">// Do not use Hungarian notation.</span></span><br></pre></td></tr></table></figure><ul><li><p>标识符类型的命名规则</p><ul><li>包名<br>包名全是<strong>lowerCamelCase</strong>。例如，<code> my.exampleCode.deepSpace</code>但不是<code>my.examplecode.deepspace</code>或<code>my.example_code.deep_space</code>。</li><li>类名<br>定义类，接口，记录和 typedef 名称时,使用大写开头的驼峰<strong>UpperCamelCase</strong>。</li></ul><p>  未被导出的类只本地使用，并没有用 @private 标识，所以命名上不需要以下划线结尾。</p><p>  类型名称通常为名词或名词短语。比如，Request，ImmutableList，或者 VisibilityMode。此外，接口名有时会是一个形容词或形容短语（比如 Readable）。</p><ul><li>方法名<br>方法名使用小写开头的驼峰。私有方法需以下划线结尾。</li></ul><p>  方法名一般为动词或动词短语。比如<code>sendMessage</code>或者<code>stop_</code>。属性的 Getter 或 Setter 不是必需的，如果有的话，也是小写驼峰命名且需要类似这样 <code>getFoo</code>(对于布尔值使用 isFoo 或 hasFoo 形式)， <code>setFoo(value)</code>。</p><p>  单元测试代码中的方法名会出现用下划线来分隔组件形式。一种典型的形式是这样的 <code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如 <code>testPop_emptyStack</code>。对于这种测试代码中的方法，命名上没有统一的要求。</p><ul><li>枚举名<br>枚举使用大写开头的驼峰，和类相似，一般一个单数形式的名词。枚举中的元素写成<code>CONSTANT_CASE</code>。</li><li>常量名<br>常量写成 CONSTANT_CASE：所有字母使用大写，以下划线分隔单词。私有静态属性可以用内部变量代替，所以不会有使用私有枚举的情况，也就无需将常量以下划线结尾来命名。<ul><li>常量的定义<br>每个常量都是 @const 标识的静态属性或模块内部通过<code>const</code>声明的变量，但并不是所有 @const 标识的静态属性或 <code>const</code>声明的变量都是常量。需要常量时，先想清楚该对象是否真的不可变。例如，如果该对象中可观察状态中任何一个可被改变，那么几乎可以肯定它不是常数。只是想着不去改变它的值是不够的，我们要求它需要从本质上来说应该一成不变,例:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/** <span class="doctag">@const </span>*/</span> <span class="built_in">exports</span>.NAMES = ImmutableList.of(<span class="string">&#x27;Ed&#x27;</span>, <span class="string">&#x27;Ann&#x27;</span>);</span><br><span class="line"><span class="comment">/** <span class="doctag">@enum </span>*/</span> <span class="built_in">exports</span>.SomeEnum = &#123; <span class="attr">ENUM_CONSTANT</span>: <span class="string">&#x27;value&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">let</span> letVariable = <span class="string">&#x27;non-const&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123; <span class="comment">/** <span class="doctag">@const <span class="type">&#123;string&#125;</span> </span>*/</span> <span class="built_in">this</span>.nonStatic = <span class="string">&#x27;non-static&#x27;</span>; &#125; &#125;;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;string&#125;</span> </span>*/</span> MyClass.staticButMutable = <span class="string">&#x27;not @const, can be reassigned&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="comment">/** Set&lt;string&gt; */</span> mutableCollection = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="comment">/** ImmutableSet&lt;SomeMutableType&gt; */</span> mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">const</span> Foo = goog.require(<span class="string">&#x27;my.Foo&#x27;</span>);  <span class="comment">// mirrors imported name</span></span><br><span class="line"><span class="keyword">const</span> logger = log.getLogger(<span class="string">&#x27;loggers.are.not.immutable&#x27;</span>);</span><br></pre></td></tr></table></figure>常量的名称通常是名词或名词短语。</li><li>本地别名<br>给导入的变量起别名来提高可读性是可行的。函数中也有使用别名的情况。别名必需是<code>const</code>类型。</li></ul></li><li>非常量字段名<br>非常量字段（静态或其他）使用小写开头的驼峰，如果是私有的私有的则以下划线结尾。</li></ul><p>  一般是名词或名词短语。例如 <code>computedValues</code>，<code>index_</code>。</p><ul><li>参数名<br>参数使用小写开头的驼峰形式。即使参数需要一个构造器来初始化时，也是这一规则。</li></ul><p>  公有方法的参数名不能只使用一个字母。</p><p>  <strong>例外：</strong>如果三方库需要，参数名可以用 $ 开头。此例外不适用于其他标识符（e.g. 本地变量或属性）。</p><ul><li>局部变量名<br>如上所述，除了模块本地（顶级）常量外，本地变量名称都用<strong>lowerCamelCase</strong>形式编写。 函数作用域中的常量仍遵循lowerCamelCase形式。 请注意，即使变量包含构造函数，也将使用<strong>lowerCamelCase</strong>形式。</li><li>模板参数名<br>模板参数力求简洁，用一个单词，一个字母表示，全部使用大写，例如 TYPE，THIS。</li><li>模板本地名<br>未导出的模块本地名称是隐式私有的。 它们未被标记为@private，并且不以下划线结尾。这适用于类，函数，变量，常量，枚举和其他模块本地标识符。</li></ul></li><li><p>驼峰：定义<br>有时将一个英文短语转成驼峰有很多形式，例如首字母进行缩略，IPv6 以及 iOS 这种都有出现。为保证代码可控，本规范规定出如下规则。</p><ul><li>将短语移除撇号转成<strong>ASCII</strong>表示。例如 Müller’s algorithm 表示成 Muellers algorithm。</li><li>将上述结果拆分成单词，以空格或其他不发音符号（中横线）进行分隔。<ul><li>推荐的做法：如果其中包含一个已经常用的驼峰翻译，直接提取出来（e.g. AdWords 会成为 adwords）。需要注意的是 iOS 本身并不是个驼峰形式，它不属性任何形式，所以它不适用本条规则。</li></ul></li><li>将所有字母转成小写，然后将以下情况中的首字母大写：<ul><li>每个单词的首字母，这样便得到了大写开头的驼峰</li><li>除首个单词的其他所有单词的首字母，这样得到小写开头的驼峰</li></ul></li><li>将上述结果合并。</li></ul></li></ul><p>  过程中原来名称中的大小写均被忽略，例：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prose form               | Correct            | Incorrect</span><br><span class="line">-------------            | -------------      | -------------</span><br><span class="line"><span class="string">&quot;XML HTTP request&quot;</span>       | XmlHttpRequest     | XMLHTTPRequest</span><br><span class="line"><span class="string">&quot;new customer ID&quot;</span>        | newCustomerId      | newCustomerID</span><br><span class="line"><span class="string">&quot;inner stopwatch&quot;</span>        | innerStopwatch     | innerStopWatch</span><br><span class="line"><span class="string">&quot;supports IPv6 on iOS?&quot;</span>  | supportsIpv6OnIos  | supportsIPv6OnIOS</span><br><span class="line"><span class="string">&quot;YouTube importe&quot;</span>        | YouTubeImporter    | YoutubeImporter</span><br></pre></td></tr></table></figure><p>  可以接受，但不推荐。</p><p>  <strong>注意：一些英文词汇通过中横线连接的方式是有歧义的，比如 “nonempty” 和 “non-empty” 都是正确写法，所以方法名 checkNonempty checkNonEmpty 都算正确。</strong></p></li><li><p>格式化</p></li></ul><p><strong>术语解释：</strong>代码块（block-like construct）指类，函数，方法这些元素的正文部分，或花括号包裹的代码部分。参考数组字面量,对象字面量的定义，数组或对象也可以被视作一个类似于块的构造。<br><strong>提示:使用 clang-format。社区已经做了大量努力以使得 clang-format 能够很好地处理 JavaScript 文件。其中也集成了几位著名代码开发者的努力。</strong><br>    - 大括号(花括号)<br>        - 括号用于各种流程控制结构<br>        括号用在各种控制结构中（譬如 if，else，for，do，while 等），即使结构中只包含一句代码。第一条指令的非空块状结构必须另起一行。<br>        错误的写法,例:<br>        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someVeryLongCondition())</span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; foo.length; i++) bar(foo[i]);</span><br></pre></td></tr></table></figure><br>        **例外:**如果指令可以完全地用写在一行里，那么可以不用大括号以增加可读性,例:’if (shortCondition()) foo();`</p><pre><code>    - 非空代码块：K&amp;R 风格    非空代码块使用的花括号遵循 Kernighan and Ritchie 风格 (也即 [Egyptian brackets](https://blog.codinghorror.com/new-programming-jargon/))：        - 左花括号不另起新行        - 左花括号后紧跟换行        - 右花括号前需要换行        - 如果右花括号结束了语句，或者它是函数、类、类中的方法的结束括号，则其后面需要换行。如果后面紧跟的是 else，catch 或 while，或逗号，分号以及右括号，则不需要跟一个换行。        例:    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>foo */</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params">foo</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (condition(foo)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Note: this might fail.</span></span><br><span class="line">something();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">recover();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 空代码块：应紧凑    对于空代码块打开的时候就应立即闭合，中间不留空格，换行以及其他任何字符（`&#123;&#125;`），除非该代码块处于一个连续的声明语境中（譬如这些带有多个代码块的语句 `if/else`，`try/catch/finally`）,例:`function doNothing() &#123;&#125;`。    错误的写法，例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherCondition) &#123;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure>- 代码块中的缩进：2个空格每当新开一个区块或块状结构，增加两个空格的缩进。区块结束之后，缩进恢复到前一级水平。缩进对该区块内的代码和注释同样有要求。    - 数组字面量：可作为块状结构    任何数组都可以按块状结构的格式书写。例如，以下的写法都是有效（不代表全部写法）：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b =</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">someMethod(foo, [</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">], bar);</span><br></pre></td></tr></table></figure>    允许其他组合，尤其是在强调元素之间的语义分组时，而不是只用来减小较大数组的垂直大小。    - 对象字面量：可作为块状结构    对象字面量也可以当作代码块处理，规则与上面数组字面量类似。以下写法都是合法的：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b =</span><br><span class="line">&#123;<span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = &#123;<span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">someMethod(foo, &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">0</span>, <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">&#125;, bar);</span><br></pre></td></tr></table></figure>    - 类    类的声明（无论是内容声明[declarations]还是表达式声明[expressions]）都像块状结构一样缩进。在类的方法声明和类中的内容声明（表达式结束时仍然需要加分号）的右大括号（后一个大括号）之后不加分号。其中可以使用关键字extends，但是不要用@extends的JS注文（JSDoc），除非你继承了一个模板类型（templatized type）,例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@type <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="built_in">this</span>.x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>*/</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.Empty = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@extends <span class="type">&#123;Foo&lt;string&gt;&#125;</span> </span>*/</span></span><br><span class="line">foo.Bar = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@override </span>*/</span></span><br><span class="line"><span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.method() / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@interface </span>*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frobnicator</span> </span>&#123;</span><br><span class="line"><span class="comment">/** <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>message */</span></span><br><span class="line"><span class="function"><span class="title">frobnicate</span>(<span class="params">message</span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    - 函数表达式    当声明匿名函数时，函数正文在原有缩进水平上增加两个空格的缩进，例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">prefix.something.reallyLongFunctionName(<span class="string">&#x27;whatever&#x27;</span>, <span class="function">(<span class="params">a1, a2</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Indent the function body +2 relative to indentation depth</span></span><br><span class="line"><span class="comment">// of the &#x27;prefix&#x27; statement one line above.</span></span><br><span class="line"><span class="keyword">if</span> (a1.equals(a2)) &#123;</span><br><span class="line">someOtherLongFunctionName(a1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">andNowForSomethingCompletelyDifferent(a2.parrot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">some.reallyLongFunctionCall(arg1, arg2, arg3)</span><br><span class="line">.thatsWrapped()</span><br><span class="line">.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Indent the function body +2 relative to the indentation depth</span></span><br><span class="line"><span class="comment">// of the &#x27;.then()&#x27; call.</span></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">result.use();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>    - Switch语句    就像其他块状结构，该语句的缩进方式也是+2。        开始新的一条Switch标签，格式要像开始一个新的块状结构，新起一行，缩进+2。适当时候可以用块状结构来明确Switch全文范围。而到下一条Switch标签的开始行，缩进（暂时）还原到原缩进水平。        在break和下一条Switch标签之间可以适当地空一行。    例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (animal) &#123;</span><br><span class="line"><span class="keyword">case</span> Animal.BANDERSNATCH:</span><br><span class="line">handleBandersnatch();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Animal.JABBERWOCK:</span><br><span class="line">handleJabberwock();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown animal&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 声明语句    - 一个声明占一行    每个声明语句后都跟换行。    - 分号是必需的    语句后需用分号结束。不能依赖于编辑器的自动分号插入功能。- 最大列宽：80对于 JavaScript 源码，规定其单行长度不超过 80 字符。除以下列出的情形外，超出的时候需要根据下面的换行规则来进行换行操作。例外的情形：    - `goog.module`，`goog.require`和`goog.requireType`语句    - ES模块的`import`和`export from`语句- 换行**术语解释：**换行指将一个表达式拆分成多行展示。    并没有一个全面准确的的规则来指导每种场景下该如何换行，相反，对同一段代码往往存在多种合法的换行方式。    **提示：尽管换行大多时候是为了满足列宽限制，但在满足的情况下，编码过程中每个人做法也不尽相同，这是可以的。抽取方法或变量有可能会规避掉换行的问题。**        - 何处该换行        换行的的准则是：尽量在优先级高的语法层面（higher syntactic level）进行，例：        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">currentEstimate =</span><br><span class="line">calc(currentEstimate + x * currentEstimate) /</span><br><span class="line"><span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>        不推荐的写法，例：            <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">currentEstimate = calc(currentEstimate + x *</span><br><span class="line">currentEstimate) / <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>        上面示例中，语法优先级从高到低依次为：赋值，除法，函数调用，参数，数字常量。        操作符的规则：        - 请在运算符之后换行（注意这和JAVA谷歌代码风格不同）。“.”并不是一个运算符，所以不适用上述规则。        - 方法和构造函数之后的左圆括号不能换行。        - 逗号紧跟前面的代码。        **注意：换行首要目的是保持代码整洁，当最小行数能满足需求时，换行是不需要的。**    - 换行后后续行至少有4个空格的缩进    当发生换行时，第一行后面跟着的其他行至少缩进 4 个空格，除非满足代码块的缩进规则，可另说。    换行后后续跟随多行时，缩进可适当大于 4 个空格。通常，语法中低优先级的后续行以 4 的倍数进行缩进，如果只有两行并且处于同一优先级，则保持一样的缩进即可。- 空格    - 垂直方向的空格    以下场景需要有一个空行：        - 类或对象中的方法间        例外的情形：对象中属性间的空行是可选的。如果有的话，一般是用来将属性进行分组。                - 方法体中，尽量少地使用空行来进行代码的分隔。函数体开始和结束都不要加空行。                - 类或对象中首个方法前及最后一个方法后的空行，既不提倡也不反对。            连续多个空行是允许的，但不鼓励这么做。    - 水平方向的空格    水平方向的空格根据出现的位置不同分为三类：行首（一行的开始），行尾（一行的结束）以及行间（一行中除去行首及行尾的部分）。行首的空格（i.e. 缩进）无处不在。行尾的空格是禁止的。        除了 Javascript 本身及其他规则的要求，还有字面量，注释，JSDoc 等需要的空格外，单个的 ASCII 类型的空格在以下情形中也是需要的。    - 将关键字（比如 `if`，`for`，`catch`）与括号（`(`）分隔。        - 将关键字（`else`，`catch`）与闭合括号（`&#125;`） 分隔。        - 对于左花括号有两种例外：            - 作为函数首个参数的对象之前，数组中首个对象元素 （`foo(&#123;a: [&#123;c: d&#125;]&#125;)`）。                - 在模板表达式中，因为模板语法的限制不能加空格（`abc$&#123;1 + 2&#125;def`）。            - 二元，三元操作符的两边。        - 逗号或分号后，但其前面是不允许有空格的。        - 对象字面量中冒号后面。        - 双斜线（//）两边。这里可以使用多个空格，但也不是必需的。        - JSDoc 注释及其两边        比如简写的类型声明`this.foo = /** @type &#123;number&#125; */ (bar);` 或 `function(/** string */ foo) &#123;;` 或 `baz(/* buzz= */ true)`    - 水平对齐:不鼓励    **术语解释：**水平对齐是在代码中添加可变数量的附加空格的一种做法，目的是使某些标记直接出现在前几行中其他标记的下面。    下面的示例中展示了正常的代码及带水平对齐的代码，后者是不推荐的:    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">tiny</span>: <span class="number">42</span>, <span class="comment">// this is great</span></span><br><span class="line"><span class="attr">longer</span>: <span class="number">435</span>, <span class="comment">// this too</span></span><br><span class="line">&#125;;</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">tiny</span>:   <span class="number">42</span>,  <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="attr">longer</span>: <span class="number">435</span>, <span class="comment">// may leave it unaligned</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>    这种做法是允许的，但 Google 风格里面不推荐。甚至在已经存在的代码中也不鼓励继续使用这种方式进行维护。    **注意：对齐可以增加可读性，但是对后续的维护增加了困难。考虑到后续改写代码可能只会该代码中的一行。修改可能会导致规则允许下格式的崩坏。这常常会错使代码编写者（比如你）调整附近几行的空格，从而导致一系列的格式重写。这样，只是一行的修改就会有一个“爆炸半径”（对附近代码的影响）。这么做最多会让你做一些无用功，但是至少是个失败的历史版本，降低了阅读者的速度，也会导致一些合并冲突。**    - 函数参数    本规则更倾向于把所有函数的参数放在函数名的同一行。如果这么做让代码超出了80字符的限制，那么就必须做基于可读性的自动换行。为了节约空间，最好每行都接近80字符，或者一个参数一行来增加可读性。缩进4个空格。允许和圆括号对齐，但是不推荐。</code></pre><p>下列就是最常见的函数参数对齐模式：<br>        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arguments start on a new line, indented four spaces. Preferred when the</span></span><br><span class="line"><span class="comment">// arguments don&#x27;t fit on the same line with the function name (or the keyword</span></span><br><span class="line"><span class="comment">// &quot;function&quot;) but fit entirely on the second line. Works with very long</span></span><br><span class="line"><span class="comment">// function names, survives renaming without reindenting, low on space.</span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree</span>)</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the argument list is longer, wrap at 80. Uses less vertical space,</span></span><br><span class="line"><span class="comment">// but violates the rectangle rule and is thus not recommended.</span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params">veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,</span></span></span><br><span class="line"><span class="params"><span class="function">tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator</span>)</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Four-space, one argument per line.  Works with long function names,</span></span><br><span class="line"><span class="comment">// survives renaming, and emphasizes each argument.</span></span><br><span class="line"><span class="function"><span class="title">doSomething</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">veryDescriptiveArgumentNumberOne,</span></span></span><br><span class="line"><span class="params"><span class="function">veryDescriptiveArgumentTwo,</span></span></span><br><span class="line"><span class="params"><span class="function">tableModelEventHandlerProxy,</span></span></span><br><span class="line"><span class="params"><span class="function">artichokeDescriptorAdapterIterator</span>)</span> &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    - 分组括号（Grouping parentheses）：推荐的写法<br>    只有代码作者和审阅者都觉得如果不分组不会引起歧义，并且加了分组也不会让代码变得更易读，那么分组可以省略。因为，不是每个人都将操作符优先级熟记于心。</p><pre><code>对于这些关键字，不要添加额外的分组 `delete`，`typeof`，`void`，`return`，`throw`，`case`，`in`，`of` 以及 `yield`。类型转换时需要使用括号强制分组：`/** @type &#123;!Foo&#125; */ (foo)`。- 注释本规则讨论注释的写法。JSDoc 相关的注释单独在上面已经讨论过了。    - 块注释风格    块状注释与被注释代码保持相同缩进。`/* ... */ `和 `//` 都是。对于多行的` /* ... */ `注释，后续注释行以`*`开头且与上一行缩进保持一致。参数的注释紧随参数之后，用于在函数名或参数名无法完全表达其意思的情况,例：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is</span></span><br><span class="line"><span class="comment">* okay.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// And so</span></span><br><span class="line"><span class="comment">// is this.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is fine, too. */</span></span><br></pre></td></tr></table></figure>    不要将JSDoc（`/ **…* /`）用于实现注释。    - 参数名称注释    每当值和方法名称未能充分传达含义时，都应使用“参数名称”注释，并且将方法重构得更清晰是不可行的。 它们的首选格式是值之前使用`=`：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(obviousParam, <span class="comment">/* shouldRender= */</span> <span class="literal">true</span>, <span class="comment">/* name= */</span> <span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure>                为了与周围的代码保持一致，可以将它们放在值后面，而不使用`=`：    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someFunction(obviousParam, <span class="literal">true</span> <span class="comment">/* shouldRender */</span>, <span class="string">&#x27;hello&#x27;</span> <span class="comment">/* name */</span>);</span><br></pre></td></tr></table></figure></code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>保持一致性.</p><p>当你在编辑代码之前，先花一些时间查看一下现有代码的风格。比如，如果现有的代码给算术运算符添加了空格，你也应该添加。</p><p>代码风格中一个关键点是整理一份常用词汇表, 开发者认同它并且遵循, 这样在代码中就能统一表述。 这里提出了一些全局上的风格规则, 但也要考虑自身情况形成自己的代码风格。 但如果你添加的代码和现有的代码有很大的区别, 这就让阅读者感到很不和谐。 所以, 避免这种情况的发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>人生——读书笔记</title>
    <link href="http://example.com/2020/02/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F/"/>
    <id>http://example.com/2020/02/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E4%BA%BA%E7%94%9F/</id>
    <published>2020-02-13T11:54:00.000Z</published>
    <updated>2021-08-07T05:59:13.574Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>如果此时此刻有人和我说：人生如梦，世事难料。我肯定请他坐下来喝两杯畅谈一下人生!<br>必须承认,以往很多时候，年纪轻轻的我不曾真正好好珍惜眼前的一切,即便一些大道理烂熟于心。从某种程度上来说，我和高加林一样：受过教育,想要更好的生活。但生活常常和我或者说我们开玩笑，一切在惊喜和挫败往复循环，它教会我们很多东西,但大多情况下，我们会先失去一些东西，比如友情，或者一些物质上东西，然后再深刻地体会到某些道理，然而不是深切感受完就可以避免以后发生类似的事情给我们带来的伤害。<br>高加林生于农村，长于县城，书中说多年的教育洗去他身上的泥土气息，我是认同的，他受教育的时间远多于在农村老家生活的时间，且几乎没有劳作，同时他能一眼看尽农村人的一生，这无疑坚定了他想扎根城市的决心。<br>高明楼的儿子勉勉强强上完高中走后门夺走了高加林的教师工作，断了高加林的念想，高加林的父母老老实实本本分分一辈子，这样的受打击的事情让一家人感到怎样的无助和绝望，我无法想象。这里我是替他们一家打抱不平的；<br>回归农民，高玉德把轻松的活交给儿子，儿子第一天上县城的表现让人唏嘘，却也因此开启了和巧珍的爱情。经历心里的麻木和生理上的痛苦，还有巧珍热烈且温柔的爱，高的心态渐渐平和，但身边人对于他想回到城里的想法清清楚楚。生活过得去，却失去了实现梦想的机会，这里我是同情他的，因为这也是真实生活中一些人真实的样子；<br>而后高加林的叔叔坐着”大领导”的位置归来，马占胜又一手包办高加林的工作，高的前程似乎又得见光明。回到城里的他，生活和事业都有了很大的起色，我是高兴的。后来黄亚萍对他展开热烈的爱情攻势，一边是内心真正爱着的巧珍，一边是象征着梦想的未来，最终选择他选择和中学同学”私定终身”，抛弃巧珍。在更远更大的天地向他招手时候，再一次出现人生波折，高被检举，再次回到农村已然物是人非，巧珍已嫁为他人妇。此刻她仍然盼着高能够好好活下去，自己去为高谋出路，高也后悔不已。看到这里我也经历一系列情绪波折，开始非常佩服作者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果此时此刻有人和我说：人生如梦，世事难料。我肯定请他坐下来喝两杯畅谈一下人生!&lt;br&gt;</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文学" scheme="http://example.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>跨域及解决方案</title>
    <link href="http://example.com/2020/02/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2020/02/12/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-02-12T09:24:11.000Z</published>
    <updated>2021-08-07T05:59:13.635Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="跨域问题的产生"><a href="#跨域问题的产生" class="headerlink" title="跨域问题的产生"></a>跨域问题的产生</h2><p>前端开发人员都知道,浏览器安全的基石是”同源策略”（same-origin policy）.<br>同源策略是 1995 年由 Netscape 公司引入浏览器.目前所有浏览器都实行这个策略.它主要是为了防止XSS,CSRF攻击.</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>URL的构成——http://主机名 . 域名（端口号、参数、查询等可选）</p><p>此外,我们还要知道域是分层管理的,像中国的行政级别:<br>最高层的域是根域(root)”.”,就是一个点,像国家主席一样.全球只有13个根域服务器,基本数都在美国,中国一台根域服务器都没有.</p><p>根域的下一层就是第二层次的顶级域(TLD),像各省的省长.它也就是俗称的”域名后缀”,顶级域划分方法:</p><ul><li>按国家划分: .cn(中国)、.tw(台湾)、.hk(香港)等</li><li>按组织性质划分: .org、.net、.com、.gov、.cc等</li><li>反向域: arpa(这是反向解析的特殊顶级域)</li></ul><p>顶级域的下一层就是普通的域,公司或个人在互联网上注册的域名一般都是这些普通的域,如baidu.com.</p><p><strong>注意点:</strong></p><ul><li>顶级域名就是一级域名</li><li>N级域名就是在N-1级域名前追加一级</li></ul><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>这里的”同源”指的是:</p><ul><li><strong>协议相同</strong></li><li><strong>域名相同</strong></li><li><strong>端口相同</strong></li></ul><p>带来的限制:</p><ul><li><strong>Cookie、LocalStorage 和 IndexDB 无法读取</strong></li><li><strong>DOM无法获得</strong></li><li><strong>AJAX请求不能发送</strong></li></ul><p>但是有三个标签是允许跨域加载资源的:</p><ul><li><strong>&lt;img src=””&gt;</strong></li><li><strong>&lt;link href=””&gt;</strong></li><li><strong>&lt;script src=””&gt;</strong></li></ul><h2 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h2><p>当协议、子域名、主域名、端口号任意一个不相同时,都是不同的域.<br>不同域之间相互请求资源,就称为”<strong>跨域</strong>“,常见跨域场景如下所示:<br><img src="%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.png" alt="跨域及解决方案.md"></p><p><strong>注意点:</strong></p><ul><li>如果是协议和端口造成的跨域问题,”前台”是无能为力的</li><li>在跨域问题上,仅仅是通过”URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断.</li></ul><p>这里你或许有两个疑问:</p><ul><li>在跨域的情况下,请求被怎么处理了?<br>  跨域并不是请求发不出去,请求能发出去,服务端能收到请求并正常响应,只是响应结果被浏览器拦截了.</li><li>为什么提交表单可以避免跨域问题,Ajax就不行?<br>  跨域的目的是为了组织用户读到另一个域名下的内容,Ajax可以获取响应,这里存在有安全隐患,故而浏览器拦截了响应;表单则只是提交数据,不会获取新的内容,所以可以发去跨域请求.</li></ul><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h4 id="CORS跨域资源共享-Cross-Origin-Resource-Sharing"><a href="#CORS跨域资源共享-Cross-Origin-Resource-Sharing" class="headerlink" title="CORS跨域资源共享(Cross-Origin Resource Sharing)"></a>CORS跨域资源共享(Cross-Origin Resource Sharing)</h4><p>CORS 需要浏览器和后端同时支持,实现 CORS 通信的关键是后端.目前几乎所有浏览器都支持 CORS, IE则不能低于IE10.<br>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS. 该属性可以表示哪些域名可以访问资源,如果设置通配符则表示所有网站都可以访问资源.<br>虽然设置 CORS 和前端没什么关系,但是通过这种方式解决跨域问题的话,会在发送请求时出现两种情况,分别为简单请求和非简单请求(需预检请求).</p><p><strong>简单请求:</strong></p><p>使用下面任意HTTP方法的:</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>Content-Type 的值仅限于下列三者之一:</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>对于简单请求,浏览器会直接发送 CORS 请求,具体说来就是在 header 中加入 Origin 请求头字段.同样,在响应头中,返回服务器设置的相关 CORS 头部字段, Access-Control-Allow-Origin 字段为允许跨域请求的源.请求时浏览器在请求头的 Origin 中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回,具体如下:<br><img src="%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2.png" alt="跨域及解决方案.md"><br><strong>非简单请求:</strong></p><p>使用下面任意HTTP方法的:</p><ul><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ul><p>Content-Type 的值不属于下列三者之一:</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>当符合非简单请求(预检请求)的条件时,浏览器会自动先发送一个options请求,如果服务端支持该请求,则会将真正的请求发送到后端;反之,控制台将会抛出错误.</p><p>如果非简单请求(预检请求)发送成功，则会在头部多返回以下字段:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://localhost:8000  //该字段表明可供那个源跨域</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT        // 该字段表明服务端支持的请求方法</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header       // 实际请求将携带的自定义请求首部字段</span><br></pre></td></tr></table></figure><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ul><li>原理:利用**&lt;script&gt;**标签没有跨域限制的漏洞,网页可以得到从其它来源动态产生 JSON 数据.JSONP 请求必须要对方的服务器做支持才可以.</li><li>JSONP和AJAX对比:二者都是客户端遵循向服务器发送请求,从服务器获取数据的方式.但AJAX属于同源策略,JSONP不是.</li></ul><p>看个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;mera http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;JSONP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;http://a2.att.hudong.com/36/48/19300001357258133412489354717.jpg&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3.png" alt="跨域及解决方案.md"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;跨域问题的产生&quot;&gt;&lt;a href=&quot;#跨域问题的产生&quot; class=&quot;head</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中Promise</title>
    <link href="http://example.com/2020/02/11/JavaScript%E4%B8%ADPromise/"/>
    <id>http://example.com/2020/02/11/JavaScript%E4%B8%ADPromise/</id>
    <published>2020-02-11T09:16:41.000Z</published>
    <updated>2021-08-07T05:59:13.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="Promise-出现的原因"><a href="#Promise-出现的原因" class="headerlink" title="Promise 出现的原因"></a>Promise 出现的原因</h2><p>在 Promise 出现以前,处理一个Ajax请求,大概是这样的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: data&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>, result)<span class="comment">// 成功的回调，result为异步拿到的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看起来还不错,但需求变化了,现在需要根据第前面的结果继续请求,代码大概如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: data&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: result1&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: result2&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result3</span>)</span>&#123;</span><br><span class="line">            $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: result3&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">result4</span>)</span>&#123;</span><br><span class="line">                ......</span><br><span class="line">                $.get(<span class="string">&#x27;url&#x27;</span>, &#123;<span class="attr">data</span>: resultn&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">resultn+<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上就是<strong>回调地狱</strong>,更糟糕的是,我们可能还要对每次请求的结果进行一些处理,代码会更加臃肿,后期维护也非常痛苦!</p><p>那么总结一下回调地狱的特点:</p><ul><li>代码臃肿</li><li>可读性差</li><li>耦合度过高,可维护性差</li><li>代码复用性差</li><li>容易出现Bug</li><li>只能在回调里处理异常</li></ul><p>后来出现了Promise,它以一种更加友好的代码组织方式,解决了异步嵌套的问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 请求结果<span class="number">1</span> = 请求<span class="number">1</span>();</span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">2</span> = 请求<span class="number">2</span>(请求结果<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">3</span> = 请求<span class="number">3</span>(请求结果<span class="number">2</span>); </span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">4</span> = 请求<span class="number">2</span>(请求结果<span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> 请求结果<span class="number">5</span> = 请求<span class="number">3</span>(请求结果<span class="number">4</span>); </span><br></pre></td></tr></table></figure><p>类似与上面同步的写法.于是Promise规范诞生了!</p><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><p>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.</p><p>优点:</p><ul><li>异步操作将以同步的流程表达出来,避免了层层嵌套的回调函数.</li><li>Promise 对象提供了统一的接口,使得控制异步操作更容易.</li></ul><p>缺点:</p><ul><li>无法取消,一旦新建就会立即执行,无法中途取消.</li><li>若不设置回调函数,promise 内部会抛出错误,不会反映到外部</li></ul><h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise/A+ 规范"></a>Promise/A+ 规范</h2><p>** Promise 规范 **有很多,如 Promise/A , Promise/B , Promise/D 以及 Promise/A 的升级版 Promise/A+ ,最终ES6采用了 <strong>Promise/A+</strong> 规范.</p><p>Promise 规范:</p><ul><li>英文版: <a href="https://promisesaplus.com/">https://promisesaplus.com/</a></li><li>中文版: <a href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/">http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/</a></li></ul><p>总结如下:</p><ul><li><p>一个 Promise 对象有种个状态,并且状态一旦改变,便不能再被更改为其他状态.</p><ul><li><strong>pending</strong>: 异步任务正在执行.</li><li><strong>fulfilled</strong>: 异步任务执行成功.</li><li><strong>rejected</strong>: 异步任务执行失败.</li></ul></li><li><p><strong>then</strong>方法可以被同一个 Promise 调用多次,且必须返回一个 Promise</p></li></ul><h2 id="Promise-语法"><a href="#Promise-语法" class="headerlink" title="Promise 语法"></a>Promise 语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;<span class="comment">/* executor */</span>&#125;   );</span><br></pre></td></tr></table></figure><ul><li>Promise构造函数接受一个函数作为参数,该函数的两个参数分别是resolve和reject.它们是两个函数,由 JavaScript 引擎提供,不用自己部署.</li><li>resolve 函数的作用:将Promise实例的状态从”pending”到”fulfilled”,在异步操作成功时调用,并将异步操作的结果,作为参数传递出去.</li><li>reject 函数的作用:将Promise实例的状态从”pending”到”rejected”,在异步操作失败时调用,并将异步操作报出的错误，作为参数传递出去.</li></ul><p>例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(promise);<span class="comment">//Promise &#123; &#x27;Cola&#x27; &#125;</span></span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">//Cola</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise);<span class="comment">//Promise &#123; &lt;pending&gt; &#125;</span></span><br></pre></td></tr></table></figure><p>输出顺序:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123; <span class="string">&#x27;Cola&#x27;</span> &#125;</span><br><span class="line">Cola</span><br></pre></td></tr></table></figure><h2 id="Promise-常用API"><a href="#Promise-常用API" class="headerlink" title="Promise 常用API"></a>Promise 常用API</h2><ul><li>Promise.resolve()</li><li>Promise.reject()</li><li>Promise.then(成功回调函数，失败回调函数)</li><li>Promise.then(成功回调函数).catch(失败回调函数)</li><li>Promise.then(成功回调函数).catch(失败回调函数).finally(成功失败都执行的函数)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I like &#x27;</span> + data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;).finally(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;这是finally&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Promise.all(iterable):方法返回一个 Promise 实例,此实例在 iterable 参数内所有的 promise 都”完成（resolved）”或参数中不包含 promise 时回调完成（resolve）;如果参数中 promise 有一个失败（rejected）,此实例回调失败（reject）,失败原因的是第一个失败 promise 的结果.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="string">&#x27;like&#x27;</span></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">//[ &#x27;I&#x27;, &#x27;like&#x27;, &#x27;Cola&#x27; ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>Promise.race(iterable):返回一个 promise,一旦迭代器中的某个promise解决或拒绝,返回的 promise就会解决或拒绝.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);<span class="comment">//two</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Promise-出现的原因&quot;&gt;&lt;a href=&quot;#Promise-出现的原因&quot;</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="ES6" scheme="http://example.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的同步异步和执行机制</title>
    <link href="http://example.com/2020/02/10/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2020/02/10/JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-10T07:23:13.000Z</published>
    <updated>2021-08-07T05:59:13.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>##JavaScript中的单线程<br>技术的出现总是和应用场景密切相关.<br>JavaScript诞生于1995年,主要用于处理表单验证操作,也就是实现用户和浏览器的交互.</p><p>由此带来一个思考:这门语言为什么是单线程?<br>作为浏览器脚本语言,JavaScript 的主要用途是与用户互动,以及操作 DOM.这决定了它只能是单线程,否则会带来很复杂的同步问题.比如,假定JavaScript同时有两个线程,一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以,<strong>为了避免复杂性，从一诞生,JavaScript 就是单线程,这已经成了这门语言的核心特征,将来也不会改变.</strong></p><p>为了利用多核 CPU 的计算能力,HTML5 提出 <strong>Web Worker 标准</strong>,允许 JavaScript 脚本创建多个线程,但是子线程完全受主线程控制,且不得操作 DOM.所以,<strong>这个新标准并没有改变 JavaScript 单线程的本质.</strong></p><p>那么单线程的特点就很明显了:</p><ul><li>实现起来比较简单,执行环境相对单纯；</li><li>只要有一个任务耗时很长,后面的任务都必须排队等着,会拖延整个程序的执行.<br>(常见的浏览器无响应(假死),往往就是因为某一段Javascript代码长时间运行(比如死循),导致整个页面卡在这个地方,其他任务无法执行.)</li></ul><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>在JS中,同步意味着在很多情况下CPU在等待:后一个任务等待前一个任务结束,然后再执行,程序的执行顺序与任务的排列顺序是一致的、同步的;也就是说当一件事情没有处理完成,JS会一直处理它,直至完成,才会开始下一件事情,这样可能会堵塞代码执行;</p><p>异步则是指每一个任务有一个或多个回调函数(callback),前一个任务结束后,不是执行后一个任务,而是执行回调函数,后一个任务则是不等前一个任务结束就执行,所以程序的执行顺序与任务的排列顺序是不一致的、异步的.</p><p>一句话概括就是:<strong>同步等结果,异步不等结果.</strong></p><h2 id="JavaScript的执行机制"><a href="#JavaScript的执行机制" class="headerlink" title="JavaScript的执行机制"></a>JavaScript的执行机制</h2><p>流程图如下:<br><img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/1.png" alt="JavaScript的同步异步和执行机制.md"><br>注意点:</p><ul><li>JS代码分为同步任务和异步任务.</li><li>同步任务进入主线程执行,异步任务进入<strong>Event Table(事件表)</strong>,当事件表中的异步任务完成后会在**Event Queue(事件队列)**中注册回调函数.</li><li>主线程中的任务全部完成后,才会执行<strong>Event Queue中</strong>的任务.</li><li>JS解析器会不断重复检查主线程执行栈是否为空,然后重复第3步,这称为<strong>Event Loop(事件循环)</strong>.</li></ul><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>JS代码的类型如下图所示:<br><img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/2.png" alt="JavaScript的同步异步和执行机制.md"></p><p>宏任务主要有:</p><ul><li>script代码段</li><li>setTimeout</li><li>setInterval</li><li>I/O</li></ul><p>微任务主要有:</p><ul><li>process.nextTick</li><li>Promise</li></ul><p>注意点:</p><ul><li>任务有**宏任务(Macro Task)<strong>和</strong>微任务(Micro Task)**之分,这对JS代码的执行有更细致的影响.</li><li>异步任务中的宏任务和微任务会进入不同的<strong>Event Queue(事件队列)</strong>,即<strong>Event Queue</strong>又可以分为宏任务队列和微任务队列.</li><li><strong>setInterval</strong>会按照设定的时间间隔重复地在<strong>Event Queue</strong>中注册回调函数,如果某一段时间主线程代码执行太久,那么<strong>setInterval</strong>的回调函数可能阻塞到一起执行,无法保持设定的时间间隔,如果此时<strong>setInterval</strong>用于动画,则体现为卡顿.</li></ul><h2 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h2><p><img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/3.png" alt="JavaScript的同步异步和执行机制.md"></p><p>通常来说,页面中JS的执行顺序是这样的:</p><ul><li>第一轮事件循环:<br>  1.主线程执行JS整段(宏代码),将ajax、setTimeOut、promise等回调函数注册到<strong>Event Queue</strong>中,并区分宏任务和微任务.<br>  2.主线程提取并执行<strong>Evene Queue</strong>中的ajax、promise等所有微任务,并注册微任务中的异步任务到<strong>Event Queue</strong>(如果有).</li><li>第二轮事件循环:<br>  1.主线程提取并执行<strong>Evene Queue</strong>中的第一个宏任务,注册该任务中的异步任务到<strong>Evene Queue</strong>(如果有).<br>  2.执行<strong>Evene Queue</strong>中所有的微任务,并注册微任务中的异步任务到<strong>Evene Queue</strong>(如果有).</li><li>类似的循环:宏任务没执行完一个,就清空一次时间队列中的微任务.<br>注意点:<strong>事件队列中分”宏任务队列”和”微任务队列”，每执行一次任务都可能注册新的宏任务或微任务到相应的任务队列中.</strong></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记作 set1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    <span class="comment">// set4</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// pro2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记作 pro1</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    <span class="comment">// set3</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记作 set2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="comment">// 记作 pro3</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终输出 : 1 6 7 2 4 5 9 10 11 8 3</span></span><br></pre></td></tr></table></figure><ul><li><p>第一轮事件循环:<br>  1.将整段script作为第一个宏任务进入主线程,遇到console.log,输出1.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/4.png" alt="JavaScript的同步异步和执行机制.md"><br>  2.遇到set1,其回调函数被分发到宏任务<strong>Event Queue</strong>中.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/5.png" alt="JavaScript的同步异步和执行机制.md"><br>  3.遇到pro1,new Promise直接执行,输出6.then被分发到微任务<strong>Event Queue</strong>中.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/6.png" alt="JavaScript的同步异步和执行机制.md"><br>  4.遇到set2,其回调函数被分发到宏任务<strong>Event Queue</strong>中.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/7.png" alt="JavaScript的同步异步和执行机制.md"><br>  5.主线程的整段JS代码(宏任务)执行完成,开始清空所有微任务;主线程执行微任务pro1,输出7;遇到set3，注册回调函数。<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/8.png" alt="JavaScript的同步异步和执行机制.md"></p></li><li><p>第二轮事件循环<br>  1.主线程执行队列中第一个宏任务set1,输出2;遇到set4,注册回调;再遇到pro2,new Promise直接执行,输出4,并注册回调.<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/9.png" alt="JavaScript的同步异步和执行机制.md"><br>  2.set1(宏任务)执行完,开始清空微任务,主线程执行微任务pro2,输出5;<br>  <img src="JavaScript%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/10.png" alt="JavaScript的同步异步和执行机制.md"></p></li><li><p>第三轮事件循环<br>  1.主线程执行队列中第一个宏任务set2，输出9；代码中遇到了pro3，new promise()直接输出10，并注册回调；<br>  2.set2宏任务执行完毕，开始情况微任务，主线程执行微任务pro3，输出11。</p></li><li><p>类似循环…</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##JavaScript中的单线程&lt;br&gt;技术的出现总是和应用场景密切相关.&lt;br&gt;Ja</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>围城——读书笔记</title>
    <link href="http://example.com/2020/02/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%9B%B4%E5%9F%8E/"/>
    <id>http://example.com/2020/02/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--%E5%9B%B4%E5%9F%8E/</id>
    <published>2020-02-09T15:27:15.000Z</published>
    <updated>2021-08-07T05:59:13.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>惊叹钱老的经典！借着小说揭露那个时代的病态，文笔犀利，辛辣讽刺。<br>方鸿渐自己留洋归来，在有着前清举人称号的父亲，迂腐的母亲，惺惺作态的弟妹的大家庭中，代表着西式文化，与传统的中国文化进行了一场激烈的碰撞。还有和肝胆相照的赵辛楣，极具才气的苏小姐，道貌岸然的李梅亭等一系列个性鲜明人物的故事，道出世事无常，人性虚伪，也暗讽陈腐的旧中国包括代表西方文化的部分知识分子。<br>“城中的人想出去，城外的人想冲进来”，我想这话不仅仅只是说婚姻，生活也是如此。方鸿渐的一生都在城内外兜兜转转，恋爱跟着失恋，教书跟着被辞退，结婚跟着不快乐。<br>之后方鸿渐和孙柔嘉的结合，到底不是有情人终成眷属，步入婚姻，逐渐暴露出双方的真实，原生家庭带来的矛盾，经济上的窘迫，让两个人并不快乐。可以说这样婚姻是围城，不过也不能忽视现实。<br>在现实中我们也会深陷”围城”，大多时候都是我们自己造成的困扰和奇怪的想法，消极的想法总是让人感到悲观，要经常审视自己的内心。有些人快乐的时候很少，和生活一直在做抗争，有些人一直保持积极乐观的心态，带着极大的热情生活，这些人并非一直如此，状态相互转化间可见”围城”并非牢不可破，该破的是我们自己的想法。</p><hr><h3 id="围城—读书笔记2-3-2-10"><a href="#围城—读书笔记2-3-2-10" class="headerlink" title="围城—读书笔记2.3-2.10"></a>围城—读书笔记2.3-2.10</h3><h4 id="小范宝贝"><a href="#小范宝贝" class="headerlink" title="小范宝贝"></a>小范宝贝</h4><p>《围城》这本书，刚看时没有什么深刻的体会，但它可能经典就经典在随着故事情节的发展，人性的弱点与人生的荒凉慢慢的展现在了你的面前，甚至会使读者在方鸿渐的身上找到一丝情感的共鸣，像是人性的缩影，在他的身上体现的淋漓尽致。<br>故事以夕阳下海面上缓缓行驶的船只开头，在这艘船上方鸿渐与“半裸的”“局部真理的”鲍小姐有了一夜的情缘。而同时，同样留学归来的苏小姐也对他芳心暗许。苏文纨家室不错又是留样归来，长得也眉清目秀，可是方鸿渐到最后也没有喜欢上苏小姐，反而是对她的表妹唐晓芙可以说是一见钟情。钱钟书先生是这样描述唐晓芙的：唐小姐妩媚端正的圆脸，有两个浅酒涡。天生着一般女人要花钱费时、调脂和粉来仿造的好脸色，新鲜得使人见了忘掉口渴而又觉嘴馋，仿佛是好水果。她眼睛并不顶大，可是灵活温柔，反衬得许多女人的大眼睛只像政治家讲的大话，大而无当。古典学者看她说笑时露出的好牙齿，会诧异为什么古今中外诗人，都甘心变成女人头插的钗，腰束的带，身体睡的席，甚至脚下践踏的鞋，可是从没想到化作她的牙刷。她头发没烫，眉毛不镊，口红也没有擦，似乎安心遵守天生的限止，不要弥补造化的缺陷。总而言之，唐小姐是摩登文明社会里那桩罕物——一个真正的女孩子。这段话，真的是我在整本书中，见过的对女孩子最美好的描述了，唐小姐就像一朵红玫瑰，深深地插进了方鸿渐的心中。而这段感情最终也因为他自己的懦弱与退缩夭折在了那个下着大雨的午后。<br>如果说鲍小姐代表肉欲，苏小姐代表才情和家室，唐小姐代表初恋，那接下来出现的这位孙柔嘉则代表了婚姻。孙小姐出现时，一张寡淡的脸上有着些小的雀斑，这与唐小姐的外貌描述简直天差地别。而她一个女孩独自和4个男人一起出远门去大学教书，这种行为刚开始让我不太理解，可看到后面她父母的重男轻女，迫使她一个女孩子要不断的努力才能创造出属于自己的好生活。原以为她是一个乖巧甚至有些单纯的女生，可在她一步一步设下圈套，让方鸿渐慢慢走进自己婚姻的围城中时，让我觉得她实在心思深重，却也觉得她有些可怜。家庭和生活的压力逼迫她成长为了一个敏感、富有心计的女子。她与方鸿渐婚后也渐渐暴露出自己善妒、专横的一面。她过于聪明，每每吵架嘴上说着不想方鸿渐的朋友觉得她限制了他的生活，可他们有哪一次吵架不是孙柔嘉在限制他呢？在生活上、工作上，甚至是朋友的交往上。她很勇敢，她大胆的追求自己的幸福，选择了方鸿渐这在她看来是最好的选择，她拥有抗争人生，迎来幸福生活的勇气，可她选择的却未必是幸福的生活。他们的婚后生活打破了方鸿渐对婚姻的幻想，这是一段被掌控的婚姻，而方鸿渐在被生活不断打磨棱角的同时，也在不断的向他的婚姻做出妥协。可是这些妥协并不能改变他们不断的争吵、不断的发生矛盾的现状。<br>是啊，方鸿渐从来就不是一个会主动争取的人，他好像经不得一点挫折与麻烦。他总是在有了一点点退路后拔腿就跑，不愿意面对一点点的困难或者说努力一点点。考取文凭时是这样，与岳父岳母闹翻时是这样，大学教书时没有聘书也是这样。他也曾在年轻的时候意气风发，被大家吹捧、有女孩喜爱。那时他的身边围绕着的是苏小姐、赵先生、唐小姐、曹先生，这些人无一例外都是家世好，文化高，他也曾是这些人中的一员。但是在时间的细细打磨下，他慢慢露出了原本的样子。文凭是假的，家室也一般，性格又软弱，只有那一身的傲气还算真实。最后只能娶一个像孙柔嘉这样平凡的女生作为妻子，还说“也许这正是我所需要的”。他总是被迫的接受着，还反过来安慰自己也许一切都是最好的安排，真是一个可悲又可恨的人物。<br>方鸿渐有些小聪明，也比一般人有学识，可他的一生，在我看来的的确确是一场悲剧。他一生都无法走出自己的围城里。这个围城，不是别人给他造的，而是他的懦弱退缩加上他莫名的不肯低头的傲气，自己给自己设下的围城。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;惊叹钱老的经典！借着小说揭露那个时代的病态，文笔犀利，辛辣讽刺。&lt;br&gt;方鸿渐自己留洋归</summary>
      
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://example.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文学" scheme="http://example.com/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中Set和Map</title>
    <link href="http://example.com/2020/02/07/JavaScript%E4%B8%ADSet%E5%92%8CMap/"/>
    <id>http://example.com/2020/02/07/JavaScript%E4%B8%ADSet%E5%92%8CMap/</id>
    <published>2020-02-07T07:32:12.000Z</published>
    <updated>2021-08-07T05:59:13.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>ES6 提供了新的数据结构 Set.它类似于数组,但是成员的值都是唯一的,没有重复的值.</p><p>Set 本身是一个构造函数,用来生成 Set 数据结构.<br>基本用法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set);<span class="comment">//Set &#123; 1, 2, 3, 4 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>接下来详细了解一下Set实例的属性和方法:</p><ul><li>属性<ul><li>size:返回集合所包含元素的数量</li></ul></li><li>方法<ul><li>操作方法(见例子1)<ul><li>add(value):向集合中添加一个新的项</li><li>delete(value):从集合中移除一个值</li><li>has(value): 判断一个值在集合中是否存在,存在返回true,否则false</li><li>clear(): 移除集合里所有的项</li></ul></li><li>遍历方法(见例子2)<ul><li>keys():返回键名的遍历器</li><li>values():返回键值的遍历器</li><li>entries():返回键值对的遍历器</li><li>forEach():使用回调函数遍历每个成员</li></ul></li></ul></li></ul><p>例子1:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(<span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">set.add(<span class="number">3.5</span>);</span><br><span class="line">set.add(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set);<span class="comment">//Set &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">set.delete(<span class="number">3.5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set);<span class="comment">//Set &#123; &#x27;Cola&#x27;, &#x27;red&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="string">&#x27;red&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="string">&#x27;blue&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">set.clear();</span><br><span class="line"><span class="built_in">console</span>.log(set);<span class="comment">//Set &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>例子2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;Cola&#x27;</span>, <span class="number">3.5</span>, <span class="string">&#x27;red&#x27;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set.keys());<span class="comment">//SetIterator &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set.values());<span class="comment">//SetIterator &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set.entries());<span class="comment">//SetIterator &#123; [ &#x27;Cola&#x27;, &#x27;Cola&#x27; ], [ 3.5, 3.5 ], [ &#x27;red&#x27;, &#x27;red&#x27; ] &#125;</span></span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27; : &#x27;</span> + value + <span class="string">&#x27; : &#x27;</span> + array);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//Cola : Cola : [object Set]</span></span><br><span class="line"><span class="comment">//3.5 : 3.5 : [object Set]</span></span><br><span class="line"><span class="comment">//red : red : [object Set]</span></span><br></pre></td></tr></table></figure><p><strong>注意:Set的遍历顺序就是插入顺序,由于 Set 结构没有键名,只有键值(或者说键名和键值是同一个值),所以keys方法和values方法的行为完全一致</strong></p><p>for of遍历方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;Cola&#x27;</span>, <span class="number">3.5</span>, <span class="string">&#x27;red&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> set)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cola</span></span><br><span class="line"><span class="comment">//3.5</span></span><br><span class="line"><span class="comment">//red</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [value,key] <span class="keyword">of</span> set.entries())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value+<span class="string">&#x27;:&#x27;</span>+key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cola:Cola</span></span><br><span class="line"><span class="comment">//3.5:3.5</span></span><br><span class="line"><span class="comment">//red:red</span></span><br></pre></td></tr></table></figure><h4 id="Set和Array转换"><a href="#Set和Array转换" class="headerlink" title="Set和Array转换"></a>Set和Array转换</h4><ul><li><p>数组 =&gt; Set:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Cola&#x27;</span>, <span class="number">3.5</span>, <span class="string">&#x27;red&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line"><span class="built_in">console</span>.log(set);<span class="comment">//Set &#123; &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Set =&gt; 数组:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;Cola&#x27;</span>, <span class="number">3.5</span>, <span class="string">&#x27;red&#x27;</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(set)</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ &#x27;Cola&#x27;, 3.5, &#x27;red&#x27; ]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>我们再看看Set,当有对象存储在Set实例中时,这相当于把对象存储在变量中,只要Set实例的引用仍然存在,所存储的对象就无法被垃圾回收机制回收,从而无法释放内存:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;Cola&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">set.add(obj);</span><br><span class="line">set.add(color);</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set &#123; &#123; name: &#x27;Cola&#x27; &#125;, &#x27;red&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>WeakSet 结构与 Set 类似,也是不重复的值的集合.但它与 Set 有两个区别:</p><ul><li><p>WeakSet 的成员只能是对象，而不能是其他类型的值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="string">&#x27;Cala&#x27;</span>);<span class="comment">//TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></table></figure></li><li><p>WeakSet 中的对象都是弱引用,即垃圾回收机制不考虑 WeakSet 对该对象的引用,也就是说,如果其他对象都不再引用该对象,那么垃圾回收机制会自动回收该对象所占用的内存,不考虑该对象还存在于 WeakSet 之中.因为这个特点,WeakSet 不可遍历.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">let</span> obj =&#123;<span class="attr">name</span>:<span class="string">&#x27;Cola&#x27;</span>&#125;</span><br><span class="line">ws.add(obj);</span><br><span class="line">ws.add(&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(ws.has(obj))<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">ws.delete(obj)</span><br><span class="line"><span class="built_in">console</span>.log(ws.has(obj))<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>Weak Set 不提供任何迭代器(例如 keys() 与 values() 方法),没有size属性.</p></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map类型是一组键值对的结构,具有极快的查找速度.它是键值对的有序列表，而键和值都可以是任意类型.<br>基本用法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;food&#x27;</span>],[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Cola&#x27;</span>]]);</span><br><span class="line">map.set(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>).set(<span class="string">&#x27;price&#x27;</span>, <span class="number">3.5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.size)<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;name&#x27;</span>))<span class="comment">//Cola</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;size&#x27;</span>))<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(map);<span class="comment">//Map &#123; &#x27;type&#x27; =&gt; &#x27;food&#x27;, &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, &#x27;color&#x27; =&gt; &#x27;red&#x27;, &#x27;price&#x27; =&gt; 3.5 &#125;</span></span><br></pre></td></tr></table></figure><p>接下来详细了解一下Set实例的属性和方法:</p><ul><li>属性<ul><li>size:返回集合所包含元素的数量</li></ul></li><li>方法<ul><li>操作方法(见例子3)<ul><li>set(key, value):设置键名key对应的键值为value,然后返回整个 Map 结构.如果key已经有值,则键值会被更新,否则就新生成该键.set方法返回的是当前的Map对象，因此可以采用链式写法</li><li>get(key):读取key对应的键值，如果找不到key，返回undefined</li><li>has(key):判断指定键在Map中是否存在,存在返回true,否则false</li><li>delete(ley):移除Map中的建以及对应的值</li><li>clear():移除Map中所有的键与值</li></ul></li><li>遍历方法(见例子4)<ul><li>keys():返回键名的遍历器</li><li>values():返回键值的遍历器</li><li>entries():返回所有成员的遍历器</li><li>forEach():遍历 Map 的所有成员</li></ul></li></ul></li></ul><p>例子3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Cola&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;price&#x27;</span>, <span class="number">3.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;name&#x27;</span>))<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;color&#x27;</span>))<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">&#x27;name&#x27;</span>))<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">map.clear();</span><br><span class="line"><span class="built_in">console</span>.log(map.size)<span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>例子4:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;food&#x27;</span>], [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Cola&#x27;</span>], [<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>], [<span class="string">&#x27;price&#x27;</span>, <span class="number">3.5</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map.keys());<span class="comment">//MapIterator &#123; &#x27;type&#x27;, &#x27;name&#x27;, &#x27;color&#x27;, &#x27;price&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.values());<span class="comment">//MapIterator &#123; &#x27;food&#x27;, &#x27;Cola&#x27;, &#x27;red&#x27;, 3.5 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.entries());</span><br><span class="line"><span class="comment">//MapIterator &#123;</span></span><br><span class="line"><span class="comment">//  [ &#x27;type&#x27;, &#x27;food&#x27; ],</span></span><br><span class="line"><span class="comment">//  [ &#x27;name&#x27;, &#x27;Cola&#x27; ],</span></span><br><span class="line"><span class="comment">//  [ &#x27;color&#x27;, &#x27;red&#x27; ],</span></span><br><span class="line"><span class="comment">//  [ &#x27;price&#x27;, 3.5 ] &#125;</span></span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;:&#x27;</span> + value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//type:food</span></span><br><span class="line"><span class="comment">//name:Cola</span></span><br><span class="line"><span class="comment">//color:red</span></span><br><span class="line"><span class="comment">//price:3.5</span></span><br></pre></td></tr></table></figure><p>for of遍历方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;food&#x27;</span>], [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Cola&#x27;</span>], [<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>], [<span class="string">&#x27;price&#x27;</span>, <span class="number">3.5</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>] + <span class="string">&#x27;:&#x27;</span> + item[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type:food</span></span><br><span class="line"><span class="comment">//name:Cola</span></span><br><span class="line"><span class="comment">//color:red</span></span><br><span class="line"><span class="comment">//price:3.5</span></span><br></pre></td></tr></table></figure><h4 id="Map与其他数据结构的相互转换"><a href="#Map与其他数据结构的相互转换" class="headerlink" title="Map与其他数据结构的相互转换"></a>Map与其他数据结构的相互转换</h4><ul><li>Map =&gt; 数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;food&#x27;</span>], [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Cola&#x27;</span>], [<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>], [<span class="string">&#x27;price&#x27;</span>, <span class="number">3.5</span>]]);</span><br><span class="line"><span class="keyword">let</span> arr = [...map];<span class="comment">//或者 let arr = Array.from(map);</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ [ &#x27;type&#x27;, &#x27;food&#x27; ],[ &#x27;name&#x27;, &#x27;Cola&#x27; ],[ &#x27;color&#x27;, &#x27;red&#x27; ],[ &#x27;price&#x27;, 3.5 ] ]</span></span><br></pre></td></tr></table></figure></li><li>数组 =&gt; Map<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;food&#x27;</span>], [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Cola&#x27;</span>], [<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>], [<span class="string">&#x27;price&#x27;</span>, <span class="number">3.5</span>]]);</span><br></pre></td></tr></table></figure></li><li>Map =&gt; 对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;food&#x27;</span>], [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Cola&#x27;</span>], [<span class="number">2</span>, <span class="string">&#x27;red&#x27;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mapToObj(map))<span class="comment">//Map &#123; &#x27;type&#x27; =&gt; &#x27;food&#x27;, &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, 2 =&gt; &#x27;red&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li>对象 =&gt; Map<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">map.set(item, obj[item]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objToMap(obj));<span class="comment">//Map &#123; &#x27;name&#x27; =&gt; &#x27;Cola&#x27;, &#x27;color&#x27; =&gt; &#x27;red&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="WeakSet-1"><a href="#WeakSet-1" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>如果希望不再引用Map的时候自动触发垃圾回收机制.那么也需要WeakMap。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">map.set(key, <span class="string">&#x27;这是一个div&#x27;</span>);</span><br><span class="line"></span><br><span class="line">map.get(key) <span class="comment">// &quot;这是一个div&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除该元素</span></span><br><span class="line">key.parentNode.removeChild(key);</span><br><span class="line">key = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Set&quot;&gt;&lt;a href=&quot;#Set&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中IIFE</title>
    <link href="http://example.com/2020/02/06/JavaScript%E4%B8%ADIIFE/"/>
    <id>http://example.com/2020/02/06/JavaScript%E4%B8%ADIIFE/</id>
    <published>2020-02-06T10:10:25.000Z</published>
    <updated>2021-08-07T05:59:13.820Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>IIFE(Immediately-Invoked Function Expression) 立即执行函数表达式,也就是说在声明函数的同时立即调用该函数.<br>先看看IIFE的语法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;)()<span class="comment">//red</span></span><br></pre></td></tr></table></figure><p>常规函数的定义和调用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cola</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cola();<span class="comment">//red</span></span><br></pre></td></tr></table></figure><h2 id="为什么有IIFE"><a href="#为什么有IIFE" class="headerlink" title="为什么有IIFE"></a>为什么有IIFE</h2><p>如果只是为了执行一个函数,从上面的例子可以看出好处有限.实际上IIFE的出现是为了弥补JS在在scope方面的缺陷：JS只有全局作用域(global scope)、函数作用域(function scope),从ES6开始才有块级作用域(block scope).<br>在JS中，只有function才能实现作用域隔离，因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cola</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(cola());<span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(color);</span><br></pre></td></tr></table></figure><p>在我们通常的理解中，将代码封装到函数中的目的是为了复用。在JS中，声明函数的目的在大多数情况下也是为了复用，但是JS迫于作用域控制手段的贫乏，我们也经常看到只使用一次的函数：目的就是为了隔离作用域.<br>既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也省掉了！这就是IIFE的由来。</p><h2 id="IIFE一些要注意的地方"><a href="#IIFE一些要注意的地方" class="headerlink" title="IIFE一些要注意的地方"></a>IIFE一些要注意的地方</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//statements</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>表达式中的变量不能从外部访问<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> color;</span><br><span class="line">&#125;)()<span class="comment">//red</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(color);<span class="comment">//抛出错误 : ReferenceError: color is not defined</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>将IIFE分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> color;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//red</span></span><br></pre></td></tr></table></figure></li><li><p>IIFE的多参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, <span class="built_in">document</span></span>) </span>&#123;  </span><br><span class="line"><span class="comment">// 这里可以调用到window和document    </span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>); </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IIFE的目的是为了隔离作用域,防止污染全局命名空间.</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中深拷贝和浅拷贝</title>
    <link href="http://example.com/2020/02/05/JavaScript%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/2020/02/05/JavaScript%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-02-05T11:07:22.000Z</published>
    <updated>2021-08-07T05:59:13.806Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博客 <a href="https://hjy-xh.github.io/">hjy-xh</a>，转载请申明出处</p></blockquote><p>在JavaScript中,对于引用类型数据的值,当从一个变量向另一个变量复制引用类型值时，这个值的副本其实是一个指针，两个变量指向同一个堆对象，改变其中一个变量，另一个也会受到影响.<br>这种拷贝分为两种情况:拷贝引用和拷贝实例,也就是我们说的浅拷贝和深拷贝.</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ul><li><p>浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用:<br>第一个例子是直接拷贝原对象的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Cola&quot;</span>, <span class="attr">detail</span>: &#123; <span class="attr">price</span>: <span class="number">3.5</span> &#125;, <span class="attr">color</span>: [<span class="string">&#x27;red&#x27;</span>] &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj;</span><br><span class="line">obj2.name = <span class="string">&quot;Coca Cola&quot;</span>;</span><br><span class="line">obj2.detail.price = <span class="number">5</span>;</span><br><span class="line">obj2.color[<span class="number">0</span>] = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)<span class="comment">//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; price: 5 &#125;, color: [ &#x27;blue&#x27; ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; price: 5 &#125;, color: [ &#x27;blue&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure><p>再看第二个例子,理解拷贝一层的含义(Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。注意：Object.assign()拷贝的是属性值，假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span>, <span class="attr">detail</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.name=<span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line">obj2.detail.color=<span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>其他实现方法</p><ul><li><p>扩展运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span>, <span class="attr">detail</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj&#125;;</span><br><span class="line">obj2.name=<span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line">obj2.detail.color=<span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.slice(),该方法提取并返回一个新的数组,如果源数组中的元素是个对象的引用,slice会拷贝这个对象的引用到新的数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Cola&#x27;</span>, &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.slice();</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line">arr2[<span class="number">1</span>].color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ &#x27;Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//[ &#x27;Coca Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure></li><li><p>Array.prototype.concat(),该方法用于合并多个数组,并返回一个新的数组,和slice方法类似,当源数组中的元素是个对象的引用，concat在合并时拷贝的就是这个对象的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Cola&#x27;</span>, &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = [&#123; <span class="attr">price</span>: <span class="number">3.5</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.concat(arr2);</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line">arr3[<span class="number">2</span>].price = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[ &#x27;Cola&#x27;, &#123; color: &#x27;red&#x27; &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//[ &#123; price: 5 &#125; ]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>手动实现浅拷贝:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error arguments&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = source.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line"><span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">target[key] = source[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = [<span class="string">&#x27;Cola&#x27;</span>, &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> obj2 = shallowClone(obj);</span><br><span class="line"></span><br><span class="line">obj[<span class="number">0</span>] = <span class="string">&#x27;Coca Cola&#x27;</span></span><br><span class="line">obj[<span class="number">1</span>].color = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)<span class="comment">//[ &#x27;Coca Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">//[ &#x27;Cola&#x27;, &#123; color: &#x27;blue&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul><li><p>深拷贝是拷贝多层，每一级别的数据都会拷贝出来:也就是说深拷贝会另外拷贝一份一个一模一样的对象,从堆内存中开辟一个新的区域存放新对象,新对象跟原对象不共享内存，修改新对象不会改到原对象.</p></li><li><p>常用方法:JSON.parse(JSON.stringify())</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span>, <span class="attr">detail</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">obj2.name = <span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line">obj2.detail.color = <span class="string">&#x27;blue&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);<span class="comment">//&#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);<span class="comment">//&#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>这是前端开发过程中比较常用的深拷贝方式。原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象.<br>它有一些值得注意的地方</p><ul><li>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失</li><li>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null</li></ul></li><li><p>还可以借助jQuery，lodash等第三方库完成一个深拷贝实例.</p></li><li><p>手动实现深拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error arguments&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = source.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line"><span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span> &amp;&amp; source[key]) &#123;</span><br><span class="line">target[key] = deepClone(source[key]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">target[key] = source[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Cola&#x27;</span>, <span class="attr">detail</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = deepClone(obj);</span><br><span class="line">obj2.name=<span class="string">&#x27;Coca Cola&#x27;</span>;</span><br><span class="line">obj2.detail.color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; name: &#x27;Cola&#x27;, detail: &#123; color: &#x27;red&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// &#123; name: &#x27;Coca Cola&#x27;, detail: &#123; color: &#x27;blue&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本博客 &lt;a href=&quot;https://hjy-xh.github.io/&quot;&gt;hjy-xh&lt;/a&gt;，转载请申明出处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在JavaScript中,对于引用类型数据的值,当从一个变量向另一个变量复制引用类型值时</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
